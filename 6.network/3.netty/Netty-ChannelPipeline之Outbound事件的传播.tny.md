<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelPipeline（四）之 Outbound 事件的传播
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们来分享，在 pipeline 中的 <strong>Outbound 事件的传播</strong>。我们先来回顾下 Outbound 事件的定义：</p>
<blockquote>
<p>老艿艿：A01、A02 等等，是我们每条定义的编号。</p>
</blockquote>
<ul>
<li><p>[x] A01：Outbound 事件是【请求】事件(由 Connect 发起一个请求, 并最终由 Unsafe 处理这个请求)</p>
<blockquote>
<p>老艿艿：A01 = A02 + A03</p>
</blockquote>
</li>
<li><p>[x] A02：Outbound 事件的发起者是 Channel</p>
</li>
<li>[x] A03：Outbound 事件的处理者是 Unsafe</li>
<li>[x] A04：Outbound 事件在 Pipeline 中的传输方向是 <code>tail</code> -&gt; <code>head</code> </li>
<li>[x] A05：在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Handler ，则需要调用 <code>ctx.xxx</code> (例如 <code>ctx.connect</code> ) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</li>
<li>[x] A06：Outbound 事件流: <code>Context.OUT_EVT</code> -&gt; <code>Connect.findContextOutbound</code> -&gt; <code>nextContext.invokeOUT_EVT</code> -&gt; <code>nextHandler.OUT_EVT</code> -&gt; <code>nextContext.OUT_EVT</code></li>
</ul>
<p>下面，我们来跟着代码，理解每条定义。</p>
<h1 id="2-ChannelOutboundInvoker"><a href="#2-ChannelOutboundInvoker" class="headerlink" title="2. ChannelOutboundInvoker"></a>2. ChannelOutboundInvoker</h1><p>在 <code>io.netty.channel.ChannelOutboundInvoker</code> 接口中，定义了所有 Outbound 事件对应的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">deregister</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">deregister</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>而 ChannelOutboundInvoker 的<strong>部分</strong>子类/接口如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_10/01.png" title="类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_10/01.png" alt="类图"></a><span class="caption">类图</span></p>
<ul>
<li>我们可以看到类图，有 Channel、ChannelPipeline、AbstractChannelHandlerContext 都继承/实现了该接口。那这意味着什么呢？我们继续往下看。</li>
</ul>
<p>在 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/">《精尽 Netty 源码解析 —— 启动（一）之服务端》</a> 中，我们可以看到 Outbound 事件的其中之一 <strong>bind</strong> ，本文就以 <strong>bind</strong> 的过程，作为示例。调用栈如下：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_10/02.png" title="调用栈" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_10/02.png" alt="调用栈"></a><span class="caption">调用栈</span></p>
<ul>
<li><p><code>AbstractChannel#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>AbstractChannel#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，实现的自 ChannelOutboundInvoker 接口。<ul>
<li>Channel 是 <strong>bind</strong> 的发起者，<strong>这符合 Outbound 事件的定义 A02</strong> 。</li>
</ul>
</li>
<li>在方法内部，会调用 <code>ChannelPipeline#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，而这个方法，也是实现的自 ChannelOutboundInvoker 接口。<em>从这里可以看出，对于 ChannelOutboundInvoker 接口方法的实现，Channel 对它的实现，会调用 ChannelPipeline 的对应方法</em>( ( 有一点绕，胖友理解下 ) )。<ul>
<li>那么接口下，让我们看看 <code>ChannelPipeline#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法的具体实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-DefaultChannelPipeline"><a href="#3-DefaultChannelPipeline" class="headerlink" title="3. DefaultChannelPipeline"></a>3. DefaultChannelPipeline</h1><p><code>DefaultChannelPipeline#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用 <code>TailContext#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法。<strong>这符合 Outbound 事件的定义 A04</strong> 。<ul>
<li>实际上，TailContext 的该方法，继承自 AbstractChannelHandlerContext 抽象类，而 AbstractChannelHandlerContext 实现了 ChannelOutboundInvoker 接口。<em>从这里可以看出，对于 ChannelOutboundInvoker 接口方法的实现，ChannelPipeline 对它的实现，会调用 AbstractChannelHandlerContext 的对应方法</em>( 有一点绕，胖友理解下 )。</li>
</ul>
</li>
</ul>
<h1 id="4-AbstractChannelHandlerContext"><a href="#4-AbstractChannelHandlerContext" class="headerlink" title="4. AbstractChannelHandlerContext"></a>4. AbstractChannelHandlerContext</h1><p><code>AbstractChannelHandlerContext#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 判断是否为合法的 Promise 对象</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">false</span>)) {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// cancelled</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">return</span> promise;</span><br><span class="line"><span class="number">10</span>:     }</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 获得下一个 Outbound 节点</span></span><br><span class="line"><span class="number">13</span>:     <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 获得下一个 Outbound 节点的执行器</span></span><br><span class="line"><span class="number">15</span>:     EventExecutor executor = next.executor();</span><br><span class="line"><span class="number">16</span>:     <span class="comment">// 调用下一个 Outbound 节点的 bind 方法</span></span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (executor.inEventLoop()) {</span><br><span class="line"><span class="number">18</span>:         next.invokeBind(localAddress, promise);</span><br><span class="line"><span class="number">19</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">20</span>:         safeExecute(executor, <span class="keyword">new</span> Runnable() {</span><br><span class="line"><span class="number">21</span>:             <span class="meta">@Override</span></span><br><span class="line"><span class="number">22</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">23</span>:                 next.invokeBind(localAddress, promise);</span><br><span class="line"><span class="number">24</span>:             }</span><br><span class="line"><span class="number">25</span>:         }, promise, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">26</span>:     }</span><br><span class="line"><span class="number">27</span>:     <span class="keyword">return</span> promise;</span><br><span class="line"><span class="number">28</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 6 至 10 行：判断 <code>promise</code> 是否为合法的 Promise 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotValidPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> allowVoidPromise)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (promise == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"promise"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Promise 已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (promise.isDone()) {</span><br><span class="line">        <span class="comment">// Check if the promise was cancelled and if so signal that the processing of the operation</span></span><br><span class="line">        <span class="comment">// should not be performed.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2349</span></span><br><span class="line">        <span class="keyword">if</span> (promise.isCancelled()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"promise already done: "</span> + promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel 不符合</span></span><br><span class="line">    <span class="keyword">if</span> (promise.channel() != channel()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"promise.channel does not match: %s (expected: %s)"</span>, promise.channel(), channel()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DefaultChannelPromise 合法 // &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (promise.getClass() == DefaultChannelPromise.class) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 禁止 VoidChannelPromise </span></span><br><span class="line">    <span class="keyword">if</span> (!allowVoidPromise &amp;&amp; promise <span class="keyword">instanceof</span> VoidChannelPromise) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                StringUtil.simpleClassName(VoidChannelPromise.class) + <span class="string">" not allowed for this operation"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 禁止 CloseFuture</span></span><br><span class="line">    <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> AbstractChannel.CloseFuture) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + <span class="string">" not allowed in a pipeline"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然方法很长，重点是 <code>&lt;1&gt;</code> 处，<code>promise</code> 的类型为 DefaultChannelPromise 。</li>
</ul>
</li>
<li><p>第 13 行：【重要】调用 <code>#findContextOutbound()</code> 方法，获得下一个 Outbound 节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 循环，向前获得一个 Outbound 节点</span></span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    } <span class="keyword">while</span> (!ctx.outbound);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>循环，<strong>向前</strong>获得一个 Outbound 节点。</li>
<li>循环，<strong>向前</strong>获得一个 Outbound 节点。</li>
<li>循环，<strong>向前</strong>获得一个 Outbound 节点。</li>
<li>😈 重要的事情说三遍，对于 Outbound 事件的传播，是从 pipeline 的尾巴到头部，<strong>这符合 Outbound 事件的定义 A04</strong> 。</li>
</ul>
</li>
<li><p>第 15 行：调用 <code>AbstractChannelHandlerContext#executor()</code> 方法，获得下一个 Outbound 节点的执行器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Will be set to null if no child executor should be used, otherwise it will be set to the</span></span><br><span class="line"><span class="comment">// child executor.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventExecutor 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> channel().eventLoop();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果未设置<strong>子执行器</strong>，则使用 Channel 的 EventLoop 作为执行器。😈 一般情况下，我们可以忽略<strong>子执行器</strong>的逻辑，也就是说，可以直接认为是使用 <strong>Channel 的 EventLoop 作为执行器</strong>。</li>
</ul>
</li>
<li><p>第 16 至 26 行：<strong>在 EventLoop 的线程中</strong>，调用<strong>下一个节点</strong>的 <code>AbstractChannelHandlerContext#invokeBind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，传播 <strong>bind</strong> 事件给<strong>下一个节点</strong>。</p>
<ul>
<li><p>第 20 至 25 行：如果不在 EventLoop 的线程中，会调用 <code>#safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</code> 方法，提交到 EventLoop 的线程中执行。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 提交 EventLoop 的线程中，进行执行任务</span></span><br><span class="line">        executor.execute(runnable);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable cause) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 发生异常，回调通知 promise 相关的异常</span></span><br><span class="line">            promise.setFailure(cause);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放 msg 相关的资源</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><code>AbstractChannelHandlerContext#invokeBind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (invokeHandler()) { <span class="comment">// 判断是否符合的 ChannelHandler</span></span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">4</span>:             <span class="comment">// 调用该 ChannelHandler 的 bind 方法</span></span><br><span class="line"> <span class="number">5</span>:             ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line"> <span class="number">6</span>:         } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"> <span class="number">7</span>:             notifyOutboundHandlerException(t, promise); <span class="comment">// 通知 Outbound 事件的传播，发生异常</span></span><br><span class="line"> <span class="number">8</span>:         }</span><br><span class="line"> <span class="number">9</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 跳过，传播 Outbound 事件给下一个节点</span></span><br><span class="line"><span class="number">11</span>:         bind(localAddress, promise);</span><br><span class="line"><span class="number">12</span>:     }</span><br><span class="line"><span class="number">13</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 2 行：调用 <code>#invokeHandler()</code> 方法，判断是否符合的 ChannelHandler 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Makes best possible effort to detect if {<span class="doctag">@link</span> ChannelHandler#handlerAdded(ChannelHandlerContext)} was called</span></span><br><span class="line"><span class="comment"> * yet. If not return {<span class="doctag">@code</span> false} and if called or could not detect return {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this method returns {<span class="doctag">@code</span> false} we will not invoke the {<span class="doctag">@link</span> ChannelHandler} but just forward the event.</span></span><br><span class="line"><span class="comment"> * This is needed as {<span class="doctag">@link</span> DefaultChannelPipeline} may already put the {<span class="doctag">@link</span> ChannelHandler} in the linked-list</span></span><br><span class="line"><span class="comment"> * but not called {<span class="doctag">@link</span> ChannelHandler#handlerAdded(ChannelHandlerContext)}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">invokeHandler</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Store in local variable to reduce volatile reads.</span></span><br><span class="line">    <span class="keyword">int</span> handlerState = <span class="keyword">this</span>.handlerState;</span><br><span class="line">    <span class="keyword">return</span> handlerState == ADD_COMPLETE || (!ordered &amp;&amp; handlerState == ADD_PENDING);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 <code>ordered = true</code> 的节点，必须 ChannelHandler 已经添加完成。</li>
<li>对于 <code>ordered = false</code> 的节点，没有 ChannelHandler 的要求。</li>
</ul>
</li>
<li>第 9 至 12 行：若是<strong>不符合</strong>的 ChannelHandler ，则<strong>跳过</strong>该节点，调用 <code>AbstractChannelHandlerContext#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，传播 Outbound 事件给下一个节点。即，又回到 <a href="#">「4. AbstractChannelHandlerContext」</a> 的开头。</li>
<li><p>第 2 至 8 行：若是<strong>符合</strong>的 ChannelHandler ：</p>
<ul>
<li><p>第 5 行：调用 ChannelHandler 的 <code>#bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</code> 方法，处理 bind 事件。</p>
<ul>
<li><p>😈 实际上，此时节点的数据类型为 DefaultChannelHandlerContext 类。若它被认为是 Outbound 节点，那么他的处理器的类型会是 <strong>ChannelOutboundHandler</strong> 。而 <code>io.netty.channel.ChannelOutboundHandler</code> 类似 ChannelOutboundInvoker ，定义了对每个 Outbound 事件的处理。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>胖友自己对比下噢。</li>
</ul>
</li>
<li><p>如果节点的 <code>ChannelOutboundHandler#bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</code> 方法的实现，不调用 <code>AbstractChannelHandlerContext#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，就不会传播 Outbound 事件给下一个节点。<strong>这就是 Outbound 事件的定义 A05</strong> 。可能有点绕，我们来看下 Netty LoggingHandler 对该方法的实现代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingHandler</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span>, <span class="title">ChannelOutboundHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略无关方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        log(Event.BIND, <span class="string">"localAddress="</span> + localAddress);</span><br><span class="line">        <span class="comment">// 传递 bind 事件，给下一个节点</span></span><br><span class="line">        ctx.bind(localAddress, promise); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果把 <code>&lt;1&gt;</code> 处的代码去掉，bind 事件将不会传播给下一个节点！！！<strong>一定要注意</strong>。</li>
</ul>
</li>
<li>这块的逻辑非常重要，如果胖友觉得很绕，一定要自己多调试 + 调试 + 调试。</li>
</ul>
</li>
<li>第 7 行：如果发生异常，调用 <code>#notifyOutboundHandlerException(Throwable, Promise)</code> 方法，通知 Outbound 事件的传播，发生异常。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ChannelPipeline-6-exception">《精尽 Netty 源码解析 —— ChannelPipeline（六）之异常事件的传播》</a> 。</li>
</ul>
</li>
</ul>
<hr>
<p>本小节的整个代码实现，<strong>就是 Outbound 事件的定义 A06</strong>的体现。而随着 Outbound 事件在节点不断从 pipeline 的尾部到头部的传播，最终会到达 HeadContext 节点。</p>
<h1 id="5-HeadContext"><a href="#5-HeadContext" class="headerlink" title="5. HeadContext"></a>5. HeadContext</h1><p><code>HeadContext#bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>Unsafe#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，进行 bind 事件的处理。也就是说 Unsafe 是 <strong>bind</strong> 的处理着，<strong>这符合 Outbound 事件的定义 A03</strong> 。</li>
<li>而后续的逻辑，就是 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/">《精尽 Netty 源码分析 —— 启动（一）之服务端》</a> 的 <a href="#"> 「3.13.2 doBind0」</a> 小节，从 <code>Unsafe#bind(SocketAddress localAddress, ChannelPromise promise)</code> 方法，开始。</li>
<li>至此，整个 pipeline 的 Outbound 事件的传播结束。</li>
</ul>
<h1 id="6-关于其他-Outbound-事件"><a href="#6-关于其他-Outbound-事件" class="headerlink" title="6. 关于其他 Outbound 事件"></a>6. 关于其他 Outbound 事件</h1><p>本文暂时只分享了 <strong>bind</strong> 这个 Outbound 事件。剩余的其他事件，胖友可以自己进行调试和理解。例如：<strong>connect</strong> 事件，并且结合 <a href="http://svip.iocoder.cn/Netty/bootstrap-2-client/">《精尽 Netty 源码分析 —— 启动（二）之客户端》</a> 一文。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>*推荐阅读文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/087b7e9a27a2" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 pipeline(二)》</a>*</li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Pipeline-4-outbound/" data-id="ck4pl3foy00dlfgcf4lhdb16h" class="article-share-link">分享</a>



</footer>
-->
</div>