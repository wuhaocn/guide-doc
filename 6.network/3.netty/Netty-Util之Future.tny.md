<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Util 之 Future
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<p>笔者先把 Netty 主要的内容写完，所以关于 Future 的分享，先放在后续的计划里。</p>
<blockquote>
<p>老艿艿：其实是因为，自己想去研究下 Service Mesh ，所以先简单收个小尾。</p>
</blockquote>
<p>当然，良心如我，还是为对这块感兴趣的胖友，先准备好了一篇不错的文章：</p>
<ul>
<li>Hypercube <a href="https://www.jianshu.com/p/a06da3256f0c" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（五）–Future》</a></li>
</ul>
<p>为避免可能 <a href="https://www.jianshu.com/p/a06da3256f0c" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（五）–Future》</a> 被作者删除，笔者这里先复制一份作为备份。</p>
<h1 id="666-备份"><a href="#666-备份" class="headerlink" title="666. 备份"></a>666. 备份</h1><p>再次回顾这幅图，在上一章中，我们分析了Reactor的完整实现。由于Java NIO事件驱动的模型，要求Netty的事件处理采用异步的方式，异步处理则需要表示异步操作的结果。Future正是用来表示异步操作结果的对象，Future的类签名为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>其中的泛型参数V即表示异步结果的类型。</p>
<h3 id="5-1-总述"><a href="#5-1-总述" class="headerlink" title="5.1 总述"></a>5.1 总述</h3><p>也许你已经使用过JDK的Future对象，该接口的方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 取消异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"><span class="comment">// 异步操作是否取消</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 异步操作是否完成，正常终止、异常、取消都是完成</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 阻塞直到取得异步操作结果</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="comment">// 同上，但最长阻塞时间为timeout</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>我们的第一印象会觉得这样的设计并不坏，但仔细思考，便会发现问题：<br> (1).接口中只有isDone()方法判断一个异步操作是否完成，但是对于完成的定义过于模糊，JDK文档指出正常终止、抛出异常、用户取消都会使isDone()方法返回真。在我们的使用中，我们极有可能是对这三种情况分别处理，而JDK这样的设计不能满足我们的需求。<br> (2).对于一个异步操作，我们更关心的是这个异步操作触发或者结束后能否再执行一系列动作。比如说，我们浏览网页时点击一个按钮后实现用户登录。在javascript中，处理代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">$(<span class="string">"#login"</span>).click(function(){</span><br><span class="line">    login();</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>可见在这样的情况下，JDK中的Future便不能处理，所以，Netty扩展了JDK的Future接口，使其能解决上面的两个问题。扩展的方法如下（类似方法只列出一个）：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 异步操作完成且正常终止</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 异步操作是否可以取消</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancellable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 异步操作失败的原因</span></span><br><span class="line"><span class="function">Throwable <span class="title">cause</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 添加一个监听者，异步操作完成时回调，类比javascript的回调函数</span></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞直到异步操作完成</span></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 同上，但异步操作失败时抛出异常</span></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 非阻塞地返回异步结果，如果尚未完成返回null</span></span><br><span class="line"><span class="function">V <span class="title">getNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如果你对Future的状态还有疑问，放上代码注释中的ascii图打消你的疑虑：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">*                                      +---------------------------+</span><br><span class="line">*                                      | Completed successfully    |</span><br><span class="line">*                                      +---------------------------+</span><br><span class="line">*                                 +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">* +--------------------------+    |    |   isSuccess() = <span class="keyword">true</span>      |</span><br><span class="line">* |        Uncompleted       |    |    +===========================+</span><br><span class="line">* +--------------------------+    |    | Completed with failure    |</span><br><span class="line">* |      isDone() = <span class="keyword">false</span>    |    |    +---------------------------+</span><br><span class="line">* |   isSuccess() = <span class="keyword">false</span>    |----+----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">* | isCancelled() = <span class="keyword">false</span>    |    |    |       cause() = non-<span class="keyword">null</span>  |</span><br><span class="line">* |       cause() = <span class="keyword">null</span>     |    |    +===========================+</span><br><span class="line">* +--------------------------+    |    | Completed by cancellation |</span><br><span class="line">*                                 |    +---------------------------+</span><br><span class="line">*                                 +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">*                                      | isCancelled() = <span class="keyword">true</span>      |</span><br><span class="line">*                                      +---------------------------+</span><br></pre></td></tr></tbody></table></figure>
<p>可知，Future对象有两种状态尚未完成和已完成，其中已完成又有三种状态：成功、失败、用户取消。各状态的状态断言请在此图中查找。<br> 仔细看完上面的图并联系Future接口中的方法，你是不是也会和我有相同的疑问：Future接口中的方法都是getter方法而没有setter方法，也就是说这样实现的Future子类的状态是不可变的，如果我们想要变化，那该怎么办呢？Netty提供的解决方法是：使用可写的Future即Promise。Promise接口扩展的方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">// 标记异步操作结果为成功，如果已被设置（不管成功还是失败）则抛出异常IllegalStateException</span></span><br><span class="line"> <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line"> <span class="comment">// 同上，只是结果已被设置时返回False</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置结果为不可取消，结果已被取消返回False</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是：Promise接口继承自Future接口，它提供的setter方法与常见的setter方法大为不同。Promise从Uncompleted–&gt;Completed的状态转变<strong>有且只能有一次</strong>，也就是说setSuccess和setFailure方法最多只会成功一个，此外，在setSuccess和setFailure方法中会通知注册到其上的监听者。为了加深对Future和Promise的理解，我们可以将Future类比于定额发票，Promise类比于机打发票。当商户拿到税务局的发票时，如果是定额发票，则已经确定好金额是100还是50或其他，商户再也不能更改；如果是机打发票，商户相当于拿到了一个发票模板，需要多少金额按实际情况填到模板指定处。显然，不能两次使用同一张机打发票打印，这会使发票失效，而Promise做的更好，它使第二次调用setter方法失败。<br> 至此，我们从总体上了解了Future和Promise的原理。我们再看一下类图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2019_02_01/01.png" title="Future类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2019_02_01/01.png" alt="Future类图"></a><span class="caption">Future类图</span></p>
<p>类图给我们的第一印象是：繁杂。我们抓住关键点：Future和Promise两条分支，分而治之。我们使用自顶向下的方法分析其实现细节，使用两条线索：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">AbstractFuture&lt;--CompleteFuture&lt;--CompleteChannelFuture&lt;--Succeeded/FailedChannelFuture</span><br><span class="line"></span><br><span class="line">DefaultPromise&lt;--DefaultChannelPromise</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-2-Future"><a href="#5-2-Future" class="headerlink" title="5.2 Future"></a>5.2 Future</h3><h4 id="5-2-1-AbstractFuture"><a href="#5-2-1-AbstractFuture" class="headerlink" title="5.2.1 AbstractFuture"></a>5.2.1 AbstractFuture</h4><p>AbstractFuture主要实现Future的get()方法，取得Future关联的异步操作结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    await();    <span class="comment">// 阻塞直到异步操作完成</span></span><br><span class="line"></span><br><span class="line">    Throwable cause = cause();</span><br><span class="line">    <span class="keyword">if</span> (cause == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> getNow();    <span class="comment">// 成功则返回关联结果</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> CancellationException) {</span><br><span class="line">        <span class="keyword">throw</span> (CancellationException) cause;    <span class="comment">// 由用户取消</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(cause);    <span class="comment">// 失败抛出异常</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中的实现简单明了，但关键调用方法的具体实现并没有，我们将在子类实现中分析。对应的加入超时时间的get(long timeout, TimeUnit unit)实现也类似，不再列出。</p>
<h4 id="5-2-2-CompleteFuture"><a href="#5-2-2-CompleteFuture" class="headerlink" title="5.2.2 CompleteFuture"></a>5.2.2 CompleteFuture</h4><p>Complete表示操作已完成，所以CompleteFuture表示一个异步操作已完成的结果，由此可推知：该类的实例在异步操作完成时创建，返回给用户，用户则使用addListener()方法定义一个异步操作。如果你熟悉javascript，将Listener类比于回调函数callback()可方便理解。<br> 我们首先看其中的字段和构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 执行器，执行Listener中定义的操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这有一个构造方法，可知executor是必须的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CompleteFuture</span><span class="params">(EventExecutor executor)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>CompleteFuture类定义了一个EventExecutor，可视为一个线程，用于执行Listener中的操作。我们再看addListener()和removeListener()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>{</span><br><span class="line">    <span class="comment">// 由于这是一个已完成的Future，所以立即通知Listener执行</span></span><br><span class="line">    DefaultPromise.notifyListener(executor(), <span class="keyword">this</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>{</span><br><span class="line">    <span class="comment">// 由于已完成，Listener中的操作已完成，没有需要删除的Listener</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中的实现也很简单，我们看一下GenericFutureListener接口，其中只定义了一个方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 异步操作完成是调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(F future)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>关于Listener我们再关注一下ChannelFutureListener，它并没有扩展GenericFutureListener接口，所以类似于一个标记接口。我们看其中实现的三个通用ChannelFutureListener：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ChannelFutureListener CLOSE = (future) --&gt; {</span><br><span class="line">    future.channel().close();   <span class="comment">//操作完成时关闭Channel</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ChannelFutureListener CLOSE_ON_FAILURE = (future) --&gt; {</span><br><span class="line">    <span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line">        future.channel().close();   <span class="comment">// 操作失败时关闭Channel</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ChannelFutureListener FIRE_EXCEPTION_ON_FAILURE = (future) --&gt; {</span><br><span class="line">    <span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line">        <span class="comment">// 操作失败时触发一个ExceptionCaught事件</span></span><br><span class="line">        future.channel().pipeline().fireExceptionCaught(future.cause());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>这三个Listener对象定义了对Channel处理时常用的操作，如果符合需求，可以直接使用。<br> 由于CompleteFuture表示一个已完成的异步操作，所以可推知sync()和await()方法都将立即返回。此外，可推知线程的状态如下，不再列出代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">isDone() = <span class="keyword">true</span>; isCancelled() = <span class="keyword">false</span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-2-3-CompleteChannelFuture"><a href="#5-2-3-CompleteChannelFuture" class="headerlink" title="5.2.3 CompleteChannelFuture"></a>5.2.3 CompleteChannelFuture</h4><p>CompleteChannelFuture的类签名如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteChannelFuture</span> <span class="keyword">extends</span> <span class="title">CompleteFuture</span>&lt;<span class="title">Void</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFuture</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>ChannelFuture是不是觉得很亲切？你肯定已经使用过ChannelFuture。ChannelFuture接口相比于Future只扩展了一个方法channel()用于取得关联的Channel对象。CompleteChannelFuture还继承了CompleteFuture<void>，尖括号中的泛型表示Future关联的结果，此结果为Void，意味着CompleteChannelFuture不关心这个特定结果即get()相关方法返回null。也就是说，我们可以将CompleteChannelFuture纯粹的视为一种回调函数机制。<br> CompleteChannelFuture的字段只有一个：</void></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel; <span class="comment">// 关联的Channel对象</span></span><br></pre></td></tr></tbody></table></figure>
<p>CompleteChannelFuture的大部分方法实现中，只是将方法返回的Future覆盖为ChannelFuture对象（ChannelFuture接口的要求），代码不在列出。我们看一下executor()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>{</span><br><span class="line">    EventExecutor e = <span class="keyword">super</span>.executor(); <span class="comment">// 构造方法指定</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> channel().eventLoop();   <span class="comment">// 构造方法未指定使用channel注册到的eventLoop</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-2-4-Succeeded-FailedChannelFuture"><a href="#5-2-4-Succeeded-FailedChannelFuture" class="headerlink" title="5.2.4 Succeeded/FailedChannelFuture"></a>5.2.4 Succeeded/FailedChannelFuture</h4><p>Succeeded/FailedChannelFuture为特定的两个异步操作结果，回忆总述中关于Future状态的讲解，成功意味着</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Succeeded: isSuccess() == <span class="keyword">true</span>, cause() == <span class="keyword">null</span>;</span><br><span class="line">Failed:    isSuccess() == <span class="keyword">false</span>, cause() == non-<span class="keyword">null</span></span><br></pre></td></tr></tbody></table></figure>
<p>代码中的实现也很简单，不再列出。需要注意的是，其中的构造方法不建议用户调用，一般使用Channel对象的方法newSucceededFuture()和newFailedFuture(Throwable)代替。</p>
<h3 id="5-3-Promise"><a href="#5-3-Promise" class="headerlink" title="5.3 Promise"></a>5.3 Promise</h3><h4 id="5-3-1-DefaultPromise"><a href="#5-3-1-DefaultPromise" class="headerlink" title="5.3.1 DefaultPromise"></a>5.3.1 DefaultPromise</h4><p>我们首先看其中的static字段：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以嵌套的Listener的最大层数，可见最大值为8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LISTENER_STACK_DEPTH = Math.min(<span class="number">8</span>,</span><br><span class="line">        SystemPropertyUtil.getInt(<span class="string">"io.netty.defaultPromise.maxListenerStackDepth"</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">// result字段由使用RESULT_UPDATER更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;DefaultPromise, Object&gt; RESULT_UPDATER;</span><br><span class="line"><span class="comment">// 此处的Signal是Netty定义的类，继承自Error，异步操作成功且结果为null时设置为改值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Signal SUCCESS = Signal.valueOf(DefaultPromise.class.getName() + <span class="string">".SUCCESS"</span>);</span><br><span class="line"><span class="comment">// 异步操作不可取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Signal UNCANCELLABLE = Signal.valueOf(...);</span><br><span class="line"><span class="comment">// 异步操作失败时保存异常原因</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CauseHolder CANCELLATION_CAUSE_HOLDER = <span class="keyword">new</span> CauseHolder(...);</span><br></pre></td></tr></tbody></table></figure>
<p>嵌套的Listener，是指在listener的operationComplete方法中，可以再次使用future.addListener()继续添加listener，Netty限制的最大层数是8，用户可使用系统变量io.netty.defaultPromise.maxListenerStackDepth设置。<br> 再看其中的私有字段：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 异步操作结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object result;</span><br><span class="line"><span class="comment">// 执行listener操作的执行器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="keyword">private</span> Object listeners;</span><br><span class="line"><span class="comment">// 阻塞等待该结果的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">short</span> waiters;</span><br><span class="line"><span class="comment">// 通知正在进行标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> notifyingListeners;</span><br></pre></td></tr></tbody></table></figure>
<p>也许你已经注意到，listeners是一个Object类型。这似乎不合常理，一般情况下我们会使用一个集合或者一个数组。Netty之所以这样设计，是因为大多数情况下listener只有一个，用集合和数组都会造成浪费。当只有一个listener时，该字段为一个GenericFutureListener对象；当多余一个listener时，该字段为DefaultFutureListeners，可以储存多个listener。明白了这些，我们分析关键方法addListener()：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        addListener0(listener); <span class="comment">// 保证多线程情况下只有一个线程执行添加操作</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDone()) {</span><br><span class="line">        notifyListeners();  <span class="comment">// 异步操作已经完成通知监听者</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addListener0</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) {</span><br><span class="line">        listeners = listener;   <span class="comment">// 只有一个</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (listeners <span class="keyword">instanceof</span> DefaultFutureListeners) {</span><br><span class="line">        ((DefaultFutureListeners) listeners).add(listener); <span class="comment">// 大于两个</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 从一个扩展为两个</span></span><br><span class="line">        listeners = <span class="keyword">new</span> DefaultFutureListeners((GenericFutureListener&lt;? extends Future&lt;V&gt;&gt;) listeners, listener);   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从代码中可以看出，在添加Listener时，如果异步操作已经完成，则会notifyListeners()：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>{</span><br><span class="line">    EventExecutor executor = executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) {   <span class="comment">//执行线程为指定线程</span></span><br><span class="line">        <span class="keyword">final</span> InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth(); <span class="comment">// 嵌套层数</span></span><br><span class="line">        <span class="keyword">if</span> (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) {</span><br><span class="line">            <span class="comment">// 执行前增加嵌套层数</span></span><br><span class="line">            threadLocals.setFutureListenerStackDepth(stackDepth + <span class="number">1</span>);   </span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                notifyListenersNow();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 执行完毕，无论如何都要回滚嵌套层数</span></span><br><span class="line">                threadLocals.setFutureListenerStackDepth(stackDepth);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 外部线程则提交任务给执行线程</span></span><br><span class="line">    safeExecute(executor, () -&gt; { notifyListenersNow(); });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(EventExecutor executor, Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        rejectedExecutionLogger.error(<span class="string">"Failed to submit a listener notification task. Event loop shut down?"</span>, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以，外部线程不能执行监听者Listener中定义的操作，只能提交任务到指定Executor，其中的操作最终由指定Executor执行。我们再看notifyListenersNow()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListenersNow</span><span class="params">()</span> </span>{</span><br><span class="line">    Object listeners;</span><br><span class="line">    <span class="comment">// 此时外部线程可能会执行添加Listener操作，所以需要同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { </span><br><span class="line">        <span class="keyword">if</span> (notifyingListeners || <span class="keyword">this</span>.listeners == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 正在通知或已没有监听者（外部线程删除）直接返回</span></span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        }</span><br><span class="line">        notifyingListeners = <span class="keyword">true</span>;  </span><br><span class="line">        listeners = <span class="keyword">this</span>.listeners;</span><br><span class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (listeners <span class="keyword">instanceof</span> DefaultFutureListeners) { <span class="comment">// 通知单个</span></span><br><span class="line">            notifyListeners0((DefaultFutureListeners) listeners);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 通知多个（遍历集合调用单个）</span></span><br><span class="line">            notifyListener0(<span class="keyword">this</span>, (GenericFutureListener&lt;? extends Future&lt;V&gt;&gt;) listeners);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="comment">// 执行完毕且外部线程没有再添加监听者</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.listeners == <span class="keyword">null</span>) {</span><br><span class="line">                notifyingListeners = <span class="keyword">false</span>; </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 外部线程添加了监听者继续执行</span></span><br><span class="line">            listeners = <span class="keyword">this</span>.listeners; </span><br><span class="line">            <span class="keyword">this</span>.listeners = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener0</span><span class="params">(Future future, GenericFutureListener l)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        l.operationComplete(future);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        logger.warn(<span class="string">"An exception was thrown by "</span> + l.getClass().getName() + <span class="string">".operationComplete()"</span>, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>到此为止，我们分析完了Promise最重要的addListener()和notifyListener()方法。在源码中还有static的notifyListener()方法，这些方法是CompleteFuture使用的，对于CompleteFuture，添加监听者的操作不需要缓存，直接执行Listener中的方法即可，执行线程为调用线程，相关代码可回顾CompleteFuture。addListener()相对的removeListener()方法实现简单，我们不再分析。<br> 回忆result字段，修饰符有volatile，所以使用RESULT_UPDATER更新，保证更新操作为原子操作。Promise不携带特定的结果（即携带Void）时，成功时设置为静态字段的Signal对象SUCCESS；如果携带泛型参数结果，则设置为泛型一致的结果。对于Promise，设置成功、设置失败、取消操作，<strong>三个操作至多只能调用一个且同一个方法至多生效一次</strong>，再次调用会抛出异常（set）或返回失败（try）。这些设置方法原理相同，我们以setSuccess()为例分析:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) {</span><br><span class="line">        notifyListeners();  <span class="comment">// 可以设置结果说明异步操作已完成，故通知监听者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"complete already: "</span> + <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setSuccess0</span><span class="params">(V result)</span> </span>{</span><br><span class="line">    <span class="comment">// 为空设置为Signal对象Success</span></span><br><span class="line">    <span class="keyword">return</span> setValue0(result == <span class="keyword">null</span> ? SUCCESS : result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>{</span><br><span class="line">    <span class="comment">// 只有结果为null或者UNCANCELLABLE时才可设置且只可以设置一次</span></span><br><span class="line">    <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</span><br><span class="line">        RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) {</span><br><span class="line">        checkNotifyWaiters();   <span class="comment">// 通知等待的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>checkNotifyWaiters()方法唤醒调用await()和sync()方法等待该异步操作结果的线程，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkNotifyWaiters</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 确实有等待的线程才notifyAll</span></span><br><span class="line">    <span class="keyword">if</span> (waiters &gt; <span class="number">0</span>) {  </span><br><span class="line">        notifyAll();    <span class="comment">// JDK方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>有了唤醒操作，那么sync()和await()的实现是怎么样的呢？我们首先看sync()的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    await();</span><br><span class="line">    rethrowIfFailed();  <span class="comment">// 异步操作失败抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见，sync()和await()很类似，区别只是sync()调用，如果异步操作失败，则会抛出异常。我们接着看await()的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 异步操作已经完成，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isDone()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(toString());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 死锁检测</span></span><br><span class="line">    checkDeadLock();</span><br><span class="line">    <span class="comment">// 同步使修改waiters的线程只有一个</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">while</span> (!isDone()) { <span class="comment">// 等待直到异步操作完成</span></span><br><span class="line">            incWaiters();   <span class="comment">// ++waiters;</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait(); <span class="comment">// JDK方法</span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                decWaiters(); <span class="comment">// --waiters</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中的实现简单明了，其他await()方法也类似，不再分析。我们注意其中的checkDeadLock()方法用来进行死锁检测：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">protected void checkDeadLock() {</span><br><span class="line">    EventExecutor e = executor();</span><br><span class="line">    if (e != null &amp;&amp; e.inEventLoop()) {</span><br><span class="line">        throw new BlockingOperationException(toString());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，<strong>不能在同一个线程中调用await()相关的方法</strong>。为了更好的理解这句话，我们使用代码注释中的例子来解释。Handler中的channelRead()方法是由Channel注册到的eventLoop执行的，其中的Future的Executor也是这个eventLoop，所以不能在channelRead()方法中调用await这一类（包括sync）方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的例子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{</span><br><span class="line">    ChannelFuture future = ctx.channel().close();</span><br><span class="line">    future.awaitUninterruptibly();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{</span><br><span class="line">    ChannelFuture future = ctx.channel().close();</span><br><span class="line">    future.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>{</span><br><span class="line">            <span class="comment">// ... 使用异步操作</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>到了这里，我们已经分析完Future和Promise的主要实现。剩下的DefaultChannelPromise、VoidChannelPromise实现都很简单，我们不再分析。ProgressivePromise表示异步的进度结果，也不再进行分析。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>一条有趣的评论：</p>
<blockquote>
<p>其实Netty在实现Future接口的cancel和isDone方法时违反了Java的约定规则，请参见文章：<a href="https://www.jianshu.com/p/6a87ceb7f70a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/6a87ceb7f70a</a></p>
</blockquote>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Util-1-Future/" data-id="ck4pl3fpc00elfgcf6djvdz7p" class="article-share-link">分享</a>



</footer>
-->
</div>