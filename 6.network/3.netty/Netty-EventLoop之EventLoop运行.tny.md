<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（四）之 EventLoop 运行
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们分享 EventLoop 的<strong>运行</strong>相关代码的实现。</p>
<p>因为 EventLoop 的<strong>运行</strong>主要是通过 NioEventLoop 的 <code>#run()</code> 方法实现，考虑到内容相对的完整性，在 <a href="http://svip.iocoder.cn">《精尽 Netty 源码解析 —— EventLoop（三）之 EventLoop 初始化》</a> 一文中，我们并未分享 NioEventLoop 的<strong>初始化</strong>，所以本文也会分享这部分的内容。</p>
<p>OK ，还是老样子，自上而下的方式，一起来看看 NioEventLoop 的代码实现。</p>
<blockquote>
<p>老艿艿，本文的重点在 <a href="#">「2.9 run」</a> 和 <a href="#">「2.12 select」</a> 中。</p>
</blockquote>
<h1 id="2-NioEventLoop"><a href="#2-NioEventLoop" class="headerlink" title="2. NioEventLoop"></a>2. NioEventLoop</h1><p><code>io.netty.channel.nio.NioEventLoop</code> ，继承 SingleThreadEventLoop 抽象类，NIO EventLoop 实现类，实现对注册到其中的 Channel 的就绪的 IO 事件，和对用户提交的任务进行处理。</p>
<h2 id="2-1-static"><a href="#2-1-static" class="headerlink" title="2.1 static"></a>2.1 static</h2><p>在 <code>static</code> 代码块中，初始化了 NioEventLoop 的静态属性们。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1007 NioEventLoop cancel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLEANUP_INTERVAL = <span class="number">256</span>; <span class="comment">// XXX Hard-coded value, but won't need customization.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否禁用 SelectionKey 的优化，默认开启</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DISABLE_KEYSET_OPTIMIZATION = SystemPropertyUtil.getBoolean(<span class="string">"io.netty.noKeySetOptimization"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 少于该 N 值，不开启空轮询重建新的 Selector 对象的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PREMATURE_SELECTOR_RETURNS = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO Selector 空轮询该 N 次后，重建新的 Selector 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SELECTOR_AUTO_REBUILD_THRESHOLD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="comment">// 解决 Selector#open() 方法 // &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">final</span> String key = <span class="string">"sun.nio.ch.bugLevel"</span>;</span><br><span class="line">    <span class="keyword">final</span> String buglevel = SystemPropertyUtil.get(key);</span><br><span class="line">    <span class="keyword">if</span> (buglevel == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    System.setProperty(key, <span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (<span class="keyword">final</span> SecurityException e) {</span><br><span class="line">            logger.debug(<span class="string">"Unable to get/set System Property: "</span> + key, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> selectorAutoRebuildThreshold = SystemPropertyUtil.getInt(<span class="string">"io.netty.selectorAutoRebuildThreshold"</span>, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (selectorAutoRebuildThreshold &lt; MIN_PREMATURE_SELECTOR_RETURNS) {</span><br><span class="line">        selectorAutoRebuildThreshold = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"-Dio.netty.noKeySetOptimization: {}"</span>, DISABLE_KEYSET_OPTIMIZATION);</span><br><span class="line">        logger.debug(<span class="string">"-Dio.netty.selectorAutoRebuildThreshold: {}"</span>, SELECTOR_AUTO_REBUILD_THRESHOLD);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>CLEANUP_INTERVAL</code> 属性，TODO 1007 NioEventLoop cancel</li>
<li><code>DISABLE_KEYSET_OPTIMIZATION</code> 属性，是否禁用 SelectionKey 的优化，默认开启。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。</li>
<li><code>SELECTOR_AUTO_REBUILD_THRESHOLD</code> 属性，NIO Selector 空轮询该 N 次后，重建新的 Selector 对象，用以解决 JDK NIO 的 epoll 空轮询 Bug 。<ul>
<li><code>MIN_PREMATURE_SELECTOR_RETURNS</code> 属性，少于该 N 值，不开启空轮询重建新的 Selector 对象的功能。</li>
</ul>
</li>
<li><code>&lt;1&gt;</code> 处，解决 <code>Selector#open()</code> 方法，发生 NullPointException 异常。详细解析，见 <a href="http://bugs.sun.com/view_bug.do?bug_id=6427854" rel="external nofollow noopener noreferrer" target="_blank">http://bugs.sun.com/view_bug.do?bug_id=6427854</a> 和 <a href="https://github.com/netty/netty/issues/203" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/netty/netty/issues/203</a> 。</li>
<li><code>&lt;2&gt;</code> 处，初始化 <code>SELECTOR_AUTO_REBUILD_THRESHOLD</code> 属性。默认 512 。</li>
</ul>
<h2 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The NIO {<span class="doctag">@link</span> Selector}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 包装的 Selector 对象，经过优化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #openSelector()}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未包装的 Selector 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册的 SelectionKey 集合。Netty 自己实现，经过优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SelectorProvider 对象，用于创建 Selector 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Boolean that controls determines if a blocked Selector.select should</span></span><br><span class="line"><span class="comment"> * break out of its selection process. In our case we use a timeout for</span></span><br><span class="line"><span class="comment"> * the select method and the select method will block for that time unless</span></span><br><span class="line"><span class="comment"> * waken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 唤醒标记。因为唤醒方法 {<span class="doctag">@link</span> Selector#wakeup()} 开销比较大，通过该标识，减少调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #wakeup(boolean)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #run() </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean wakenUp = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Select 策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #select(boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategy selectStrategy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 Channel 的就绪的 IO 事件，占处理任务的总时间的比例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ioRatio = <span class="number">50</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消 SelectionKey 的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO 1007 NioEventLoop cancel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cancelledKeys;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要再次 select Selector 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO 1007 NioEventLoop cancel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> needsToSelectAgain;</span><br><span class="line"></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">    }</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 创建 Selector 对象 &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Selector 相关：<ul>
<li><code>unwrappedSelector</code> 属性，未包装的 NIO Selector 对象。</li>
<li><code>selector</code> 属性，包装的 NIO Selector 对象。Netty 对 NIO Selector 做了优化。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。</li>
<li><code>selectedKeys</code> 属性，注册的 NIO SelectionKey 集合。Netty 自己实现，经过优化。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。 </li>
<li><code>provider</code> 属性，NIO SelectorProvider 对象，用于创建 NIO Selector 对象。</li>
<li>在 <code>&lt;1&gt;</code> 处，调用 <code>#openSelector()</code> 方法，创建 NIO Selector 对象。</li>
</ul>
</li>
<li><code>wakenUp</code> 属性，唤醒标记。因为唤醒方法 <code>Selector#wakeup()</code> 开销比较大，通过该标识，减少调用。详细解析，见 <a href="#">「2.8 wakeup」</a> 。</li>
<li><code>selectStrategy</code> 属性，Select 策略。详细解析，见 <a href="#">「2.10 SelectStrategy」</a> 。</li>
<li><code>ioRatio</code> 属性，在 NioEventLoop 中，会三种类型的任务：1) Channel 的就绪的 IO 事件；2) 普通任务；3) 定时任务。而 <code>ioRatio</code> 属性，处理 Channel 的就绪的 IO 事件，占处理任务的总时间的比例。</li>
<li>取消 SelectionKey 相关：<ul>
<li><code>cancelledKeys</code> 属性， 取消 SelectionKey 的数量。TODO 1007 NioEventLoop cancel</li>
<li><code>needsToSelectAgain</code> 属性，是否需要再次 select Selector 对象。TODO 1007 NioEventLoop cancel</li>
</ul>
</li>
</ul>
<h2 id="2-3-openSelector"><a href="#2-3-openSelector" class="headerlink" title="2.3 openSelector"></a>2.3 openSelector</h2><p><code>#openSelector()</code> 方法，创建 NIO Selector 对象。</p>
<p>考虑到让本文更专注在 EventLoop 的逻辑，并且不影响对本文的理解，所以暂时不讲解它的具体实现。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。 </p>
<h2 id="2-4-rebuildSelector"><a href="#2-4-rebuildSelector" class="headerlink" title="2.4 rebuildSelector"></a>2.4 rebuildSelector</h2><p><code>#rebuildSelector()</code> 方法，重建 NIO Selector 对象。</p>
<p>考虑到让本文更专注在 EventLoop 的逻辑，并且不影响对本文的理解，所以暂时不讲解它的具体实现。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。</p>
<h2 id="2-5-newTaskQueue"><a href="#2-5-newTaskQueue" class="headerlink" title="2.5 newTaskQueue"></a>2.5 newTaskQueue</h2><p><code>#newTaskQueue(int maxPendingTasks)</code> 方法，创建任务队列。代码如下：</p>
<blockquote>
<p>该方法覆写父类的该方法。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>{</span><br><span class="line">    <span class="comment">// This event loop never calls takeTask()</span></span><br><span class="line">    <span class="keyword">return</span> maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.&lt;Runnable&gt;newMpscQueue()</span><br><span class="line">                                                : PlatformDependent.&lt;Runnable&gt;newMpscQueue(maxPendingTasks);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>PlatformDependent#newMpscQueue(...)</code> 方法，创建 mpsc 队列。我们来看看代码注释对 mpsc 队列的描述：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Create a <span class="keyword">new</span> {<span class="meta">@link</span> Queue} <span class="function">which is safe to use <span class="keyword">for</span> multiple <span class="title">producers</span> <span class="params">(different threads)</span> and a single <span class="title">consumer</span> <span class="params">(one thread!)</span>.</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>mpsc 是 multiple producers and a single consumer 的缩写。</li>
<li>mpsc 是对<strong>多</strong>线程生产任务，<strong>单</strong>线程消费任务的消费，恰好符合 NioEventLoop 的情况。</li>
<li>详细解析，见后续文章。当然，着急的胖友，可以先看看 <a href="https://www.jianshu.com/p/119a03332619" rel="external nofollow noopener noreferrer" target="_blank">《原理剖析（第 012 篇）Netty 之无锁队列 MpscUnboundedArrayQueue 原理分析》</a> 。</li>
</ul>
</li>
</ul>
<h2 id="2-6-pendingTasks"><a href="#2-6-pendingTasks" class="headerlink" title="2.6 pendingTasks"></a>2.6 pendingTasks</h2><p><code>#pendingTasks()</code> 方法，获得待执行的任务数量。代码如下：</p>
<blockquote>
<p>该方法覆写父类的该方法。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pendingTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// As we use a MpscQueue we need to ensure pendingTasks() is only executed from within the EventLoop as</span></span><br><span class="line">    <span class="comment">// otherwise we may see unexpected behavior (as size() is only allowed to be called by a single consumer).</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/5297</span></span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.pendingTasks();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> submit(pendingTasksCallable).syncUninterruptibly().getNow();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 MpscQueue 仅允许单消费，所以获得队列的大小，仅允许在 EventLoop 的线程中调用。</li>
</ul>
<h2 id="2-7-setIoRatio"><a href="#2-7-setIoRatio" class="headerlink" title="2.7 setIoRatio"></a>2.7 setIoRatio</h2><p><code>#setIoRatio(int ioRatio)</code> 方法，设置 <code>ioRatio</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the percentage of the desired amount of time spent for I/O in the event loop.  The default value is</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIoRatio</span><span class="params">(<span class="keyword">int</span> ioRatio)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ioRatio &lt;= <span class="number">0</span> || ioRatio &gt; <span class="number">100</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ioRatio: "</span> + ioRatio + <span class="string">" (expected: 0 &lt; ioRatio &lt;= 100)"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.ioRatio = ioRatio;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-8-wakeup"><a href="#2-8-wakeup" class="headerlink" title="2.8 wakeup"></a>2.8 wakeup</h2><p><code>#wakeup(boolean inEventLoop)</code> 方法，唤醒线程。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) { <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        selector.wakeup(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，因为 NioEventLoop 的线程阻塞，主要是调用 <code>Selector#select(long timeout)</code> 方法，阻塞等待有 Channel 感兴趣的 IO 事件，或者超时。所以需要调用 <code>Selector#wakeup()</code> 方法，进行唤醒 Selector 。</li>
<li><code>&lt;2&gt;</code> 处，因为 <code>Selector#wakeup()</code> 方法的唤醒操作是开销比较大的操作，并且每次重复调用相当于重复唤醒。所以，通过 <code>wakenUp</code> 属性，通过 CAS 修改 <code>false =&gt; true</code> ，保证有且仅有进行一次唤醒。</li>
<li>当然，详细的解析，可以结合 <a href="#">「2.9 run」</a> 一起看，这样会更加清晰明了。</li>
</ul>
<h2 id="2-9-run"><a href="#2-9-run" class="headerlink" title="2.9 run"></a>2.9 run</h2><p><code>#run()</code> 方法，NioEventLoop 运行，处理任务。<strong>这是本文最重要的方法</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">5</span>:             <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {</span><br><span class="line"> <span class="number">6</span>:                 <span class="keyword">case</span> SelectStrategy.CONTINUE: <span class="comment">// 默认实现下，不存在这个情况。</span></span><br><span class="line"> <span class="number">7</span>:                     <span class="keyword">continue</span>;</span><br><span class="line"> <span class="number">8</span>:                 <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line"> <span class="number">9</span>:                     <span class="comment">// 重置 wakenUp 标记为 false</span></span><br><span class="line"><span class="number">10</span>:                     <span class="comment">// 选择( 查询 )任务</span></span><br><span class="line"><span class="number">11</span>:                     select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:                     <span class="comment">// 'wakenUp.compareAndSet(false, true)' is always evaluated</span></span><br><span class="line"><span class="number">14</span>:                     <span class="comment">// before calling 'selector.wakeup()' to reduce the wake-up</span></span><br><span class="line"><span class="number">15</span>:                     <span class="comment">// overhead. (Selector.wakeup() is an expensive operation.)</span></span><br><span class="line"><span class="number">16</span>:                     <span class="comment">//</span></span><br><span class="line"><span class="number">17</span>:                     <span class="comment">// However, there is a race condition in this approach.</span></span><br><span class="line"><span class="number">18</span>:                     <span class="comment">// The race condition is triggered when 'wakenUp' is set to</span></span><br><span class="line"><span class="number">19</span>:                     <span class="comment">// true too early.</span></span><br><span class="line"><span class="number">20</span>:                     <span class="comment">//</span></span><br><span class="line"><span class="number">21</span>:                     <span class="comment">// 'wakenUp' is set to true too early if:</span></span><br><span class="line"><span class="number">22</span>:                     <span class="comment">// 1) Selector is waken up between 'wakenUp.set(false)' and</span></span><br><span class="line"><span class="number">23</span>:                     <span class="comment">//    'selector.select(...)'. (BAD)</span></span><br><span class="line"><span class="number">24</span>:                     <span class="comment">// 2) Selector is waken up between 'selector.select(...)' and</span></span><br><span class="line"><span class="number">25</span>:                     <span class="comment">//    'if (wakenUp.get()) { ... }'. (OK)</span></span><br><span class="line"><span class="number">26</span>:                     <span class="comment">//</span></span><br><span class="line"><span class="number">27</span>:                     <span class="comment">// In the first case, 'wakenUp' is set to true and the</span></span><br><span class="line"><span class="number">28</span>:                     <span class="comment">// following 'selector.select(...)' will wake up immediately.</span></span><br><span class="line"><span class="number">29</span>:                     <span class="comment">// Until 'wakenUp' is set to false again in the next round,</span></span><br><span class="line"><span class="number">30</span>:                     <span class="comment">// 'wakenUp.compareAndSet(false, true)' will fail, and therefore</span></span><br><span class="line"><span class="number">31</span>:                     <span class="comment">// any attempt to wake up the Selector will fail, too, causing</span></span><br><span class="line"><span class="number">32</span>:                     <span class="comment">// the following 'selector.select(...)' call to block</span></span><br><span class="line"><span class="number">33</span>:                     <span class="comment">// unnecessarily.</span></span><br><span class="line"><span class="number">34</span>:                     <span class="comment">//</span></span><br><span class="line"><span class="number">35</span>:                     <span class="comment">// To fix this problem, we wake up the selector again if wakenUp</span></span><br><span class="line"><span class="number">36</span>:                     <span class="comment">// is true immediately after selector.select(...).</span></span><br><span class="line"><span class="number">37</span>:                     <span class="comment">// It is inefficient in that it wakes up the selector for both</span></span><br><span class="line"><span class="number">38</span>:                     <span class="comment">// the first case (BAD - wake-up required) and the second case</span></span><br><span class="line"><span class="number">39</span>:                     <span class="comment">// (OK - no wake-up required).</span></span><br><span class="line"><span class="number">40</span>: </span><br><span class="line"><span class="number">41</span>:                     <span class="comment">// 唤醒。原因，见上面中文注释</span></span><br><span class="line"><span class="number">42</span>:                     <span class="keyword">if</span> (wakenUp.get()) {</span><br><span class="line"><span class="number">43</span>:                         selector.wakeup();</span><br><span class="line"><span class="number">44</span>:                     }</span><br><span class="line"><span class="number">45</span>:                     <span class="comment">// fall through</span></span><br><span class="line"><span class="number">46</span>:                 <span class="keyword">default</span>:</span><br><span class="line"><span class="number">47</span>:             }</span><br><span class="line"><span class="number">48</span>: </span><br><span class="line"><span class="number">49</span>:             <span class="comment">// TODO 1007 NioEventLoop cancel 方法</span></span><br><span class="line"><span class="number">50</span>:             cancelledKeys = <span class="number">0</span>;</span><br><span class="line"><span class="number">51</span>:             needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">52</span>: </span><br><span class="line"><span class="number">53</span>:             <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line"><span class="number">54</span>:             <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) {</span><br><span class="line"><span class="number">55</span>:                 <span class="keyword">try</span> {</span><br><span class="line"><span class="number">56</span>:                     <span class="comment">// 处理 Channel 感兴趣的就绪 IO 事件</span></span><br><span class="line"><span class="number">57</span>:                     processSelectedKeys();</span><br><span class="line"><span class="number">58</span>:                 } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">59</span>:                     <span class="comment">// 运行所有普通任务和定时任务，不限制时间</span></span><br><span class="line"><span class="number">60</span>:                     <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line"><span class="number">61</span>:                     runAllTasks();</span><br><span class="line"><span class="number">62</span>:                 }</span><br><span class="line"><span class="number">63</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">64</span>:                 <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line"><span class="number">65</span>:                 <span class="keyword">try</span> {</span><br><span class="line"><span class="number">66</span>:                     <span class="comment">// 处理 Channel 感兴趣的就绪 IO 事件</span></span><br><span class="line"><span class="number">67</span>:                     processSelectedKeys();</span><br><span class="line"><span class="number">68</span>:                 } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">69</span>:                     <span class="comment">// 运行所有普通任务和定时任务，限制时间</span></span><br><span class="line"><span class="number">70</span>:                     <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line"><span class="number">71</span>:                     <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line"><span class="number">72</span>:                     runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line"><span class="number">73</span>:                 }</span><br><span class="line"><span class="number">74</span>:             }</span><br><span class="line"><span class="number">75</span>:         } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">76</span>:             handleLoopException(t);</span><br><span class="line"><span class="number">77</span>:         }</span><br><span class="line"><span class="number">78</span>:         <span class="comment">// TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="number">79</span>:         <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line"><span class="number">80</span>:         <span class="keyword">try</span> {</span><br><span class="line"><span class="number">81</span>:             <span class="keyword">if</span> (isShuttingDown()) {</span><br><span class="line"><span class="number">82</span>:                 closeAll();</span><br><span class="line"><span class="number">83</span>:                 <span class="keyword">if</span> (confirmShutdown()) {</span><br><span class="line"><span class="number">84</span>:                     <span class="keyword">return</span>;</span><br><span class="line"><span class="number">85</span>:                 }</span><br><span class="line"><span class="number">86</span>:             }</span><br><span class="line"><span class="number">87</span>:         } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">88</span>:             handleLoopException(t);</span><br><span class="line"><span class="number">89</span>:         }</span><br><span class="line"><span class="number">90</span>:     }</span><br><span class="line"><span class="number">91</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：“死”循环，直到 NioEventLoop 关闭，即【第 78 至 89 行】的代码。</li>
<li>第 5 行：调用 <code>SelectStrategy#calculateStrategy(IntSupplier selectSupplier, boolean hasTasks)</code> 方法，获得使用的 select 策略。详细解析，胖友先跳到 <a href="#">「2.10 SelectStrategy」</a> 中研究。😈 看完回来。<ul>
<li>我们知道 <code>SelectStrategy#calculateStrategy(...)</code> 方法，有 3 种返回的情况。</li>
<li>第 6 至 7 行：第一种，<code>SelectStrategy.CONTINUE</code> ，默认实现下，不存在这个情况。</li>
<li>第 8 至 44 行：第二种，<code>SelectStrategy.SELECT</code> ，进行 Selector <strong>阻塞</strong> select 。<ul>
<li>第 11 行：重置 <code>wakeUp</code> 标识为 <code>false</code> ，并返回修改前的值。</li>
<li>第 11 行：调用 <code>#select(boolean oldWakeUp)</code> 方法，选择( 查询 )任务。直接看这个方法不能完全表达出该方法的用途，所以详细解析，见 <a href="#">「2.12 select」</a> 。</li>
<li>第 41 至 44 行：若唤醒标识 <code>wakeup</code> 为 <code>true</code> 时，调用 <code>Selector#wakeup()</code> 方法，唤醒 Selector 。可能看到此处，很多胖友会和我一样，一脸懵逼。实际上，<strong>耐下性子</strong>，答案在上面的<strong>英文注释</strong>中。笔者来简单解析下：<ul>
<li>1）在 <code>wakenUp.getAndSet(false)</code> 和 <code>#select(boolean oldWakeUp)</code> 之间，在标识 <code>wakeUp</code> 设置为 <code>false</code> 时，在 <code>#select(boolean oldWakeUp)</code> 方法中，正在调用 <code>Selector#select(...)</code> 方法，处于<strong>阻塞</strong>中。</li>
<li>2）此时，有另外的线程调用了 <code>#wakeup()</code> 方法，会将标记 <code>wakeUp</code> 设置为 <code>true</code> ，并<strong>唤醒</strong> <code>Selector#select(...)</code> 方法的阻塞等待。</li>
<li>3）标识 <code>wakeUp</code> 为 <code>true</code> ，所以再有另外的线程调用 <code>#wakeup()</code> 方法，都无法唤醒 <code>Selector#select(...)</code> 。为什么呢？因为 <code>#wakeup()</code> 的 CAS 修改 <code>false =&gt; true</code> 会<strong>失败</strong>，导致无法调用 <code>Selector#wakeup()</code> 方法。</li>
<li>解决方式：所以在 <code>#select(boolean oldWakeUp)</code> 执行完后，增加了【第 41 至 44 行】来解决。</li>
<li>😈😈😈 整体比较绕，胖友结合实现代码 + 英文注释，再好好理解下。</li>
</ul>
</li>
</ul>
</li>
<li>第 46 行：第三种，<code>&gt;= 0</code> ，已经有可以处理的任务，直接向下。</li>
</ul>
</li>
<li>第 49 至 51 行：TODO 1007 NioEventLoop cancel 方法</li>
<li>第 53 至 74 行：根据 <code>ioRatio</code> 的配置不同，分成<strong>略有差异</strong>的 2 种：<ul>
<li>第一种，<code>ioRatio</code> 为 100 ，则<strong>不考虑</strong>时间占比的分配。<ul>
<li>第 57 行：调用 <code>#processSelectedKeys()</code> 方法，处理 Channel 感兴趣的就绪 IO 事件。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。</li>
<li>第 58 至 62 行：调用 <code>#runAllTasks()</code> 方法，运行所有普通任务和定时任务，<strong>不限制时间</strong>。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件》</a> 。</li>
</ul>
</li>
<li>第二种，<code>ioRatio</code> 为 <code>&lt; 100</code> ，则<strong>考虑</strong>时间占比的分配。<ul>
<li>第 64 行：记录当前时间。</li>
<li>第 67 行：和【第 57 行】的代码<strong>一样</strong>。 </li>
<li>第 71 至 72 行：🙂 比较巧妙的方式，是不是和胖友之前认为的不太一样。它是以 <code>#processSelectedKeys()</code> 方法的执行时间作为<strong>基准</strong>，计算 <code>#runAllTasks(long timeoutNanos)</code> 方法可执行的时间。</li>
<li>第 72 行：调用 #runAllTasks(long timeoutNanos)` 方法，运行所有普通任务和定时任务，<strong>限制时间</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 75 至 77 行：当发生异常时，调用 <code>#handleLoopException(Throwable t)</code> 方法，处理异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleLoopException</span><span class="params">(Throwable t)</span> </span>{</span><br><span class="line">    logger.warn(<span class="string">"Unexpected exception in the selector loop."</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent possible consecutive immediate failures that lead to</span></span><br><span class="line">    <span class="comment">// excessive CPU consumption.</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="comment">// Ignore.</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 78 至 89 行：TODO 1006 EventLoop 优雅关闭</p>
</li>
<li>总的来说，<code>#run()</code> 的执行过程，就是如下一张图：<a href="http://static2.iocoder.cn/images/Netty/2018_05_10/01.png" title="run" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_10/01.png" alt="run"></a><span class="caption">run</span></li>
</ul>
<h2 id="2-10-SelectStrategy"><a href="#2-10-SelectStrategy" class="headerlink" title="2.10 SelectStrategy"></a>2.10 SelectStrategy</h2><p><code>io.netty.channel.SelectStrategy</code> ，选择( select )策略接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectStrategy</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates a blocking select should follow.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 表示使用阻塞 select 的策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> SELECT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the IO loop should be retried, no blocking select to follow directly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 表示需要进行重试的策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CONTINUE = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The {<span class="doctag">@link</span> SelectStrategy} can be used to steer the outcome of a potential select</span></span><br><span class="line"><span class="comment">     * call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectSupplier The supplier with the result of a select result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hasTasks true if tasks are waiting to be processed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@link</span> #SELECT} if the next step should be blocking select {<span class="doctag">@link</span> #CONTINUE} if</span></span><br><span class="line"><span class="comment">     *         the next step should be to not select but rather jump back to the IO loop and try</span></span><br><span class="line"><span class="comment">     *         again. Any value &gt;= 0 is treated as an indicator that work needs to be done.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>calculateStrategy(IntSupplier selectSupplier, boolean hasTasks)</code> 接口方法有 <strong>3</strong> 种返回的情况：<ul>
<li><code>SELECT</code>，<code>-1</code> ，表示使用阻塞 <strong>select</strong> 的策略。</li>
<li><code>CONTINUE</code>，<code>-2</code>，表示需要进行重试的策略。实际上，默认情况下，不会返回 <code>CONTINUE</code> 的策略。</li>
<li><code>&gt;= 0</code> ，表示不需要 select  ，目前已经有可以执行的任务了。</li>
</ul>
</li>
</ul>
<h3 id="2-10-1-DefaultSelectStrategy"><a href="#2-10-1-DefaultSelectStrategy" class="headerlink" title="2.10.1 DefaultSelectStrategy"></a>2.10.1 DefaultSelectStrategy</h3><p><code>io.netty.channel.DefaultSelectStrategy</code> ，实现 SelectStrategy 接口，默认选择策略实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectStrategy</span> <span class="keyword">implements</span> <span class="title">SelectStrategy</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> SelectStrategy INSTANCE = <span class="keyword">new</span> DefaultSelectStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectStrategy</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>当 <code>hasTasks</code> 为 <code>true</code> ，表示当前已经有任务，所以调用 <code>IntSupplier#get()</code> 方法，返回当前 Channel 新增的 IO 就绪事件的数量。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntSupplier selectNowSupplier = <span class="keyword">new</span> IntSupplier() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> selectNow();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>io.netty.util.IntSupplier</code> ，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntSupplier</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>类似 Java 自带的 <code>Callable&lt;Int&gt;</code> 。</li>
</ul>
</li>
<li>IntSupplier 在 NioEventLoop 中的实现为 <code>selectNowSupplier</code> 属性。在它的内部会调用 <code>#selectNow()</code> 方法。详细解析，见 <a href="#">「2.11 selectNow」</a> 。</li>
<li>实际上，这里不调用 <code>IntSupplier#get()</code> 方法，也是可以的。只不过考虑到，可以通过 <code>#selectNow()</code> 方法，<strong>无阻塞</strong>的 select Channel 是否有感兴趣的就绪事件。</li>
</ul>
</li>
<li>当 <code>hasTasks</code> 为 <code>false</code> 时，直接返回 <code>SelectStrategy.SELECT</code> ，进行<strong>阻塞</strong> select Channel 感兴趣的就绪 IO 事件。</li>
</ul>
<h2 id="2-11-selectNow"><a href="#2-11-selectNow" class="headerlink" title="2.11 selectNow"></a>2.11 selectNow</h2><p><code>#selectNow()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> selector.selectNow(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// restore wakeup state if needed &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (wakenUp.get()) {</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>Selector#selectorNow()</code> 方法，立即( <strong>无阻塞</strong> )返回 Channel 新增的感兴趣的就绪 IO 事件数量。</li>
<li><p><code>&lt;2&gt;</code> 处，若唤醒标识 <code>wakeup</code> 为 <code>true</code> 时，调用 <code>Selector#wakeup()</code> 方法，唤醒 Selector 。因为 <code>&lt;1&gt;</code> 处的 <code>Selector#selectorNow()</code> 会使用我们对 Selector 的唤醒，所以需要进行<strong>复原</strong>。有一个冷知道，可能有胖友不知道：</p>
<blockquote>
<p>注意，如果有其它线程调用了 <code>#wakeup()</code> 方法，但当前没有线程阻塞在 <code>#select()</code> 方法上，下个调用 <code>#select()</code> 方法的线程会立即被唤醒。😈 有点神奇。</p>
</blockquote>
</li>
</ul>
<h2 id="2-12-select"><a href="#2-12-select" class="headerlink" title="2.12 select"></a>2.12 select</h2><p><code>#select(boolean oldWakenUp)</code> 方法，选择( 查询 )任务。<strong>这是本文最重要的方法</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// 记录下 Selector 对象</span></span><br><span class="line">  <span class="number">3</span>:     Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">try</span> {</span><br><span class="line">  <span class="number">5</span>:         <span class="comment">// select 计数器</span></span><br><span class="line">  <span class="number">6</span>:         <span class="keyword">int</span> selectCnt = <span class="number">0</span>; <span class="comment">// cnt 为 count 的缩写</span></span><br><span class="line">  <span class="number">7</span>:         <span class="comment">// 记录当前时间，单位：纳秒</span></span><br><span class="line">  <span class="number">8</span>:         <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">  <span class="number">9</span>:         <span class="comment">// 计算 select 截止时间，单位：纳秒。</span></span><br><span class="line"> <span class="number">10</span>:         <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"> <span class="number">11</span>: </span><br><span class="line"> <span class="number">12</span>:         <span class="keyword">for</span> (;;) {</span><br><span class="line"> <span class="number">13</span>:             <span class="comment">// 计算本次 select 的超时时长，单位：毫秒。</span></span><br><span class="line"> <span class="number">14</span>:             <span class="comment">// + 500000L 是为了四舍五入</span></span><br><span class="line"> <span class="number">15</span>:             <span class="comment">// / 1000000L 是为了纳秒转为毫秒</span></span><br><span class="line"> <span class="number">16</span>:             <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line"> <span class="number">17</span>:             <span class="comment">// 如果超时时长，则结束 select</span></span><br><span class="line"> <span class="number">18</span>:             <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) {</span><br><span class="line"> <span class="number">19</span>:                 <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) { <span class="comment">// 如果是首次 select ，selectNow 一次，非阻塞</span></span><br><span class="line"> <span class="number">20</span>:                     selector.selectNow();</span><br><span class="line"> <span class="number">21</span>:                     selectCnt = <span class="number">1</span>;</span><br><span class="line"> <span class="number">22</span>:                 }</span><br><span class="line"> <span class="number">23</span>:                 <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">24</span>:             }</span><br><span class="line"> <span class="number">25</span>: </span><br><span class="line"> <span class="number">26</span>:             <span class="comment">// If a task was submitted when wakenUp value was true, the task didn't get a chance to call</span></span><br><span class="line"> <span class="number">27</span>:             <span class="comment">// Selector#wakeup. So we need to check task queue again before executing select operation.</span></span><br><span class="line"> <span class="number">28</span>:             <span class="comment">// If we don't, the task might be pended until select operation was timed out.</span></span><br><span class="line"> <span class="number">29</span>:             <span class="comment">// It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span></span><br><span class="line"> <span class="number">30</span>:             <span class="comment">// 若有新的任务加入</span></span><br><span class="line"> <span class="number">31</span>:             <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line"> <span class="number">32</span>:                 <span class="comment">// selectNow 一次，非阻塞</span></span><br><span class="line"> <span class="number">33</span>:                 selector.selectNow();</span><br><span class="line"> <span class="number">34</span>:                 <span class="comment">// 重置 select 计数器</span></span><br><span class="line"> <span class="number">35</span>:                 selectCnt = <span class="number">1</span>;</span><br><span class="line"> <span class="number">36</span>:                 <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">37</span>:             }</span><br><span class="line"> <span class="number">38</span>: </span><br><span class="line"> <span class="number">39</span>:             <span class="comment">// 阻塞 select ，查询 Channel 是否有就绪的 IO 事件</span></span><br><span class="line"> <span class="number">40</span>:             <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line"> <span class="number">41</span>:             <span class="comment">// select 计数器 ++</span></span><br><span class="line"> <span class="number">42</span>:             selectCnt ++;</span><br><span class="line"> <span class="number">43</span>: </span><br><span class="line"> <span class="number">44</span>:             <span class="comment">// 结束 select ，如果满足下面任一一个条件</span></span><br><span class="line"> <span class="number">45</span>:             <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {</span><br><span class="line"> <span class="number">46</span>:                 <span class="comment">// - Selected something,</span></span><br><span class="line"> <span class="number">47</span>:                 <span class="comment">// - waken up by user, or</span></span><br><span class="line"> <span class="number">48</span>:                 <span class="comment">// - the task queue has a pending task.</span></span><br><span class="line"> <span class="number">49</span>:                 <span class="comment">// - a scheduled task is ready for processing</span></span><br><span class="line"> <span class="number">50</span>:                 <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">51</span>:             }</span><br><span class="line"> <span class="number">52</span>:             <span class="comment">// 线程被打断。一般情况下不会出现，出现基本是 bug ，或者错误使用。</span></span><br><span class="line"> <span class="number">53</span>:             <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line"> <span class="number">54</span>:                 <span class="comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span></span><br><span class="line"> <span class="number">55</span>:                 <span class="comment">// As this is most likely a bug in the handler of the user or it's client library we will</span></span><br><span class="line"> <span class="number">56</span>:                 <span class="comment">// also log it.</span></span><br><span class="line"> <span class="number">57</span>:                 <span class="comment">//</span></span><br><span class="line"> <span class="number">58</span>:                 <span class="comment">// See https://github.com/netty/netty/issues/2426</span></span><br><span class="line"> <span class="number">59</span>:                 <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line"> <span class="number">60</span>:                     logger.debug(<span class="string">"Selector.select() returned prematurely because "</span> +</span><br><span class="line"> <span class="number">61</span>:                             <span class="string">"Thread.currentThread().interrupt() was called. Use "</span> +</span><br><span class="line"> <span class="number">62</span>:                             <span class="string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span>);</span><br><span class="line"> <span class="number">63</span>:                 }</span><br><span class="line"> <span class="number">64</span>:                 selectCnt = <span class="number">1</span>;</span><br><span class="line"> <span class="number">65</span>:                 <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">66</span>:             }</span><br><span class="line"> <span class="number">67</span>: </span><br><span class="line"> <span class="number">68</span>:             <span class="comment">// 记录当前时间</span></span><br><span class="line"> <span class="number">69</span>:             <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line"> <span class="number">70</span>:             <span class="comment">// 符合 select 超时条件，重置 selectCnt 为 1</span></span><br><span class="line"> <span class="number">71</span>:             <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) {</span><br><span class="line"> <span class="number">72</span>:                 <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line"> <span class="number">73</span>:                 selectCnt = <span class="number">1</span>;</span><br><span class="line"> <span class="number">74</span>:             <span class="comment">// 不符合 select 超时的提交，若 select 次数到达重建 Selector 对象的上限，进行重建</span></span><br><span class="line"> <span class="number">75</span>:             } <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line"> <span class="number">76</span>:                     selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) {</span><br><span class="line"> <span class="number">77</span>:                 <span class="comment">// The selector returned prematurely many times in a row.</span></span><br><span class="line"> <span class="number">78</span>:                 <span class="comment">// Rebuild the selector to work around the problem.</span></span><br><span class="line"> <span class="number">79</span>:                 logger.warn(<span class="string">"Selector.select() returned prematurely {} times in a row; rebuilding Selector {}."</span>, selectCnt, selector);</span><br><span class="line"> <span class="number">80</span>: </span><br><span class="line"> <span class="number">81</span>:                 <span class="comment">// 重建 Selector 对象</span></span><br><span class="line"> <span class="number">82</span>:                 rebuildSelector();</span><br><span class="line"> <span class="number">83</span>:                 <span class="comment">// 修改下 Selector 对象</span></span><br><span class="line"> <span class="number">84</span>:                 selector = <span class="keyword">this</span>.selector;</span><br><span class="line"> <span class="number">85</span>: </span><br><span class="line"> <span class="number">86</span>:                 <span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line"> <span class="number">87</span>:                 <span class="comment">// 立即 selectNow 一次，非阻塞</span></span><br><span class="line"> <span class="number">88</span>:                 selector.selectNow();</span><br><span class="line"> <span class="number">89</span>:                 <span class="comment">// 重置 selectCnt 为 1</span></span><br><span class="line"> <span class="number">90</span>:                 selectCnt = <span class="number">1</span>;</span><br><span class="line"> <span class="number">91</span>:                 <span class="comment">// 结束 select</span></span><br><span class="line"> <span class="number">92</span>:                 <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">93</span>:             }</span><br><span class="line"> <span class="number">94</span>: </span><br><span class="line"> <span class="number">95</span>:             currentTimeNanos = time;</span><br><span class="line"> <span class="number">96</span>:         }</span><br><span class="line"> <span class="number">97</span>: </span><br><span class="line"> <span class="number">98</span>:         <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) {</span><br><span class="line"> <span class="number">99</span>:             <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line"><span class="number">100</span>:                 logger.debug(<span class="string">"Selector.select() returned prematurely {} times in a row for Selector {}."</span>, selectCnt - <span class="number">1</span>, selector);</span><br><span class="line"><span class="number">101</span>:             }</span><br><span class="line"><span class="number">102</span>:         }</span><br><span class="line"><span class="number">103</span>:     } <span class="keyword">catch</span> (CancelledKeyException e) {</span><br><span class="line"><span class="number">104</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line"><span class="number">105</span>:             logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">" raised by a Selector {} - JDK bug?"</span>, selector, e);</span><br><span class="line"><span class="number">106</span>:         }</span><br><span class="line"><span class="number">107</span>:         <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line"><span class="number">108</span>:     }</span><br><span class="line"><span class="number">109</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：获得使用的 Selector 对象，不需要每次访问使用 <code>volatile</code> 修饰的 <code>selector</code> 属性。</li>
<li>第 6 行：获得 select 操作的计数器。主要用于记录 Selector 空轮询次数，所以每次在正在轮询完成( 例如：轮询超时 )，则重置 <code>selectCnt</code> 为 1 。</li>
<li>第 8 行：记录当前时间，单位：纳秒。</li>
<li>第 10 行：计算 select 操作的截止时间，单位：纳秒。<ul>
<li><code>#delayNanos(currentTimeNanos)</code> 方法返回的为下一个定时任务距离现在的时间，如果不存在定时任务，则默认返回 1000 ms 。该方法的详细解析，见后续文章。</li>
</ul>
</li>
<li>第 12 行：“死”循环，直到符合如下<strong>任一</strong>一种情况后<strong>结束</strong>：<ol>
<li>select 操作超时，对应【第 18 至 24 行】。</li>
<li>若有新的任务加入，对应【第 26 至 37 行】。</li>
<li>查询到任务或者唤醒，对应【第 45 至 51 行】。</li>
<li>线程被异常打断，对应【第 52 至 66 行】。</li>
<li>发生 NIO 空轮询的 Bug 后重建 Selector 对象后，对应【第 75 至 93 行】。</li>
</ol>
</li>
<li>第 16 行：计算本次 select 的<strong>超时时长</strong>，单位：毫秒。因为【第 40 行】的 <code>Selector#select(timeoutMillis)</code> 方法，可能因为<strong>各种情况结束</strong>，所以需要循环，并且每次<strong>重新</strong>计算超时时间。至于 <code>+ 500000L</code> 和 <code>/ 1000000L</code> 的用途，看下代码注释。</li>
<li>第 17 至 24 行：如果超过 select 超时时长，则结束 select 。<ul>
<li>第 19 至 21 行：如果是首次 select ，则调用 <code>Selector#selectNow()</code> 方法，获得<strong>非阻塞</strong>的 Channel 感兴趣的就绪的 IO 事件，并重置 <code>selectCnt</code> 为 1 。</li>
</ul>
</li>
<li>第 26 至 37 行：若有新的任务加入。这里实际要分成两种情况：<ul>
<li>第一种，提交的任务的类型是 NonWakeupRunnable ，那么它并不会调用 <code>#wakeup()</code> 方法，原因胖友自己看 <code>#execute(Runnable task)</code> 思考下。Netty 在 <code>#select()</code> 方法的设计上，<strong>能尽快执行任务</strong>。此时如果标记 <code>wakeup</code> 为 <code>false</code> ，说明符合这种情况，直接结束 select 。</li>
<li>第二种，提交的任务的类型<strong>不是</strong> NonWakeupRunnable ，那么在 <code>#run()</code> 方法的【第 8 至 11 行】的 <code>wakenUp.getAndSet(false)</code> 之前，发起了一次 <code>#wakeup()</code> 方法，那么因为 <code>wakenUp.getAndSet(false)</code> 会将标记 <code>wakeUp</code> 设置为 <code>false</code> ，所以就能满足 <code>hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)</code> 的条件。<ul>
<li>这个解释，就和【第 27 至 28 行】的英文注释 <code>So we need to check task queue again before executing select operation.If we don't, the task might be pended until select operation was timed out.</code> 有出入了？这是为什么呢？因为 Selector 被提前 wakeup 了，所以下一次 Selector 的 select 是被直接唤醒结束的。</li>
</ul>
</li>
<li>第 33 行：虽然已经发现任务，但是还是调用 <code>Selector#selectNow()</code> 方法，<strong>非阻塞</strong>的获取一次 Channel 新增的就绪的 IO 事件。</li>
<li>对应 Github 的代码提交为 <a href="https://github.com/lightningMan/netty/commit/f44f3e7926f1676315ae86d0f18bdd9b95681d9f" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/lightningMan/netty/commit/f44f3e7926f1676315ae86d0f18bdd9b95681d9f</a> 。</li>
</ul>
</li>
<li>第 40 行：调用 <code>Selector#select(timeoutMillis)</code> 方法，<strong>阻塞</strong> select ，获得 Channel 新增的就绪的 IO 事件的数量。</li>
<li>第 42 行：select 计数器加 1 。</li>
<li>第 44 至 51 行：如果满足下面<strong>任一</strong>一个条件，结束 select ：<ol>
<li><code>selectedKeys != 0</code> 时，表示有 Channel 新增的就绪的 IO 事件，所以结束 select ，很好理解。</li>
<li><code>oldWakenUp || wakenUp.get()</code> 时，表示 Selector 被唤醒，所以结束 select 。</li>
<li><code>hasTasks()  || hasScheduledTasks()</code> ，表示有普通任务或定时任务，所以结束 select 。</li>
<li>那么剩余的情况，主要是 select <strong>超时</strong>或者发生<strong>空轮询</strong>，即【第 68 至 93 行】的代码。</li>
</ol>
</li>
<li>第 52 至 66 行：线程被打断。一般情况下不会出现，出现基本是 <strong>bug</strong> ，或者错误使用。感兴趣的胖友，可以看看 <a href="https://github.com/netty/netty/issues/2426" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/netty/netty/issues/2426</a> 。</li>
<li>第 69 行：记录当前时间。<ul>
<li>第 70 至 73 行：若满足 <code>time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos</code> ，说明到达此处时，Selector 是<strong>超时</strong> select ，那么是<strong>正常</strong>的，所以重置 <code>selectCnt</code> 为 1 。</li>
<li>第 74 至 93 行：不符合 select 超时的提交，若 select 次数到达重建 Selector 对象的上限，进行重建。<strong>这就是 Netty 判断发生 NIO Selector 空轮询的方式</strong>，N ( 默认 512 )次 select 并未阻塞超时这么长，那么就认为发生 NIO Selector 空轮询。过多的 NIO Selector 将会导致 CPU 100% 。<ul>
<li>第 82 行：调用 <code>#rebuildSelector()</code> 方法，重建 Selector 对象。</li>
<li>第 84 行：<strong>重新</strong>获得使用的 Selector 对象。</li>
<li>第 86 至 90 行：同【第 20 至 21 行】的代码。</li>
<li>第 92 行：结束 select 。</li>
</ul>
</li>
</ul>
</li>
<li>第 95 行：记录新的当前时间，用于【第 16 行】，<strong>重新</strong>计算本次 select 的超时时长。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>总的来说还是比较简单的，比较困难的，在于对标记 <code>wakeup</code> 的理解。真的是，细思极恐！！！感谢在理解过程中，闪电侠和大表弟普架的帮助。</p>
<p>推荐阅读文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/0d0eece6d467" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之揭开 reactor 线程的面纱（一）》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/d0f06b13e2fb" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析 Netty（四）–EventLoop-2》</a></li>
</ul>
<blockquote>
<p>老艿艿：全文的 NIO Selector 空轮询，指的是 epoll cpu 100% 的 bug 。</p>
</blockquote>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-4-EventLoop-run/" data-id="ck4pl3fow00dffgcf8jgv02ba" class="article-share-link">分享</a>



</footer>
-->
</div>