<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Util 之 HashedWheelTimer
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<p>笔者先把 Netty 主要的内容写完，所以关于 HashedWheelTimer 的分享，先放在后续的计划里。</p>
<blockquote>
<p>老艿艿：其实是因为，自己想去研究下 Service Mesh ，所以先简单收个小尾。</p>
</blockquote>
<p>当然，良心如我，还是为对这块感兴趣的胖友，先准备好了一篇不错的文章：</p>
<ul>
<li>德胜 <a href="https://my.oschina.net/haogrgr/blog/489320" rel="external nofollow noopener noreferrer" target="_blank">《Netty工具类HashedWheelTimer源码走读(一)》</a></li>
<li>德胜 <a href="https://my.oschina.net/haogrgr/blog/490266" rel="external nofollow noopener noreferrer" target="_blank">《Netty工具类HashedWheelTimer源码走读(二)》</a></li>
<li>德胜 <a href="https://my.oschina.net/haogrgr/blog/490348" rel="external nofollow noopener noreferrer" target="_blank">《Netty工具类HashedWheelTimer源码走读(三)》</a></li>
<li>Zacard <a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/" rel="external nofollow noopener noreferrer" target="_blank">《netty源码解读之时间轮算法实现-HashedWheelTimer》</a></li>
</ul>
<p>为避免可能 <a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/" rel="external nofollow noopener noreferrer" target="_blank">《netty源码解读之时间轮算法实现-HashedWheelTimer》</a> 被作者删除，笔者这里先复制一份作为备份。</p>
<h1 id="666-备份"><a href="#666-备份" class="headerlink" title="666. 备份"></a>666. 备份</h1><h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>由于netty动辄管理100w+的连接，每一个连接都会有很多超时任务。比如发送超时、心跳检测间隔等，如果每一个定时任务都启动一个<code>Timer</code>,不仅低效，而且会消耗大量的资源。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>根据George Varghese 和 Tony Lauck 1996 年的论文：<a href="http://static2.iocoder.cn/62dc58eaa06cbd6f431dc616c375b717" rel="external nofollow noopener noreferrer" target="_blank">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a>。提出了一种定时轮的方式来管理和维护大量的<code>Timer</code>调度.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>时间轮其实就是一种环形的数据结构，可以想象成时钟，分成很多格子，一个格子代码一段时间（这个时间越短，<code>Timer</code>的精度越高）。并用一个链表报错在该格子上的到期任务，同时一个指针随着时间一格一格转动，并执行相应格子中的到期任务。任务通过<code>取摸</code>决定放入那个格子。如下图所示：</p>
<p><a href="http://static2.iocoder.cn/89a84b18103e57fc95e596a47daa49c5" rel="external nofollow noopener noreferrer" target="_blank"><a href="http://static2.iocoder.cn/89a84b18103e57fc95e596a47daa49c5" title="img" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/89a84b18103e57fc95e596a47daa49c5" alt="img"></a><span class="caption">img</span></a></p>
<p>以上图为例，假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。</p>
<p>是不是很像java中的<code>Hashmap</code>。其实就是<code>HashMap</code>的哈希拉链算法，只不过多了指针转动与一些定时处理的逻辑。所以其相关的操作和<code>HashMap</code>也一致：</p>
<ul>
<li>添加任务：O(1)</li>
<li>删除/取消任务：O(1)</li>
<li>过期/执行任务：最差情况为O(n)-&gt;也就是当<code>HashMap</code>里面的元素全部hash冲突，退化为一条链表的情况。平均O(1)-&gt;显然，格子越多，每个格子上的链表就越短，这里需要权衡时间与空间。</li>
</ul>
<h3 id="多层时间轮"><a href="#多层时间轮" class="headerlink" title="多层时间轮"></a>多层时间轮</h3><p>如果任务的时间跨度很大，数量很大，单层的时间轮会造成任务的<code>round</code>很大，单个格子的链表很长。这时候可以将时间轮分层，类似于时钟的时分秒3层。如下图所示：</p>
<p><a href="http://static2.iocoder.cn/f3172a69ecb37b8c26871a2553bdeb2e" rel="external nofollow noopener noreferrer" target="_blank"><a href="http://static2.iocoder.cn/f3172a69ecb37b8c26871a2553bdeb2e" title="img" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/f3172a69ecb37b8c26871a2553bdeb2e" alt="img"></a><span class="caption">img</span></a></p>
<p>但是个人认为，多层的时间轮造成的算法复杂度的进一步提升。单层时间轮只需增加每一轮的格子就能解决链表过长的问题。因此，更倾向使用单层的时间轮，netty4中时间轮的实现也是单层的。</p>
<h2 id="netty时间轮的实现-HashedWheelTimer"><a href="#netty时间轮的实现-HashedWheelTimer" class="headerlink" title="netty时间轮的实现-HashedWheelTimer"></a>netty时间轮的实现-HashedWheelTimer</h2><h3 id="简单使用示例"><a href="#简单使用示例" class="headerlink" title="简单使用示例"></a>简单使用示例</h3><p>1.引入netty依赖</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>2.示例代码</p>
<p>示例1：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"start:"</span> + LocalDateTime.now().format(formatter));</span><br><span class="line"></span><br><span class="line">    hashedWheelTimer.newTimeout(timeout -&gt; {</span><br><span class="line">        System.out.println(<span class="string">"task :"</span> + LocalDateTime.now().format(formatter));</span><br><span class="line">    }, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为：</p>
<blockquote>
<p>start:2016-11-30 05:56:35</p>
<p>task :2016-11-30 05:56:38</p>
</blockquote>
<p>示例2：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"start:"</span> + LocalDateTime.now().format(formatter));</span><br><span class="line"></span><br><span class="line">    hashedWheelTimer.newTimeout(timeout -&gt; {</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"task1:"</span> + LocalDateTime.now().format(formatter));</span><br><span class="line">    }, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    hashedWheelTimer.newTimeout(timeout -&gt; System.out.println(<span class="string">"task2:"</span> + LocalDateTime.now().format(</span><br><span class="line">            formatter)), <span class="number">4</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<blockquote>
<p>start:2016-12-01 08:32:37</p>
<p>task1:2016-12-01 08:32:43</p>
<p>task2:2016-12-01 08:32:43</p>
</blockquote>
<p>可以看到，当前一个任务执行时间过长的时候，会影响后续任务的到期执行时间的。也就是说其中的任务是串行执行的。所以，要求里面的任务都要短平快。</p>
<h3 id="HashedWheelTimer源码之构造函数"><a href="#HashedWheelTimer源码之构造函数" class="headerlink" title="HashedWheelTimer源码之构造函数"></a>HashedWheelTimer源码之构造函数</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          ThreadFactory threadFactory, // 用来创建worker线程</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> tickDuration, // tick的时长，也就是指针多久转一格</span></span></span><br><span class="line"><span class="function"><span class="params">          TimeUnit unit, // tickDuration的时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> ticksPerWheel, // 一圈有几格</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> leakDetection // 是否开启内存泄露检测</span></span></span><br><span class="line"><span class="function"><span class="params">          )</span> </span>{</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一些参数校验</span></span><br><span class="line">      <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (unit == <span class="keyword">null</span>) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (tickDuration &lt;= <span class="number">0</span>) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"tickDuration must be greater than 0: "</span> + tickDuration);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建时间轮基本的数据结构，一个数组。长度为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">      wheel = createWheel(ticksPerWheel);</span><br><span class="line">      <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></span><br><span class="line">      <span class="comment">// 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：</span></span><br><span class="line">      <span class="comment">// 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;mast == deadline%wheel.length</span></span><br><span class="line">      <span class="comment">// java中的HashMap也是使用这种处理方法</span></span><br><span class="line">      mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 转换成纳秒处理</span></span><br><span class="line">      <span class="keyword">this</span>.tickDuration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&gt;Long.MAX_VALUE</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.tickDuration &gt;= Long.MAX_VALUE / wheel.length) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                  <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                  tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 创建worker线程</span></span><br><span class="line">      workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里默认是启动内存泄露检测：当HashedWheelTimer实例超过当前cpu可用核数*4的时候，将发出警告</span></span><br><span class="line">      leak = leakDetection || !workerThread.isDaemon() ? leakDetector.open(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p>再来看下<code>createWheel</code>的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) {</span><br><span class="line">      <span class="comment">// 一些参数校验</span></span><br><span class="line"><span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                  <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                  <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">      ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line"><span class="comment">// 初始化wheel数组</span></span><br><span class="line">      HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) {</span><br><span class="line">          wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> wheel;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p><code>normalizeTicksPerWheel()</code>的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) {</span><br><span class="line">           normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<p>这里其实不建议使用这种方式，因为当ticksPerWheel的值很大的时候，这个方法会循环很多次，方法执行时间不稳定，效率也不够。推荐使用java8 HashMap的做法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里参考java8 hashmap的算法，使推算的过程固定</span></span><br><span class="line">    <span class="keyword">int</span> n = ticksPerWheel - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 这里1073741824 = 2^30,防止溢出</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= <span class="number">1073741824</span>) ? <span class="number">1073741824</span> : n + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="HashedWheelTimer源码之启动、停止与添加任务"><a href="#HashedWheelTimer源码之启动、停止与添加任务" class="headerlink" title="HashedWheelTimer源码之启动、停止与添加任务"></a>HashedWheelTimer源码之启动、停止与添加任务</h3><p><code>start()</code>启动时间轮的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 启动时间轮。这个方法其实不需要显示的主动调用，因为在添加定时任务（newTimeout()方法）的时候会自动调用此方法。</span></span><br><span class="line"><span class="comment">// 这个是合理的设计，因为如果时间轮里根本没有定时任务，启动时间轮也是空耗资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断当前时间轮的状态，如果是初始化，则启动worker线程，启动整个时间轮；如果已经启动则略过；如果是已经停止，则报错</span></span><br><span class="line">    <span class="comment">// 这里是一个Lock Free的设计。因为可能有多个线程调用启动方法，这里使用AtomicIntegerFieldUpdater原子的更新时间轮的状态</span></span><br><span class="line">    <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) {</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {</span><br><span class="line">                workerThread.start();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待worker线程初始化时间轮的启动时间</span></span><br><span class="line">    <span class="keyword">while</span> (startTime == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            startTimeInitialized.await();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException ignore) {</span><br><span class="line">            <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AtomicIntegerFieldUpdater是JUC里面的类，原理是利用反射进行原子操作。有比AtomicInteger更好的性能和更低得内存占用。跟踪这个类的github 提交记录，可以看到更详细的<a href="http://static2.iocoder.cn/894e662550de6d9f418324da5b2469d5" rel="external nofollow noopener noreferrer" target="_blank">原因</a></p>
<p><code>stop()</code>停止时间轮的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// worker线程不能停止时间轮，也就是加入的定时任务，不能调用这个方法。</span></span><br><span class="line">    <span class="comment">// 不然会有恶意的定时任务调用这个方法而造成大量定时任务失效</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() == workerThread) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                HashedWheelTimer.class.getSimpleName() +</span><br><span class="line">                        <span class="string">".stop() cannot be called from "</span> +</span><br><span class="line">                        TimerTask.class.getSimpleName());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试CAS替换当前状态为“停止：2”。如果失败，则当前时间轮的状态只能是“初始化：0”或者“停止：2”。直接将当前状态设置为“停止：2“</span></span><br><span class="line">    <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {</span><br><span class="line">        <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">        WORKER_STATE_UPDATER.set(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leak != <span class="keyword">null</span>) {</span><br><span class="line">            leak.close();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终端worker线程</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (workerThread.isAlive()) {</span><br><span class="line">        workerThread.interrupt();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            workerThread.join(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException ignored) {</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从中断中恢复</span></span><br><span class="line">    <span class="keyword">if</span> (interrupted) {</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leak != <span class="keyword">null</span>) {</span><br><span class="line">        leak.close();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回未处理的任务</span></span><br><span class="line">    <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>newTimeout()</code>添加定时任务：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果时间轮没有启动，则启动</span></span><br><span class="line">    start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></span><br><span class="line">    <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></span><br><span class="line">    <span class="comment">// 计算任务的deadline</span></span><br><span class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line">    <span class="comment">// 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，会从队列里取出最多100000个任务加入到指定的格子中</span></span><br><span class="line">    HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line">    timeouts.add(timeout);</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里使用的Queue不是普通java自带的Queue的实现，而是使用<a href="http://static2.iocoder.cn/752997222ee0591298f89db49439b894" rel="external nofollow noopener noreferrer" target="_blank">JCTool</a>–一个高性能的的并发Queue实现包。</p>
<h3 id="HashedWheelTimer源码之HashedWheelTimeout"><a href="#HashedWheelTimer源码之HashedWheelTimeout" class="headerlink" title="HashedWheelTimer源码之HashedWheelTimeout"></a>HashedWheelTimer源码之HashedWheelTimeout</h3><p><code>HashedWheelTimeout</code>是一个定时任务的内部包装类，双向链表结构。会保存定时任务到期执行的任务、deadline、round等信息。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义定时任务的3个状态：初始化、取消、过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 用来CAS方式更新定时任务状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; updater =</span><br><span class="line">                PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimeout.class, <span class="string">"state"</span>);</span><br><span class="line">        <span class="keyword">if</span> (updater == <span class="keyword">null</span>) {</span><br><span class="line">            updater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, <span class="string">"state"</span>);</span><br><span class="line">        }</span><br><span class="line">        STATE_UPDATER = updater;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">    <span class="comment">// 具体到期需要执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>, <span class="string">"RedundantFieldInitialization"</span> })</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离任务执行的轮数，当将次任务加入到格子中是计算该值，每过一轮，该值减一。</span></span><br><span class="line">    <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表结构，由于只有worker线程会访问，这里不需要synchronization / volatile</span></span><br><span class="line">    HashedWheelTimeout next;</span><br><span class="line">    HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务所在的格子</span></span><br><span class="line">    HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">    HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) {</span><br><span class="line">        <span class="keyword">this</span>.timer = timer;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timer <span class="title">timer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> timer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimerTask <span class="title">task</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 这里只是修改状态为ST_CANCELLED，会在下次tick时，在格子中移除</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 加入到时间轮的待取消队列，并在每次tick的时候，从相应格子中移除。</span></span><br><span class="line">        timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从格子中移除自身</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">        HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</span><br><span class="line">        <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) {</span><br><span class="line">            bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expected, <span class="keyword">int</span> state)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, expected, state);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">state</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> state() == ST_CANCELLED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> state() == ST_EXPIRED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期并执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            task.run(<span class="keyword">this</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask.class.getSimpleName() + <span class="string">'.'</span>, t);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略过toString()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="HashedWheelTimer源码之HashedWheelBucket"><a href="#HashedWheelTimer源码之HashedWheelBucket" class="headerlink" title="HashedWheelTimer源码之HashedWheelBucket"></a>HashedWheelTimer源码之HashedWheelBucket</h3><p><code>HashedWheelBucket</code>用来存放HashedWheelTimeout，结构类似于LinkedList。提供了<code>expireTimeouts(long deadline)</code>方法来过期并执行格子中的定时任务</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>{</span><br><span class="line">    <span class="comment">// 指向格子中任务的首尾</span></span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础的链表添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>{</span><br><span class="line">        <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line">        timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">            head = tail = timeout;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            tail.next = timeout;</span><br><span class="line">            timeout.prev = tail;</span><br><span class="line">            tail = timeout;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法，根据deadline和remainingRounds判断任务是否过期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>{</span><br><span class="line">        HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历格子中的所有定时任务</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">boolean</span> remove = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) { <span class="comment">// 定时任务到期</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) {</span><br><span class="line">                    timeout.expire();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果round数已经为0，deadline却&gt;当前格子的deadline，说放错格子了，这种情况应该不会出现</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                            <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</span><br><span class="line">                }</span><br><span class="line">                remove = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) {</span><br><span class="line">                remove = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">//没有到期，轮数-1</span></span><br><span class="line">                timeout.remainingRounds --;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 先保存next，因为移除后next将被设置为null</span></span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line">            <span class="keyword">if</span> (remove) {</span><br><span class="line">                remove(timeout);</span><br><span class="line">            }</span><br><span class="line">            timeout = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础的链表移除node操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>{</span><br><span class="line">        HashedWheelTimeout next = timeout.next;</span><br><span class="line">        <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">        <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) {</span><br><span class="line">            timeout.prev.next = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) {</span><br><span class="line">            timeout.next.prev = timeout.prev;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout == head) {</span><br><span class="line">            <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">            <span class="keyword">if</span> (timeout == tail) {</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                head = next;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) {</span><br><span class="line">            <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">            tail = timeout.prev;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">        timeout.prev = <span class="keyword">null</span>;</span><br><span class="line">        timeout.next = <span class="keyword">null</span>;</span><br><span class="line">        timeout.bucket = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clear this bucket and return all not expired / cancelled {<span class="doctag">@link</span> Timeout}s.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearTimeouts</span><span class="params">(Set&lt;Timeout&gt; set)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            HashedWheelTimeout timeout = pollTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (timeout.isExpired() || timeout.isCancelled()) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            set.add(timeout);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表的poll操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HashedWheelTimeout <span class="title">pollTimeout</span><span class="params">()</span> </span>{</span><br><span class="line">        HashedWheelTimeout head = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        HashedWheelTimeout next = head.next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) {</span><br><span class="line">            tail = <span class="keyword">this</span>.head =  <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">this</span>.head = next;</span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// null out prev and next to allow for GC.</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head.prev = <span class="keyword">null</span>;</span><br><span class="line">        head.bucket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="HashedWheelTimer源码之Worker"><a href="#HashedWheelTimer源码之Worker" class="headerlink" title="HashedWheelTimer源码之Worker"></a>HashedWheelTimer源码之Worker</h3><p><code>Worker</code>是时间轮的核心线程类。tick的转动，过期任务的处理都是在这个线程中处理的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 初始化startTime.只有所有任务的的deadline都是想对于这个时间点</span></span><br><span class="line">        startTime = System.nanoTime();</span><br><span class="line">        <span class="comment">// 由于System.nanoTime()可能返回0，甚至负数。并且0是一个标示符，用来判断startTime是否被初始化，所以当startTime=0的时候，重新赋值为1</span></span><br><span class="line">        <span class="keyword">if</span> (startTime == <span class="number">0</span>) {</span><br><span class="line">            startTime = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒阻塞在start()的线程</span></span><br><span class="line">        startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要时间轮的状态为WORKER_STATE_STARTED，就循环的“转动”tick，循环判断响应格子中的到期任务</span></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">// waitForNextTick方法主要是计算下次tick的时间, 然后sleep到下次tick</span></span><br><span class="line">            <span class="comment">// 返回值就是System.nanoTime() - startTime, 也就是Timer启动后到这次tick, 所过去的时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line">            <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) { <span class="comment">// 可能溢出或者被中断的时候会返回负数, 所以小于等于0不管</span></span><br><span class="line">                <span class="comment">// 获取tick对应的格子索引</span></span><br><span class="line">                <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line">                <span class="comment">// 移除被取消的任务</span></span><br><span class="line">                processCancelledTasks();</span><br><span class="line">                HashedWheelBucket bucket =</span><br><span class="line">                        wheel[idx];</span><br><span class="line">                <span class="comment">// 从任务队列中取出任务加入到对应的格子中</span></span><br><span class="line">                transferTimeoutsToBuckets();</span><br><span class="line">                <span class="comment">// 过期执行格子中的任务</span></span><br><span class="line">                bucket.expireTimeouts(deadline);</span><br><span class="line">                tick++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里应该是时间轮停止了，清除所有格子中的任务，并加入到未处理任务列表，以供stop()方法返回</span></span><br><span class="line">        <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) {</span><br><span class="line">            bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将还没有加入到格子中的待处理定时任务队列中的任务取出，如果是未取消的任务，则加入到未处理任务队列中，以供stop()方法返回</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!timeout.isCancelled()) {</span><br><span class="line">                unprocessedTimeouts.add(timeout);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理取消的任务</span></span><br><span class="line">        processCancelledTasks();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 每次tick只处理10w个任务，以免阻塞worker线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {</span><br><span class="line">            HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">            <span class="comment">// 如果没有任务了，直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 还没有放入到格子中就取消了，直接略过</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算任务需要经过多少个tick</span></span><br><span class="line">            <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line">            <span class="comment">// 计算任务的轮数</span></span><br><span class="line">            timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line">            <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务加入到响应的格子中</span></span><br><span class="line">            HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line">            bucket.addTimeout(timeout);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将取消的任务取出，并从格子中移除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            HashedWheelTimeout timeout = cancelledTimeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// all processed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                timeout.remove();</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                    logger.warn(<span class="string">"An exception was thrown while process a cancellation task"</span>, t);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * calculate goal nanoTime from startTime and current tick number,</span></span><br><span class="line"><span class="comment">     * then wait until that goal has been reached.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Long.MIN_VALUE if received a shutdown request,</span></span><br><span class="line"><span class="comment">     * current time otherwise (with Long.MIN_VALUE changed by +1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//sleep, 直到下次tick到来, 然后返回该次tick和启动时间之间的时长</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//下次tick的时间点, 用于计算需要sleep的时间</span></span><br><span class="line">        <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 计算需要sleep的时间, 之所以加999999后再除10000000, 是为了保证足够的sleep时间</span></span><br><span class="line">            <span class="comment">// 例如：当deadline - currentTime=2000002的时候，如果不加999999，则只睡了2ms，</span></span><br><span class="line">            <span class="comment">// 而2ms其实是未到达deadline这个时间点的，所有为了使上述情况能sleep足够的时间，加上999999后，会多睡1ms</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line">            <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) {</span><br><span class="line">	<span class="comment">// 以下为个人理解：（如有错误，欢迎大家指正）</span></span><br><span class="line">                <span class="comment">// 这里的意思应该是从时间轮启动到现在经过太长的时间(跨度大于292年...)，以至于让long装不下，都溢出了...对于netty的严谨，我服！</span></span><br><span class="line">                <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) {</span><br><span class="line">                    <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> currentTime;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">            <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">            <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">            <span class="keyword">if</span> (PlatformDependent.isWindows()) { <span class="comment">// 这里是因为windows平台的定时调度最小单位为10ms，如果不是10ms的倍数，可能会引起sleep时间不准确</span></span><br><span class="line">                sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(sleepTimeMs);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException ignored) {</span><br><span class="line">	<span class="comment">// 调用HashedWheelTimer.stop()时优雅退出</span></span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) {</span><br><span class="line">                    <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">unprocessedTimeouts</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(unprocessedTimeouts);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码，学到了很多之前不知道的知识点和注意事项。比如：</p>
<ol>
<li>操作数字型要考虑溢出问题</li>
<li>System.nanoTime(）返回值</li>
<li>Atomic*FieldUpdater类的运用</li>
<li>一些代码设计方式</li>
<li>不断优化性能，Lock Less代替Lock；Lock Free代替Lock Less</li>
<li>JCTool高性能队列的使用</li>
</ol>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Util-4-HashedWheelTimer/" data-id="ck4pl3fpg00erfgcflfiecqbv" class="article-share-link">分享</a>



</footer>
-->
</div>