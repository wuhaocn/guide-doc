<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在应用程序里，我们可以使用 PooledByteBufAllocator 来创建 ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">PooledByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法的内部实现，通过 PoolArena 来进行内存分配。</li>
</ul>
<p>下面，就让我们来看看 PoolArena 具体的代码实现。</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/15304cd63175" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–JEMalloc分配算法》</a></p>
<p>为了提高内存分配效率并减少内部碎片，Jemalloc 算法将 Arena 切分为小块 Chunk，根据每块的内存使用率又将小块组合为以下几种状态：QINIT、Q00、Q25、Q50、Q75、Q100 。Chunk 块可以在这几种状态间随着内存使用率的变化进行转移，从而提高分配效率。</p>
</blockquote>
<h1 id="2-PoolArena"><a href="#2-PoolArena" class="headerlink" title="2. PoolArena"></a>2. PoolArena</h1><p><code>io.netty.buffer.PoolArena</code> ，实现 PoolArenaMetric 接口，Netty 对 Jemalloc Arena 的抽象实现类。</p>
<p>PoolArena 有两个子类实现：</p>
<ul>
<li>HeapArena ，对 Heap 类型的内存分配。</li>
<li>DirectArena ，对 Direct 类型的内存分配。</li>
</ul>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持 Unsafe 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> HAS_UNSAFE = PlatformDependent.hasUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存分类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> SizeClass {</span><br><span class="line">    Tiny,</span><br><span class="line">    Small,</span><br><span class="line">    Normal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有一个隐藏的，Huge</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #tinySubpagePools} 数组的大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认为 32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> numTinySubpagePools = <span class="number">512</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 PooledByteBufAllocator 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> PooledByteBufAllocator parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 满二叉树的高度。默认为 11 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxOrder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Page 大小，默认 8KB = 8192B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 1 开始左移到 {<span class="doctag">@link</span> #pageSize} 的位数。默认 13 ，1 &lt;&lt; 13 = 8192 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pageShifts;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 内存块占用大小。默认为 16M = 16 * 1024  。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断分配请求内存是否为 Tiny/Small ，即分配 Subpage 内存块。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Used to determine if the requested capacity is equal to or greater than pageSize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> subpageOverflowMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #smallSubpagePools} 数组的大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认为 23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> numSmallSubpagePools;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对齐基准</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> directMemoryCacheAlignment;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #directMemoryCacheAlignment} 掩码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> directMemoryCacheAlignmentMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tiny 类型的 PoolSubpage 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组的每个元素，都是双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * small 类型的 SubpagePools 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组的每个元素，都是双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] smallSubpagePools;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoolChunkList 之间的双向链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q050;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q025;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q000;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; qInit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q075;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q100;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolChunkListMetric 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolChunkListMetric&gt; chunkListMetrics;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Metrics for allocations and deallocations</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配 Normal 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> allocationsNormal;</span><br><span class="line"><span class="comment">// We need to use the LongCounter here as this is not guarded via synchronized block.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配 Tiny 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LongCounter allocationsTiny = PlatformDependent.newLongCounter();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配 Small 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LongCounter allocationsSmall = PlatformDependent.newLongCounter();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配 Huge 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LongCounter allocationsHuge = PlatformDependent.newLongCounter();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正在使用中的 Huge 内存块的总共占用字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LongCounter activeBytesHuge = PlatformDependent.newLongCounter();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 Tiny 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> deallocationsTiny;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 Small 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> deallocationsSmall;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 Normal 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> deallocationsNormal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 Huge 内存块的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// We need to use the LongCounter here as this is not guarded via synchronized block.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LongCounter deallocationsHuge = PlatformDependent.newLongCounter();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该 PoolArena 被多少线程引用的计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Number of thread caches backed by this arena.</span></span><br><span class="line"><span class="keyword">final</span> AtomicInteger numThreadCaches = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="title">PoolArena</span><span class="params">(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">2</span>:       <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> cacheAlignment)</span> </span>{</span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">  <span class="number">5</span>:     <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">  <span class="number">6</span>:     <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">  <span class="number">7</span>:     <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">  <span class="number">8</span>:     directMemoryCacheAlignment = cacheAlignment;</span><br><span class="line">  <span class="number">9</span>:     directMemoryCacheAlignmentMask = cacheAlignment - <span class="number">1</span>;</span><br><span class="line"> <span class="number">10</span>:     subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line"> <span class="number">11</span>: </span><br><span class="line"> <span class="number">12</span>:     <span class="comment">// 初始化 tinySubpagePools 数组</span></span><br><span class="line"> <span class="number">13</span>:     tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);</span><br><span class="line"> <span class="number">14</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) {</span><br><span class="line"> <span class="number">15</span>:         tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line"> <span class="number">16</span>:     }</span><br><span class="line"> <span class="number">17</span>: </span><br><span class="line"> <span class="number">18</span>:     <span class="comment">// 初始化 smallSubpagePools 数组</span></span><br><span class="line"> <span class="number">19</span>:     numSmallSubpagePools = pageShifts - <span class="number">9</span>;</span><br><span class="line"> <span class="number">20</span>:     smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);</span><br><span class="line"> <span class="number">21</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smallSubpagePools.length; i ++) {</span><br><span class="line"> <span class="number">22</span>:         smallSubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line"> <span class="number">23</span>:     }</span><br><span class="line"> <span class="number">24</span>: </span><br><span class="line"> <span class="number">25</span>:     <span class="comment">// PoolChunkList 之间的双向链表，初始化</span></span><br><span class="line"> <span class="number">26</span>: </span><br><span class="line"> <span class="number">27</span>:     q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line"> <span class="number">28</span>:     q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line"> <span class="number">29</span>:     q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line"> <span class="number">30</span>:     q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line"> <span class="number">31</span>:     q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line"> <span class="number">32</span>:     qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br><span class="line"> <span class="number">33</span>: </span><br><span class="line"> <span class="number">34</span>:     q100.prevList(q075);</span><br><span class="line"> <span class="number">35</span>:     q075.prevList(q050);</span><br><span class="line"> <span class="number">36</span>:     q050.prevList(q025);</span><br><span class="line"> <span class="number">37</span>:     q025.prevList(q000);</span><br><span class="line"> <span class="number">38</span>:     q000.prevList(<span class="keyword">null</span>); <span class="comment">// 无前置节点</span></span><br><span class="line"> <span class="number">39</span>:     qInit.prevList(qInit); <span class="comment">// 前置节点为自己</span></span><br><span class="line"> <span class="number">40</span>: </span><br><span class="line"> <span class="number">41</span>:     <span class="comment">// 创建 PoolChunkListMetric 数组</span></span><br><span class="line"> <span class="number">42</span>:     List&lt;PoolChunkListMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolChunkListMetric&gt;(<span class="number">6</span>);</span><br><span class="line"> <span class="number">43</span>:     metrics.add(qInit);</span><br><span class="line"> <span class="number">44</span>:     metrics.add(q000);</span><br><span class="line"> <span class="number">45</span>:     metrics.add(q025);</span><br><span class="line"> <span class="number">46</span>:     metrics.add(q050);</span><br><span class="line"> <span class="number">47</span>:     metrics.add(q075);</span><br><span class="line"> <span class="number">48</span>:     metrics.add(q100);</span><br><span class="line"> <span class="number">49</span>:     chunkListMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line"> <span class="number">50</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>虽然属性比较多，但是内部主要还是以 PoolSubpage 和 PoolChunkList 对象为主。如下图所示：</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/4856bd30dd56" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolArena》</a></p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_09_13/01.png" title="大体结构" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_13/01.png" alt="大体结构"></a><span class="caption">大体结构</span></p>
</blockquote>
</li>
<li><p>SizeClass <strong>枚举类</strong>，内存分类，一共有四种：Tiny、Small、Normal、Huge 。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_13/02.png" title="内存分配" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_13/02.png" alt="内存分配"></a><span class="caption">内存分配</span></p>
</li>
<li><p><code>parent</code> 属性，所属 PooledByteBufAllocator 对象。</p>
</li>
<li>内存属性相关<ul>
<li><code>HAS_UNSAFE</code> <strong>静态</strong>属性，是否支持 Unsafe 操作。 </li>
<li><code>directMemoryCacheAlignment</code> 属性，对齐基准，默认为 0 。😈 实际可以忽略哈。</li>
<li><code>directMemoryCacheAlignmentMask</code> 属性，<code>directMemoryCacheAlignment</code> 的掩码，默认为 -1( 【第 9 行】的代码 <code>directMemoryCacheAlignment - 1</code> )。😈 实际可以忽略哈。</li>
</ul>
</li>
<li>PoolChunk 属性相关，<code>maxOrder</code>、<code>pageSize</code>、<code>pageShifts</code>、<code>chunkSize</code>、<code>subpageOverflowMask</code> 。已经在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》</a> 。</li>
<li>PoolSubpage 属性相关<ul>
<li><code>tinySubpagePools</code> 属性，tiny 类型的 PoolSubpage 数组。数组的每个元素，都是<strong>双向链表</strong>。<ul>
<li>在【第 12 至 16 行】的代码，进行初始化。</li>
<li><code>numTinySubpagePools</code> <strong>静态</strong>属性，数组大小。默认为 32 。</li>
</ul>
</li>
<li><code>smallSubpagePools</code> 属性，small 类型的 SubpagePools 数组。数组的每个元素，都是<strong>双向链表</strong>。<ul>
<li>在【第 18 至 23 行】的代码，进行初始化。</li>
<li><code>numSmallSubpagePools</code> 属性，数组大小。默认为 23( <code>numTinySubpagePools - 9</code> )。</li>
</ul>
</li>
</ul>
</li>
<li>PoolChunkList 属性相关，<code>qInit</code>、<code>q025</code>、<code>q050</code>、<code>q075</code>、<code>q100</code>、<code>chunkListMetrics</code> 。已经在 <a href="http://svip.iocoder.cn/Netty/Netty/ByteBuf-3-4-Jemalloc-chunkList">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（四）PoolChunkList》</a> 。</li>
<li>PoolArenaMetric 属性相关<ul>
<li>分配 <em>XXX</em> 内存块的次数的属性：<code>allocationsNormal</code>、<code>allocationsTiny</code>、<code>allocationsSmall</code>、<code>allocationsHuge</code> 。</li>
<li>释放 <em>XXX</em> 内存块的次数的属性：<code>deallocationsTiny</code>、<code>deallocationsSmall</code>、<code>deallocationsNormal</code>、<code>deallocationsHuge</code> 。</li>
<li>↑↑↑ 上述属性使用 LongCounter 还是 <code>long</code> 类型，主要是变量访问时，是否在 <code>synchronized {}</code> 代码块中访问，从而保证<strong>内存的可见性</strong>。 </li>
<li><code>activeBytesHuge</code> 属性，<strong>正在使用中</strong>的 Huge 内存块的总共占用字节数。</li>
<li><code>numThreadCaches</code> 属性，该 PoolArena 被多少线程引用的计数器。</li>
</ul>
</li>
<li>😈 构造方法，简单看看就好，基本上面都已经提到了。</li>
</ul>
<h2 id="2-2-容量相关方法"><a href="#2-2-容量相关方法" class="headerlink" title="2.2 容量相关方法"></a>2.2 容量相关方法</h2><h3 id="2-2-1-normalizeCapacity"><a href="#2-2-1-normalizeCapacity" class="headerlink" title="2.2.1 normalizeCapacity"></a>2.2.1 normalizeCapacity</h3><p><code>#normalizeCapacity(int reqCapacity)</code> 方法，标准化请求分配的内存大小。通过这样的方式，<strong>保证分配的内存块统一</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">int</span> <span class="title">normalizeCapacity</span><span class="params">(<span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (reqCapacity &lt; <span class="number">0</span>) {</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"capacity: "</span> + reqCapacity + <span class="string">" (expected: 0+)"</span>);</span><br><span class="line"> <span class="number">4</span>:     }</span><br><span class="line"> <span class="number">5</span>: </span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// Huge 内存类型，直接使用 reqCapacity ，无需进行标准化。</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (reqCapacity &gt;= chunkSize) {</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">return</span> directMemoryCacheAlignment == <span class="number">0</span> ? reqCapacity : alignCapacity(reqCapacity);</span><br><span class="line"> <span class="number">9</span>:     }</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 非 tiny 内存类型</span></span><br><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (!isTiny(reqCapacity)) { <span class="comment">// &gt;= 512</span></span><br><span class="line"><span class="number">13</span>:         <span class="comment">// Doubled</span></span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 转换成接近于两倍的容量</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">int</span> normalizedCapacity = reqCapacity;</span><br><span class="line"><span class="number">16</span>:         normalizedCapacity --;</span><br><span class="line"><span class="number">17</span>:         normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">1</span>;</span><br><span class="line"><span class="number">18</span>:         normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">2</span>;</span><br><span class="line"><span class="number">19</span>:         normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">4</span>;</span><br><span class="line"><span class="number">20</span>:         normalizedCapacity |= normalizedCapacity &gt;&gt;&gt;  <span class="number">8</span>;</span><br><span class="line"><span class="number">21</span>:         normalizedCapacity |= normalizedCapacity &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="number">22</span>:         normalizedCapacity ++;</span><br><span class="line"><span class="number">23</span>:         <span class="keyword">if</span> (normalizedCapacity &lt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">24</span>:             normalizedCapacity &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="number">25</span>:         }</span><br><span class="line"><span class="number">26</span>:         <span class="keyword">assert</span> directMemoryCacheAlignment == <span class="number">0</span> || (normalizedCapacity &amp; directMemoryCacheAlignmentMask) == <span class="number">0</span>;</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:         <span class="keyword">return</span> normalizedCapacity;</span><br><span class="line"><span class="number">29</span>:     }</span><br><span class="line"><span class="number">30</span>: </span><br><span class="line"><span class="number">31</span>:     <span class="keyword">if</span> (directMemoryCacheAlignment &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">32</span>:         <span class="keyword">return</span> alignCapacity(reqCapacity);</span><br><span class="line"><span class="number">33</span>:     }</span><br><span class="line"><span class="number">34</span>: </span><br><span class="line"><span class="number">35</span>:     <span class="comment">// 补齐成 16 的倍数</span></span><br><span class="line"><span class="number">36</span>:     <span class="comment">// Quantum-spaced</span></span><br><span class="line"><span class="number">37</span>:     <span class="keyword">if</span> ((reqCapacity &amp; <span class="number">15</span>) == <span class="number">0</span>) {</span><br><span class="line"><span class="number">38</span>:         <span class="keyword">return</span> reqCapacity;</span><br><span class="line"><span class="number">39</span>:     }</span><br><span class="line"><span class="number">40</span>:     <span class="keyword">return</span> (reqCapacity &amp; ~<span class="number">15</span>) + <span class="number">16</span>;</span><br><span class="line"><span class="number">41</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 6 至 9 行：<strong>Huge</strong> 内存类型，直接使用 reqCapacity ，无需进行标准化。</li>
<li>第 11 至 29 行：<strong>Small</strong>、<strong>Normal</strong> 内存类型，转换成接近于<strong>两倍</strong>的容量。</li>
<li>第 35 至 40 行：<strong>Tiny</strong> 内存类型，补齐成 <strong>16</strong> 的倍数。</li>
</ul>
<p>总结来说，还是下图：<a href="http://static2.iocoder.cn/images/Netty/2018_09_13/03.png" title="内存容量" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_13/03.png" alt="内存容量"></a><span class="caption">内存容量</span></p>
<h3 id="2-2-2-alignCapacity"><a href="#2-2-2-alignCapacity" class="headerlink" title="2.2.2 alignCapacity"></a>2.2.2 alignCapacity</h3><p><code>#alignCapacity(int reqCapacity)</code> 方法，对齐请求分配的内存大小。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alignCapacity</span><span class="params">(<span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得 delta</span></span><br><span class="line">    <span class="keyword">int</span> delta = reqCapacity &amp; directMemoryCacheAlignmentMask;</span><br><span class="line">    <span class="comment">// 补齐 directMemoryCacheAlignment ，并减去 delta</span></span><br><span class="line">    <span class="keyword">return</span> delta == <span class="number">0</span> ? reqCapacity : reqCapacity + directMemoryCacheAlignment - delta;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-3-isTinyOrSmall"><a href="#2-2-3-isTinyOrSmall" class="headerlink" title="2.2.3 isTinyOrSmall"></a>2.2.3 isTinyOrSmall</h3><p><code>#isTinyOrSmall(int normCapacity)</code> 方法，判断请求分配的内存类型是否为 tiny 或 small 类型。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// capacity &lt; pageSize</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTinyOrSmall</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (normCapacity &amp; subpageOverflowMask) == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-4-isTiny"><a href="#2-2-4-isTiny" class="headerlink" title="2.2.4 isTiny"></a>2.2.4 isTiny</h3><p><code>#isTiny(int normCapacity)</code> 方法，判断请求分配的内存类型是否为 tiny 类型。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// normCapacity &lt; 512</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTiny</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (normCapacity &amp; <span class="number">0xFFFFFE00</span>) == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-5-tinyIdx"><a href="#2-2-5-tinyIdx" class="headerlink" title="2.2.5 tinyIdx"></a>2.2.5 tinyIdx</h3><p><code>#tinyIdx(int normCapacity)</code> <strong>静态</strong>方法，计算请求分配的内存大小在 <code>tinySubpagePools</code> 数组的下标。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tinyIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> normCapacity &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-6-smallIdx"><a href="#2-2-6-smallIdx" class="headerlink" title="2.2.6 smallIdx"></a>2.2.6 smallIdx</h3><p><code>#smallIdx(int normCapacity)</code> <strong>静态</strong>方法，计算请求分配的内存大小在 <code>smallSubpagePools</code> 数组的下标。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tableIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = normCapacity &gt;&gt;&gt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span>) {</span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        tableIdx ++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tableIdx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-7-sizeClass"><a href="#2-2-7-sizeClass" class="headerlink" title="2.2.7 sizeClass"></a>2.2.7 sizeClass</h3><p><code>#sizeClass(int normCapacity)</code> 方法，计算请求分配的内存的内存类型。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SizeClass <span class="title">sizeClass</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isTinyOrSmall(normCapacity)) {</span><br><span class="line">        <span class="keyword">return</span> SizeClass.Normal;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isTiny(normCapacity) ? SizeClass.Tiny : SizeClass.Small;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-3-findSubpagePoolHead"><a href="#2-3-findSubpagePoolHead" class="headerlink" title="2.3 findSubpagePoolHead"></a>2.3 findSubpagePoolHead</h2><p><code>#findSubpagePoolHead(int elemSize)</code> 方法，获得请求分配的 Subpage 类型的内存的链表的<strong>头节点</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">PoolSubpage&lt;T&gt; <span class="title">findSubpagePoolHead</span><span class="params">(<span class="keyword">int</span> elemSize)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tableIdx;</span><br><span class="line">    PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">    <span class="keyword">if</span> (isTiny(elemSize)) { <span class="comment">// &lt; 512</span></span><br><span class="line">        <span class="comment">// 实际上，就是 `#tinyIdx(int normCapacity)` 方法</span></span><br><span class="line">        tableIdx = elemSize &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 获得 table</span></span><br><span class="line">        table = tinySubpagePools;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 实际上，就是 `#smallIdx(int normCapacity)` 方法</span></span><br><span class="line">        tableIdx = <span class="number">0</span>;</span><br><span class="line">        elemSize &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (elemSize != <span class="number">0</span>) {</span><br><span class="line">            elemSize &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            tableIdx ++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获得 table</span></span><br><span class="line">        table = smallSubpagePools;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 Subpage 链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> table[tableIdx];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-4-allocate"><a href="#2-4-allocate" class="headerlink" title="2.4 allocate"></a>2.4 allocate</h2><p>PoolArena 根据申请分配的内存大小不同，提供了<strong>两种</strong>方式分配内存：</p>
<ul>
<li>1、PoolSubpage ，用于分配<strong>小于</strong> <code>8KB</code> 的内存块<ul>
<li>1.1 <code>tinySubpagePools</code> 属性，用于分配小于 <code>512B</code> 的 tiny <strong>Subpage</strong> 内存块。</li>
<li>1.2  <code>smallSubpagePools</code> 属性，用于分配小于 <code>8KB</code> 的 small <strong>Subpage</strong> 内存块。</li>
</ul>
</li>
<li>2、PoolChunkList ，用于分配<strong>大于等于</strong> <code>8KB</code> 的内存块<ul>
<li>2.1 小于 <code>32MB</code> ，分配 normal 内存块，即一个 Chunk 中的 <strong>Page</strong> 内存块。</li>
<li>2.2 大于等于 <code>32MB</code> ，分配 huge 内存块，即一整个 <strong>Chunk</strong> 内存块。</li>
</ul>
</li>
</ul>
<hr>
<p><code>#allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity)</code> 方法，创建 PooledByteBuf 对象，并分配内存块给 PooledByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 标准化请求分配的容量</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// PoolSubpage 的情况</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) { <span class="comment">// capacity &lt; pageSize</span></span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">int</span> tableIdx;</span><br><span class="line"> <span class="number">7</span>:         PoolSubpage&lt;T&gt;[] table;</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 判断是否为 tiny 类型的内存块申请</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line"><span class="number">10</span>:         <span class="keyword">if</span> (tiny) { <span class="comment">// &lt; 512 tiny 类型的内存块申请</span></span><br><span class="line"><span class="number">11</span>:             <span class="comment">// 从 PoolThreadCache 缓存中，分配 tiny 内存块，并初始化到 PooledByteBuf 中。</span></span><br><span class="line"><span class="number">12</span>:             <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) {</span><br><span class="line"><span class="number">13</span>:                 <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line"><span class="number">14</span>:                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">15</span>:             }</span><br><span class="line"><span class="number">16</span>:             <span class="comment">// 获得 tableIdx 和 table 属性</span></span><br><span class="line"><span class="number">17</span>:             tableIdx = tinyIdx(normCapacity);</span><br><span class="line"><span class="number">18</span>:             table = tinySubpagePools;</span><br><span class="line"><span class="number">19</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">20</span>:             <span class="comment">// 从 PoolThreadCache 缓存中，分配 small 内存块，并初始化到 PooledByteBuf 中。</span></span><br><span class="line"><span class="number">21</span>:             <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) {</span><br><span class="line"><span class="number">22</span>:                 <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line"><span class="number">23</span>:                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">24</span>:             }</span><br><span class="line"><span class="number">25</span>:             <span class="comment">// 获得 tableIdx 和 table 属性</span></span><br><span class="line"><span class="number">26</span>:             tableIdx = smallIdx(normCapacity);</span><br><span class="line"><span class="number">27</span>:             table = smallSubpagePools;</span><br><span class="line"><span class="number">28</span>:         }</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:         <span class="comment">// 获得 PoolSubpage 链表的头节点</span></span><br><span class="line"><span class="number">31</span>:         <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line"><span class="number">32</span>: </span><br><span class="line"><span class="number">33</span>:         <span class="comment">// 从 PoolSubpage 链表中，分配 Subpage 内存块</span></span><br><span class="line"><span class="number">34</span>:         <span class="comment">/**</span></span><br><span class="line"><span class="comment">35:          * Synchronize on the head. This is needed as {<span class="doctag">@link</span> PoolChunk#allocateSubpage(int)} and</span></span><br><span class="line"><span class="comment">36:          * {<span class="doctag">@link</span> PoolChunk#free(long)} may modify the doubly linked list as well.</span></span><br><span class="line"><span class="comment">37:          */</span></span><br><span class="line"><span class="number">38</span>:         <span class="keyword">synchronized</span> (head) { <span class="comment">// 同步 head ，避免并发问题</span></span><br><span class="line"><span class="number">39</span>:             <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line"><span class="number">40</span>:             <span class="keyword">if</span> (s != head) {</span><br><span class="line"><span class="number">41</span>:                 <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line"><span class="number">42</span>:                 <span class="comment">// 分配 Subpage 内存块</span></span><br><span class="line"><span class="number">43</span>:                 <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line"><span class="number">44</span>:                 <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="number">45</span>:                 <span class="comment">// 初始化 Subpage 内存块到 PooledByteBuf 对象中</span></span><br><span class="line"><span class="number">46</span>:                 s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line"><span class="number">47</span>:                 <span class="comment">// 增加 allocationsTiny 或 allocationsSmall 计数</span></span><br><span class="line"><span class="number">48</span>:                 incTinySmallAllocation(tiny);</span><br><span class="line"><span class="number">49</span>:                 <span class="comment">// 返回，因为已经分配成功</span></span><br><span class="line"><span class="number">50</span>:                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">51</span>:             }</span><br><span class="line"><span class="number">52</span>:         }</span><br><span class="line"><span class="number">53</span>:         <span class="comment">// 申请 Normal Page 内存块。实际上，只占用其中一块 Subpage 内存块。</span></span><br><span class="line"><span class="number">54</span>:         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { <span class="comment">// 同步 arena ，避免并发问题</span></span><br><span class="line"><span class="number">55</span>:             allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line"><span class="number">56</span>:         }</span><br><span class="line"><span class="number">57</span>:         <span class="comment">// 增加 allocationsTiny 或 allocationsSmall 计数</span></span><br><span class="line"><span class="number">58</span>:         incTinySmallAllocation(tiny);</span><br><span class="line"><span class="number">59</span>:         <span class="comment">// 返回，因为已经分配成功</span></span><br><span class="line"><span class="number">60</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">61</span>:     }</span><br><span class="line"><span class="number">62</span>:     <span class="keyword">if</span> (normCapacity &lt;= chunkSize) {</span><br><span class="line"><span class="number">63</span>:         <span class="comment">// 从 PoolThreadCache 缓存中，分配 normal 内存块，并初始化到 PooledByteBuf 中。</span></span><br><span class="line"><span class="number">64</span>:         <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) {</span><br><span class="line"><span class="number">65</span>:             <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line"><span class="number">66</span>:             <span class="keyword">return</span>;</span><br><span class="line"><span class="number">67</span>:         }</span><br><span class="line"><span class="number">68</span>:         <span class="comment">// 申请 Normal Page 内存块</span></span><br><span class="line"><span class="number">69</span>:         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { <span class="comment">// 同步 arena ，避免并发问题</span></span><br><span class="line"><span class="number">70</span>:             allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line"><span class="number">71</span>:             <span class="comment">// 增加 allocationsNormal</span></span><br><span class="line"><span class="number">72</span>:             ++allocationsNormal;</span><br><span class="line"><span class="number">73</span>:         }</span><br><span class="line"><span class="number">74</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">75</span>:         <span class="comment">// 申请 Huge Page 内存块</span></span><br><span class="line"><span class="number">76</span>:         <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line"><span class="number">77</span>:         allocateHuge(buf, reqCapacity);</span><br><span class="line"><span class="number">78</span>:     }</span><br><span class="line"><span class="number">79</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：调用 <code>#normalizeCapacity(int reqCapacity)</code> 方法，标准化请求分配的内存大小。</li>
<li><p>第 5 至 61 行：上述“1、PoolSubpage ，用于分配小于 8KB 的内存块”。</p>
<ul>
<li>第 5 行：调用 <code>#isTinyOrSmall(int normCapacity)</code> 方法，判断请求分配的内存类型是否为 tiny 或 small 类型。<ul>
<li>第 9 行：调用 <code>#isTiny(int normCapacity)</code> 方法，判断请求分配的内存类型是否为 tiny 类型。</li>
</ul>
</li>
<li>第 10 至 31 行：获得 PoolSubpage 链表的头节点。从实现上，和 <a href="#">「2.3 findSubpagePoolHead」</a> 功能上是一致的。<ul>
<li>第 11 至 15 行：调用 <code>PoolThreadCache#allocateTiny(this, buf, reqCapacity, normCapacity)</code> 方法，从 PoolThreadCache 缓存中，分配 tiny 内存块，并初始化到 PooledByteBuf 中。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-6-Jemalloc-ThreadCache">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache》</a> 中。</li>
<li>第 20 至 24 行：调用 <code>PoolThreadCache#allocateSmall(this, buf, reqCapacity, normCapacity)</code> 方法，从 PoolThreadCache 缓存中，分配 small 内存块，并初始化到 PooledByteBuf 中。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-6-Jemalloc-ThreadCache">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache》</a> 中。</li>
</ul>
</li>
<li>第 33 至 52 行：从 PoolSubpage 链表中，分配 Subpage 内存块。<ul>
<li>第 43 行：调用 <code>head.next</code> 节点的 <code>PoolSubpage#allocate()</code> 方法，分配一个 Subpage 内存块，并返回该内存块的位置 <code>handle</code> 。如果遗忘这个过程的胖友，可以看看 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-3-Jemalloc-subpage">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（三）PoolSubpage》</a> 的 <a href="#">「2.4 allocate」</a> 。 </li>
<li>第 46 行：调用 <code>PoolChunk#initBufWithSubpage(buf, handle, reqCapacity)</code> 方法，初始化 Subpage 内存块到 PooledByteBuf 对象中。如果遗忘这个过程的胖友，可以看看 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》</a> 的 <a href="#">「2.5.1 initBufWithSubpage」</a> 。</li>
<li>第 48 行：调用 <code>#incTinySmallAllocation(boolean tiny)</code> 方法，增加 <code>allocationsTiny</code> 或 <code>allocationsSmall</code> 计数。详细解析，见 <a href="#">「2.8.1 incTinySmallAllocation」</a> 。</li>
<li>第 50 行：<code>return</code> 返回，因为已经分配成功。</li>
</ul>
</li>
<li>第 53 至 60 行：在 PoolSubpage 链表中，分配不到 Subpage 内存块，所以申请 Normal Page 内存块。实际上，只占用其中一块 Subpage 内存块。<ul>
<li>第 53 至 56 行：调用 <code>#allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity)</code> 方法，申请 Normal Page 内存块。详细解析，见 <a href="#">「2.4.1 allocateNormal」</a> 。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 62 至 73 行：上述“2.1 小于 <code>32MB</code> ，分配 normal 内存块，即一个 Chunk 中的 <strong>Page</strong> 内存块”。</p>
<ul>
<li>第 62 行：通过 <code>normCapacity &lt;= chunkSize</code> 判断，判断请求分配的内存类型是否为 normal 类型。</li>
<li>第 63 至 67 行：调用 <code>PoolThreadCache#allocateNormal(this, buf, reqCapacity, normCapacity)</code> 方法，从 PoolThreadCache 缓存中，分配 normal 内存块，并初始化到 PooledByteBuf 中。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-6-Jemalloc-ThreadCache">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache》</a> 中。</li>
<li>第 68 至 70 行：同【第 53 至 56 行】的代码。</li>
<li>第 72 行：增加 <code>allocationsNormal</code> 。</li>
</ul>
</li>
<li>第 74 至 78 行：上述“2.2 大于等于 <code>32MB</code> ，分配 huge 内存块，即一整个 <strong>Chunk</strong> 内存块。”<ul>
<li>第 77 行：调用 <code>#allocateHuge(PooledByteBuf&lt;T&gt; buf, int reqCapacity)</code> 方法，申请 Huge 内存块。</li>
</ul>
</li>
</ul>
<h3 id="2-4-1-allocateNormal"><a href="#2-4-1-allocateNormal" class="headerlink" title="2.4.1 allocateNormal"></a>2.4.1 allocateNormal</h3><p><code>#allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity)</code> 方法，申请 Normal Page 内存块。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">// Method must be called inside synchronized(this) { ... }&nbsp;block // 必须在 synchronized(this) { ... } 中执行</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 按照优先级，从多个 ChunkList 中，分配 Normal Page 内存块。如果有一分配成功，返回</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line"> <span class="number">4</span>:         q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line"> <span class="number">5</span>:         q075.allocate(buf, reqCapacity, normCapacity)) {</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>:     }</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// Add a new chunk.</span></span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 新建 Chunk 内存块</span></span><br><span class="line"><span class="number">11</span>:     PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 申请对应的 Normal Page 内存块。实际上，如果申请分配的内存类型为 tiny 或 small 类型，实际申请的是 Subpage 内存块。</span></span><br><span class="line"><span class="number">13</span>:     <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line"><span class="number">14</span>:     <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>:     <span class="comment">// 初始化 Normal Page / Subpage 内存块到 PooledByteBuf 对象中</span></span><br><span class="line"><span class="number">16</span>:     c.initBuf(buf, handle, reqCapacity);</span><br><span class="line"><span class="number">17</span>:     <span class="comment">// 添加到 ChunkList 双向链中。</span></span><br><span class="line"><span class="number">18</span>:     qInit.add(c);</span><br><span class="line"><span class="number">19</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>按照优先级，从多个 ChunkList 中，调用 <code>PoolChunkList#allocate(normCapacity)</code> 方法，分配 Normal Page 内存块。如果有一分配成功，<code>return</code> 返回。如果遗忘这个过程的胖友，可以看看 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-4-Jemalloc-chunkList">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（四）PoolChunkList》</a> 的 <a href="#">「2.2 allocate」</a> 。</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/4856bd30dd56" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolArena》</a></p>
<p>分配内存时，为什么不从内存使用率较低的 <code>q000</code> 开始？在 ChunkList 中，我们知道一个 chunk 随着内存的释放，会往当前 ChunkList 的前一个节点移动。</p>
<p><strong><code>q000</code> 存在的目的是什么？</strong></p>
<p><code>q000</code> 是用来保存内存利用率在 <code>1%-50%</code> 的 chunk ，那么这里为什么不包括 <code>0%</code> 的chunk？<br>直接弄清楚这些，才好理解为什么不从 <code>q000</code> 开始分配。`q000  中的chunk，当内存利用率为 0 时，就从链表中删除，直接释放物理内存，避免越来越多的 chunk 导致内存被占满。</p>
<p>想象一个场景，当应用在实际运行过程中，碰到访问高峰，这时需要分配的内存是平时的好几倍，当然也需要创建好几倍的 chunk ，如果先从 <code>q0000</code> 开始，这些在高峰期创建的 chunk 被回收的概率会大大降低，延缓了内存的回收进度，造成内存使用的浪费。</p>
<p><strong>那么为什么选择从 <code>q050</code> 开始？</strong></p>
<ul>
<li>1、<code>q050</code> 保存的是内存利用率 <code>50%~100%</code> 的 chunk ，这应该是个折中的选择！这样大部分情况下，chunk 的利用率都会保持在一个较高水平，提高整个应用的内存利用率；</li>
<li>2、<code>qinit</code> 的 chunk 利用率低，但不会被回收；</li>
<li>3、<code>q075</code> 和 <code>q100</code> 由于内存利用率太高，导致内存分配的成功率大大降低，因此放到最后；</li>
</ul>
</blockquote>
</li>
<li><p>第 11 行：调用 <code>#newChunk(pageSize, maxOrder, pageShifts, chunkSize)</code> <strong>抽象</strong>方法，新建 Chunk 内存块。需要 PoolArea 子类实现该方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PoolChunk&lt;T&gt; <span class="title">newChunk</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 13 行：调用新申请的 Chunk 内存块的 <code>PoolChunk#allocate(normCapacity)</code> 方法，申请对应的 Normal Page 内存块。实际上，如果申请分配的内存类型为 tiny 或 small 类型，实际申请的是 Subpage 内存块。如果遗忘这个过程的胖友，可以看看 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》</a> 的 <a href="#">「2.2 allocate」</a> 。<ul>
<li>第 16 行：调用 <code>PoolChunk#initBuf(buf, handle, reqCapacity)</code> 方法，初始化 Normal Page / Subpage 内存块到 PooledByteBuf 对象中。</li>
</ul>
</li>
<li>第 18 行：调用 <code>PoolChunkList#add(PoolChunk)</code> 方法，添加到 ChunkList 双向链中。</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-allocateHuge"><a href="#2-4-2-allocateHuge" class="headerlink" title="2.4.2 allocateHuge"></a>2.4.2 allocateHuge</h3><p><code>#allocateHuge(PooledByteBuf&lt;T&gt; buf, int reqCapacity)</code> 方法，申请 Huge 内存块。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateHuge</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 新建 Chunk 内存块，它是 unpooled 的</span></span><br><span class="line"> <span class="number">3</span>:     PoolChunk&lt;T&gt; chunk = newUnpooledChunk(reqCapacity);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 增加 activeBytesHuge</span></span><br><span class="line"> <span class="number">5</span>:     activeBytesHuge.add(chunk.chunkSize());</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 初始化 Huge 内存块到 PooledByteBuf 对象中</span></span><br><span class="line"> <span class="number">7</span>:     buf.initUnpooled(chunk, reqCapacity);</span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// 增加 allocationsHuge</span></span><br><span class="line"> <span class="number">9</span>:     allocationsHuge.increment();</span><br><span class="line"><span class="number">10</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 3 行：调用 <code>#newUnpooledChunk(int capacity)</code> <strong>抽象</strong>方法，新建 <strong>unpooled</strong> Chunk 内存块。需要 PoolArea 子类实现该方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PoolChunk&lt;T&gt; <span class="title">newUnpooledChunk</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>; <span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 7 行：调用 <code>PoolChunk#initUnpooled(chunk, reqCapacity)</code> 方法，初始化 Huge 内存块到 PooledByteBuf 对象中。</p>
</li>
<li>第 5 行：增加 <code>activeBytesHuge</code> 计数。</li>
<li>第 9 行：增加 <code>allocationsHuge</code> 计数。</li>
</ul>
<h2 id="2-5-reallocate"><a href="#2-5-reallocate" class="headerlink" title="2.5 reallocate"></a>2.5 reallocate</h2><p><code>#reallocate(PooledByteBuf&lt;T&gt; buf, int newCapacity, boolean freeOldMemor)</code> 方法，因为要扩容或缩容，所以重新分配合适的内存块给 PooledByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> newCapacity, <span class="keyword">boolean</span> freeOldMemory)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span> || newCapacity &gt; buf.maxCapacity()) {</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"newCapacity: "</span> + newCapacity);</span><br><span class="line"> <span class="number">4</span>:     }</span><br><span class="line"> <span class="number">5</span>: </span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 容量大小没有变化，直接返回</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">int</span> oldCapacity = buf.length;</span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (oldCapacity == newCapacity) {</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>:     }</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 记录老的内存块的信息</span></span><br><span class="line"><span class="number">13</span>:     PoolChunk&lt;T&gt; oldChunk = buf.chunk;</span><br><span class="line"><span class="number">14</span>:     <span class="keyword">long</span> oldHandle = buf.handle;</span><br><span class="line"><span class="number">15</span>:     T oldMemory = buf.memory;</span><br><span class="line"><span class="number">16</span>:     <span class="keyword">int</span> oldOffset = buf.offset;</span><br><span class="line"><span class="number">17</span>:     <span class="keyword">int</span> oldMaxLength = buf.maxLength;</span><br><span class="line"><span class="number">18</span>: </span><br><span class="line"><span class="number">19</span>:     <span class="comment">// 记录读写索引</span></span><br><span class="line"><span class="number">20</span>:     <span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="number">21</span>:     <span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="number">22</span>: </span><br><span class="line"><span class="number">23</span>:     <span class="comment">// 分配新的内存块给 PooledByteBuf 对象</span></span><br><span class="line"><span class="number">24</span>:     allocate(parent.threadCache(), buf, newCapacity);</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:     <span class="comment">// 扩容</span></span><br><span class="line"><span class="number">27</span>:     <span class="keyword">if</span> (newCapacity &gt; oldCapacity) {</span><br><span class="line"><span class="number">28</span>:         <span class="comment">// 将老的内存块的数据，复制到新的内存块中</span></span><br><span class="line"><span class="number">29</span>:         memoryCopy(</span><br><span class="line"><span class="number">30</span>:                 oldMemory, oldOffset,</span><br><span class="line"><span class="number">31</span>:                 buf.memory, buf.offset, oldCapacity);</span><br><span class="line"><span class="number">32</span>:     <span class="comment">// 缩容</span></span><br><span class="line"><span class="number">33</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">34</span>:         <span class="comment">// 有部分数据未读取完</span></span><br><span class="line"><span class="number">35</span>:         <span class="keyword">if</span> (readerIndex &lt; newCapacity) {</span><br><span class="line"><span class="number">36</span>:             <span class="comment">// 如果 writerIndex 大于 newCapacity ，重置为 newCapacity ，避免越界</span></span><br><span class="line"><span class="number">37</span>:             <span class="keyword">if</span> (writerIndex &gt; newCapacity) {</span><br><span class="line"><span class="number">38</span>:                 writerIndex = newCapacity;</span><br><span class="line"><span class="number">39</span>:             }</span><br><span class="line"><span class="number">40</span>:             <span class="comment">// 将老的内存块的数据，复制到新的内存块中</span></span><br><span class="line"><span class="number">41</span>:             memoryCopy(</span><br><span class="line"><span class="number">42</span>:                     oldMemory, oldOffset + readerIndex,</span><br><span class="line"><span class="number">43</span>:                     buf.memory, buf.offset + readerIndex, writerIndex - readerIndex);</span><br><span class="line"><span class="number">44</span>:         <span class="comment">// 全部读完，重置 readerIndex 和 writerIndex 为 newCapacity ，避免越界</span></span><br><span class="line"><span class="number">45</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">46</span>:             readerIndex = writerIndex = newCapacity;</span><br><span class="line"><span class="number">47</span>:         }</span><br><span class="line"><span class="number">48</span>:     }</span><br><span class="line"><span class="number">49</span>: </span><br><span class="line"><span class="number">50</span>:     <span class="comment">// 设置读写索引</span></span><br><span class="line"><span class="number">51</span>:     buf.setIndex(readerIndex, writerIndex);</span><br><span class="line"><span class="number">52</span>: </span><br><span class="line"><span class="number">53</span>:     <span class="comment">// 释放老的内存块</span></span><br><span class="line"><span class="number">54</span>:     <span class="keyword">if</span> (freeOldMemory) {</span><br><span class="line"><span class="number">55</span>:         free(oldChunk, oldHandle, oldMaxLength, buf.cache);</span><br><span class="line"><span class="number">56</span>:     }</span><br><span class="line"><span class="number">57</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 4 行：新的容量( <code>newCapacity</code> ) ，不能<strong>超过</strong> PooledByteBuf 对象的可分配的最大容量( <code>maxCapacity</code> ) 。</li>
<li>第 6 至 10 行：容量大小没有变化，直接返回。</li>
<li>第 12 至 17 行：记录<strong>老的</strong>内存块的信息。<ul>
<li>第 20 至 21 行：记录读写索引。</li>
</ul>
</li>
<li><p>第 26 至 31 行：容量变大，说明是扩容，调用 <code>#memoryCopy(T src, int srcOffset, T dst, int dstOffset, int length)</code> <strong>抽象</strong>方法，将老的内存块的数据( 此处的复制，是全部数据 )，<strong>复制到新的内存块中</strong>。需要 PoolArea 子类实现该方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">memoryCopy</span><span class="params">(T src, <span class="keyword">int</span> srcOffset, T dst, <span class="keyword">int</span> dstOffset, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 33 至 48 行：容量变小，说明是缩容。</p>
<ul>
<li>第 34 至 44 行：有<strong>部分</strong>数据<strong>未读取完</strong>，调用 <code>#memoryCopy(T src, int srcOffset, T dst, int dstOffset, int length)</code> <strong>抽象</strong>方法，将老的内存块的数据( 此处的复制，是全部数据 )，复制到新的内存块中。😈 注意，<strong>此处复制的只有未读取完的部分数据</strong>。<ul>
<li>第 36 至 39 行：如果 <code>writerIndex</code> 大于 <code>newCapacity</code> ，重置为 <code>newCapacity</code> ，避免越界。</li>
</ul>
</li>
<li>第 44 至 47 行：全部读完，<strong>无需复制</strong>。<ul>
<li>第 46 行: 全部读完，重置 <code>readerIndex</code> 和 <code>writerIndex</code> 为 <code>newCapacity</code> ，避免越界。 </li>
</ul>
</li>
</ul>
</li>
<li>第 51 行：设置读写索引。</li>
<li>第 53 至 56 行：如果需要释放老的内存块( <code>freeOldMemory</code> 为 <code>true</code> ) 时，调用 <code>#free(PoolChunk&lt;T&gt; chunk, long handle, int normCapacity, PoolThreadCache cache)</code> 方法，进行释放。详细解析，见 <a href="#">「2.6 free」</a> 。</li>
</ul>
<h2 id="2-6-free"><a href="#2-6-free" class="headerlink" title="2.6 free"></a>2.6 free</h2><p><code>#free(PoolChunk&lt;T&gt; chunk, long handle, int normCapacity, PoolThreadCache cache)</code> 方法，释放内存块。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (chunk.unpooled) {</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 直接销毁 Chunk 内存块，因为占用空间较大</span></span><br><span class="line"> <span class="number">5</span>:         destroyChunk(chunk);</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// 减少 activeBytesHuge 计数</span></span><br><span class="line"> <span class="number">7</span>:         activeBytesHuge.add(-size);</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 减少 deallocationsHuge 计数</span></span><br><span class="line"> <span class="number">9</span>:         deallocationsHuge.increment();</span><br><span class="line"><span class="number">10</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 计算内存的 SizeClass</span></span><br><span class="line"><span class="number">12</span>:         SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 添加内存块到 PoolThreadCache 缓存</span></span><br><span class="line"><span class="number">14</span>:         <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, handle, normCapacity, sizeClass)) {</span><br><span class="line"><span class="number">15</span>:             <span class="comment">// cached so not free it.</span></span><br><span class="line"><span class="number">16</span>:             <span class="keyword">return</span>;</span><br><span class="line"><span class="number">17</span>:         }</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 释放 Page / Subpage 内存块回 Chunk 中</span></span><br><span class="line"><span class="number">19</span>:         freeChunk(chunk, handle, sizeClass);</span><br><span class="line"><span class="number">20</span>:     }</span><br><span class="line"><span class="number">21</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 9 行：<strong>unpooled</strong> 类型的 Chunk 对象，目前是 Huge 内存块。<ul>
<li>第 5 行：调用 <code>#destroyChunk(PoolChunk&lt;T&gt; chunk)</code> 方法，直接销毁 Chunk 内存块，因为占用空间较大。详细解析，见 <a href="#">「2.7 finalize」</a> 。</li>
<li>第 6 至 9 行：减少 <code>activeBytesHuge</code>、<code>deallocationsHuge</code> 计数。</li>
</ul>
</li>
<li>第 10 至 20 行：<strong>pooled</strong> 类型的 Chunk 对象，目前是 Page / Subpage 内存块。<ul>
<li>第 12 行：调用 <code>#size(normCapacity)</code> 方法，计算内存的 SizeClass 内存类型。</li>
<li>第 12 行：计算内存的 SizeClass 。</li>
<li>第 13 至 17 行：调用 <code>PoolThreadCache#add(PoolArena&lt;?&gt; area, PoolChunk chunk, long handle, int normCapacity, SizeClass sizeClass)</code> 方法，添加内存块到 PoolThreadCache 的指定 MemoryRegionCache 的队列中，进行缓存。并且，返回是否添加成功。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-6-Jemalloc-ThreadCache/">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache》</a> 。</li>
<li>第 19 行：调用 <code>#freeChunk(PoolChunk&lt;T&gt; chunk, long handle, SizeClass sizeClass)</code> 方法，释放指定位置的 Page / Subpage 内存块回 Chunk 中。</li>
</ul>
</li>
</ul>
<h3 id="2-6-1-freeChunk"><a href="#2-6-1-freeChunk" class="headerlink" title="2.6.1 freeChunk"></a>2.6.1 freeChunk</h3><p><code>#freeChunk(PoolChunk&lt;T&gt; chunk, long handle, SizeClass sizeClass)</code> 方法，释放指定位置的 Page / Subpage 内存块回 Chunk 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">freeChunk</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, SizeClass sizeClass)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> destroyChunk;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { <span class="comment">// 锁，避免并发</span></span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 减小相应的计数</span></span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">switch</span> (sizeClass) {</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">case</span> Normal:</span><br><span class="line"> <span class="number">7</span>:             ++deallocationsNormal;</span><br><span class="line"> <span class="number">8</span>:             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">case</span> Small:</span><br><span class="line"><span class="number">10</span>:             ++deallocationsSmall;</span><br><span class="line"><span class="number">11</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">12</span>:         <span class="keyword">case</span> Tiny:</span><br><span class="line"><span class="number">13</span>:             ++deallocationsTiny;</span><br><span class="line"><span class="number">14</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">15</span>:         <span class="keyword">default</span>:</span><br><span class="line"><span class="number">16</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line"><span class="number">17</span>:         }</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 释放指定位置的内存块</span></span><br><span class="line"><span class="number">19</span>:         destroyChunk = !chunk.parent.free(chunk, handle);</span><br><span class="line"><span class="number">20</span>:     }</span><br><span class="line"><span class="number">21</span>:     <span class="comment">// 当 destroyChunk 为 true 时，意味着 Chunk 中不存在在使用的 Page / Subpage 内存块。也就是说，内存使用率为 0 ，所以销毁 Chunk</span></span><br><span class="line"><span class="number">22</span>:     <span class="keyword">if</span> (destroyChunk) {</span><br><span class="line"><span class="number">23</span>:         <span class="comment">// destroyChunk not need to be called while holding the synchronized lock.</span></span><br><span class="line"><span class="number">24</span>:         destroyChunk(chunk);</span><br><span class="line"><span class="number">25</span>:     }</span><br><span class="line"><span class="number">26</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 至 17 行：减小<strong>相应</strong>的计数。</li>
<li>第 19 行：调用 Chunk 对象所在的 ChunList 的 <code>ChunkList#free(chunk, handle)</code> 方法，释放指定位置的内存块。如果遗忘这个过程的胖友，可以看看 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-4-Jemalloc-chunkList">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（四）PoolChunkList》</a> 的 <a href="#">「2.3 free」</a> 。</li>
<li>第 21 至 25 行：当 <code>destroyChunk</code> 为 <code>true</code> 时，意味着 Chunk 中不存在在使用的 Page / Subpage 内存块。也就是说，内存使用率为 0 ，所以调用 <code>#destroyChunk(PoolChunk&lt;T&gt; chunk)</code> 方法，直接销毁 Chunk 内存块，回收对应的空间。详细解析，见 <a href="#">「2.7 finalize」</a> 。</li>
</ul>
<h2 id="2-7-finalize"><a href="#2-7-finalize" class="headerlink" title="2.7 finalize"></a>2.7 finalize</h2><p>在 PoolArena 对象被 GC 回收时，清理其管理的内存。😈 实际上，主要是为了清理对外内存。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用父方法</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 清理 tiny Subpage 们</span></span><br><span class="line">        destroyPoolSubPages(smallSubpagePools);</span><br><span class="line">        <span class="comment">// 清理 small Subpage 们</span></span><br><span class="line">        destroyPoolSubPages(tinySubpagePools);</span><br><span class="line">        <span class="comment">// 清理 ChunkList 们</span></span><br><span class="line">        destroyPoolChunkLists(qInit, q000, q025, q050, q075, q100);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyPoolSubPages</span><span class="params">(PoolSubpage&lt;?&gt;[] pages)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (PoolSubpage&lt;?&gt; page : pages) {</span><br><span class="line">        page.destroy();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyPoolChunkLists</span><span class="params">(PoolChunkList&lt;T&gt;... chunkLists)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (PoolChunkList&lt;T&gt; chunkList: chunkLists) {</span><br><span class="line">        chunkList.destroy(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-8-PoolArenaMetric"><a href="#2-8-PoolArenaMetric" class="headerlink" title="2.8 PoolArenaMetric"></a>2.8 PoolArenaMetric</h2><blockquote>
<p>老艿艿：这个小节，主要是读取 Metric 数据的方法，快速浏览或跳过都可以。</p>
</blockquote>
<p><code>io.netty.buffer.PoolArenaMetric</code> ，PoolArena Metric 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PoolArenaMetric</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of thread caches backed by this arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numThreadCaches</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of tiny sub-pages for the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTinySubpages</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of small sub-pages for the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSmallSubpages</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of chunk lists for the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numChunkLists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an unmodifiable {<span class="doctag">@link</span> List} which holds {<span class="doctag">@link</span> PoolSubpageMetric}s for tiny sub-pages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;PoolSubpageMetric&gt; <span class="title">tinySubpages</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an unmodifiable {<span class="doctag">@link</span> List} which holds {<span class="doctag">@link</span> PoolSubpageMetric}s for small sub-pages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;PoolSubpageMetric&gt; <span class="title">smallSubpages</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an unmodifiable {<span class="doctag">@link</span> List} which holds {<span class="doctag">@link</span> PoolChunkListMetric}s.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;PoolChunkListMetric&gt; <span class="title">chunkLists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of allocations done via the arena. This includes all sizes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of tiny allocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numTinyAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of small allocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numSmallAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of normal allocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numNormalAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of huge allocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numHugeAllocations</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of deallocations done via the arena. This includes all sizes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numDeallocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of tiny deallocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numTinyDeallocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of small deallocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numSmallDeallocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of normal deallocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numNormalDeallocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of huge deallocations done via the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numHugeDeallocations</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of currently active allocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numActiveAllocations</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of currently active tiny allocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numActiveTinyAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of currently active small allocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numActiveSmallAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of currently active normal allocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numActiveNormalAllocations</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of currently active huge allocations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numActiveHugeAllocations</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of active bytes that are currently allocated by the arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">numActiveBytes</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>PoolArena 对 PoolArenaMetric 接口的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numThreadCaches</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> numThreadCaches.get();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTinySubpages</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tinySubpagePools.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSmallSubpages</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> smallSubpagePools.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numChunkLists</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> chunkListMetrics.size();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PoolSubpageMetric&gt; <span class="title">tinySubpages</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> subPageMetricList(tinySubpagePools);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PoolSubpageMetric&gt; <span class="title">smallSubpages</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> subPageMetricList(smallSubpagePools);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PoolChunkListMetric&gt; <span class="title">chunkLists</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> chunkListMetrics;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;PoolSubpageMetric&gt; <span class="title">subPageMetricList</span><span class="params">(PoolSubpage&lt;?&gt;[] pages)</span> </span>{</span><br><span class="line">    List&lt;PoolSubpageMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolSubpageMetric&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PoolSubpage&lt;?&gt; head : pages) {</span><br><span class="line">        <span class="keyword">if</span> (head.next == head) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        PoolSubpage&lt;?&gt; s = head.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            metrics.add(s);</span><br><span class="line">            s = s.next;</span><br><span class="line">            <span class="keyword">if</span> (s == head) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> metrics;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> allocsNormal;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        allocsNormal = allocationsNormal;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> allocationsTiny.value() + allocationsSmall.value() + allocsNormal + allocationsHuge.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numTinyAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocationsTiny.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numSmallAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocationsSmall.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">numNormalAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocationsNormal;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numDeallocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deallocs;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        deallocs = deallocationsTiny + deallocationsSmall + deallocationsNormal;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> deallocs + deallocationsHuge.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">numTinyDeallocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> deallocationsTiny;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">numSmallDeallocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> deallocationsSmall;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">numNormalDeallocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> deallocationsNormal;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numHugeAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocationsHuge.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numHugeDeallocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> deallocationsHuge.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">long</span> <span class="title">numActiveAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> val = allocationsTiny.value() + allocationsSmall.value() + allocationsHuge.value()</span><br><span class="line">            - deallocationsHuge.value();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        val += allocationsNormal - (deallocationsTiny + deallocationsSmall + deallocationsNormal);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(val, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numActiveTinyAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> max(numTinyAllocations() - numTinyDeallocations(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numActiveSmallAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> max(numSmallAllocations() - numSmallDeallocations(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numActiveNormalAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        val = allocationsNormal - deallocationsNormal;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(val, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numActiveHugeAllocations</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> max(numHugeAllocations() - numHugeDeallocations(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numActiveBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> val = activeBytesHuge.value();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chunkListMetrics.size(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (PoolChunkMetric m: chunkListMetrics.get(i)) {</span><br><span class="line">                val += m.chunkSize();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>, val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-8-1-incTinySmallAllocation"><a href="#2-8-1-incTinySmallAllocation" class="headerlink" title="2.8.1 incTinySmallAllocation"></a>2.8.1 incTinySmallAllocation</h3><p><code>#incTinySmallAllocation(boolean tiny)</code> 方法，增加 <code>allocationsTiny</code> 或 <code>allocationsSmall</code> 计数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incTinySmallAllocation</span><span class="params">(<span class="keyword">boolean</span> tiny)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tiny) {</span><br><span class="line">        allocationsTiny.increment();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        allocationsSmall.increment();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-9-抽象方法"><a href="#2-9-抽象方法" class="headerlink" title="2.9 抽象方法"></a>2.9 抽象方法</h2><p>虽然上文中，已经提到了几个抽象方法，这里还是同一整理如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PoolChunk&lt;T&gt; <span class="title">newChunk</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span></span>; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PoolChunk&lt;T&gt; <span class="title">newUnpooledChunk</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PooledByteBuf&lt;T&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">memoryCopy</span><span class="params">(T src, <span class="keyword">int</span> srcOffset, T dst, <span class="keyword">int</span> dstOffset, <span class="keyword">int</span> length)</span></span>; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">destroyChunk</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-HeapArena"><a href="#3-HeapArena" class="headerlink" title="3. HeapArena"></a>3. HeapArena</h1><p>HeapArena ，继承 PoolArena 抽象类，对 Heap 类型的内存分配。</p>
<blockquote>
<p>HeapArena 是 PoolArena 的内部静态类。代码比较简单，胖友自己看看就成。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">static final class HeapArena extends PoolArena&lt;byte[]&gt; { // 管理 byte[] 数组</span><br><span class="line"></span><br><span class="line">    HeapArena(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> directMemoryCacheAlignment) {</span><br><span class="line">        <span class="keyword">super</span>(parent, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] newByteArray(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.allocateUninitializedArray(size); <span class="comment">// 创建 byte[] 数组</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt; newChunk(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">this</span>, newByteArray(chunkSize), pageSize, maxOrder, pageShifts, chunkSize, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt; newUnpooledChunk(<span class="keyword">int</span> capacity) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">this</span>, newByteArray(capacity), capacity, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyChunk</span><span class="params">(PoolChunk&lt;<span class="keyword">byte</span>[]&gt; chunk)</span> </span>{</span><br><span class="line">        <span class="comment">// Rely on GC. 依赖 GC</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> PooledByteBuf&lt;<span class="keyword">byte</span>[]&gt; newByteBuf(<span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">return</span> HAS_UNSAFE ? PooledUnsafeHeapByteBuf.newUnsafeInstance(maxCapacity)</span><br><span class="line">                : PooledHeapByteBuf.newInstance(maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">memoryCopy</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcOffset, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstOffset, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.arraycopy(src, srcOffset, dst, dstOffset, length);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="4-DirectArena"><a href="#4-DirectArena" class="headerlink" title="4. DirectArena"></a>4. DirectArena</h1><p>DirectArena ，继承 PoolArena 抽象类，对 Direct 类型的内存分配。</p>
<blockquote>
<p>DirectArena 是 PoolArena 的内部静态类。代码比较简单，胖友自己看看就成。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectArena</span> <span class="keyword">extends</span> <span class="title">PoolArena</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>{ <span class="comment">// 管理 Direct ByteBuffer 对象</span></span><br><span class="line"></span><br><span class="line">    DirectArena(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span><br><span class="line">            <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> directMemoryCacheAlignment) {</span><br><span class="line">        <span class="keyword">super</span>(parent, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">offsetCacheLine</span><span class="params">(ByteBuffer memory)</span> </span>{</span><br><span class="line">        <span class="comment">// We can only calculate the offset if Unsafe is present as otherwise directBufferAddress(...) will</span></span><br><span class="line">        <span class="comment">// throw an NPE.</span></span><br><span class="line">        <span class="keyword">return</span> HAS_UNSAFE ?</span><br><span class="line">                (<span class="keyword">int</span>) (PlatformDependent.directBufferAddress(memory) &amp; directMemoryCacheAlignmentMask) : <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newChunk</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (directMemoryCacheAlignment == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, allocateDirect(chunkSize), pageSize, maxOrder, pageShifts, chunkSize, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer memory = allocateDirect(chunkSize + directMemoryCacheAlignment);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, memory, pageSize, maxOrder, pageShifts, chunkSize, offsetCacheLine(memory));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PoolChunk&lt;ByteBuffer&gt; <span class="title">newUnpooledChunk</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (directMemoryCacheAlignment == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>,</span><br><span class="line">                    allocateDirect(capacity), capacity, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer memory = allocateDirect(capacity + directMemoryCacheAlignment);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolChunk&lt;ByteBuffer&gt;(<span class="keyword">this</span>, memory, capacity, offsetCacheLine(memory));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{ <span class="comment">// 创建 Direct ByteBuffer 对象</span></span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.useDirectBufferNoCleaner() ?</span><br><span class="line">                PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyChunk</span><span class="params">(PoolChunk&lt;ByteBuffer&gt; chunk)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.useDirectBufferNoCleaner()) {</span><br><span class="line">            PlatformDependent.freeDirectNoCleaner(chunk.memory);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            PlatformDependent.freeDirectBuffer(chunk.memory);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (HAS_UNSAFE) {</span><br><span class="line">            <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">memoryCopy</span><span class="params">(ByteBuffer src, <span class="keyword">int</span> srcOffset, ByteBuffer dst, <span class="keyword">int</span> dstOffset, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HAS_UNSAFE) {</span><br><span class="line">            PlatformDependent.copyMemory(</span><br><span class="line">                    PlatformDependent.directBufferAddress(src) + srcOffset,</span><br><span class="line">                    PlatformDependent.directBufferAddress(dst) + dstOffset, length);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// We must duplicate the NIO buffers because they may be accessed by other Netty buffers.</span></span><br><span class="line">            src = src.duplicate();</span><br><span class="line">            dst = dst.duplicate();</span><br><span class="line">            src.position(srcOffset).limit(srcOffset + length);</span><br><span class="line">            dst.position(dstOffset);</span><br><span class="line">            dst.put(src);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>终于看懂 Jemalloc 算法的大体的实现。一开始看，一脸懵逼！！！其实耐下性子，慢慢看，总能看懂的。</p>
<p>当然，如果这个时候让自己手写 Jemalloc 算法，估计还是会泪崩。哈哈哈，相比写代码来说，读懂代码还是容易很多的。</p>
<p>嘿嘿，找了一张厉害的图，胖友在结合这个图，理解理解。</p>
<blockquote>
<p>FROM <a href="http://www.woowen.com/%E6%BA%90%E7%A0%81/2016/08/01/Netty%20buffer%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20PoolArena/" rel="external nofollow noopener noreferrer" target="_blank">《Netty Buffer - 内存管理 PoolArena》</a></p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_09_13/04.png" title="内存分配" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_13/04.png" alt="内存分配"></a><span class="caption">内存分配</span></p>
</blockquote>
<hr>
<p>参考如下文章：</p>
<ul>
<li>占小狼 <a href="https://www.jianshu.com/p/4856bd30dd56" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolArena》</a> </li>
<li>Hypercube <a href="https://www.jianshu.com/p/86fbacdb68bd" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–PoolArena》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena/" data-id="ck4pl3fp900ecfgcfbu2ekmuq" class="article-share-link">分享</a>



</footer>
-->
</div>