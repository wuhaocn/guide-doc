<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelHandler（六）之 AbstractTrafficShapingHandler
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<p>笔者先把 Netty 主要的内容写完，所以关于 AbstractTrafficShapingHandler 的分享，先放在后续的计划里。</p>
<p>当然，良心如我，还是为对这块感兴趣的胖友，先准备好了一篇不错的文章：</p>
<ul>
<li>tomas家的小拨浪鼓 <a href="https://www.jianshu.com/p/bea1b4ea8402" rel="external nofollow noopener noreferrer" target="_blank">《Netty 那些事儿 ——— Netty实现“流量整形”原理分析及实战》</a></li>
</ul>
<p>为避免可能 <a href="https://www.jianshu.com/p/bea1b4ea8402" rel="external nofollow noopener noreferrer" target="_blank">《Netty 那些事儿 ——— Netty实现“流量整形”原理分析及实战》</a> 被作者删除，笔者这里先复制一份作为备份。</p>
<h1 id="666-备份"><a href="#666-备份" class="headerlink" title="666. 备份"></a>666. 备份</h1><blockquote>
<p>本文是Netty文集中“Netty 那些事儿”系列的文章。主要结合在开发实战中，我们遇到的一些“奇奇怪怪”的问题，以及如何正确且更好的使用Netty框架，并会对Netty中涉及的重要设计理念进行介绍。</p>
</blockquote>
<h3 id="Netty实现“流量整形”原理分析"><a href="#Netty实现“流量整形”原理分析" class="headerlink" title="Netty实现“流量整形”原理分析"></a>Netty实现“流量整形”原理分析</h3><h5 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h5><p>流量整形（Traffic Shaping）是一种主动调整流量输出速率的措施。流量整形与流量监管的主要区别在于，流量整形对流量监管中需要丢弃的报文进行缓存——通常是将它们放入缓冲区或队列内，也称流量整形（Traffic Shaping，简称TS）。当报文的发送速度过快时，首先在缓冲区进行缓存；再通过流量计量算法的控制下“均匀”地发送这些被缓冲的报文。流量整形与流量监管的另一区别是，整形可能会增加延迟，而监管几乎不引入额外的延迟。</p>
<p>Netty提供了GlobalTrafficShapingHandler、ChannelTrafficShapingHandler、GlobalChannelTrafficShapingHandler三个类来实现流量整形，他们都是AbstractTrafficShapingHandler抽象类的实现类，下面我们就对其进行介绍，让我们来了解Netty是如何实现流量整形的。</p>
<h5 id="核心类分析"><a href="#核心类分析" class="headerlink" title="核心类分析"></a>核心类分析</h5><h6 id="AbstractTrafficShapingHandler"><a href="#AbstractTrafficShapingHandler" class="headerlink" title="AbstractTrafficShapingHandler"></a>AbstractTrafficShapingHandler</h6><p>AbstractTrafficShapingHandler允许限制全局的带宽（见GlobalTrafficShapingHandler）或者每个session的带宽（见ChannelTrafficShapingHandler）作为流量整形。<br> 它允许你使用TrafficCounter来实现几乎实时的带宽监控，TrafficCounter会在每个检测间期（checkInterval）调用这个处理器的doAccounting方法。</p>
<p>如果你有任何特别的原因想要停止监控（计数）或者改变读写的限制或者改变检测间期（checkInterval），可以使用如下方法：<br> ① configure：允许你改变读或写的限制，或者检测间期（checkInterval）；<br> ② getTrafficCounter：允许你获得TrafficCounter，并可以停止或启动监控，直接改变检测间期（checkInterval），或去访问它的值。</p>
<p><strong>TrafficCounter</strong>：对读和写的字节进行计数以用于限制流量。<br> 它会根据给定的检测间期周期性的计算统计入站和出站的流量，并会回调AbstractTrafficShapingHandler的doAccounting方法。<br> 如果检测间期（checkInterval）是0，将不会进行计数并且统计只会在每次读或写操作时进行计算。</p>
<ul>
<li>configure</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(<span class="keyword">long</span> newWriteLimit, <span class="keyword">long</span> newReadLimit,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> newCheckInterval)</span> </span>{</span><br><span class="line">    configure(newWriteLimit, newReadLimit);</span><br><span class="line">    configure(newCheckInterval);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>配置新的写限制、读限制、检测间期。该方法会尽最大努力进行此更改，这意味着已经被延迟进行的流量将不会使用新的配置，它仅用于新的流量中。</p>
<ul>
<li>ReopenReadTimerTask</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReopenReadTimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line">    ReopenReadTimerTask(ChannelHandlerContext ctx) {</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        ChannelConfig config = ctx.channel().config();</span><br><span class="line">        <span class="keyword">if</span> (!config.isAutoRead() &amp;&amp; isHandlerActive(ctx)) {</span><br><span class="line">            <span class="comment">// If AutoRead is False and Active is True, user make a direct setAutoRead(false)</span></span><br><span class="line">            <span class="comment">// Then Just reset the status</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Not unsuspend: "</span> + config.isAutoRead() + <span class="string">':'</span> +</span><br><span class="line">                        isHandlerActive(ctx));</span><br><span class="line">            }</span><br><span class="line">            ctx.attr(READ_SUSPENDED).set(<span class="keyword">false</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Anything else allows the handler to reset the AutoRead</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                <span class="keyword">if</span> (config.isAutoRead() &amp;&amp; !isHandlerActive(ctx)) {</span><br><span class="line">                    logger.debug(<span class="string">"Unsuspend: "</span> + config.isAutoRead() + <span class="string">':'</span> +</span><br><span class="line">                            isHandlerActive(ctx));</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    logger.debug(<span class="string">"Normal unsuspend: "</span> + config.isAutoRead() + <span class="string">':'</span></span><br><span class="line">                            + isHandlerActive(ctx));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ctx.attr(READ_SUSPENDED).set(<span class="keyword">false</span>);</span><br><span class="line">            config.setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">            ctx.channel().read();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Unsuspend final status =&gt; "</span> + config.isAutoRead() + <span class="string">':'</span></span><br><span class="line">                    + isHandlerActive(ctx));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>重启读操作的定时任务。该定时任务总会实现：<br> a) 如果Channel的autoRead为false，并且AbstractTrafficShapingHandler的READ_SUSPENDED属性设置为null或false（说明读暂停未启用或开启），则直接将READ_SUSPENDED属性设置为false。<br> b) 否则，如果Channel的autoRead为true，或者READ_SUSPENDED属性的值为true（说明读暂停开启了），则将READ_SUSPENDED属性设置为false，并将Channel的autoRead标识为true（该操作底层会将该Channel的OP_READ事件重新注册为感兴趣的事件，这样Selector就会监听该Channel的读就绪事件了），最后触发一次Channel的read操作。<br> 也就说，若“读操作”为“开启”状态（READ_SUSPENDED为null或false）的情况下，Channel的autoRead是保持Channel原有的配置，此时并不会做什么操作。但当“读操作”从“暂停”状态（READ_SUSPENDED为true）转为“开启”状态（READ_SUSPENDED为false）时，则会将Channel的autoRead标志为true，并将“读操作”设置为“开启”状态（READ_SUSPENDED为false）。</p>
<ul>
<li>channelRead</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">long</span> size = calculateSize(msg);</span><br><span class="line">    <span class="keyword">long</span> now = TrafficCounter.milliSecondFromNano();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// compute the number of ms to wait before reopening the channel</span></span><br><span class="line">        <span class="keyword">long</span> wait = trafficCounter.readTimeToWait(size, readLimit, maxTime, now);</span><br><span class="line">        wait = checkWaitReadTime(ctx, wait, now);</span><br><span class="line">        <span class="keyword">if</span> (wait &gt;= MINIMAL_WAIT) { <span class="comment">// At least 10ms seems a minimal</span></span><br><span class="line">            <span class="comment">// time in order to try to limit the traffic</span></span><br><span class="line">            <span class="comment">// Only AutoRead AND HandlerActive True means Context Active</span></span><br><span class="line">            ChannelConfig config = ctx.channel().config();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Read suspend: "</span> + wait + <span class="string">':'</span> + config.isAutoRead() + <span class="string">':'</span></span><br><span class="line">                        + isHandlerActive(ctx));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (config.isAutoRead() &amp;&amp; isHandlerActive(ctx)) {</span><br><span class="line">                config.setAutoRead(<span class="keyword">false</span>);</span><br><span class="line">                ctx.attr(READ_SUSPENDED).set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// Create a Runnable to reactive the read if needed. If one was create before it will just be</span></span><br><span class="line">                <span class="comment">// reused to limit object creation</span></span><br><span class="line">                Attribute&lt;Runnable&gt; attr = ctx.attr(REOPEN_TASK);</span><br><span class="line">                Runnable reopenTask = attr.get();</span><br><span class="line">                <span class="keyword">if</span> (reopenTask == <span class="keyword">null</span>) {</span><br><span class="line">                    reopenTask = <span class="keyword">new</span> ReopenReadTimerTask(ctx);</span><br><span class="line">                    attr.set(reopenTask);</span><br><span class="line">                }</span><br><span class="line">                ctx.executor().schedule(reopenTask, wait, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                    logger.debug(<span class="string">"Suspend final status =&gt; "</span> + config.isAutoRead() + <span class="string">':'</span></span><br><span class="line">                            + isHandlerActive(ctx) + <span class="string">" will reopened at: "</span> + wait);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    informReadOperation(ctx, now);</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>① 『long size = calculateSize(msg);』计算本次读取到的消息的字节数。<br> ② 如果读取到的字节数大于0，则根据数据的大小、设定的readLimit、最大延迟时间等计算（『long wait = trafficCounter.readTimeToWait(size, readLimit, maxTime, now);』）得到下一次开启读操作需要的延迟时间（距当前时间而言）wait(毫秒)。<br> ③ 如果a）wait &gt;= MINIMAL_WAIT(10毫秒)。并且b）当前Channel为自动读取（即，autoRead为true）以及c）当前的READ_SUSPENDED标识为null或false（即，读操作未被暂停），那么将Channel的autoRead设置为false（该操作底层会将该Channel的OP_READ事件从感兴趣的事件中移除，这样Selector就不会监听该Channel的读就绪事件了），并且将READ_SUSPENDED标识为true（说明，接下来的读操作会被暂停），并将“重新开启读操作“封装为一个任务，让入Channel所注册NioEventLoop的定时任务队列中（延迟wait时间后执行）。<br> 也就说，只有当计算出的下一次读操作的时间大于了MINIMAL_WAIT(10毫秒)，并且当前Channel是自动读取的，且“读操作”处于“开启”状态时，才会去暂停读操作，而暂停读操作主要需要完成三件事：[1]将Channel的autoRead标识设置为false，这使得OP_READ会从感兴趣的事件中移除，这样Selector就会不会监听这个Channel的读就绪事件了；[2]将“读操作”状态设置为“暂停”（READ_SUSPENDED为true）；[3]将重启开启“读操作”的操作封装为一个task，在延迟wait时间后执行。<br> 当你将得Channel的autoRead都会被设置为false时，Netty底层就不会再去执行读操作了，也就是说，这时如果有数据过来，会先放入到内核的接收缓冲区，只有我们执行读操作的时候数据才会从内核缓冲区读取到用户缓冲区中。而对于TCP协议来说，你不要担心一次内核缓冲区会溢出。因为如果应用进程一直没有读取，接收缓冲区满了之后，发生的动作是：通知对端TCP协议中的窗口关闭。这个便是滑动窗口的实现。保证TCP套接口接收缓冲区不会溢出，从而保证了TCP是可靠传输。因为对方不允许发出超过所通告窗口大小的数据。 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。<br> ④ 将当前的消息发送给ChannelPipeline中的下一个ChannelInboundHandler。</p>
<ul>
<li>write</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">long</span> size = calculateSize(msg);</span><br><span class="line">    <span class="keyword">long</span> now = TrafficCounter.milliSecondFromNano();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// compute the number of ms to wait before continue with the channel</span></span><br><span class="line">        <span class="keyword">long</span> wait = trafficCounter.writeTimeToWait(size, writeLimit, maxTime, now);</span><br><span class="line">        <span class="keyword">if</span> (wait &gt;= MINIMAL_WAIT) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Write suspend: "</span> + wait + <span class="string">':'</span> + ctx.channel().config().isAutoRead() + <span class="string">':'</span></span><br><span class="line">                        + isHandlerActive(ctx));</span><br><span class="line">            }</span><br><span class="line">            submitWrite(ctx, msg, size, wait, now, promise);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// to maintain order of write</span></span><br><span class="line">    submitWrite(ctx, msg, size, <span class="number">0</span>, now, promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>① 『long size = calculateSize(msg);』计算待写出的数据大小<br> ② 如果待写出数据的字节数大于0，则根据数据大小、设置的writeLimit、最大延迟时间等计算（『long wait = trafficCounter.writeTimeToWait(size, writeLimit, maxTime, now);』）得到本次写操作需要的延迟时间（距当前时间而言）wait(毫秒)。<br> ③ 如果wait &gt;= MINIMAL_WAIT（10毫秒），则调用『submitWrite(ctx, msg, size, wait, now, promise);』wait即为延迟时间，该方法的具体实现由子类完成；否则，若wait &lt; MINIMAL_WAIT（10毫秒），则调用『submitWrite(ctx, msg, size, 0, now, promise);』注意这里传递的延迟时间为0了。</p>
<h6 id="GlobalTrafficShapingHandler"><a href="#GlobalTrafficShapingHandler" class="headerlink" title="GlobalTrafficShapingHandler"></a>GlobalTrafficShapingHandler</h6><p>这实现了AbstractTrafficShapingHandler的全局流量整形，也就是说它限制了全局的带宽，无论开启了几个channel。<br> 注意『 OutboundBuffer.setUserDefinedWritability(index, boolean)』中索引使用’2’。</p>
<p>一般用途如下：<br> 创建一个唯一的GlobalTrafficShapingHandler</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">GlobalTrafficShapingHandler myHandler = <span class="keyword">new</span> GlobalTrafficShapingHandler(executor);</span><br><span class="line">pipeline.addLast(myHandler);</span><br></pre></td></tr></tbody></table></figure>
<p>executor可以是底层的IO工作池</p>
<p>注意，这个处理器是覆盖所有管道的，这意味着只有一个处理器对象会被创建并且作为所有channel间共享的计数器，它必须于所有的channel共享。<br> 所有你可以见到，该类的定义上面有个<code>@Sharable</code>注解。</p>
<p>在你的处理器中，你需要考虑使用『channel.isWritable()』和『channelWritabilityChanged(ctx)』来处理可写性，或通过在ctx.write()返回的future上注册listener来实现。</p>
<p>你还需要考虑读或写操作对象的大小需要和你要求的带宽相对应：比如，你将一个10M大小的对象用于10KB/s的带宽将会导致爆发效果，若你将100KB大小的对象用于在1M/s带宽那么将会被流量整形处理器平滑处理。</p>
<p>一旦不在需要这个处理器时请确保调用『release()』以释放所有内部的资源。这不会关闭EventExecutor，因为它可能是共享的，所以这需要你自己做。</p>
<p>GlobalTrafficShapingHandler中持有一个Channel的哈希表，用于存储当前应用所有的Channel：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer, PerChannel&gt; channelQueues = PlatformDependent.newConcurrentHashMap();</span><br></pre></td></tr></tbody></table></figure>
<p>key为Channel的hashCode；value是一个PerChannel对象。<br> PerChannel对象中维护有该Channel的待发送数据的消息队列（ArrayDeque<tosend> messagesQueue）。</tosend></p>
<ul>
<li>submitWrite</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submitWrite</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> Object msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> size, <span class="keyword">final</span> <span class="keyword">long</span> writedelay, <span class="keyword">final</span> <span class="keyword">long</span> now,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    Channel channel = ctx.channel();</span><br><span class="line">    Integer key = channel.hashCode();</span><br><span class="line">    PerChannel perChannel = channelQueues.get(key);</span><br><span class="line">    <span class="keyword">if</span> (perChannel == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// in case write occurs before handlerAdded is raised for this handler</span></span><br><span class="line">        <span class="comment">// imply a synchronized only if needed</span></span><br><span class="line">        perChannel = getOrSetPerChannel(ctx);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> ToSend newToSend;</span><br><span class="line">    <span class="keyword">long</span> delay = writedelay;</span><br><span class="line">    <span class="keyword">boolean</span> globalSizeExceeded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// write operations need synchronization</span></span><br><span class="line">    <span class="keyword">synchronized</span> (perChannel) {</span><br><span class="line">        <span class="keyword">if</span> (writedelay == <span class="number">0</span> &amp;&amp; perChannel.messagesQueue.isEmpty()) {</span><br><span class="line">            trafficCounter.bytesRealWriteFlowControl(size);</span><br><span class="line">            ctx.write(msg, promise);</span><br><span class="line">            perChannel.lastWriteTimestamp = now;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (delay &gt; maxTime &amp;&amp; now + delay - perChannel.lastWriteTimestamp &gt; maxTime) {</span><br><span class="line">            delay = maxTime;</span><br><span class="line">        }</span><br><span class="line">        newToSend = <span class="keyword">new</span> ToSend(delay + now, msg, size, promise);</span><br><span class="line">        perChannel.messagesQueue.addLast(newToSend);</span><br><span class="line">        perChannel.queueSize += size;</span><br><span class="line">        queuesSize.addAndGet(size);</span><br><span class="line">        checkWriteSuspend(ctx, delay, perChannel.queueSize);</span><br><span class="line">        <span class="keyword">if</span> (queuesSize.get() &gt; maxGlobalWriteSize) {</span><br><span class="line">            globalSizeExceeded = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (globalSizeExceeded) {</span><br><span class="line">        setUserDefinedWritability(ctx, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> futureNow = newToSend.relativeTimeAction;</span><br><span class="line">    <span class="keyword">final</span> PerChannel forSchedule = perChannel;</span><br><span class="line">    ctx.executor().schedule(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            sendAllValid(ctx, forSchedule, futureNow);</span><br><span class="line">        }</span><br><span class="line">    }, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>写操作提交上来的数据。<br> ① 如果写延迟为0，且当前该Channel的messagesQueue为空（说明，在此消息前没有待发送的消息了），那么直接发送该消息包。并返回，否则到下一步。<br> ② 『newToSend = new ToSend(delay + now, msg, size, promise);<br> perChannel.messagesQueue.addLast(newToSend);』<br> 将待发送的数据封装成ToSend对象放入PerChannel的消息队列中（messagesQueue）。注意，这里的messagesQueue是一个ArrayDeque队列，我们总是从队列尾部插入。然后从队列的头获取消息来依次发送，这就保证了消息的有序性。但是，如果一个大数据包前于一个小数据包发送的话，小数据包也会因为大数据包的延迟发送而被延迟到大数据包发送后才会发送。<br> ToSend 对象中持有带发送的数据对象、发送的相对延迟时间（即，根据数据包大小以及设置的写流量限制值（writeLimit）等计算出来的延迟操作的时间）、消息数据的大小、异步写操作的promise。<br> ③ 『checkWriteSuspend(ctx, delay, perChannel.queueSize);』<br> 检查单个Channel待发送的数据包是否超过了maxWriteSize（默认4M），或者延迟时间是否超过了maxWriteDelay（默认4s）。如果是的话，则调用『setUserDefinedWritability(ctx, false);』该方法会将ChannelOutboundBuffer中的unwritable属性值的相应标志位置位（unwritable关系到isWritable方法是否会返回true。以及会在unwritable从0到非0间变化时触发ChannelWritabilityChanged事件）。<br> ④ 如果所有待发送的数据大小（这里指所有Channel累积的待发送的数据大小）大于了maxGlobalWriteSize（默认400M），则标识globalSizeExceeded为true，并且调用『setUserDefinedWritability(ctx, false)』将ChannelOutboundBuffer中的unwritable属性值相应的标志位置位。<br> ⑤ 根据指定的延迟时间（一个 &gt;= 0 且 &lt;= maxTime 的值，maxTime默认15s）delay，将『sendAllValid(ctx, forSchedule, futureNow);』操作封装成一个任务提交至executor的定时周期任务队列中。<br> sendAllValid操作会遍历该Channel中待发送的消息队列messagesQueue，依次取出perChannel.messagesQueue中的消息包，将满足发送条件（即，延迟发送的时间已经到了）的消息发送给到ChannelPipeline中的下一个ChannelOutboundHandler（ctx.write(newToSend.toSend, newToSend.promise);），并且将perChannel.queueSize（当前Channel待发送的总数据大小）和queuesSize（所有Channel待发送的总数据大小）减小相应的值（即，被发送出去的这个数据包的大小）。循环遍历前面的操作直到当前的消息不满足发送条件则退出遍历。并且如果该Channel的消息队列中的消息全部都发送出去的话（即，messagesQueue.isEmpty()为true），则会通过调用『releaseWriteSuspended(ctx);』来释放写暂停。而该方法底层会将ChannelOutboundBuffer中的unwritable属性值相应的标志位重置。</p>
<h6 id="ChannelTrafficShapingHandler"><a href="#ChannelTrafficShapingHandler" class="headerlink" title="ChannelTrafficShapingHandler"></a>ChannelTrafficShapingHandler</h6><p>ChannelTrafficShapingHandler是针对单个Channel的流量整形，和GlobalTrafficShapingHandler的思想是一样的。只是实现中没有对全局概念的检测，仅检测了当前这个Channel的数据。<br> 这里就不再赘述了。</p>
<h6 id="GlobalChannelTrafficShapingHandler"><a href="#GlobalChannelTrafficShapingHandler" class="headerlink" title="GlobalChannelTrafficShapingHandler"></a>GlobalChannelTrafficShapingHandler</h6><p>相比于GlobalTrafficShapingHandler增加了一个误差概念，以平衡各个Channel间的读/写操作。也就是说，使得各个Channel间的读/写操作尽量均衡。比如，尽量避免不同Channel的大数据包都延迟近乎一样的是时间再操作，以及如果小数据包在一个大数据包后才发送，则减少该小数据包的延迟发送时间等。。</p>
<h3 id="“流量整形”实战"><a href="#“流量整形”实战" class="headerlink" title="“流量整形”实战"></a>“流量整形”实战</h3><p>这里仅展示服务端和客户端中使用“流量整形”功能涉及的关键代码，完整demo可见<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Flinling1%2Fnetty_module_function%2Ftree%2Fmaster%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinling%2Fnetty%2Ftrafficshaping" rel="external nofollow noopener noreferrer" target="_blank">github</a><br> <strong>服务端</strong><br> 使用GlobalTrafficShapingHandler来实现服务端的“流量整形”，每当有客户端连接至服务端时服务端就会开始往这个客户端发送26M的数据包。我们将GlobalTrafficShapingHandler的writeLimit设置为10M/S。并使用了ChunkedWriteHandler来实现大数据包拆分成小数据包发送的功能。</p>
<p>MyServerInitializer实现：在ChannelPipeline中注册了GlobalTrafficShapingHandler</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    Charset utf8 = Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        GlobalTrafficShapingHandler globalTrafficShapingHandler = <span class="keyword">new</span> GlobalTrafficShapingHandler(ch.eventLoop().parent(), <span class="number">10</span> * M, <span class="number">50</span> * M);</span><br><span class="line"><span class="comment">//        globalTrafficShapingHandler.setMaxGlobalWriteSize(50 * M);</span></span><br><span class="line"><span class="comment">//        globalTrafficShapingHandler.setMaxWriteSize(5 * M);</span></span><br><span class="line"></span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="string">"LengthFieldBasedFrameDecoder"</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="keyword">true</span>))</span><br><span class="line">                .addLast(<span class="string">"LengthFieldPrepender"</span>, <span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>, <span class="number">0</span>))</span><br><span class="line">                .addLast(<span class="string">"GlobalTrafficShapingHandler"</span>, globalTrafficShapingHandler)</span><br><span class="line">                .addLast(<span class="string">"chunkedWriteHandler"</span>, <span class="keyword">new</span> ChunkedWriteHandler())</span><br><span class="line">                .addLast(<span class="string">"myServerChunkHandler"</span>, <span class="keyword">new</span> MyServerChunkHandler())</span><br><span class="line">                .addLast(<span class="string">"StringDecoder"</span>, <span class="keyword">new</span> StringDecoder(utf8))</span><br><span class="line">                .addLast(<span class="string">"StringEncoder"</span>, <span class="keyword">new</span> StringEncoder(utf8))</span><br><span class="line">                .addLast(<span class="string">"myServerHandler"</span>, <span class="keyword">new</span> MyServerHandlerForPlain());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> ServerHandler：当有客户端连接上了后就开始给客户端发送消息。并且通过『Channel#isWritable』方法以及『channelWritabilityChanged』事件来监控可写性，以判断啥时需要停止数据的写出，啥时可以开始继续写出数据。同时写了一个简易的task来计算每秒数据的发送速率（并非精确的计算）。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandlerForPlain</span> <span class="keyword">extends</span> <span class="title">MyServerCommonHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sentData</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">        sentFlag = <span class="keyword">true</span>;</span><br><span class="line">        ctx.writeAndFlush(tempStr, getChannelProgressivePromise(ctx, future -&gt; {</span><br><span class="line">            <span class="keyword">if</span>(ctx.channel().isWritable() &amp;&amp; !sentFlag) {</span><br><span class="line">                sentData(ctx);</span><br><span class="line">            }</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span>(ctx.channel().isWritable() &amp;&amp; !sentFlag) {</span><br><span class="line"><span class="comment">//            System.out.println(" ###### 重新开始写数据 ######");</span></span><br><span class="line">            sentData(ctx);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//            System.out.println(" ===== 写暂停 =====");</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerCommonHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">protected</span> String tempStr;</span><br><span class="line">    <span class="keyword">protected</span> AtomicLong consumeMsgLength;</span><br><span class="line">    <span class="keyword">protected</span> Runnable counterTask;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> priorProgress;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> sentFlag;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        consumeMsgLength = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        counterTask = () -&gt; {</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">              <span class="keyword">try</span> {</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line"></span><br><span class="line">              }</span><br><span class="line"></span><br><span class="line">              <span class="keyword">long</span> length = consumeMsgLength.getAndSet(<span class="number">0</span>);</span><br><span class="line">              System.out.println(<span class="string">"*** "</span> + ctx.channel().remoteAddress() + <span class="string">" rate（M/S）："</span> + (length / M));</span><br><span class="line">          }</span><br><span class="line">        };</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) {</span><br><span class="line">            builder.append(<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>);</span><br><span class="line">        }</span><br><span class="line">        tempStr = builder.toString();</span><br><span class="line">        <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        sentData(ctx);</span><br><span class="line">        <span class="keyword">new</span> Thread(counterTask).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ChannelProgressivePromise <span class="title">getChannelProgressivePromise</span><span class="params">(ChannelHandlerContext ctx, Consumer&lt;ChannelProgressiveFuture&gt; completedAction)</span> </span>{</span><br><span class="line">        ChannelProgressivePromise channelProgressivePromise = ctx.newProgressivePromise();</span><br><span class="line">        channelProgressivePromise.addListener(<span class="keyword">new</span> ChannelProgressiveFutureListener(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationProgressed</span><span class="params">(ChannelProgressiveFuture future, <span class="keyword">long</span> progress, <span class="keyword">long</span> total)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                consumeMsgLength.addAndGet(progress - priorProgress);</span><br><span class="line">                priorProgress = progress;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelProgressiveFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                sentFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(future.isSuccess()){</span><br><span class="line">                    System.out.println(<span class="string">"成功发送完成！"</span>);</span><br><span class="line">                    priorProgress -= <span class="number">26</span> * M;</span><br><span class="line">                    Optional.ofNullable(completedAction).ifPresent(action -&gt; action.accept(future));</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    System.out.println(<span class="string">"发送失败！！！！！"</span>);</span><br><span class="line">                    future.cause().printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> channelProgressivePromise;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sentData</span><span class="params">(ChannelHandlerContext ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"===== receive client msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> <strong>客户端</strong><br> 客户端比较简单了，使用ChannelTrafficShapingHandler来实现“流量整形”，并将readLimit设置为1M/S。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    Charset utf8 = Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ChannelTrafficShapingHandler channelTrafficShapingHandler = <span class="keyword">new</span> ChannelTrafficShapingHandler(<span class="number">10</span> * M, <span class="number">1</span> * M);</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="string">"channelTrafficShapingHandler"</span>,channelTrafficShapingHandler)</span><br><span class="line">                .addLast(<span class="string">"lengthFieldBasedFrameDecoder"</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="keyword">true</span>))</span><br><span class="line">                .addLast(<span class="string">"lengthFieldPrepender"</span>, <span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>, <span class="number">0</span>))</span><br><span class="line">                .addLast(<span class="string">"stringDecoder"</span>, <span class="keyword">new</span> StringDecoder(utf8))</span><br><span class="line">                .addLast(<span class="string">"stringEncoder"</span>, <span class="keyword">new</span> StringEncoder(utf8))</span><br><span class="line">                .addLast(<span class="string">"myClientHandler"</span>, <span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>① 注意，trafficShaping是通过程序来达到控制流量的作用，并不是网络层真实的传输流量大小的控制。TrafficShapingHandler仅仅是根据消息大小（待发送出去的数据包大小）和设定的流量限制来得出延迟发送该包的时间，即同一时刻不会发送过大的数据导致带宽负荷不了。但是并没有对大数据包进行拆分的作用，这会使在发送这个大数据包时同样可能会导致带宽爆掉的情况。所以你需要注意一次发送数据包的大小，不要大于你设置限定的写带宽大小(writeLimit)。你可以通过在业务handler中自己控制的方式，或者考虑使用ChunkedWriteHandler，如果它能满足你的要求的话。同时注意，不要将writeLimit和readLimit设置的过小，这是没有意义的，只会导致读/写操作的不断停顿。。<br> ② 注意，不要在非NioEventLoop线程中不停歇的发送非ByteBuf、ByteBufHolder或者FileRegion对象的大数据包，如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span>(ctx.channel().isWritable()) {</span><br><span class="line">                ctx.writeAndFlush(tempStr, getChannelProgressivePromise(ctx, <span class="keyword">null</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br></pre></td></tr></tbody></table></figure>
<p>因为写操作是一个I/O操作，当你在非NioEventLoop线程上执行了Channel的I/O操作的话，该操作会封装为一个task 被提交至NioEventLoop的任务队列中，以使得I/O操作最终是NioEventLoop线程上得到执行。<br> 而提交这个任务的流程，仅会对ByteBuf、ByteBufHolder或者FileRegion对象进行真实数据大小的估计（其他情况默认估计大小为8 bytes），并将估计后的数据大小值对该ChannelOutboundBuffer的totalPendingSize属性值进行累加。而totalPendingSize同WriteBufferWaterMark一起来控制着Channel的unwritable。所以，如果你在一个非NioEventLoop线程中不断地发送一个非ByteBuf、ByteBufHolder或者FileRegion对象的大数据包时，最终就会导致提交大量的任务到NioEventLoop线程的任务队列中，而当NioEventLoop线程在真实执行这些task时可能发生OOM。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h5 id="关于-“OP-WRITE”-与-“Channel-isWritable-”"><a href="#关于-“OP-WRITE”-与-“Channel-isWritable-”" class="headerlink" title="关于 “OP_WRITE” 与 “Channel#isWritable()”"></a>关于 “OP_WRITE” 与 “Channel#isWritable()”</h5><p>首先，我们需要明确的一点是，“OP_WRITE” 与 “Channel#isWritable()” 虽然都是的对数据的可写性进行检测，但是它们是分别针对不同层面的可写性的。</p>
<ul>
<li>“OP_WRITE”是当内核的发送缓冲区满的时候，我们程序执行write操作（这里是真实写操作了，将数据通过TCP协议进行网络传输）无法将数据写出，这时我们需要注册OP_WRITE事件。这样当发送缓冲区空闲时就OP_WRITE事件就会触发，我们就可以继续write未写完的数据了。这可以看做是对系统层面的可写性的一种检测。</li>
<li>而“Channel#isWritable()”则是检测程序中的缓存的待写出的数据大小超过了我们设定的相关最大写数据大小，如果超过了isWritable()方法将返回false，说明这时我们不应该再继续进行write操作了（这里写操作一般为通过ChannelHandlerContext或Channel进行的写操作）。<br> 关于“OP_WRITE”前面的<a href="https://www.jianshu.com/p/1af407c043cb" rel="external nofollow noopener noreferrer" target="_blank">NIO文章</a>及前面Netty系列文章已经进行过不少介绍了，这里不再赘述。下面我们来看看“Channel#isWritable()”是如果检测可写性的。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unwritable == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ChannelOutboundBuffer 的 unwritable属性为0时，Channel的isWritable()方法将返回true；否之，返回false；<br> unwritable可以看做是一个二进制的开关属性值。它的二进制的不同位表示的不同状态的开关。如：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/4235178-5291c64aba1bbaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/jpeg" title="img" class="fancybox" rel="article0"><img src="https://upload-images.jianshu.io/upload_images/4235178-5291c64aba1bbaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/jpeg" alt="img"></a><span class="caption">img</span></p>
<p>ChannelOutboundBuffer有四个方法会对unwritable属性值进行修改：clearUserDefinedWritability、setUnwritable、setUserDefinedWritability、setWritable。并且，当unwritable从0到非0间改变时还会触发ChannelWritabilityChanged事件，以通知ChannelPipeline中的各个ChannelHandler当前Channel可写性发生了改变。</p>
<p>其中setUnwritable、setWritable这对方法是由于待写数据大小高于或低于了WriteBufferWaterMark的水位线而导致的unwritable属性值的改变。<br> 我们所执行的『ChannelHandlerContext#write』和『Channel#write』操作会先将待发送的数据包放到Channel的输出缓冲区（ChannelOutboundBuffer）中，然后在执行flush操作的时候，会从ChannelOutboundBuffer中依次出去数据包进行真实的网络数据传输。而WriteBufferWaterMark控制的就是ChannelOutboundBuffer中待发送的数据总大小（即，totalPendingSize：包含一个个ByteBuf中待发送的数据大小，以及数据包对象占用的大小）。如果totalPendingSize的大小超过了WriteBufferWaterMark高水位（默认为64KB），则会unwritable属性的’WriteBufferWaterMark状态位’置位1；随着数据不断写出（每写完一个ByteBuf后，就会将totalPendingSize减少相应的值），当totalPendingSize的大小小于WriteBufferWaterMark低水位（默认为32KB）时，则会将unwritable属性的’WriteBufferWaterMark状态位’置位0。</p>
<p>而本文的主题“流量整形”则是使用了clearUserDefinedWritability、setUserDefinedWritability这对方法来控制unwritable相应的状态位。<br> 当数据write到GlobalTrafficShapingHandler的时候，估计的数据大小大于0，且通过trafficCounter计算出的延迟时间大于最小延迟时间（MINIMAL_WAIT，默认为10ms）时，满足如下任意条件会使得unwritable的’GlobalTrafficShaping状态位’置为1：</p>
<ul>
<li>当perChannel.queueSize（单个Channel中待写出的总数据大小）设定的最大写数据大小时（默认为4M）</li>
<li>当queuesSize（所有Channel的待写出的总数据大小）超过设定的最大写数据大小时（默认为400M）</li>
<li>对于Channel发送的单个数据包如果太大，以至于计算出的延迟发送时间大于了最大延迟发送时间（maxWriteDelay，默认为4s）时</li>
</ul>
<p>随着写延迟时间的到达GlobalTrafficShaping中积压的数据不断被写出，当某个Channel中所有待写出的数据都写出后（注意，这里指将数据写到ChannelPipeline中的下一个ChannelOutboundBuffer中）会将unwritable的’GlobalTrafficShaping状态位’置为0。</p>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ChannelHandler-6-idle/" data-id="ck4pl3fp900edfgcff7x5rrww" class="article-share-link">分享</a>



</footer>
-->
</div>