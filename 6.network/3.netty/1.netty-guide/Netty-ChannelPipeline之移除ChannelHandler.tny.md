<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelPipeline（三）之移除 ChannelHandler
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们来分享，从 pipeline 中<strong>移除</strong> ChannelHandler 的代码具体实现。</p>
<p>在 <a href="http://svip.iocoder.cn/Netty/ChannelPipeline-1-init">《精尽 Netty 源码解析 —— ChannelPipeline（一）之初始化》</a> 中，我们看到 ChannelPipeline 定义了一大堆<strong>移除</strong> ChannelHandler 的接口方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelHandler <span class="title">remove</span><span class="params">(String name)</span></span>;</span><br><span class="line">&lt;T extends ChannelHandler&gt; <span class="function">T <span class="title">remove</span><span class="params">(Class&lt;T&gt; handlerType)</span></span>;</span><br><span class="line"><span class="function">ChannelHandler <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelHandler <span class="title">removeLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>本文仅分享 <code>#remove(ChannelHandler handler)</code> 方法，从 pipeline <strong>移除</strong>指定的 ChannelHandler 对象。</li>
</ul>
<h1 id="2-remove"><a href="#2-remove" class="headerlink" title="2. remove"></a>2. remove</h1><p><code>#remove(ChannelHandler handler)</code> 方法，从 pipeline <strong>移除</strong>指定的 ChannelHandler 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">    remove(getContextOrDie(handler));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>#getContextOrDie(ChannelHandler handler)</code> 方法，获得对应的 AbstractChannelHandlerContext 节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">    AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) { <span class="comment">// die</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(handler.getClass().getName());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelHandlerContext <span class="title">context</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">    }</span><br><span class="line">    AbstractChannelHandlerContext ctx = head.next;</span><br><span class="line">    <span class="comment">// 循环，获得指定 ChannelHandler 对象的节点</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ctx.handler() == handler) { <span class="comment">// ChannelHandler 相等</span></span><br><span class="line">            <span class="keyword">return</span> ctx;</span><br><span class="line">        }</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法使用 Die 的原因是，获得不到节点的情况下，抛出 NoSuchElementException 异常。</li>
</ul>
</li>
<li>调用 <code>#remove(AbstractChannelHandlerContext ctx)</code> 方法，移除指定 AbstractChannelHandlerContext 节点。</li>
</ul>
<hr>
<p><code>#remove(AbstractChannelHandlerContext ctx)</code> 方法，移除指定 AbstractChannelHandlerContext 节点。代码如下：</p>
<blockquote>
<p>代码的整体结构，和 <code>#addLast(EventExecutorGroup group, String name, ChannelHandler handler)</code> 方法是<strong>一致</strong>的。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail;</span><br><span class="line"> <span class="number">3</span>: </span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { <span class="comment">// 同步，为了防止多线程并发操作 pipeline 底层的双向链表</span></span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 移除节点</span></span><br><span class="line"> <span class="number">6</span>:         remove0(ctx);</span><br><span class="line"> <span class="number">7</span>: </span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// pipeline 暂未注册，添加回调。再注册完成后，执行回调。详细解析，见 {@link #callHandlerCallbackLater} 方法。</span></span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line"><span class="number">10</span>:         <span class="comment">// In this case we remove the context from the pipeline and add a task that will call</span></span><br><span class="line"><span class="number">11</span>:         <span class="comment">// ChannelHandler.handlerRemoved(...) once the channel is registered.</span></span><br><span class="line"><span class="number">12</span>:         <span class="keyword">if</span> (!registered) {</span><br><span class="line"><span class="number">13</span>:             callHandlerCallbackLater(ctx, <span class="keyword">false</span>);</span><br><span class="line"><span class="number">14</span>:             <span class="keyword">return</span> ctx;</span><br><span class="line"><span class="number">15</span>:         }</span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 不在 EventLoop 的线程中，提交 EventLoop 中，执行回调用户方法</span></span><br><span class="line"><span class="number">18</span>:         EventExecutor executor = ctx.executor();</span><br><span class="line"><span class="number">19</span>:         <span class="keyword">if</span> (!executor.inEventLoop()) {</span><br><span class="line"><span class="number">20</span>:             <span class="comment">// 提交 EventLoop 中，执行回调 ChannelHandler removed 事件</span></span><br><span class="line"><span class="number">21</span>:             executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line"><span class="number">22</span>:                 <span class="meta">@Override</span></span><br><span class="line"><span class="number">23</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">24</span>:                     callHandlerRemoved0(ctx);</span><br><span class="line"><span class="number">25</span>:                 }</span><br><span class="line"><span class="number">26</span>:             });</span><br><span class="line"><span class="number">27</span>:             <span class="keyword">return</span> ctx;</span><br><span class="line"><span class="number">28</span>:         }</span><br><span class="line"><span class="number">29</span>:     }</span><br><span class="line"><span class="number">30</span>: </span><br><span class="line"><span class="number">31</span>:     <span class="comment">// 回调 ChannelHandler removed 事件</span></span><br><span class="line"><span class="number">32</span>:     callHandlerRemoved0(ctx);</span><br><span class="line"><span class="number">33</span>:     <span class="keyword">return</span> ctx;</span><br><span class="line"><span class="number">34</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：<code>synchronized</code> 同步，为了防止多线程并发操作 pipeline 底层的双向链表。</li>
<li>第 6 行：调用 <code>#remove0(AbstractChannelHandlerContext ctx)</code> 方法，从 pipeline <strong>移除</strong>指定的 AbstractChannelHandlerContext 节点。详细解析，见 <a href="#">「3. remove0」</a> 。</li>
<li>========== 后续分成 3 种情况 ==========</li>
<li><code>&lt;1&gt;</code></li>
<li>第 12 行：Channel 并未注册。</li>
<li>第 13 行：调用 <code>#callHandlerCallbackLater(AbstractChannelHandlerContext, added)</code> 方法，添加 PendingHandlerRemovedTask 回调。在 Channel 注册完成后，执行该回调。详细解析，见 <a href="#">「8. PendingHandlerCallback」</a> 。</li>
<li><code>&lt;2&gt;</code></li>
<li>第 19 行：不在 EventLoop 的线程中。</li>
<li>第 20 至 26 行：提交 EventLoop 中，调用 <code>#callHandlerRemoved0(AbstractChannelHandlerContext)</code> 方法，执行回调 ChannelHandler 移除完成( removed )事件。详细解析，见 <a href="#">「4. callHandlerRemoved0」</a> 。</li>
<li><code>&lt;3&gt;</code></li>
<li>这种情况，是 <code>&lt;2&gt;</code> 在 EventLoop 的线程中的版本。也因为此，已经确认在 EventLoop 的线程中，所以不需要在 <code>synchronized</code> 中。</li>
<li>第 32 行：和【第 24 行】的代码一样，调用 <code>#callHandlerRemoved0(AbstractChannelHandlerContext)</code> 方法，执行回调 ChannelHandler 移除完成( removed )事件。</li>
</ul>
<h1 id="3-remove0"><a href="#3-remove0" class="headerlink" title="3. remove0"></a>3. remove0</h1><p><code>#remove0(AbstractChannelHandlerContext ctx)</code> 方法，从 pipeline <strong>移除</strong>指定的 AbstractChannelHandlerContext 节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove0</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得移除节点的前后节点</span></span><br><span class="line">    AbstractChannelHandlerContext prev = ctx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = ctx.next;</span><br><span class="line">    <span class="comment">// 前后节点互相指向</span></span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>FROM 闪电侠 <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 pipeline(一)》</a></p>
<ul>
<li><p>经历的过程要比添加节点要简单，可以用下面一幅图来表示</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_07/01.png" title="删除节点过程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_07/01.png" alt="删除节点过程"></a><span class="caption">删除节点过程</span></p>
</li>
<li><p>最后的结果为</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_07/02.png" title="删除节点之后" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_07/02.png" alt="删除节点之后"></a><span class="caption">删除节点之后</span></p>
</li>
</ul>
<p>结合这两幅图，可以很清晰地了解移除 Handler 的过程，另外，被删除的节点因为没有对象引用到，果过段时间就会被 gc 自动回收。</p>
</blockquote>
<h1 id="4-callHandlerRemoved0"><a href="#4-callHandlerRemoved0" class="headerlink" title="4. callHandlerRemoved0"></a>4. callHandlerRemoved0</h1><p><code>#callHandlerRemoved0(AbstractChannelHandlerContext)</code> 方法，执行回调 ChannelHandler 移除完成( removed )事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerRemoved0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// Notify the complete removal.</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">5</span>:             <span class="comment">// 回调 ChannelHandler 移除完成( removed )事件</span></span><br><span class="line"> <span class="number">6</span>:             ctx.handler().handlerRemoved(ctx);</span><br><span class="line"> <span class="number">7</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">8</span>:             <span class="comment">// 设置 AbstractChannelHandlerContext 已移除</span></span><br><span class="line"> <span class="number">9</span>:             ctx.setRemoved();</span><br><span class="line"><span class="number">10</span>:         }</span><br><span class="line"><span class="number">11</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 触发异常的传播</span></span><br><span class="line"><span class="number">13</span>:         fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line"><span class="number">14</span>:                 ctx.handler().getClass().getName() + <span class="string">".handlerRemoved() has thrown an exception."</span>, t));</span><br><span class="line"><span class="number">15</span>:     }</span><br><span class="line"><span class="number">16</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 6 行：调用 <code>ChannelHandler#handlerRemoved(AbstractChannelHandlerContext)</code> 方法，回调 ChannelHandler 移除完成( removed )事件。一般来说，通过这个方法，来释放 ChannelHandler 占用的资源。<strong>注意</strong>，因为这个方法的执行在 EventLoop 的线程中，所以要尽量避免执行时间过长。</li>
<li>第 9 行：调用 <code>AbstractChannelHandlerContext#setRemoved()</code> 方法，设置 AbstractChannelHandlerContext 已移除。</li>
<li>第 11 至 15 行：发生异常，触发异常的传播。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ChannelPipeline-6-exception">《精尽 Netty 源码解析 —— ChannelPipeline（六）之异常事件的传播》</a> 。</li>
</ul>
<h1 id="5-PendingHandlerRemovedTask"><a href="#5-PendingHandlerRemovedTask" class="headerlink" title="5. PendingHandlerRemovedTask"></a>5. PendingHandlerRemovedTask</h1><p>PendingHandlerRemovedTask 实现 PendingHandlerCallback 抽象类，用于回调移除 ChannelHandler 节点。代码如下： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerRemovedTask</span> <span class="keyword">extends</span> <span class="title">PendingHandlerCallback</span> </span>{</span><br><span class="line"></span><br><span class="line">    PendingHandlerRemovedTask(AbstractChannelHandlerContext ctx) {</span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        callHandlerRemoved0(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{</span><br><span class="line">        EventExecutor executor = ctx.executor();</span><br><span class="line">        <span class="comment">// 在 EventLoop 的线程中，回调 ChannelHandler removed 事件</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) {</span><br><span class="line">            callHandlerRemoved0(ctx);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 提交 EventLoop 中，执行回调 ChannelHandler removed 事件</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                executor.execute(<span class="keyword">this</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">            } <span class="keyword">catch</span> (RejectedExecutionException e) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Can't invoke handlerRemoved() as the EventExecutor {} rejected it,"</span> +</span><br><span class="line">                                    <span class="string">" removing handler {}."</span>, executor, ctx.name(), e);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 标记 AbstractChannelHandlerContext 为已移除</span></span><br><span class="line">                <span class="comment">// remove0(...) was call before so just call AbstractChannelHandlerContext.setRemoved().</span></span><br><span class="line">                ctx.setRemoved();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <code>#execute()</code> 实现方法中，我们可以看到，和 <code>#remove((AbstractChannelHandlerContext ctx)</code> 方法的【第 17 至 32 行】的代码比较类似，目的是，在 EventLoop 的线程中，执行 <code>#callHandlerRemoved0(AbstractChannelHandlerContext)</code> 方法，回调 ChannelHandler 移除完成( removed )事件。</li>
<li><code>&lt;1&gt;</code> 处，为什么 PendingHandlerRemovedTask 可以直接提交到 EventLoop 中呢？因为 PendingHandlerRemovedTask 是个 Runnable ，这也就是为什么 PendingHandlerCallback 实现 Runnable 接口的原因。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>水文一小篇。推荐阅读文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 pipeline(一)》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ChannelPipeline-3-remove-channel-handler/" data-id="ck4pl3fox00dhfgcfkplkxbbl" class="article-share-link">分享</a>



</footer>
-->
</div>