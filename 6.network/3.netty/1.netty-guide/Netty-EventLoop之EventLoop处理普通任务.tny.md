<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（六）之 EventLoop 处理普通任务
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们分享 EventLoop 的<strong>执行任务</strong>相关代码的实现。对应如下图的紫条 <strong>run tasks</strong> 部分：<a href="http://static2.iocoder.cn/images/Netty/2018_05_10/01.png" title="run" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_10/01.png" alt="run"></a><span class="caption">run</span></p>
<p>EventLoop 执行的任务分成<strong>普通</strong>任务和<strong>定时</strong>任务，考虑到内容切分的更细粒度，本文近仅仅分享【<strong>普通任务</strong>】的部分。</p>
<h1 id="2-runAllTasks-带超时"><a href="#2-runAllTasks-带超时" class="headerlink" title="2. runAllTasks 带超时"></a>2. runAllTasks 带超时</h1><p>在 <code>#run()</code> 方法中，会调用 <code>#runAllTasks(long timeoutNanos)</code> 方法，执行所有任务直到完成所有，或者超过执行时间上限。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 从定时任务获得到时间的任务</span></span><br><span class="line"> <span class="number">3</span>:     fetchFromScheduledTaskQueue();</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得队头的任务</span></span><br><span class="line"> <span class="number">5</span>:     Runnable task = pollTask();</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 获取不到，结束执行</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 执行所有任务完成的后续方法</span></span><br><span class="line"> <span class="number">9</span>:         afterRunningAllTasks();</span><br><span class="line"><span class="number">10</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">11</span>:     }</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:     <span class="comment">// 计算执行任务截止时间</span></span><br><span class="line"><span class="number">14</span>:     <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line"><span class="number">15</span>:     <span class="keyword">long</span> runTasks = <span class="number">0</span>; <span class="comment">// 执行任务计数</span></span><br><span class="line"><span class="number">16</span>:     <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line"><span class="number">17</span>:     <span class="comment">// 循环执行任务</span></span><br><span class="line"><span class="number">18</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="number">19</span>:         <span class="comment">// 执行任务</span></span><br><span class="line"><span class="number">20</span>:         safeExecute(task);</span><br><span class="line"><span class="number">21</span>: </span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 计数 +1</span></span><br><span class="line"><span class="number">23</span>:         runTasks ++;</span><br><span class="line"><span class="number">24</span>: </span><br><span class="line"><span class="number">25</span>:         <span class="comment">// 每隔 64 个任务检查一次时间，因为 nanoTime() 是相对费时的操作</span></span><br><span class="line"><span class="number">26</span>:         <span class="comment">// 64 这个值当前是硬编码的，无法配置，可能会成为一个问题。</span></span><br><span class="line"><span class="number">27</span>:         <span class="comment">// Check timeout every 64 tasks because nanoTime() is relatively expensive.</span></span><br><span class="line"><span class="number">28</span>:         <span class="comment">// <span class="doctag">XXX:</span> Hard-coded value - will make it configurable if it is really a problem.</span></span><br><span class="line"><span class="number">29</span>:         <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) {</span><br><span class="line"><span class="number">30</span>:             <span class="comment">// 重新获得时间</span></span><br><span class="line"><span class="number">31</span>:             lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line"><span class="number">32</span>:             <span class="comment">// 超过任务截止时间，结束</span></span><br><span class="line"><span class="number">33</span>:             <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) {</span><br><span class="line"><span class="number">34</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">35</span>:             }</span><br><span class="line"><span class="number">36</span>:         }</span><br><span class="line"><span class="number">37</span>: </span><br><span class="line"><span class="number">38</span>:         <span class="comment">// 获得队头的任务</span></span><br><span class="line"><span class="number">39</span>:         task = pollTask();</span><br><span class="line"><span class="number">40</span>:         <span class="comment">// 获取不到，结束执行</span></span><br><span class="line"><span class="number">41</span>:         <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">42</span>:             <span class="comment">// 重新获得时间</span></span><br><span class="line"><span class="number">43</span>:             lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line"><span class="number">44</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">45</span>:         }</span><br><span class="line"><span class="number">46</span>:     }</span><br><span class="line"><span class="number">47</span>: </span><br><span class="line"><span class="number">48</span>:     <span class="comment">// 执行所有任务完成的后续方法</span></span><br><span class="line"><span class="number">49</span>:     afterRunningAllTasks();</span><br><span class="line"><span class="number">50</span>: </span><br><span class="line"><span class="number">51</span>:     <span class="comment">// 设置最后执行时间</span></span><br><span class="line"><span class="number">52</span>:     <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line"><span class="number">53</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">54</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法的返回值，表示是否执行过任务。因为，任务队列可能为空，那么就会返回 <code>false</code> ，表示没有执行过任务。</li>
<li>第 3 行：调用 <code>#fetchFromScheduledTaskQueue()</code> 方法，将定时任务队列 <code>scheduledTaskQueue</code> 到达可执行的任务，添加到任务队列 <code>taskQueue</code> 中。通过这样的方式，定时任务得以被执行。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-7-EventLoop-handle-schedule-task">《精尽 Netty 源码解析 —— EventLoop（七）之 EventLoop 处理定时任务》</a> 。</li>
<li>第 5 行：<strong>首次</strong>调用 <code>#pollTask()</code> 方法，获得队头的任务。详细解析，胖友先跳到 <a href="#">「4. pollTask」</a> 。<ul>
<li>第 6 至 11 行：获取不到任务，结束执行，并返回 <code>false</code> 。<ul>
<li>第 9 行：调用 <code>#afterRunningAllTasks()</code>  方法，执行所有任务完成的<strong>后续</strong>方法。详细解析，见 <a href="#">「5. afterRunningAllTasks」</a> 。</li>
</ul>
</li>
</ul>
</li>
<li>第 14 行：计算执行任务截止时间。其中，<code>ScheduledFutureTask#nanoTime()</code> 方法，我们可以暂时理解成，获取当前的时间，单位为<strong>纳秒</strong>。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-7-EventLoop-handle-schedule-task">《精尽 Netty 源码解析 —— EventLoop（七）之 EventLoop 处理定时任务》</a> 。</li>
<li>第 17 至 46 行：<strong>循环</strong>执行任务。<ul>
<li>第 20 行：【重要】调用 <code>#safeExecute(Runnable task)</code> 方法，执行任务。</li>
<li>第 23 行：计算 <code>runTasks</code> <strong>加一</strong>。</li>
<li>第 29 至 36 行：每隔 <strong>64</strong> 个任务检查一次时间，因为 <code>System#nanoTime()</code> 是<strong>相对费时</strong>的操作。也因此，超过执行时间上限是“<strong>近似的</strong>”，而不是绝对准确。<ul>
<li>第 31 行：调用 <code>ScheduledFutureTask#nanoTime()</code> 方法，获取当前的时间。</li>
<li>第 32 至 35 行：超过执行时间上限，结束执行。</li>
</ul>
</li>
<li>第 39 行：<strong>再次</strong>调用 <code>#pollTask()</code> 方法，获得队头的任务。<ul>
<li>第 41 至 45 行：获取不到，结束执行。</li>
<li>第 43 行：调用 <code>ScheduledFutureTask#nanoTime()</code> 方法，获取当前的时间，作为<strong>最终</strong>的 <code>.lastExecutionTime</code> ，即【第 52 行】的代码。</li>
</ul>
</li>
</ul>
</li>
<li>第 49 行：调用 <code>#afterRunningAllTasks()</code>  方法，执行所有任务完成的<strong>后续</strong>方法。</li>
<li>第 53 行：返回 <code>true</code> ，表示有执行任务。</li>
</ul>
<h1 id="3-runAllTasks"><a href="#3-runAllTasks" class="headerlink" title="3. runAllTasks"></a>3. runAllTasks</h1><p>在 <code>#run()</code> 方法中，会调用 <code>#runAllTasks()</code> 方法，执行所有任务直到完成所有。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">boolean</span> fetchedAll;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">boolean</span> ranAtLeastOne = <span class="keyword">false</span>; <span class="comment">// 是否执行过任务</span></span><br><span class="line"> <span class="number">5</span>: </span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">do</span> {</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 从定时任务获得到时间的任务</span></span><br><span class="line"> <span class="number">8</span>:         fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 执行任务队列中的所有任务</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">if</span> (runAllTasksFrom(taskQueue)) {</span><br><span class="line"><span class="number">11</span>:             <span class="comment">// 若有任务执行，则标记为 true</span></span><br><span class="line"><span class="number">12</span>:             ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">13</span>:         }</span><br><span class="line"><span class="number">14</span>:     } <span class="keyword">while</span> (!fetchedAll); <span class="comment">// keep on processing until we fetched all scheduled tasks.</span></span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="comment">// 如果执行过任务，则设置最后执行时间</span></span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (ranAtLeastOne) {</span><br><span class="line"><span class="number">18</span>:         lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line"><span class="number">19</span>:     }</span><br><span class="line"><span class="number">20</span>: </span><br><span class="line"><span class="number">21</span>:     <span class="comment">// 执行所有任务完成的后续方法</span></span><br><span class="line"><span class="number">22</span>:     afterRunningAllTasks();</span><br><span class="line"><span class="number">23</span>:     <span class="keyword">return</span> ranAtLeastOne;</span><br><span class="line"><span class="number">24</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：<code>ranAtLeastOne</code> ，标记是否执行过任务。</li>
<li><p>第 6 至 14 行：调用 <code>#fetchFromScheduledTaskQueue()</code> 方法，将定时任务队列 <code>scheduledTaskQueue</code> 到达可执行的任务，添加到任务队列 <code>taskQueue</code> 中。但是实际上，任务队列 <code>taskQueue</code> 是有队列大小上限的，因此使用 <code>while</code> 循环，直到没有到达可执行的任务为止。</p>
<ul>
<li><p>第 10 行：调用 <code>#runAllTasksFrom(taskQueue)</code> 方法，执行任务队列中的所有任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runAllTasksFrom</span><span class="params">(Queue&lt;Runnable&gt; taskQueue)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得队头的任务</span></span><br><span class="line">    Runnable task = pollTaskFrom(taskQueue);</span><br><span class="line">    <span class="comment">// 获取不到，结束执行，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        safeExecute(task);</span><br><span class="line">        <span class="comment">// 获得队头的任务</span></span><br><span class="line">        task = pollTaskFrom(taskQueue);</span><br><span class="line">        <span class="comment">// 获取不到，结束执行，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，和 <code>#runAllTasks(long timeoutNanos))</code> 方法的代码，大体是相似的。</li>
</ul>
</li>
<li>第 12 行：若有任务被执行，则标记 <code>ranAtLeastOne</code> 为 <code>true</code> 。</li>
</ul>
</li>
<li>第 16 至 19 行：如果执行过任务，则设置最后执行时间。</li>
<li>第 22 行：调用 <code>#afterRunningAllTasks()</code>  方法，执行所有任务完成的<strong>后续</strong>方法。</li>
<li>第 23 行：返回是否执行过任务。和 <code>#runAllTasks(long timeoutNanos))</code> 方法的返回是<strong>一致</strong>的。</li>
</ul>
<h1 id="4-pollTask"><a href="#4-pollTask" class="headerlink" title="4. pollTask"></a>4. pollTask</h1><p><code>#pollTask()</code> 方法，获得<strong>队头</strong>的任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">pollTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> pollTaskFrom(taskQueue);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">pollTaskFrom</span><span class="params">(Queue&lt;Runnable&gt; taskQueue)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) { <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        <span class="comment">// 获得并移除队首元素。如果获得不到，返回 null</span></span><br><span class="line">        Runnable task = taskQueue.poll(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        <span class="comment">// 忽略 WAKEUP_TASK 任务，因为是空任务</span></span><br><span class="line">        <span class="keyword">if</span> (task == WAKEUP_TASK) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>Queue#poll()</code> 方法，获得并移除队首元素。如果获得不到，返回 null 。<strong>注意</strong>，这个操作是<strong>非阻塞</strong>的。如果胖友不知道，请 Google 重新学习下。</li>
<li><code>&lt;2&gt;</code> 处，因为获得的任务可能是 <code>WAKEUP_TASK</code> ，所以需要通过循环来跳过。</li>
</ul>
<h1 id="5-afterRunningAllTasks"><a href="#5-afterRunningAllTasks" class="headerlink" title="5. afterRunningAllTasks"></a>5. afterRunningAllTasks</h1><p>在 <a href="http://svip.iocoder.cn/Netty/EventLoop-3-EventLoop-init/">《精尽 Netty 源码解析 —— EventLoop（三）之 EventLoop 初始化》</a> 的 <a href="#">「9.10 afterRunningAllTasks」</a> 中，<code>#afterRunningAllTasks()</code> 方法，执行所有任务完成的<strong>后续</strong>方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventLoop.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRunningAllTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    runAllTasksFrom(tailTasks);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用 <code>#runAllTasksFrom(tailTasks)</code> 方法，执行任务队列 <code>tailTasks</code> 的任务。</li>
</ul>
<p>那么，可能很多胖友会和我有一样的疑问，<strong>到底什么样的任务</strong>，适合添加到 <code>tailTasks</code> 中呢？笔者请教了自己的好基友，闪电侠，来解答了这个问题。他实现了<strong>批量提交写入</strong>功能的 Handler ，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchFlushHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CompositeByteBuf compositeByteBuf;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否使用 CompositeByteBuf 对象，用于数据写入</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> preferComposite;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SingleThreadEventLoop eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel.Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否添加任务到 tailTaskQueue 队列中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasAddTailTask = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchFlushHandler</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchFlushHandler</span><span class="params">(<span class="keyword">boolean</span> preferComposite)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.preferComposite = preferComposite;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">        <span class="comment">// 初始化 CompositeByteBuf 对象，如果开启 preferComposite 功能</span></span><br><span class="line">        <span class="keyword">if</span> (preferComposite) {</span><br><span class="line">            compositeByteBuf = ctx.alloc().compositeBuffer();</span><br><span class="line">        }</span><br><span class="line">        eventLoop = (SingleThreadEventLoop) ctx.executor();</span><br><span class="line">        unsafe = ctx.channel().unsafe();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>{</span><br><span class="line">        <span class="comment">// 写入到 CompositeByteBuf 对象中</span></span><br><span class="line">        <span class="keyword">if</span> (preferComposite) {</span><br><span class="line">            compositeByteBuf.addComponent(<span class="keyword">true</span>, (ByteBuf) msg);</span><br><span class="line">        <span class="comment">// 普通写入</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ctx.write(msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">        <span class="comment">// 通过 hasAddTailTask 有且仅有每个 EventLoop 执行循环( run )，只添加一次任务</span></span><br><span class="line">        <span class="keyword">if</span> (!hasAddTailTask) {</span><br><span class="line">            hasAddTailTask = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 【重点】添加最终批量提交( flush )的任务</span></span><br><span class="line">            <span class="comment">// 【重点】添加最终批量提交( flush )的任务</span></span><br><span class="line">            <span class="comment">// 【重点】添加最终批量提交( flush )的任务</span></span><br><span class="line">            eventLoop.executeAfterEventLoopIteration(() -&gt; {</span><br><span class="line">                <span class="keyword">if</span> (preferComposite) {</span><br><span class="line">                    ctx.writeAndFlush(compositeByteBuf).addListener(future -&gt; compositeByteBuf = ctx.alloc()</span><br><span class="line">                            .compositeBuffer());</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    unsafe.flush();</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 重置 hasAddTailTask ，从而实现下个 EventLoop 执行循环( run )，可以再添加一次任务</span></span><br><span class="line">                hasAddTailTask = <span class="keyword">false</span>;</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码可能略微有一丢丢难懂，不过笔者已经添加中文注释，胖友可以自己理解下。</li>
<li><p>为什么这样做会有好处呢？在 <a href="https://mp.weixin.qq.com/s/JRsbK1Un2av9GKmJ8DK7IQ" rel="external nofollow noopener noreferrer" target="_blank">《蚂蚁通信框架实践》</a> 的 <a href="#">「5. 批量解包与批量提交」 </a> 有相关分享。</p>
<blockquote>
<p>如此能减少 <code>pipeline</code> 的执行次数，同时提升吞吐量。这个模式在低并发场景，并没有什么优势，而在高并发场景下对提升吞吐量有不小的性能提升。</p>
</blockquote>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>美滋滋，比较简单。又是一个失眠的夜晚。</p>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-6-EventLoop-handle-normal-task/" data-id="ck4pl3fow00defgcf9y2ljwyf" class="article-share-link">分享</a>



</footer>
-->
</div>