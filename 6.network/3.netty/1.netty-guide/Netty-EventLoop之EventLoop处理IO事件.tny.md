<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（五）之 EventLoop 处理 IO 事件
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们分享 EventLoop 的<strong>处理 IO 事件</strong>相关代码的实现。对应如下图的绿条 <strong>process selected keys</strong> 部分：<a href="http://static2.iocoder.cn/images/Netty/2018_05_10/01.png" title="run" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_10/01.png" alt="run"></a><span class="caption">run</span></p>
<p>因为在 <a href="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event?self">《精尽 Netty 源码解析 —— EventLoop（四）之 EventLoop 运行》</a> 中，<code>#openSelector()</code> 和 <code>#rebuildSelector()</code> 方法并未做分享，所以我们先来一起看看。</p>
<h1 id="2-SelectorTuple"><a href="#2-SelectorTuple" class="headerlink" title="2. SelectorTuple"></a>2. SelectorTuple</h1><p>SelectorTuple ，Selector 元组。代码如下：</p>
<blockquote>
<p>SelectorTuple 内嵌在 NioEventLoop </p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorTuple</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未包装的 Selector 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未包装的 Selector 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    SelectorTuple(Selector unwrappedSelector) {</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selector = unwrappedSelector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SelectorTuple(Selector unwrappedSelector, Selector selector) {</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-openSelector"><a href="#3-openSelector" class="headerlink" title="3. openSelector"></a>3. openSelector</h1><p><code>#openSelector()</code> 方法，创建 Selector 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 创建 Selector 对象，作为 unwrappedSelector</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">5</span>:         unwrappedSelector = provider.openSelector();</span><br><span class="line"> <span class="number">6</span>:     } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, e);</span><br><span class="line"> <span class="number">8</span>:     }</span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 禁用 SelectionKey 的优化，则直接返回 SelectorTuple 对象。即，selector 也使用 unwrappedSelector 。</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (DISABLE_KEYSET_OPTIMIZATION) {</span><br><span class="line"><span class="number">12</span>:         <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line"><span class="number">13</span>:     }</span><br><span class="line"><span class="number">14</span>: </span><br><span class="line"><span class="number">15</span>:     <span class="comment">// 获得 SelectorImpl 类</span></span><br><span class="line"><span class="number">16</span>:     Object maybeSelectorImplClass = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() {</span><br><span class="line"><span class="number">17</span>:         <span class="meta">@Override</span></span><br><span class="line"><span class="number">18</span>:         <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">19</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">20</span>:                 <span class="keyword">return</span> Class.forName(</span><br><span class="line"><span class="number">21</span>:                         <span class="string">"sun.nio.ch.SelectorImpl"</span>,</span><br><span class="line"><span class="number">22</span>:                         <span class="keyword">false</span>,</span><br><span class="line"><span class="number">23</span>:                         PlatformDependent.getSystemClassLoader()); <span class="comment">// 成功，则返回该类</span></span><br><span class="line"><span class="number">24</span>:             } <span class="keyword">catch</span> (Throwable cause) {</span><br><span class="line"><span class="number">25</span>:                 <span class="keyword">return</span> cause; <span class="comment">// 失败，则返回该异常</span></span><br><span class="line"><span class="number">26</span>:             }</span><br><span class="line"><span class="number">27</span>:         }</span><br><span class="line"><span class="number">28</span>:     });</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:     <span class="comment">// 获得 SelectorImpl 类失败，则直接返回 SelectorTuple 对象。即，selector 也使用 unwrappedSelector 。</span></span><br><span class="line"><span class="number">31</span>:     <span class="keyword">if</span> (!(maybeSelectorImplClass <span class="keyword">instanceof</span> Class) ||</span><br><span class="line"><span class="number">32</span>:             <span class="comment">// ensure the current selector implementation is what we can instrument.</span></span><br><span class="line"><span class="number">33</span>:             !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) {</span><br><span class="line"><span class="number">34</span>:         <span class="keyword">if</span> (maybeSelectorImplClass <span class="keyword">instanceof</span> Throwable) {</span><br><span class="line"><span class="number">35</span>:             Throwable t = (Throwable) maybeSelectorImplClass;</span><br><span class="line"><span class="number">36</span>:             logger.trace(<span class="string">"failed to instrument a special java.util.Set into: {}"</span>, unwrappedSelector, t);</span><br><span class="line"><span class="number">37</span>:         }</span><br><span class="line"><span class="number">38</span>:         <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line"><span class="number">39</span>:     }</span><br><span class="line"><span class="number">40</span>: </span><br><span class="line"><span class="number">41</span>:     <span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line"><span class="number">42</span>: </span><br><span class="line"><span class="number">43</span>:     <span class="comment">// 创建 SelectedSelectionKeySet 对象</span></span><br><span class="line"><span class="number">44</span>:     <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"><span class="number">45</span>: </span><br><span class="line"><span class="number">46</span>:     <span class="comment">// 设置 SelectedSelectionKeySet 对象到 unwrappedSelector 中</span></span><br><span class="line"><span class="number">47</span>:     Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() {</span><br><span class="line"><span class="number">48</span>:         <span class="meta">@Override</span></span><br><span class="line"><span class="number">49</span>:         <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">50</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">51</span>:                 <span class="comment">// 获得 "selectedKeys" "publicSelectedKeys" 的 Field</span></span><br><span class="line"><span class="number">52</span>:                 Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line"><span class="number">53</span>:                 Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line"><span class="number">54</span>: </span><br><span class="line"><span class="number">55</span>:                 <span class="comment">// 设置 Field 可访问</span></span><br><span class="line"><span class="number">56</span>:                 Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">57</span>:                 <span class="keyword">if</span> (cause != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">58</span>:                     <span class="keyword">return</span> cause;</span><br><span class="line"><span class="number">59</span>:                 }</span><br><span class="line"><span class="number">60</span>:                 cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">61</span>:                 <span class="keyword">if</span> (cause != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">62</span>:                     <span class="keyword">return</span> cause;</span><br><span class="line"><span class="number">63</span>:                 }</span><br><span class="line"><span class="number">64</span>: </span><br><span class="line"><span class="number">65</span>:                 <span class="comment">// 设置 SelectedSelectionKeySet 对象到 unwrappedSelector 的 Field 中</span></span><br><span class="line"><span class="number">66</span>:                 selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line"><span class="number">67</span>:                 publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line"><span class="number">68</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">69</span>:             } <span class="keyword">catch</span> (NoSuchFieldException e) {</span><br><span class="line"><span class="number">70</span>:                 <span class="keyword">return</span> e; <span class="comment">// 失败，则返回该异常</span></span><br><span class="line"><span class="number">71</span>:             } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line"><span class="number">72</span>:                 <span class="keyword">return</span> e; <span class="comment">// 失败，则返回该异常</span></span><br><span class="line"><span class="number">73</span>:             }</span><br><span class="line"><span class="number">74</span>:         }</span><br><span class="line"><span class="number">75</span>:     });</span><br><span class="line"><span class="number">76</span>: </span><br><span class="line"><span class="number">77</span>:     <span class="comment">// 设置 SelectedSelectionKeySet 对象到 unwrappedSelector 中失败，则直接返回 SelectorTuple 对象。即，selector 也使用 unwrappedSelector 。</span></span><br><span class="line"><span class="number">78</span>:     <span class="keyword">if</span> (maybeException <span class="keyword">instanceof</span> Exception) {</span><br><span class="line"><span class="number">79</span>:         selectedKeys = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">80</span>:         Exception e = (Exception) maybeException;</span><br><span class="line"><span class="number">81</span>:         logger.trace(<span class="string">"failed to instrument a special java.util.Set into: {}"</span>, unwrappedSelector, e);</span><br><span class="line"><span class="number">82</span>:         <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line"><span class="number">83</span>:     }</span><br><span class="line"><span class="number">84</span>: </span><br><span class="line"><span class="number">85</span>:     <span class="comment">// 设置 SelectedSelectionKeySet 对象到 selectedKeys 中</span></span><br><span class="line"><span class="number">86</span>:     selectedKeys = selectedKeySet;</span><br><span class="line"><span class="number">87</span>:     logger.trace(<span class="string">"instrumented a special java.util.Set into: {}"</span>, unwrappedSelector);</span><br><span class="line"><span class="number">88</span>: </span><br><span class="line"><span class="number">89</span>:     <span class="comment">// 创建 SelectedSelectionKeySetSelector 对象</span></span><br><span class="line"><span class="number">90</span>:     <span class="comment">// 创建 SelectorTuple 对象。即，selector 也使用 SelectedSelectionKeySetSelector 对象。</span></span><br><span class="line"><span class="number">91</span>:     <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector, <span class="keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</span><br><span class="line"><span class="number">92</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 8 行：创建 Selector 对象，作为 <code>unwrappedSelector</code> 。</li>
<li>第 10 至 13 行：禁用 SelectionKey 的优化，则直接返回 SelectorTuple 对象。即，<code>selector</code> 也使用 <code>unwrappedSelector</code> 。</li>
<li>第 15 至 28 行：获得 SelectorImpl 类。胖友可以自动过滤掉 <code>AccessController#.doPrivileged(...)</code> 外层代码。在方法内部，调用 <code>Class#forName(String name, boolean initialize, ClassLoader loader)</code> 方法，加载 <code>sun.nio.ch.SelectorImpl</code> 类。加载成功，则返回该类，否则返回异常。<ul>
<li>第 30 至 39 行： 获得 SelectorImpl 类失败，则直接返回 SelectorTuple 对象。即，<code>selector</code> 也使用 <code>unwrappedSelector</code> 。</li>
</ul>
</li>
<li><p>第 44 行：创建 SelectedSelectionKeySet 对象。这是 Netty 对 Selector 的 <code>selectionKeys</code> 的优化。关于 SelectedSelectionKeySet 的详细实现，见 <a href="#">「4. SelectedSelectionKeySet」</a> 。</p>
<ul>
<li>第 46 至 75 行： 设置 SelectedSelectionKeySet 对象到 <code>unwrappedSelector</code> 中的 <code>selectedKeys</code> 和 <code>publicSelectedKeys</code> 属性。整个过程，笔者已经添加中文注释，胖友自己看下。</li>
<li><p><code>selectedKeys</code> 和 <code>publicSelectedKeys</code> 属性在 SelectorImpl 类中，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="keyword">new</span> HashSet(); <span class="comment">// =&gt; publicKeys</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;SelectionKey&gt; publicKeys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="keyword">new</span> HashSet(); <span class="comment">// =&gt; publicSelectedKeys</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;SelectionKey&gt; publicSelectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider var1)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(var1);</span><br><span class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">"1.4"</span>)) { <span class="comment">// 可以无视</span></span><br><span class="line">        <span class="keyword">this</span>.publicKeys = <span class="keyword">this</span>.keys;</span><br><span class="line">        <span class="keyword">this</span>.publicSelectedKeys = <span class="keyword">this</span>.selectedKeys;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">this</span>.publicKeys = Collections.unmodifiableSet(<span class="keyword">this</span>.keys);</span><br><span class="line">        <span class="keyword">this</span>.publicSelectedKeys = Util.ungrowableSet(<span class="keyword">this</span>.selectedKeys);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以看到，<code>selectedKeys</code> 和 <code>publicSelectedKeys</code> 的类型都是 HashSet 。</li>
</ul>
</li>
<li>第 77 至 83 行：设置 SelectedSelectionKeySet 对象到 <code>unwrappedSelector</code> 中失败，则直接返回 SelectorTuple 对象。即，<code>selector</code> 也使用 <code>unwrappedSelector</code> 。</li>
</ul>
</li>
<li>第 86 行：设置 SelectedSelectionKeySet 对象到 <code>selectedKeys</code> 中。在下文，我们会看到，是否成功优化 Selector 对象，是通过 <code>selectedKeys</code> 是否成功初始化来判断。</li>
<li>第 91 行：创建 SelectedSelectionKeySetSelector 对象。这是 Netty 对 Selector 的优化实现类。关于 SelectedSelectionKeySetSelector 的详细实现，见 <a href="#">「5. SelectedSelectionKeySetSelector」</a> 。</li>
<li>第 91 行：创建 SelectorTuple 对象。即，<code>selector</code> 使用 SelectedSelectionKeySetSelector 对象。😈 总算，创建成功优化的 <code>selector</code> 对象了。</li>
</ul>
<h1 id="4-SelectedSelectionKeySet"><a href="#4-SelectedSelectionKeySet" class="headerlink" title="4. SelectedSelectionKeySet"></a>4. SelectedSelectionKeySet</h1><p><code>io.netty.channel.nio.SelectedSelectionKeySet</code> ，继承 AbstractSet 抽象类，已 <strong>select</strong> 的 NIO SelectionKey 集合。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SelectionKey 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组可读大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() {</span><br><span class="line">        keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>]; <span class="comment">// 默认 1024 大小</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到数组</span></span><br><span class="line">        keys[size++] = o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超过数组大小上限，进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) {</span><br><span class="line">            increaseCapacity();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;SelectionKey&gt; <span class="title">iterator</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>{</span><br><span class="line">        reset(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> start)</span> </span>{</span><br><span class="line">        <span class="comment">// 重置数组内容为空</span></span><br><span class="line">        Arrays.fill(keys, start, size, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 重置可读大小为 0</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 两倍扩容</span></span><br><span class="line">        SelectionKey[] newKeys = <span class="keyword">new</span> SelectionKey[keys.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 复制老数组到新数组</span></span><br><span class="line">        System.arraycopy(keys, <span class="number">0</span>, newKeys, <span class="number">0</span>, size);</span><br><span class="line">        <span class="comment">// 赋值给老数组</span></span><br><span class="line">        keys = newKeys;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>keys</code> 和 <code>size</code> 两个属性，实现<strong>可重用</strong>的数组。</li>
<li><code>#add(SelectionKey o)</code> 方法，添加新 <strong>select</strong> 到就绪事件的 SelectionKey 到 <code>keys</code> 中。当超过数组大小上限时，调用 <code>#increaseCapacity()</code> 方法，进行<strong>两倍</strong>扩容。相比 SelectorImpl 中使用的 <code>selectedKeys</code> 所使用的 HashSet 的 <code>#add(E e)</code> 方法，事件复杂度从 <code>O(lgn)</code> <strong>降低</strong>到 <code>O(1)</code> 。</li>
<li><code>#reset(...)</code> 方法，每次读取使用完数据，调用该方法，进行重置。</li>
<li>因为 <code>#remove(Object o)</code>、<code>#contains(Object o)</code>、<code>#iterator()</code> 不会使用到，索性不进行实现。</li>
</ul>
<h1 id="5-SelectedSelectionKeySetSelector"><a href="#5-SelectedSelectionKeySetSelector" class="headerlink" title="5. SelectedSelectionKeySetSelector"></a>5. SelectedSelectionKeySetSelector</h1><p><code>io.netty.channel.nio.SelectedSelectionKeySetSelector</code> ，基于 Netty SelectedSelectionKeySet 作为 <code>selectionKeys</code> 的 Selector 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySetSelector</span> <span class="keyword">extends</span> <span class="title">Selector</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SelectedSelectionKeySet 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectedSelectionKeySet selectionKeys;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原始 Java NIO Selector 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector delegate;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySetSelector(Selector delegate, SelectedSelectionKeySet selectionKeys) {</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">this</span>.selectionKeys = selectionKeys;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.isOpen();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.provider();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">keys</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.keys();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.selectedKeys();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 重置 selectionKeys</span></span><br><span class="line">        selectionKeys.reset();</span><br><span class="line">        <span class="comment">// selectNow</span></span><br><span class="line">        <span class="keyword">return</span> delegate.selectNow();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 重置 selectionKeys</span></span><br><span class="line">        selectionKeys.reset();</span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        <span class="keyword">return</span> delegate.select(timeout);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 重置 selectionKeys</span></span><br><span class="line">        selectionKeys.reset();</span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        <span class="keyword">return</span> delegate.select();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">wakeup</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.wakeup();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        delegate.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>除了 <strong>select</strong> 相关的 3 个方法，每个实现方法，都是基于 Java NIO Selector 对应的方法的调用。</li>
<li><strong>select</strong> 相关的 3 个方法，在调用对应的 Java NIO Selector 方法之前，会调用 <code>SelectedSelectionKeySet#reset()</code> 方法，重置 <code>selectionKeys</code> 。从而实现，每次 select 之后，都是<strong>新的</strong>已 select 的 NIO SelectionKey 集合。</li>
</ul>
<h1 id="6-rebuildSelector"><a href="#6-rebuildSelector" class="headerlink" title="6. rebuildSelector"></a>6. rebuildSelector</h1><p><code>#rebuildSelector()</code> 方法，重建 Selector 对象。代码如下：</p>
<blockquote>
<p>该方法用于 NIO Selector 发生 epoll bug 时，重建 Selector 对象。</p>
<p>😈 突然又找到一个讨论，可以看看 <a href="https://github.com/Yhzhtk/note/issues/26" rel="external nofollow noopener noreferrer" target="_blank">《JDK 1.7 及以下 NIO 的 epoll bug》</a> 和 <a href="http://www.10tiao.com/html/308/201602/401718035/1.html" rel="external nofollow noopener noreferrer" target="_blank">《应用服务器中对JDK的epoll空转bug的处理》</a> 。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebuildSelector</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 只允许在 EventLoop 的线程中执行</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop()) {</span><br><span class="line">        execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    rebuildSelector0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>只允许在 EventLoop 的线程中，调用 <code>#rebuildSelector0()</code> 方法，重建 Selector 对象。</li>
</ul>
<h2 id="6-1-rebuildSelector0"><a href="#6-1-rebuildSelector0" class="headerlink" title="6.1 rebuildSelector0"></a>6.1 rebuildSelector0</h2><p><code>#rebuildSelector0()</code> 方法，重建 Selector 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildSelector0</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (oldSelector == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 创建新的 Selector 对象</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">final</span> SelectorTuple newSelectorTuple;</span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">try</span> {</span><br><span class="line"><span class="number">10</span>:         newSelectorTuple = openSelector();</span><br><span class="line"><span class="number">11</span>:     } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="number">12</span>:         logger.warn(<span class="string">"Failed to create a new Selector."</span>, e);</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">14</span>:     }</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="comment">// Register all channels to the new Selector.</span></span><br><span class="line"><span class="number">17</span>:     <span class="comment">// 将注册在 NioEventLoop 上的所有 Channel ，注册到新创建 Selector 对象上</span></span><br><span class="line"><span class="number">18</span>:     <span class="keyword">int</span> nChannels = <span class="number">0</span>; <span class="comment">// 计算重新注册成功的 Channel 数量</span></span><br><span class="line"><span class="number">19</span>:     <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) {</span><br><span class="line"><span class="number">20</span>:         Object a = key.attachment();</span><br><span class="line"><span class="number">21</span>:         <span class="keyword">try</span> {</span><br><span class="line"><span class="number">22</span>:             <span class="keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">23</span>:                 <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">24</span>:             }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:             <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line"><span class="number">27</span>:             <span class="comment">// 取消老的 SelectionKey</span></span><br><span class="line"><span class="number">28</span>:             key.cancel();</span><br><span class="line"><span class="number">29</span>:             <span class="comment">// 将 Channel 注册到新的 Selector 对象上</span></span><br><span class="line"><span class="number">30</span>:             SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</span><br><span class="line"><span class="number">31</span>:             <span class="comment">// 修改 Channel 的 selectionKey 指向新的 SelectionKey 上</span></span><br><span class="line"><span class="number">32</span>:             <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) {</span><br><span class="line"><span class="number">33</span>:                 <span class="comment">// Update SelectionKey</span></span><br><span class="line"><span class="number">34</span>:                 ((AbstractNioChannel) a).selectionKey = newKey;</span><br><span class="line"><span class="number">35</span>:             }</span><br><span class="line"><span class="number">36</span>: </span><br><span class="line"><span class="number">37</span>:             <span class="comment">// 计数 ++</span></span><br><span class="line"><span class="number">38</span>:             nChannels ++;</span><br><span class="line"><span class="number">39</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="number">40</span>:             logger.warn(<span class="string">"Failed to re-register a Channel to the new Selector."</span>, e);</span><br><span class="line"><span class="number">41</span>:             <span class="comment">// 关闭发生异常的 Channel</span></span><br><span class="line"><span class="number">42</span>:             <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) {</span><br><span class="line"><span class="number">43</span>:                 AbstractNioChannel ch = (AbstractNioChannel) a;</span><br><span class="line"><span class="number">44</span>:                 ch.unsafe().close(ch.unsafe().voidPromise());</span><br><span class="line"><span class="number">45</span>:             <span class="comment">// 调用 NioTask 的取消注册事件</span></span><br><span class="line"><span class="number">46</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">47</span>:                 <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="number">48</span>:                 NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line"><span class="number">49</span>:                 invokeChannelUnregistered(task, key, e);</span><br><span class="line"><span class="number">50</span>:             }</span><br><span class="line"><span class="number">51</span>:         }</span><br><span class="line"><span class="number">52</span>:     }</span><br><span class="line"><span class="number">53</span>: </span><br><span class="line"><span class="number">54</span>:     <span class="comment">// 修改 selector 和 unwrappedSelector 指向新的 Selector 对象</span></span><br><span class="line"><span class="number">55</span>:     selector = newSelectorTuple.selector;</span><br><span class="line"><span class="number">56</span>:     unwrappedSelector = newSelectorTuple.unwrappedSelector;</span><br><span class="line"><span class="number">57</span>: </span><br><span class="line"><span class="number">58</span>:     <span class="comment">// 关闭老的 Selector 对象</span></span><br><span class="line"><span class="number">59</span>:     <span class="keyword">try</span> {</span><br><span class="line"><span class="number">60</span>:         <span class="comment">// time to close the old selector as everything else is registered to the new one</span></span><br><span class="line"><span class="number">61</span>:         oldSelector.close();</span><br><span class="line"><span class="number">62</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">63</span>:         <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line"><span class="number">64</span>:             logger.warn(<span class="string">"Failed to close the old Selector."</span>, t);</span><br><span class="line"><span class="number">65</span>:         }</span><br><span class="line"><span class="number">66</span>:     }</span><br><span class="line"><span class="number">67</span>: </span><br><span class="line"><span class="number">68</span>:     <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line"><span class="number">69</span>:         logger.info(<span class="string">"Migrated "</span> + nChannels + <span class="string">" channel(s) to the new Selector."</span>);</span><br><span class="line"><span class="number">70</span>:     }</span><br><span class="line"><span class="number">71</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 7 行：调用 <code>#openSelector()</code> 方法，创建新的 Selector 对象。</li>
<li>第 16 至 52 行：遍历<strong>老</strong>的 Selector 对象的 <code>selectionKeys</code> ，将注册在 NioEventLoop 上的所有 Channel ，注册到<strong>新</strong>创建 Selector 对象上。<ul>
<li>第 22 至 24 行：校验 SelectionKey 有效，并且 Java NIO Channel 并未注册在<strong>新</strong>的 Selector 对象上。</li>
<li>第 28 行：调用 <code>SelectionKey#cancel()</code> 方法，取消<strong>老</strong>的 SelectionKey 。</li>
<li>第 30 行：将 Java NIO Channel 注册到<strong>新</strong>的 Selector 对象上，返回<strong>新</strong>的 SelectionKey 对象。</li>
<li>第 31 至 35 行：修改 Channel 的 <code>selectionKey</code> 指向<strong>新</strong>的 SelectionKey 对象</li>
<li>第 39 至 51 行：当发生异常时候，根据不同的 SelectionKey 的 <code>attachment</code> 来判断处理方式：<ul>
<li>第 41 至 44 行：当 <code>attachment</code> 是 Netty NIO Channel 时，调用 <code>Unsafe#close(ChannelPromise promise)</code> 方法，<strong>关闭</strong>发生异常的 Channel 。</li>
<li>第 45 至 50 行：当 <code>attachment</code> 是 Netty NioTask 时，调用 <code>#invokeChannelUnregistered(NioTask&lt;SelectableChannel&gt; task, SelectionKey k, Throwable cause)</code> 方法，通知 Channel 取消注册。详细解析，见 <a href="#">「8. NioTask」</a> 。</li>
</ul>
</li>
</ul>
</li>
<li>第 54 至 56 行：修改 <code>selector</code> 和 <code>unwrappedSelector</code> 指向<strong>新</strong>的 Selector 对象。</li>
<li>第 58 至 66 行：调用 <code>Selector#close()</code> 方法，关闭<strong>老</strong>的 Selector 对象。</li>
</ul>
<p>总的来说，<code>#rebuildSelector()</code> 方法，相比 <code>#openSelector()</code> 方法，主要是需要将老的 Selector 对象的“数据”复制到新的 Selector 对象上，并关闭老的 Selector 对象。</p>
<h1 id="7-processSelectedKeys"><a href="#7-processSelectedKeys" class="headerlink" title="7. processSelectedKeys"></a>7. processSelectedKeys</h1><p>在 <code>#run()</code> 方法中，会调用 <code>#processSelectedKeys()</code> 方法，处理 Channel <strong>新增</strong>就绪的 IO 事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) {</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当 <code>selectedKeys</code> 非空，意味着使用优化的 SelectedSelectionKeySetSelector ，所以调用 <code>#processSelectedKeysOptimized()</code> 方法；否则，调用 <code>#processSelectedKeysPlain()</code> 方法。</li>
</ul>
<h2 id="7-1-processSelectedKeysOptimized"><a href="#7-1-processSelectedKeysOptimized" class="headerlink" title="7.1 processSelectedKeysOptimized"></a>7.1 processSelectedKeysOptimized</h2><p><code>#processSelectedKeysOptimized()</code> 方法，基于 Netty SelectedSelectionKeySetSelector ，处理 Channel <strong>新增</strong>就绪的 IO 事件。代码如下：</p>
<blockquote>
<p>老艿艿：从方法名，我们也可以看出，这是个经过<strong>优化</strong>的实现。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 遍历数组</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// null out entry in the array to allow to have it GC'ed once the Channel close</span></span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line"> <span class="number">7</span>:         selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 处理一个 Channel 就绪的 IO 事件</span></span><br><span class="line"><span class="number">12</span>:         <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) {</span><br><span class="line"><span class="number">13</span>:             processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 使用 NioTask 处理一个 Channel 就绪的 IO 事件</span></span><br><span class="line"><span class="number">15</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">16</span>:             <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="number">17</span>:             NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line"><span class="number">18</span>:             processSelectedKey(k, task);</span><br><span class="line"><span class="number">19</span>:         }</span><br><span class="line"><span class="number">20</span>: </span><br><span class="line"><span class="number">21</span>:         <span class="comment">// TODO 1007 NioEventLoop cancel 方法</span></span><br><span class="line"><span class="number">22</span>:         <span class="keyword">if</span> (needsToSelectAgain) {</span><br><span class="line"><span class="number">23</span>:             <span class="comment">// null out entries in the array to allow to have it GC'ed once the Channel close</span></span><br><span class="line"><span class="number">24</span>:             <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line"><span class="number">25</span>:             selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line"><span class="number">26</span>: </span><br><span class="line"><span class="number">27</span>:             selectAgain();</span><br><span class="line"><span class="number">28</span>:             i = -<span class="number">1</span>;</span><br><span class="line"><span class="number">29</span>:         }</span><br><span class="line"><span class="number">30</span>:     }</span><br><span class="line"><span class="number">31</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：循环 <code>selectedKeys</code> 数组。<ul>
<li>第 4 至 7 行：置空，原因见 <a href="https://github.com/netty/netty/issues/2363" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/netty/netty/issues/2363</a> 。</li>
<li>第 11 至 13 行：当 <code>attachment</code> 是 Netty NIO Channel 时，调用 <code>#processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法，处理一个 Channel 就绪的 IO 事件。详细解析，见 <a href="#">「7.3 processSelectedKey」</a> 。</li>
<li>第 14 至 19 行：当 <code>attachment</code> 是 Netty NioTask 时，调用 <code>#processSelectedKey(SelectionKey k, NioTask&lt;SelectableChannel&gt; task)</code> 方法，使用 NioTask 处理一个 Channel 的 IO 事件。详细解析，见 <a href="#">「8. NioTask」</a> 。</li>
<li>第 21 至 29 行：TODO 1007 NioEventLoop cancel 方法</li>
</ul>
</li>
</ul>
<h2 id="7-2-processSelectedKeysPlain"><a href="#7-2-processSelectedKeysPlain" class="headerlink" title="7.2 processSelectedKeysPlain"></a>7.2 processSelectedKeysPlain</h2><p><code>#processSelectedKeysOptimized()</code> 方法，基于 Java NIO 原生 Selecotr ，处理 Channel <strong>新增</strong>就绪的 IO 事件。代码如下：</p>
<blockquote>
<p>老艿艿：总体和 <code>#processSelectedKeysOptimized()</code> 方法<strong>类似</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysPlain</span><span class="params">(Set&lt;SelectionKey&gt; selectedKeys)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// check if the set is empty and if so just return to not create garbage by</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// creating a new Iterator every time even if there is nothing to process.</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// See https://github.com/netty/netty/issues/597</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (selectedKeys.isEmpty()) {</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>:     }</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// 遍历 SelectionKey 迭代器</span></span><br><span class="line"><span class="number">10</span>:     Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line"><span class="number">11</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 获得 SelectionKey 对象</span></span><br><span class="line"><span class="number">13</span>:         <span class="keyword">final</span> SelectionKey k = i.next();</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 从迭代器中移除</span></span><br><span class="line"><span class="number">15</span>:         i.remove();</span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:         <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 处理一个 Channel 就绪的 IO 事件</span></span><br><span class="line"><span class="number">19</span>:         <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) {</span><br><span class="line"><span class="number">20</span>:             processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line"><span class="number">21</span>:         <span class="comment">// 使用 NioTask 处理一个 Channel 就绪的 IO 事件</span></span><br><span class="line"><span class="number">22</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">23</span>:             <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="number">24</span>:             NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line"><span class="number">25</span>:             processSelectedKey(k, task);</span><br><span class="line"><span class="number">26</span>:         }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:         <span class="comment">// 无下一个节点，结束</span></span><br><span class="line"><span class="number">29</span>:         <span class="keyword">if</span> (!i.hasNext()) {</span><br><span class="line"><span class="number">30</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">31</span>:         }</span><br><span class="line"><span class="number">32</span>: </span><br><span class="line"><span class="number">33</span>:         <span class="comment">// TODO 1007 NioEventLoop cancel 方法</span></span><br><span class="line"><span class="number">34</span>:         <span class="keyword">if</span> (needsToSelectAgain) {</span><br><span class="line"><span class="number">35</span>:             selectAgain();</span><br><span class="line"><span class="number">36</span>:             selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="number">37</span>: </span><br><span class="line"><span class="number">38</span>:             <span class="comment">// Create the iterator again to avoid ConcurrentModificationException</span></span><br><span class="line"><span class="number">39</span>:             <span class="keyword">if</span> (selectedKeys.isEmpty()) {</span><br><span class="line"><span class="number">40</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">41</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">42</span>:                 i = selectedKeys.iterator();</span><br><span class="line"><span class="number">43</span>:             }</span><br><span class="line"><span class="number">44</span>:         }</span><br><span class="line"><span class="number">45</span>:     }</span><br><span class="line"><span class="number">46</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 10 至 11 行：遍历 SelectionKey <strong>迭代器</strong>。<ul>
<li>第 12 至 15 行：获得下一个 SelectionKey 对象，并从迭代器中移除。</li>
<li>第 18 至 20 行：当 <code>attachment</code> 是 Netty NIO Channel 时，调用 <code>#processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法，处理一个 Channel 就绪的 IO 事件。详细解析，见 <a href="#">「7.3 processSelectedKey」</a> 。</li>
<li>第 21 至 26 行：当 <code>attachment</code> 是 Netty NioTask 时，调用 <code>#processSelectedKey(SelectionKey k, NioTask&lt;SelectableChannel&gt; task)</code> 方法，使用 NioTask 处理一个 Channel 的 IO 事件。详细解析，见 <a href="#">「8. NioTask」</a> 。</li>
<li>第 33 至 44 行：TODO 1007 NioEventLoop cancel 方法</li>
</ul>
</li>
</ul>
<h2 id="7-3-processSelectedKey"><a href="#7-3-processSelectedKey" class="headerlink" title="7.3 processSelectedKey"></a>7.3 processSelectedKey</h2><p><code>#processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法，处理一个 Channel 就绪的 IO 事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 如果 SelectionKey 是不合法的，则关闭 Channel</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (!k.isValid()) {</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">7</span>:             eventLoop = ch.eventLoop();</span><br><span class="line"> <span class="number">8</span>:         } <span class="keyword">catch</span> (Throwable ignored) {</span><br><span class="line"> <span class="number">9</span>:             <span class="comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span></span><br><span class="line"><span class="number">10</span>:             <span class="comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span></span><br><span class="line"><span class="number">11</span>:             <span class="comment">// to close ch.</span></span><br><span class="line"><span class="number">12</span>:             <span class="keyword">return</span>;</span><br><span class="line"><span class="number">13</span>:         }</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span></span><br><span class="line"><span class="number">15</span>:         <span class="comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span></span><br><span class="line"><span class="number">16</span>:         <span class="comment">// still healthy and should not be closed.</span></span><br><span class="line"><span class="number">17</span>:         <span class="comment">// See https://github.com/netty/netty/issues/5125</span></span><br><span class="line"><span class="number">18</span>:         <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span>) {</span><br><span class="line"><span class="number">19</span>:             <span class="keyword">return</span>;</span><br><span class="line"><span class="number">20</span>:         }</span><br><span class="line"><span class="number">21</span>:         <span class="comment">// close the channel if the key is not valid anymore</span></span><br><span class="line"><span class="number">22</span>:         unsafe.close(unsafe.voidPromise());</span><br><span class="line"><span class="number">23</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">24</span>:     }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:     <span class="keyword">try</span> {</span><br><span class="line"><span class="number">27</span>:         <span class="comment">// 获得就绪的 IO 事件的 ops</span></span><br><span class="line"><span class="number">28</span>:         <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:         <span class="comment">// OP_CONNECT 事件就绪</span></span><br><span class="line"><span class="number">31</span>:         <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line"><span class="number">32</span>:         <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line"><span class="number">33</span>:         <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) {</span><br><span class="line"><span class="number">34</span>:             <span class="comment">// 移除对 OP_CONNECT 感兴趣</span></span><br><span class="line"><span class="number">35</span>:             <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line"><span class="number">36</span>:             <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line"><span class="number">37</span>:             <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line"><span class="number">38</span>:             ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="number">39</span>:             k.interestOps(ops);</span><br><span class="line"><span class="number">40</span>:             <span class="comment">// 完成连接</span></span><br><span class="line"><span class="number">41</span>:             unsafe.finishConnect();</span><br><span class="line"><span class="number">42</span>:         }</span><br><span class="line"><span class="number">43</span>: </span><br><span class="line"><span class="number">44</span>:         <span class="comment">// OP_WRITE 事件就绪</span></span><br><span class="line"><span class="number">45</span>:         <span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line"><span class="number">46</span>:         <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) {</span><br><span class="line"><span class="number">47</span>:             <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line"><span class="number">48</span>:             <span class="comment">// 向 Channel 写入数据</span></span><br><span class="line"><span class="number">49</span>:             ch.unsafe().forceFlush();</span><br><span class="line"><span class="number">50</span>:         }</span><br><span class="line"><span class="number">51</span>: </span><br><span class="line"><span class="number">52</span>:         <span class="comment">// SelectionKey.OP_READ 或 SelectionKey.OP_ACCEPT 就绪</span></span><br><span class="line"><span class="number">53</span>:         <span class="comment">// readyOps == 0 是对 JDK Bug 的处理，防止空的死循环</span></span><br><span class="line"><span class="number">54</span>:         <span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line"><span class="number">55</span>:         <span class="comment">// to a spin loop</span></span><br><span class="line"><span class="number">56</span>:         <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) {</span><br><span class="line"><span class="number">57</span>:             unsafe.read();</span><br><span class="line"><span class="number">58</span>:         }</span><br><span class="line"><span class="number">59</span>:     } <span class="keyword">catch</span> (CancelledKeyException ignored) {</span><br><span class="line"><span class="number">60</span>:         <span class="comment">// 发生异常，关闭 Channel</span></span><br><span class="line"><span class="number">61</span>:         unsafe.close(unsafe.voidPromise());</span><br><span class="line"><span class="number">62</span>:     }</span><br><span class="line"><span class="number">63</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 24 行：如果 SelectionKey 是不合法的，则关闭 Channel 。</li>
<li>第 30 至 42 行：如果对 <code>OP_CONNECT</code> 事件就绪：<ul>
<li>第 34 至 39 行：移除对 <code>OP_CONNECT</code> 的感兴趣，即不再监听连接事件。</li>
<li>【重要】第 41 行：调用 <code>Unsafe#finishConnect()</code> 方法，完成连接。后续的逻辑，对应 <a href="http://svip.iocoder.cn/Netty/bootstrap-2-client/">《精尽 Netty 源码分析 —— 启动（二）之客户端》</a> 的 <a href="#">「3.6.4 finishConnect」</a> 小节。</li>
</ul>
</li>
<li>第 44 至 50 行：如果对 <code>OP_WRITE</code> 事件就绪，调用 <code>Unsafe#forceFlush()</code> 方法，向 Channel 写入数据。在完成写入数据后，会移除对 <code>OP_WRITE</code> 的感兴趣。想要提前了解的胖友，可以自己看下 <code>AbstractNioByteChannel#clearOpWrite()</code> 和 <code>AbstractNioMessageChannel#doWrite(ChannelOutboundBuffer in)</code> 方法。</li>
<li>第 52 至 58 行：如果对 <code>OP_READ</code> 或 <code>OP_ACCEPT</code> 事件就绪：调用 <code>Unsafe#read()</code> 方法，处理读<strong>或者</strong>者接受客户端连接的事件。</li>
</ul>
<h1 id="8-NioTask"><a href="#8-NioTask" class="headerlink" title="8. NioTask"></a>8. NioTask</h1><p><code>io.netty.channel.nio.NioTask</code> ，用于自定义 Nio 事件处理<strong>接口</strong>。对于每个 Nio 事件，可以认为是一个任务( Task )，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NioTask</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelectableChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the {<span class="doctag">@link</span> SelectableChannel} has been selected by the {<span class="doctag">@link</span> Selector}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReady</span><span class="params">(C ch, SelectionKey key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the {<span class="doctag">@link</span> SelectionKey} of the specified {<span class="doctag">@link</span> SelectableChannel} has been cancelled and thus</span></span><br><span class="line"><span class="comment">     * this {<span class="doctag">@link</span> NioTask} will not be notified anymore.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause the cause of the unregistration. {<span class="doctag">@code</span> null} if a user called {<span class="doctag">@link</span> SelectionKey#cancel()} or</span></span><br><span class="line"><span class="comment">     *              the event loop has been shut down.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(C ch, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#channelReady(C ch, SelectionKey key)</code> 方法，处理 Channel IO 就绪的事件。相当于说，我们可以通过实现该接口方法，实现 <a href="#">「7.3 processSelectedKey」</a> 的逻辑。</li>
<li><code>#channelUnregistered(C ch, Throwable cause)</code> 方法，Channel 取消注册。一般来说，我们可以通过实现该接口方法，关闭 Channel 。</li>
</ul>
<p>😈 实际上，NioTask 在 Netty 自身中并未有相关的实现类，并且和闪电侠沟通了下，他在项目中，也并未使用。所以对 NioTask 不感兴趣的胖友，可以跳过本小节。另外，NioTask 是在 <a href="https://github.com/netty/netty/issues/681" rel="external nofollow noopener noreferrer" target="_blank">Allow a user to access the Selector of an EventLoop</a> 中有相关的讨论。</p>
<h2 id="8-1-register"><a href="#8-1-register" class="headerlink" title="8.1 register"></a>8.1 register</h2><p><code>#register(final SelectableChannel ch, final int interestOps, final NioTask&lt;?&gt; task)</code> 方法，注册 Java NIO Channel ( 不一定需要通过 Netty 创建的 Channel )到 Selector 上，相当于说，也注册到了 EventLoop 上。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an arbitrary {<span class="doctag">@link</span> SelectableChannel}, not necessarily created by Netty, to the {<span class="doctag">@link</span> Selector}</span></span><br><span class="line"><span class="comment"> * of this event loop.  Once the specified {<span class="doctag">@link</span> SelectableChannel} is registered, the specified {<span class="doctag">@code</span> task} will</span></span><br><span class="line"><span class="comment"> * be executed by this event loop when the {<span class="doctag">@link</span> SelectableChannel} is ready.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> SelectableChannel ch, <span class="keyword">final</span> <span class="keyword">int</span> interestOps, <span class="keyword">final</span> NioTask&lt;?&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"ch"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (interestOps == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interestOps must be non-zero."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; ~ch.validOps()) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"invalid interestOps: "</span> + interestOps + <span class="string">"(validOps: "</span> + ch.validOps() + <span class="string">')'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"event loop shut down"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ch.register(selector, interestOps, task);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventLoopException(<span class="string">"failed to register a channel"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>SelectableChannel#register(Selector sel, int ops, Object att)</code> 方法，注册 Java NIO Channel 到 Selector 上。这里我们可以看到，<code>attachment</code> 为 NioTask 对象，而不是 Netty Channel 对象。</li>
</ul>
<h2 id="8-2-invokeChannelUnregistered"><a href="#8-2-invokeChannelUnregistered" class="headerlink" title="8.2 invokeChannelUnregistered"></a>8.2 invokeChannelUnregistered</h2><p><code>#invokeChannelUnregistered(NioTask&lt;SelectableChannel&gt; task, SelectionKey k, Throwable cause)</code> 方法，执行 Channel 取消注册。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelUnregistered</span><span class="params">(NioTask&lt;SelectableChannel&gt; task, SelectionKey k, Throwable cause)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        task.channelUnregistered(k.channel(), cause);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        logger.warn(<span class="string">"Unexpected exception while running NioTask.channelUnregistered()"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，调用 <code>NioTask#channelUnregistered()</code> 方法，执行 Channel 取消注册。</li>
</ul>
<h2 id="8-3-processSelectedKey"><a href="#8-3-processSelectedKey" class="headerlink" title="8.3 processSelectedKey"></a>8.3 processSelectedKey</h2><p><code>#processSelectedKey(SelectionKey k, NioTask&lt;SelectableChannel&gt; task)</code> 方法，使用 NioTask ，自定义实现 Channel 处理 Channel IO 就绪的事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, NioTask&lt;SelectableChannel&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>; <span class="comment">// 未执行</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用 NioTask 的 Channel 就绪事件</span></span><br><span class="line">        task.channelReady(k.channel(), k);</span><br><span class="line">        state = <span class="number">1</span>; <span class="comment">// 执行成功</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// SelectionKey 取消</span></span><br><span class="line">        k.cancel();</span><br><span class="line">        <span class="comment">// 执行 Channel 取消注册</span></span><br><span class="line">        invokeChannelUnregistered(task, k, e);</span><br><span class="line">        state = <span class="number">2</span>; <span class="comment">// 执行异常</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">switch</span> (state) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// SelectionKey 取消</span></span><br><span class="line">            k.cancel();</span><br><span class="line">            <span class="comment">// 执行 Channel 取消注册</span></span><br><span class="line">            invokeChannelUnregistered(task, k, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// SelectionKey 不合法，则执行 Channel 取消注册</span></span><br><span class="line">            <span class="keyword">if</span> (!k.isValid()) { <span class="comment">// Cancelled by channelReady()</span></span><br><span class="line">                invokeChannelUnregistered(task, k, <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看中文注释。主要是看懂 <code>state</code> 有 3 种情况：<ul>
<li><code>0</code> ：未执行。</li>
<li><code>1</code> ：执行成功。</li>
<li><code>2</code> ：执行异常。</li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p> 简单小文一篇，没什么太大难度的一篇。</p>
<p> 如果有不理解的地方，也可以看看下面的文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/467a9b41833e" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之揭开 reactor 线程的面纱（二）》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/d0f06b13e2fb" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析 Netty（四）–EventLoop-2》</a></li>
<li>杨武兵 <a href="https://my.oschina.net/ywbrj042/blog/889748" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析系列 —— EventLoop》</a></li>
<li>占小狼 <a href="https://www.jianshu.com/p/9acf36f7e025" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 NioEventLoop》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-5-EventLoop-handle-io-event/" data-id="ck4pl3fp100dpfgcfaw5kbjtj" class="article-share-link">分享</a>



</footer>
-->
</div>