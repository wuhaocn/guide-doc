<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 ByteBufAllocator（三）PooledByteBufAllocator
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来分享 PooledByteBufAllocator ，基于<strong>内存池</strong>的 ByteBuf 的分配器。而 PooledByteBufAllocator 的内存池，是基于 <strong>Jemalloc</strong> 算法进行分配管理，所以在看本文之前，胖友先跳到 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-1-Jemalloc-intro">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（一）简介》</a> ，将 Jemalloc 相关的<strong>几篇</strong>文章看完，在回到此处。</p>
<h1 id="2-PooledByteBufAllocatorMetric"><a href="#2-PooledByteBufAllocatorMetric" class="headerlink" title="2. PooledByteBufAllocatorMetric"></a>2. PooledByteBufAllocatorMetric</h1><p><code>io.netty.buffer.PooledByteBufAllocatorMetric</code> ，实现 ByteBufAllocatorMetric 接口，PooledByteBufAllocator Metric 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledByteBufAllocatorMetric</span> <span class="keyword">implements</span> <span class="title">ByteBufAllocatorMetric</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PooledByteBufAllocator 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PooledByteBufAllocator allocator;</span><br><span class="line"></span><br><span class="line">    PooledByteBufAllocatorMetric(PooledByteBufAllocator allocator) {</span><br><span class="line">        <span class="keyword">this</span>.allocator = allocator;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of heap arenas.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numHeapArenas</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.numHeapArenas();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of direct arenas.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDirectArenas</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.numDirectArenas();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a {<span class="doctag">@link</span> List} of all heap {<span class="doctag">@link</span> PoolArenaMetric}s that are provided by this pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PoolArenaMetric&gt; <span class="title">heapArenas</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.heapArenas();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a {<span class="doctag">@link</span> List} of all direct {<span class="doctag">@link</span> PoolArenaMetric}s that are provided by this pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PoolArenaMetric&gt; <span class="title">directArenas</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.directArenas();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of thread local caches used by this {<span class="doctag">@link</span> PooledByteBufAllocator}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numThreadLocalCaches</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.numThreadLocalCaches();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the size of the tiny cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tinyCacheSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.tinyCacheSize();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the size of the small cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallCacheSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.smallCacheSize();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the size of the normal cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">normalCacheSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.normalCacheSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the chunk size for an arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chunkSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.chunkSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">usedHeapMemory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.usedHeapMemory();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">usedDirectMemory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> allocator.usedDirectMemory();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        sb.append(StringUtil.simpleClassName(<span class="keyword">this</span>))</span><br><span class="line">                .append(<span class="string">"(usedHeapMemory: "</span>).append(usedHeapMemory())</span><br><span class="line">                .append(<span class="string">"; usedDirectMemory: "</span>).append(usedDirectMemory())</span><br><span class="line">                .append(<span class="string">"; numHeapArenas: "</span>).append(numHeapArenas())</span><br><span class="line">                .append(<span class="string">"; numDirectArenas: "</span>).append(numDirectArenas())</span><br><span class="line">                .append(<span class="string">"; tinyCacheSize: "</span>).append(tinyCacheSize())</span><br><span class="line">                .append(<span class="string">"; smallCacheSize: "</span>).append(smallCacheSize())</span><br><span class="line">                .append(<span class="string">"; normalCacheSize: "</span>).append(normalCacheSize())</span><br><span class="line">                .append(<span class="string">"; numThreadLocalCaches: "</span>).append(numThreadLocalCaches())</span><br><span class="line">                .append(<span class="string">"; chunkSize: "</span>).append(chunkSize()).append(<span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个实现方法，都是调用 <code>allocator</code> 对应的方法。通过 PooledByteBufAllocatorMetric 的封装，可以统一获得 PooledByteBufAllocator Metric 相关的信息。</li>
</ul>
<h1 id="3-PooledByteBufAllocator"><a href="#3-PooledByteBufAllocator" class="headerlink" title="3. PooledByteBufAllocator"></a>3. PooledByteBufAllocator</h1><p><code>io.netty.buffer.PooledByteBufAllocator</code> ，实现 ByteBufAllocatorMetricProvider 接口，实现 AbstractByteBufAllocator 抽象类，基于<strong>内存池</strong>的 ByteBuf 的分配器。</p>
<h2 id="3-1-静态属性"><a href="#3-1-静态属性" class="headerlink" title="3.1 静态属性"></a>3.1 静态属性</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 Heap 类型的 Arena 数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_HEAP_ARENA;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 Direct 类型的 Arena 数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_DIRECT_ARENA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 Page 的内存大小，单位：B 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认配置，8192 B = 8 KB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PAGE_SIZE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> PoolChunk} 满二叉树的高度，默认为 11 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_ORDER; <span class="comment">// 8192 &lt;&lt; 11 = 16 MiB per chunk</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 {<span class="doctag">@link</span> PoolThreadCache} 的 tiny 类型的内存块的缓存数量。默认为 512 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #tinyCacheSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TINY_CACHE_SIZE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 {<span class="doctag">@link</span> PoolThreadCache} 的 small 类型的内存块的缓存数量。默认为 256 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #smallCacheSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SMALL_CACHE_SIZE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 {<span class="doctag">@link</span> PoolThreadCache} 的 normal 类型的内存块的缓存数量。默认为 64 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #normalCacheSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NORMAL_CACHE_SIZE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 {<span class="doctag">@link</span> PoolThreadCache} 缓存的内存块的最大字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CACHED_BUFFER_CAPACITY;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 {<span class="doctag">@link</span> PoolThreadCache}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_TRIM_INTERVAL;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认是否使用 {<span class="doctag">@link</span> PoolThreadCache}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_USE_CACHE_FOR_ALL_THREADS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 Direct 内存对齐基准</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Page 的内存最小值。默认为 4KB = 4096B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 的内存最大值。默认为 1GB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CHUNK_SIZE = (<span class="keyword">int</span>) (((<span class="keyword">long</span>) Integer.MAX_VALUE + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_PAGE_SIZE</span></span><br><span class="line">    <span class="keyword">int</span> defaultPageSize = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.pageSize"</span>, <span class="number">8192</span>);</span><br><span class="line">    Throwable pageSizeFallbackCause = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        validateAndCalculatePageShifts(defaultPageSize);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        pageSizeFallbackCause = t;</span><br><span class="line">        defaultPageSize = <span class="number">8192</span>;</span><br><span class="line">    }</span><br><span class="line">    DEFAULT_PAGE_SIZE = defaultPageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_MAX_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> defaultMaxOrder = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.maxOrder"</span>, <span class="number">11</span>);</span><br><span class="line">    Throwable maxOrderFallbackCause = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        validateAndCalculateChunkSize(DEFAULT_PAGE_SIZE, defaultMaxOrder);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        maxOrderFallbackCause = t;</span><br><span class="line">        defaultMaxOrder = <span class="number">11</span>;</span><br><span class="line">    }</span><br><span class="line">    DEFAULT_MAX_ORDER = defaultMaxOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine reasonable default for nHeapArena and nDirectArena.</span></span><br><span class="line">    <span class="comment">// Assuming each arena has 3 chunks, the pool should not consume more than 50% of max memory.</span></span><br><span class="line">    <span class="keyword">final</span> Runtime runtime = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We use 2 * available processors by default to reduce contention as we use 2 * available processors for the</span></span><br><span class="line"><span class="comment">     * number of EventLoops in NIO and EPOLL as well. If we choose a smaller number we will run into hot spots as</span></span><br><span class="line"><span class="comment">     * allocation and de-allocation needs to be synchronized on the PoolArena.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * See https://github.com/netty/netty/issues/3888.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 默认最小 Arena 个数。为什么这样计算，见上面的英文注释，大体的思路是，一个 EventLoop 一个 Arena ，避免多线程竞争。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultMinNumArena = NettyRuntime.availableProcessors() * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化默认 Chunk 的内存大小。默认值为 8192 &lt;&lt; 11 = 16 MiB per chunk</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultChunkSize = DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER;</span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_NUM_HEAP_ARENA</span></span><br><span class="line">    DEFAULT_NUM_HEAP_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">            SystemPropertyUtil.getInt(</span><br><span class="line">                    <span class="string">"io.netty.allocator.numHeapArenas"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                            defaultMinNumArena,</span><br><span class="line">                            runtime.maxMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>))); <span class="comment">// `/ 2` 是为了不超过内存的一半，`/ 3` 是为了每个 Arena 有三个 Chunk</span></span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_NUM_DIRECT_ARENA</span></span><br><span class="line">    DEFAULT_NUM_DIRECT_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">            SystemPropertyUtil.getInt(</span><br><span class="line">                    <span class="string">"io.netty.allocator.numDirectArenas"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                            defaultMinNumArena,</span><br><span class="line">                            PlatformDependent.maxDirectMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache sizes</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 初始化 DEFAULT_TINY_CACHE_SIZE</span></span><br><span class="line">    DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.tinyCacheSize"</span>, <span class="number">512</span>);</span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_SMALL_CACHE_SIZE</span></span><br><span class="line">    DEFAULT_SMALL_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.smallCacheSize"</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_NORMAL_CACHE_SIZE</span></span><br><span class="line">    DEFAULT_NORMAL_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.normalCacheSize"</span>, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_MAX_CACHED_BUFFER_CAPACITY</span></span><br><span class="line">    <span class="comment">// 32 kb is the default maximum capacity of the cached buffer. Similar to what is explained in</span></span><br><span class="line">    <span class="comment">// 'Scalable memory allocation using jemalloc'</span></span><br><span class="line">    DEFAULT_MAX_CACHED_BUFFER_CAPACITY = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.maxCachedBufferCapacity"</span>, <span class="number">32</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_CACHE_TRIM_INTERVAL</span></span><br><span class="line">    <span class="comment">// the number of threshold of allocations when cached entries will be freed up if not frequently used</span></span><br><span class="line">    DEFAULT_CACHE_TRIM_INTERVAL = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.cacheTrimInterval"</span>, <span class="number">8192</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_USE_CACHE_FOR_ALL_THREADS</span></span><br><span class="line">    DEFAULT_USE_CACHE_FOR_ALL_THREADS = SystemPropertyUtil.getBoolean(<span class="string">"io.netty.allocator.useCacheForAllThreads"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT</span></span><br><span class="line">    DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT = SystemPropertyUtil.getInt(<span class="string">"io.netty.allocator.directMemoryCacheAlignment"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印调试日志( 省略... )</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>静态变量有点多，主要是为 PoolThreadCache 做的<strong>默认</strong>配置项。读过 <a href="精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache》</a> 的胖友，是不是灰常熟悉。</li>
<li>比较有意思的是，<code>DEFAULT_NUM_HEAP_ARENA</code> 和 <code>DEFAULT_NUM_DIRECT_ARENA</code> 变量的初始化，在 <code>&lt;1&gt;</code> 处。<ul>
<li>默认情况下，最小值是 <code>NettyRuntime.availableProcessors() * 2</code> ，也就是 CPU 线程数。这样的好处是， 一个 EventLoop 一个 Arena ，<strong>避免多线程竞争</strong>。更多的讨论，胖友可以看看 <a href="https://github.com/netty/netty/issues/3888" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/netty/netty/issues/3888</a> 。</li>
<li>比较有趣的一段是 <code>runtime.maxMemory() / defaultChunkSize / 2 / 3</code> 代码块。其中，<code>/ 2</code> 是为了保证 Arena 不超过内存的一半，而 <code>/ 3</code> 是为了每个 Arena 有三个 Chunk 。</li>
<li>当然最终取值是上述两值的最小值。所以在推荐上，尽可能配置的内存，能够保证 <code>defaultMinNumArena</code> 。因为<strong>要避免多线程竞争</strong>。</li>
</ul>
</li>
</ul>
<h2 id="3-2-validateAndCalculatePageShifts"><a href="#3-2-validateAndCalculatePageShifts" class="headerlink" title="3.2 validateAndCalculatePageShifts"></a>3.2 validateAndCalculatePageShifts</h2><p><code>#validateAndCalculatePageShifts(int pageSize)</code> 方法，校验 <code>pageSize</code> 参数，并计算 <code>pageShift</code> 值。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validateAndCalculatePageShifts</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">if</span> (pageSize &lt; MIN_PAGE_SIZE) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"pageSize: "</span> + pageSize + <span class="string">" (expected: "</span> + MIN_PAGE_SIZE + <span class="string">")"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 校验 Page 的内存大小，必须是 2 的指数级</span></span><br><span class="line">    <span class="keyword">if</span> ((pageSize &amp; pageSize - <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"pageSize: "</span> + pageSize + <span class="string">" (expected: power of 2)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 pageShift</span></span><br><span class="line">    <span class="comment">// Logarithm base 2. At this point we know that pageSize is a power of two.</span></span><br><span class="line">    <span class="keyword">return</span> Integer.SIZE - <span class="number">1</span> - Integer.numberOfLeadingZeros(pageSize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认情况下，<code>pageSize = 8KB = 8 * 1024= 8096</code> ，<code>pageShift = 8192</code> 。</li>
</ul>
<h2 id="3-3-validateAndCalculateChunkSize"><a href="#3-3-validateAndCalculateChunkSize" class="headerlink" title="3.3 validateAndCalculateChunkSize"></a>3.3 validateAndCalculateChunkSize</h2><p><code>#validateAndCalculateChunkSize(int pageSize, int maxOrder)</code> 方法，校验 <code>maxOrder</code> 参数，并计算 <code>chunkSize</code> 值。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validateAndCalculateChunkSize</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (maxOrder &gt; <span class="number">14</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxOrder: "</span> + maxOrder + <span class="string">" (expected: 0-14)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 chunkSize</span></span><br><span class="line">    <span class="comment">// Ensure the resulting chunkSize does not overflow.</span></span><br><span class="line">    <span class="keyword">int</span> chunkSize = pageSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxOrder; i &gt; <span class="number">0</span>; i --) {</span><br><span class="line">        <span class="keyword">if</span> (chunkSize &gt; MAX_CHUNK_SIZE / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"pageSize (%d) &lt;&lt; maxOrder (%d) must not exceed %d"</span>, pageSize, maxOrder, MAX_CHUNK_SIZE));</span><br><span class="line">        }</span><br><span class="line">        chunkSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> chunkSize;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-4-构造方法"><a href="#3-4-构造方法" class="headerlink" title="3.4 构造方法"></a>3.4 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PooledByteBufAllocator DEFAULT = <span class="keyword">new</span> PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heap PoolArena 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt;[] heapArenas;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Direct PoolArena 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt;[] directArenas;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> PoolThreadCache} 的 tiny 内存块缓存数组的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> tinyCacheSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> PoolThreadCache} 的 small 内存块缓存数组的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> smallCacheSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> PoolThreadCache} 的 normal 内存块缓存数组的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> normalCacheSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolArenaMetric 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolArenaMetric&gt; heapArenaMetrics;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolArenaMetric 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolArenaMetric&gt; directArenaMetrics;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程变量，用于获得 PoolThreadCache 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolThreadLocalCache threadCache;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PooledByteBufAllocatorMetric 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PooledByteBufAllocatorMetric metric;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, DEFAULT_NUM_HEAP_ARENA, DEFAULT_NUM_DIRECT_ARENA, DEFAULT_PAGE_SIZE, DEFAULT_MAX_ORDER);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, nHeapArena, nDirectArena, pageSize, maxOrder);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> use</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> PooledByteBufAllocator#PooledByteBufAllocator(boolean, int, int, int, int, int, int, int, boolean)}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder,</span><br><span class="line">            DEFAULT_TINY_CACHE_SIZE, DEFAULT_SMALL_CACHE_SIZE, DEFAULT_NORMAL_CACHE_SIZE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> use</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> PooledByteBufAllocator#PooledByteBufAllocator(boolean, int, int, int, int, int, int, int, boolean)}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder, tinyCacheSize, smallCacheSize,</span><br><span class="line">            normalCacheSize, DEFAULT_USE_CACHE_FOR_ALL_THREADS, DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> tinyCacheSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> useCacheForAllThreads)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder,</span><br><span class="line">            tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">            useCacheForAllThreads, DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> useCacheForAllThreads, <span class="keyword">int</span> directMemoryCacheAlignment)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);</span><br><span class="line">    <span class="comment">// 创建 PoolThreadLocalCache 对象</span></span><br><span class="line">    threadCache = <span class="keyword">new</span> PoolThreadLocalCache(useCacheForAllThreads);</span><br><span class="line">    <span class="keyword">this</span>.tinyCacheSize = tinyCacheSize;</span><br><span class="line">    <span class="keyword">this</span>.smallCacheSize = smallCacheSize;</span><br><span class="line">    <span class="keyword">this</span>.normalCacheSize = normalCacheSize;</span><br><span class="line">    <span class="comment">// 计算 chunkSize</span></span><br><span class="line">    chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nHeapArena &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nHeapArena: "</span> + nHeapArena + <span class="string">" (expected: &gt;= 0)"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (nDirectArena &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nDirectArea: "</span> + nDirectArena + <span class="string">" (expected: &gt;= 0)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (directMemoryCacheAlignment &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"directMemoryCacheAlignment: "</span></span><br><span class="line">                + directMemoryCacheAlignment + <span class="string">" (expected: &gt;= 0)"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (directMemoryCacheAlignment &gt; <span class="number">0</span> &amp;&amp; !isDirectMemoryCacheAlignmentSupported()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"directMemoryCacheAlignment is not supported"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((directMemoryCacheAlignment &amp; -directMemoryCacheAlignment) != directMemoryCacheAlignment) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"directMemoryCacheAlignment: "</span></span><br><span class="line">                + directMemoryCacheAlignment + <span class="string">" (expected: power of two)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pageShifts = validateAndCalculatePageShifts(pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nHeapArena &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 创建 heapArenas 数组</span></span><br><span class="line">        heapArenas = newArenaArray(nHeapArena);</span><br><span class="line">        <span class="comment">// 创建 metrics 数组</span></span><br><span class="line">        List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(heapArenas.length);</span><br><span class="line">        <span class="comment">// 初始化 heapArenas 和  metrics 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapArenas.length; i ++) {</span><br><span class="line">            <span class="comment">// 创建 HeapArena 对象</span></span><br><span class="line">            PoolArena.HeapArena arena = <span class="keyword">new</span> PoolArena.HeapArena(<span class="keyword">this</span>,</span><br><span class="line">                    pageSize, maxOrder, pageShifts, chunkSize,</span><br><span class="line">                    directMemoryCacheAlignment);</span><br><span class="line">            heapArenas[i] = arena;</span><br><span class="line">            metrics.add(arena);</span><br><span class="line">        }</span><br><span class="line">        heapArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        heapArenas = <span class="keyword">null</span>;</span><br><span class="line">        heapArenaMetrics = Collections.emptyList();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nDirectArena &gt; <span class="number">0</span>) {</span><br><span class="line">        directArenas = newArenaArray(nDirectArena);</span><br><span class="line">        List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(directArenas.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directArenas.length; i ++) {</span><br><span class="line">            PoolArena.DirectArena arena = <span class="keyword">new</span> PoolArena.DirectArena(</span><br><span class="line">                    <span class="keyword">this</span>, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);</span><br><span class="line">            directArenas[i] = arena;</span><br><span class="line">            metrics.add(arena);</span><br><span class="line">        }</span><br><span class="line">        directArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        directArenas = <span class="keyword">null</span>;</span><br><span class="line">        directArenaMetrics = Collections.emptyList();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建 PooledByteBufAllocatorMetric</span></span><br><span class="line">    metric = <span class="keyword">new</span> PooledByteBufAllocatorMetric(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>orz 代码比较长，主要是构造方法和校验代码比较长。胖友自己耐心看下。笔者下面只重点讲几个属性。</li>
<li><code>DEFAULT</code> <strong>静态</strong>属性，PooledByteBufAllocator 单例。绝绝绝大多数情况下，我们不需要自己创建 PooledByteBufAllocator 对象，而只要使用该单例即可。</li>
<li><code>threadCache</code> 属性，<strong>线程变量</strong>，用于获得 PoolThreadCache 对象。通过该属性，不同线程虽然使用<strong>相同</strong>的 <code>DEFAULT</code> 单例，但是可以获得<strong>不同</strong>的 PoolThreadCache 对象。关于 PoolThreadLocalCache 的详细解析，见 <a href="#">「4. PoolThreadLocalCache」</a> 中。</li>
<li><p><code>#newArenaArray(int size)</code> 方法，创建 PoolArena 数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; PoolArena&lt;T&gt;[] newArenaArray(<span class="keyword">int</span> size) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolArena[size];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="3-5-newHeapBuffer"><a href="#3-5-newHeapBuffer" class="headerlink" title="3.5 newHeapBuffer"></a>3.5 newHeapBuffer</h2><p><code>#newHeapBuffer(int initialCapacity, int maxCapacity)</code> 方法，创建 Heap ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得线程的 PoolThreadCache 对象</span></span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = cache.heapArena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;2.1&gt; 从 heapArena 中，分配 Heap PooledByteBuf 对象，基于池化</span></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) {</span><br><span class="line">        buf = heapArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    <span class="comment">// &lt;2.2&gt; 直接创建 Heap ByteBuf 对象，基于非池化</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                <span class="keyword">new</span> UnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> UnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt; 将 ByteBuf 装饰成 LeakAware ( 可检测内存泄露 )的 ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较易懂，胖友自己看代码注释。</li>
</ul>
<h2 id="3-6-newDirectBuffer"><a href="#3-6-newDirectBuffer" class="headerlink" title="3.6 newDirectBuffer"></a>3.6 newDirectBuffer</h2><p><code>#newDirectBuffer(int initialCapacity, int maxCapacity)</code> 方法，创建 Direct ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得线程的 PoolThreadCache 对象</span></span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="comment">// &lt;2.1&gt; 从 directArena 中，分配 Direct PooledByteBuf 对象，基于池化</span></span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) {</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    <span class="comment">// &lt;2.2&gt; 直接创建 Direct ByteBuf 对象，基于非池化</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt; 将 ByteBuf 装饰成 LeakAware ( 可检测内存泄露 )的 ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较易懂，胖友自己看代码注释。</li>
</ul>
<h2 id="3-6-其它方法"><a href="#3-6-其它方法" class="headerlink" title="3.6 其它方法"></a>3.6 其它方法</h2><p>其它方法，主要是 Metric 相关操作为主。这里就不再多做哔哔啦，胖友自己感兴趣的话，可以翻翻噢。</p>
<h1 id="4-PoolThreadLocalCache"><a href="#4-PoolThreadLocalCache" class="headerlink" title="4. PoolThreadLocalCache"></a>4. PoolThreadLocalCache</h1><p>PoolThreadLocalCache ，是 PooledByteBufAllocator 的内部类。继承 FastThreadLocal 抽象类，PoolThreadCache <strong>ThreadLocal</strong> 类。</p>
<h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否使用缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCacheForAllThreads;</span><br><span class="line"></span><br><span class="line">PoolThreadLocalCache(<span class="keyword">boolean</span> useCacheForAllThreads) {</span><br><span class="line">    <span class="keyword">this</span>.useCacheForAllThreads = useCacheForAllThreads;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-2-leastUsedArena"><a href="#4-2-leastUsedArena" class="headerlink" title="4.2 leastUsedArena"></a>4.2 leastUsedArena</h2><p><code>#leastUsedArena(PoolArena&lt;T&gt;[] arenas)</code> 方法，从 PoolArena 数组中，获取线程使用最少的 PoolArena 对象，基于 <code>PoolArena.numThreadCaches</code> 属性。通过这样的方式，尽可能让 PoolArena 平均分布在不同线程，从而尽肯能避免线程的<strong>同步和竞争</strong>问题。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">PoolArena&lt;T&gt; <span class="title">leastUsedArena</span><span class="params">(PoolArena&lt;T&gt;[] arenas)</span> </span>{</span><br><span class="line">    <span class="comment">// 一个都没有，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (arenas == <span class="keyword">null</span> || arenas.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得第零个 PoolArena 对象</span></span><br><span class="line">    PoolArena&lt;T&gt; minArena = arenas[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 比较后面的 PoolArena 对象，选择线程使用最少的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arenas.length; i++) {</span><br><span class="line">        PoolArena&lt;T&gt; arena = arenas[i];</span><br><span class="line">        <span class="keyword">if</span> (arena.numThreadCaches.get() &lt; minArena.numThreadCaches.get()) {</span><br><span class="line">            minArena = arena;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minArena;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-3-initialValue"><a href="#4-3-initialValue" class="headerlink" title="4.3 initialValue"></a>4.3 initialValue</h2><p><code>#initialValue()</code> 方法，初始化线程的 PoolThreadCache 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> PoolThreadCache <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 分别获取线程使用最少的 heapArena 和 directArena 对象，基于 `PoolArena.numThreadCaches` 属性。</span></span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建开启缓存的 PoolThreadCache 对象</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (useCacheForAllThreads || current <span class="keyword">instanceof</span> FastThreadLocalThread) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(</span><br><span class="line">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建不进行缓存的 PoolThreadCache 对象</span></span><br><span class="line">    <span class="comment">// No caching so just use 0 as sizes.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(heapArena, directArena, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-4-onRemoval"><a href="#4-4-onRemoval" class="headerlink" title="4.4 onRemoval"></a>4.4 onRemoval</h2><p><code>#onRemoval(PoolThreadCache threadCache)</code> 方法，释放 PoolThreadCache 对象的缓存。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(PoolThreadCache threadCache)</span> </span>{</span><br><span class="line">    <span class="comment">// 释放缓存</span></span><br><span class="line">    threadCache.free();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>推荐阅读文章：</p>
<ul>
<li>杨武兵 <a href="https://my.oschina.net/ywbrj042/blog/909925" rel="external nofollow noopener noreferrer" target="_blank">《netty源码分析系列——PooledByteBuf&amp;PooledByteBufAllocator》</a></li>
<li>wojiushimogui <a href="https://blog.csdn.net/u010412719/article/details/78298811" rel="external nofollow noopener noreferrer" target="_blank">《Netty源码分析：PooledByteBufAllocator》</a></li>
<li>RobertoHuang <a href="https://blog.csdn.net/RobertoHuang/article/details/81046419" rel="external nofollow noopener noreferrer" target="_blank">《死磕Netty源码之内存分配详解(一)(PooledByteBufAllocator)》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-2-3-ByteBufAllocator-pooled/" data-id="ck4pl3fp500e1fgcf9lqj6mzl" class="article-share-link">分享</a>



</footer>
-->
</div>