<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Util 之 Recycler
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<p>笔者先把 Netty 主要的内容写完，所以关于 Recycler 的分享，先放在后续的计划里。</p>
<blockquote>
<p>老艿艿：其实是因为，自己想去研究下 Service Mesh ，所以先简单收个小尾。</p>
</blockquote>
<p>当然，良心如我，还是为对这块感兴趣的胖友，先准备好了一篇不错的文章：</p>
<ul>
<li>沧行 <a href="https://www.jianshu.com/p/4eab8450560c" rel="external nofollow noopener noreferrer" target="_blank">《Netty之Recycler》</a></li>
</ul>
<p>为避免可能 <a href="https://www.jianshu.com/p/4eab8450560c" rel="external nofollow noopener noreferrer" target="_blank">《Netty之Recycler》</a> 被作者删除，笔者这里先复制一份作为备份。</p>
<h1 id="666-备份"><a href="#666-备份" class="headerlink" title="666. 备份"></a>666. 备份</h1><p>Recycler用来实现对象池，其中对应堆内存和直接内存的池化实现分别是PooledHeapByteBuf和PooledDirectByteBuf。Recycler主要提供了3个方法：</p>
<ul>
<li>get():获取一个对象。</li>
<li>recycle(T, Handle):回收一个对象，T为对象泛型。</li>
<li>newObject(Handle):当没有可用对象时创建对象的实现方法。</li>
</ul>
<p>Recycler的UML图如下：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/3751588-916c6baab07fa863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/jpeg" title="img" class="fancybox" rel="article0"><img src="https:////upload-images.jianshu.io/upload_images/3751588-916c6baab07fa863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/jpeg" alt="img"></a><span class="caption">img</span></p>
<p>Recycler.png</p>
<p>Recycler关联了4个核心类：</p>
<ul>
<li>DefaultHandle:对象的包装类，在Recycler中缓存的对象都会包装成DefaultHandle类。</li>
<li>Stack:存储本线程回收的对象。对象的获取和回收对应Stack的pop和push，即获取对象时从Stack中pop出1个DefaultHandle，回收对象时将对象包装成DefaultHandle push到Stack中。Stack会与线程绑定，即每个用到Recycler的线程都会拥有1个Stack，在该线程中获取对象都是在该线程的Stack中pop出一个可用对象。</li>
<li>WeakOrderQueue:存储其它线程回收到本线程stack的对象，当某个线程从Stack中获取不到对象时会从WeakOrderQueue中获取对象。每个线程的Stack拥有1个WeakOrderQueue链表，链表每个节点对应1个其它线程的WeakOrderQueue，其它线程回收到该Stack的对象就存储在这个WeakOrderQueue里。</li>
<li>Link: WeakOrderQueue中包含1个Link链表，回收对象存储在链表某个Link节点里，当Link节点存储的回收对象满了时会新建1个Link放在Link链表尾。</li>
</ul>
<p>整个Recycler回收对象存储结构如下图所示：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/3751588-63236f0c4e59328d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/799/format/jpeg" title="img" class="fancybox" rel="article0"><img src="https:////upload-images.jianshu.io/upload_images/3751588-63236f0c4e59328d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/799/format/jpeg" alt="img"></a><span class="caption">img</span></p>
<p>Recycler.png</p>
<p>下面分析下源码，首先看下Recycler.recycle(T, Handle)方法，用于回收1个对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">recycle</span><span class="params">(T o, Handle handle)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (handle == NOOP_HANDLE) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    DefaultHandle h = (DefaultHandle) handle;</span><br><span class="line">    <span class="keyword">if</span> (h.stack.parent != <span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (o != h.value) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"o does not belong to handle"</span>);</span><br><span class="line">    }</span><br><span class="line">    h.recycle();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>回收1个对象会调用该对象DefaultHandle.recycle()方法，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>{</span><br><span class="line">   stack.push(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>回收1个对象（DefaultHandle）就是把该对象push到stack中。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle item)</span> </span>{</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread == currentThread) {</span><br><span class="line">            <span class="comment">// The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果该stack就是本线程的stack，那么直接把DefaultHandle放到该stack的数组里</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pushNow(item);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// The current Thread is not the one that belongs to the Stack, we need to signal that the push</span></span><br><span class="line">            <span class="comment">// happens later.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果该stack不是本线程的stack，那么把该DefaultHandle放到该stack的WeakOrderQueue中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pushLater(item, currentThread);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>这里分为两种情况，当stack是当前线程对应的stack时，执行pushNow(item)方法，直接把对象放到该stack的DefaultHandle数组中，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接把DefaultHandle放到stack的数组里，如果数组满了那么扩展该数组为当前2倍大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle item)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">    }</span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) {</span><br><span class="line">        <span class="comment">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) {</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当stack是其它线程的stack时，执行pushLater(item, currentThread)方法，将对象放到WeakOrderQueue中，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle item, Thread thread)</span> </span>{</span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * Recycler有1个stack-&gt;WeakOrderQueue映射，每个stack会映射到1个WeakOrderQueue，这个WeakOrderQueue是该stack关联的其它线程WeakOrderQueue链表的head WeakOrderQueue。</span></span><br><span class="line"><span class="comment">        * 当其它线程回收对象到该stack时会创建1个WeakOrderQueue中并加到stack的WeakOrderQueue链表中。 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">        WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果delayedRecycled满了那么将1个伪造的WeakOrderQueue（DUMMY）放到delayedRecycled中，并丢弃该对象（DefaultHandle）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) {</span><br><span class="line">                <span class="comment">// Add a dummy queue so we know we should drop the object</span></span><br><span class="line">                delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Check if we already reached the maximum number of delayed queues and if we can allocate at all.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建1个WeakOrderQueue</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// drop object</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) {</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将对象放入到该stack对应的WeakOrderQueue中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue.add(item);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">allocate</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>{</span><br><span class="line">        <span class="comment">// We allocated a Link so reserve the space</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果该stack的可用共享空间还能再容下1个WeakOrderQueue，那么创建1个WeakOrderQueue，否则返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> reserveSpace(stack.availableSharedCapacity, LINK_CAPACITY)</span><br><span class="line">                ? <span class="keyword">new</span> WeakOrderQueue(stack, thread) : <span class="keyword">null</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>WeakOrderQueue的构造函数如下，WeakOrderQueue实现了多线程环境下回收对象的机制，当由其它线程回收对象到stack时会为该stack创建1个WeakOrderQueue，这些由其它线程创建的WeakOrderQueue会在该stack中按链表形式串联起来，每次创建1个WeakOrderQueue会把该WeakOrderQueue作为该stack的head WeakOrderQueue：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WeakOrderQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>{</span><br><span class="line">        head = tail = <span class="keyword">new</span> Link();</span><br><span class="line">        owner = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每次创建WeakOrderQueue时会更新WeakOrderQueue所属的stack的head为当前WeakOrderQueue， 当前WeakOrderQueue的next为stack的之前head，</span></span><br><span class="line"><span class="comment">         * 这样把该stack的WeakOrderQueue通过链表串起来了，当下次stack中没有可用对象需要从WeakOrderQueue中转移对象时从WeakOrderQueue链表的head进行scavenge转移到stack的对DefaultHandle数组。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (stack) {</span><br><span class="line">            next = stack.head;</span><br><span class="line">            stack.head = <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">        availableSharedCapacity = stack.availableSharedCapacity;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>下面再看Recycler.get()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (maxCapacity == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> newObject(NOOP_HANDLE);</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    DefaultHandle handle = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) {</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>取出该线程对应的stack，从stack中pop出1个DefaultHandle，返回该DefaultHandle的真正对象。<br> 下面看stack.pop()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">DefaultHandle <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!scavenge()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            size = <span class="keyword">this</span>.size;</span><br><span class="line">        }</span><br><span class="line">        size --;</span><br><span class="line">        DefaultHandle ret = elements[size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled multiple times"</span>);</span><br><span class="line">        }</span><br><span class="line">        ret.recycleId = <span class="number">0</span>;</span><br><span class="line">        ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>如果该stack的DefaultHandle数组中还有对象可用，那么从该DefaultHandle数组中取出1个可用对象返回，如果该DefaultHandle数组没有可用的对象了，那么执行scavenge()方法，将head WeakOrderQueue中的head Link中的DefaultHandle数组转移到stack的DefaultHandle数组，scavenge方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavenge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// continue an existing scavenge, if any</span></span><br><span class="line">        <span class="keyword">if</span> (scavengeSome()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset our scavenge cursor</span></span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>具体执行了scavengeSome()方法，清理WeakOrderQueue中部分DefaultHandle到stack，每次尽可能清理head WeakOrderQueue的head Link的全部DefaultHandle，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>{</span><br><span class="line">        WeakOrderQueue cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) {</span><br><span class="line">            cursor = head;</span><br><span class="line">            <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        WeakOrderQueue prev = <span class="keyword">this</span>.prev;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将当前WeakOrderQueue的head Link的DefaultHandle数组转移到stack的DefaultHandle数组中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) {</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            WeakOrderQueue next = cursor.next;</span><br><span class="line">            <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (cursor.hasFinalData()) {</span><br><span class="line">                    <span class="keyword">for</span> (;;) {</span><br><span class="line">                        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) {</span><br><span class="line">                            success = <span class="keyword">true</span>;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) {</span><br><span class="line">                    prev.next = next;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                prev = cursor;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cursor = next;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>WeakOrderQueue.transfer()方法如下，将WeakOrderQueue的head Link中的DefaultHandle数组迁移到stack中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(Stack&lt;?&gt; dst)</span> </span>{</span><br><span class="line">        Link head = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果head Link的readIndex到达了Link的容量LINK_CAPACITY，说明该Link已经被scavengge完了。</span></span><br><span class="line"><span class="comment">         * 这时需要把下一个Link作为新的head Link。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (head.readIndex == LINK_CAPACITY) {</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.head = head = head.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> srcStart = head.readIndex;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * head Link的回收对象数组的最大位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> srcEnd = head.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * head Link可以scavenge的DefaultHandle的数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> srcSize = srcEnd - srcStart;</span><br><span class="line">        <span class="keyword">if</span> (srcSize == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dstSize = dst.size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每次会尽可能scavenge整个head Link，如果head Link的DefaultHandle数组能全部迁移到stack中，stack的DefaultHandle数组预期容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedCapacity = dstSize + srcSize;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果预期容量大于stack的DefaultHandle数组最大长度，说明本次无法将head Link的DefaultHandle数组全部迁移到stack中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (expectedCapacity &gt; dst.elements.length) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actualCapacity = dst.increaseCapacity(expectedCapacity);</span><br><span class="line">            srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (srcStart != srcEnd) {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * head Link的DefaultHandle数组</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> DefaultHandle[] srcElems = head.elements;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * stack的DefaultHandle数组</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> DefaultHandle[] dstElems = dst.elements;</span><br><span class="line">            <span class="keyword">int</span> newDstSize = dstSize;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 迁移head Link的DefaultHandle数组到stack的DefaultHandle数组</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = srcStart; i &lt; srcEnd; i++) {</span><br><span class="line">                DefaultHandle element = srcElems[i];</span><br><span class="line">                <span class="keyword">if</span> (element.recycleId == <span class="number">0</span>) {</span><br><span class="line">                    element.recycleId = element.lastRecycledId;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (element.recycleId != element.lastRecycledId) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">                }</span><br><span class="line">                srcElems[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dst.dropHandle(element)) {</span><br><span class="line">                    <span class="comment">// Drop the object.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                element.stack = dst;</span><br><span class="line">                dstElems[newDstSize ++] = element;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当head节点的对象全都转移给stack后，取head下一个节点作为head，下次转移的时候再从新的head转移回收的对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (srcEnd == LINK_CAPACITY &amp;&amp; head.next != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// Add capacity back as the Link is GCed.</span></span><br><span class="line">                reclaimSpace(LINK_CAPACITY);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.head = head.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 迁移完成后更新原始head Link的readIndex</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            head.readIndex = srcEnd;</span><br><span class="line">            <span class="keyword">if</span> (dst.size == newDstSize) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            dst.size = newDstSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// The destination stack is full already.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Util-3-Recycler/" data-id="ck4pl3fpg00epfgcfx4duqjm6" class="article-share-link">分享</a>



</footer>
-->
</div>