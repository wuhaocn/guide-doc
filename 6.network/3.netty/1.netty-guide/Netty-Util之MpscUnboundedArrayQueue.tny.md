<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Util 之 MpscUnboundedArrayQueue
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<p>笔者先把 Netty 主要的内容写完，所以关于 MpscUnboundedArrayQueue 的分享，先放在后续的计划里。</p>
<blockquote>
<p>老艿艿：其实是因为，自己想去研究下 Service Mesh ，所以先简单收个小尾。</p>
</blockquote>
<p>当然，良心如我，还是为对这块感兴趣的胖友，先准备好了一篇不错的文章：</p>
<ul>
<li>HMILYYLIMH <a href="https://www.jianshu.com/p/119a03332619" rel="external nofollow noopener noreferrer" target="_blank">《原理剖析（第 012 篇）Netty之无锁队列MpscUnboundedArrayQueue原理分析》</a></li>
</ul>
<p>为避免可能 <a href="https://www.jianshu.com/p/119a03332619" rel="external nofollow noopener noreferrer" target="_blank">《原理剖析（第 012 篇）Netty之无锁队列MpscUnboundedArrayQueue原理分析》</a> 被作者删除，笔者这里先复制一份作为备份。</p>
<h1 id="666-备份"><a href="#666-备份" class="headerlink" title="666. 备份"></a>666. 备份</h1><h2 id="一、大致介绍"><a href="#一、大致介绍" class="headerlink" title="一、大致介绍"></a>一、大致介绍</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、了解过netty原理的童鞋，其实应该知道工作线程组的每个子线程都维护了一个任务队列；</span><br><span class="line">2、细心的童鞋会发现netty的队列是重写了队列的实现方法，覆盖了父类中的LinkedBlockingQueue队列，但是如今却换成了JCTools的一些并发队列，因为JCTools是一款对jdk并发数据结构进行增强的并发工具；</span><br><span class="line">3、那么问题就来了，现在的netty要用新的队列呢？难道是新的队列确实很高效么？</span><br><span class="line">4、那么本章节就来和大家分享分析一下Netty新采用的队列之一MpscUnboundedArrayQueue，分析Netty的源码版本为：netty-netty-4.1.22.Final；</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二、回顾预习"><a href="#二、回顾预习" class="headerlink" title="二、回顾预习"></a>二、回顾预习</h2><h3 id="2-1-构造队列"><a href="#2-1-构造队列" class="headerlink" title="2.1 构造队列"></a>2.1 构造队列</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// NioEventLoop.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>{</span><br><span class="line">        <span class="comment">// This event loop never calls takeTask()</span></span><br><span class="line">        <span class="comment">// 由于默认是没有配置io.netty.eventLoop.maxPendingTasks属性值的，所以maxPendingTasks默认值为Integer.MAX_VALUE；</span></span><br><span class="line">        <span class="comment">// 那么最后配备的任务队列的大小也就自然使用无参构造队列方法</span></span><br><span class="line">        <span class="keyword">return</span> maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.&lt;Runnable&gt;newMpscQueue()</span><br><span class="line">                                                    : PlatformDependent.&lt;Runnable&gt;newMpscQueue(maxPendingTasks);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PlatformDependent.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new {<span class="doctag">@link</span> Queue} which is safe to use for multiple producers (different threads) and a single</span></span><br><span class="line"><span class="comment">     * consumer (one thread!).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A MPSC queue which may be unbounded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Mpsc.newMpscQueue();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mpsc.java</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> USE_MPSC_CHUNKED_ARRAY_QUEUE ? <span class="keyword">new</span> MpscUnboundedArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE)</span><br><span class="line">                                            : <span class="keyword">new</span> MpscUnboundedAtomicArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、通过源码回顾，想必大家已经隐约回忆起之前分析过这段代码，我们在构建工作线程管理组的时候，还需要实例化子线程数组children[]，所以自然就会碰到这段代码；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、这段代码其实就是为了实现一个无锁方式的线程安全队列，总之一句话，效率相当相当的高；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-何为JCTools？"><a href="#2-2-何为JCTools？" class="headerlink" title="2.2 何为JCTools？"></a>2.2 何为JCTools？</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、JCTools是服务虚拟机并发开发的工具，提供一些JDK没有的并发数据结构辅助开发。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、是一个聚合四种 SPSC/MPSC/SPMC/MPMC 数据变量的并发队列：</span><br><span class="line">    • SPSC：单个生产者对单个消费者（无等待、有界和无界都有实现）</span><br><span class="line">    • MPSC：多个生产者对单个消费者（无锁、有界和无界都有实现）</span><br><span class="line">    • SPMC：单生产者对多个消费者（无锁 有界）</span><br><span class="line">    • MPMC：多生产者对多个消费者（无锁、有界）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、SPSC/MPSC 提供了一个在性能，分配和分配规则之间的平衡的关联数组队列；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-常用重要的成员属性及方法"><a href="#2-3-常用重要的成员属性及方法" class="headerlink" title="2.3 常用重要的成员属性及方法"></a>2.3 常用重要的成员属性及方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> producerLimit;</span><br><span class="line">   <span class="comment">// 数据链表所分配或者扩展后的容量值</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="keyword">protected</span> <span class="keyword">long</span> producerIndex;</span><br><span class="line">   <span class="comment">// 生产者指针，每添加一个数据，指针加2</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="keyword">protected</span> <span class="keyword">long</span> consumerIndex;</span><br><span class="line">   <span class="comment">// 消费者指针，每移除一个数据，指针加2</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRY = <span class="number">1</span>; <span class="comment">// 重新尝试，有可能是因为并发原因，CAS操作指针失败，所以需要重新尝试添加动作</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_FULL = <span class="number">2</span>; <span class="comment">// 队列已满，直接返回false操作</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_RESIZE = <span class="number">3</span>; <span class="comment">// 需要扩容处理，扩容的后的容量值producerLimit一般都是mask的N倍</span></span><br><span class="line">   <span class="comment">// 添加数据时，根据offerSlowPath返回的状态值来做各种处理</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、<span class="keyword">protected</span> E[] producerBuffer;</span><br><span class="line">   <span class="comment">// 数据缓冲区，需要添加的数据放在此</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、<span class="keyword">protected</span> <span class="keyword">long</span> producerMask;</span><br><span class="line">   <span class="comment">// 生产者扩充容量值，一般producerMask与consumerMask是一致的，而且需要扩容的数值一般和此值一样</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">final</span> E e)</span></span></span><br><span class="line"><span class="function">   <span class="comment">// 添加元素</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">8、<span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="comment">// 移除元素</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-数据结构"><a href="#2-4-数据结构" class="headerlink" title="2.4 数据结构"></a>2.4 数据结构</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、如果chunkSize初始化大小为<span class="number">4</span>，则最后显示的数据结构如下：</span><br><span class="line">   E1，E2，。。。，EN：表示具体的元素；</span><br><span class="line">   NBP：表示下一个缓冲区的指针，我采用的是英文的缩写( Next Buffer Pointer)；</span><br><span class="line"></span><br><span class="line">   而且你看着我是拆分开写的，其实每一个NBP指向的就是下面一组缓冲区；</span><br><span class="line">   Buffer1中的NBP其实就是Buffer2的指针引用；</span><br><span class="line">   Buffer2中的NBP其实就是Buffer3的指针引用；</span><br><span class="line">   以此类推。。。</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">|  E1  |  E2  |  E3  | JUMP |  NBP |    Buffer1</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line"></span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">|  E5  |  E6  | JUMP |  E4  |  NBP |    Buffer2</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line"></span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">|  E9  | JUMP |  E7  |  E8  |  NBP |    Buffer3</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line"></span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">| JUMP |  E10 |  E11 |  E12 |  NBP |    Buffer4</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line"></span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">|  E13 |  E14 |  E15 | JUMP |  NBP |    Buffer5</span><br><span class="line">|      |      |      |      |      |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、这个数据结构和我们通常所认知的链表是不是有点异样，其实大体还是雷同的，这种数据结构其实也是指针的单项指引罢了；</span><br></pre></td></tr></tbody></table></figure>
<h2 id="三、源码分析MpscUnboundedArrayQueue"><a href="#三、源码分析MpscUnboundedArrayQueue" class="headerlink" title="三、源码分析MpscUnboundedArrayQueue"></a>三、源码分析MpscUnboundedArrayQueue</h2><h3 id="3-1、MpscUnboundedArrayQueue-int"><a href="#3-1、MpscUnboundedArrayQueue-int" class="headerlink" title="3.1、MpscUnboundedArrayQueue(int)"></a>3.1、MpscUnboundedArrayQueue(int)</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// MpscUnboundedArrayQueue.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MpscUnboundedArrayQueue</span><span class="params">(<span class="keyword">int</span> chunkSize)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">super</span>(chunkSize); <span class="comment">// 调用父类的含参构造方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity the queue initial capacity. If chunk size is fixed this will be the chunk size.</span></span><br><span class="line"><span class="comment">     *                        Must be 2 or more.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseMpscLinkedArrayQueue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 校验队列容量值，大小必须不小于2</span></span><br><span class="line">        RangeUtil.checkGreaterThanOrEqual(initialCapacity, <span class="number">2</span>, <span class="string">"initialCapacity"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过传入的参数通过Pow2算法获取大于initialCapacity最近的一个2的n次方的值</span></span><br><span class="line">        <span class="keyword">int</span> p2capacity = Pow2.roundToPowerOfTwo(initialCapacity);</span><br><span class="line">        <span class="comment">// leave lower bit of mask clear</span></span><br><span class="line">        <span class="keyword">long</span> mask = (p2capacity - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 通过p2capacity计算获得mask值，该值后续将用作扩容的值</span></span><br><span class="line">        <span class="comment">// need extra element to point at next array</span></span><br><span class="line">        E[] buffer = allocate(p2capacity + <span class="number">1</span>); <span class="comment">// 默认分配一个 p2capacity + 1 大小的数据缓冲区</span></span><br><span class="line">        producerBuffer = buffer;</span><br><span class="line">        producerMask = mask;</span><br><span class="line">        consumerBuffer = buffer;</span><br><span class="line">        consumerMask = mask;</span><br><span class="line">        <span class="comment">// 同时用mask作为初始化队列的Limit值，当生产者指针producerIndex超过该Limit值时就需要做扩容处理</span></span><br><span class="line">        soProducerLimit(mask); <span class="comment">// we know it's all empty to start with</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RangeUtil.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkGreaterThanOrEqual</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> expected, String name)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 要求队列的容量值必须不小于 expected 值，这个 expected 值由上层决定，但是对 MpscUnboundedArrayQueue 而言，expected 为 2；</span></span><br><span class="line">        <span class="comment">// 那么就是说 MpscUnboundedArrayQueue 的值必须不小于 2；</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; expected)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">": "</span> + n + <span class="string">" (expected: &gt;= "</span> + expected + <span class="string">')'</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、通过调用父类的构造方法，分配了一个数据缓冲区，初始化容量大小，并且容量值不小于<span class="number">2</span>，差不多就这样队列的实例化操作已经完成了；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2、offer-E"><a href="#3-2、offer-E" class="headerlink" title="3.2、offer(E)"></a>3.2、offer(E)</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">final</span> E e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == e) <span class="comment">// 待添加的元素e不允许为空，否则抛空指针异常</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mask;</span><br><span class="line">        E[] buffer;</span><br><span class="line">        <span class="keyword">long</span> pIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">long</span> producerLimit = lvProducerLimit(); <span class="comment">// 获取当前数据Limit的阈值</span></span><br><span class="line">            pIndex = lvProducerIndex(); <span class="comment">// 获取当前生产者指针位置</span></span><br><span class="line">            <span class="comment">// lower bit is indicative of resize, if we see it we spin until it's cleared</span></span><br><span class="line">            <span class="keyword">if</span> ((pIndex &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// pIndex is even (lower bit is 0) -&gt; actual index is (pIndex &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// mask/buffer may get changed by resizing -&gt; only use for array access after successful CAS.</span></span><br><span class="line">            mask = <span class="keyword">this</span>.producerMask;</span><br><span class="line">            buffer = <span class="keyword">this</span>.producerBuffer;</span><br><span class="line">            <span class="comment">// a successful CAS ties the ordering, lv(pIndex) - [mask/buffer] -&gt; cas(pIndex)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// assumption behind this optimization is that queue is almost always empty or near empty</span></span><br><span class="line">            <span class="keyword">if</span> (producerLimit &lt;= pIndex) <span class="comment">// 当阈值小于等于生产者指针位置时，则需要扩容，否则直接通过CAS操作对pIndex做加2处理</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 通过offerSlowPath返回状态值，来查看怎么来处理这个待添加的元素</span></span><br><span class="line">                <span class="keyword">int</span> result = offerSlowPath(mask, pIndex, producerLimit);</span><br><span class="line">                <span class="keyword">switch</span> (result)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">case</span> CONTINUE_TO_P_INDEX_CAS:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RETRY: <span class="comment">// 可能由于并发原因导致CAS失败，那么则再次重新尝试添加元素</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">case</span> QUEUE_FULL: <span class="comment">// 队列已满，直接返回false操作</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">case</span> QUEUE_RESIZE: <span class="comment">// 队列需要扩容操作</span></span><br><span class="line">                        resize(mask, buffer, pIndex, e); <span class="comment">// 对队列进行直接扩容操作</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 能走到这里，则说明当前的生产者指针位置还没有超过阈值，因此直接通过CAS操作做加2处理</span></span><br><span class="line">            <span class="keyword">if</span> (casProducerIndex(pIndex, pIndex + <span class="number">2</span>))</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// INDEX visible before ELEMENT</span></span><br><span class="line">        <span class="comment">// 获取计算需要添加元素的位置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> offset = modifiedCalcElementOffset(pIndex, mask);</span><br><span class="line">        <span class="comment">// 在buffer的offset位置添加e元素</span></span><br><span class="line">        soElement(buffer, offset, e); <span class="comment">// release element e</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueueProducerFields.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">lvProducerIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 通过Unsafe对象调用native方法，获取生产者指针位置</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getLongVolatile(<span class="keyword">this</span>, P_INDEX_OFFSET);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UnsafeRefArrayAccess.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An ordered store(store + StoreStore barrier) of an element to a given offset</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer this.buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset computed via {<span class="doctag">@link</span> UnsafeRefArrayAccess#calcElementOffset}</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e      an orderly kitty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">soElement</span><span class="params">(E[] buffer, <span class="keyword">long</span> offset, E e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 通过Unsafe对象调用native方法，将元素e设置到buffer缓冲区的offset位置</span></span><br><span class="line">        UNSAFE.putOrderedObject(buffer, offset, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、此方法为添加新的元素对象，当pIndex指针超过阈值producerLimit时则扩容处理，否则直接通过CAS操作添加记录pIndex位置；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-3、offerSlowPath-long-long-long"><a href="#3-3、offerSlowPath-long-long-long" class="headerlink" title="3.3、offerSlowPath(long, long, long)"></a>3.3、offerSlowPath(long, long, long)</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We do not inline resize into this method because we do not resize on fill.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">offerSlowPath</span><span class="params">(<span class="keyword">long</span> mask, <span class="keyword">long</span> pIndex, <span class="keyword">long</span> producerLimit)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 获取消费者指针</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> cIndex = lvConsumerIndex();</span><br><span class="line">        <span class="comment">// 获取当前缓冲区的容量值，getCurrentBufferCapacity方法由子类MpscUnboundedArrayQueue实现，默认返回mask值</span></span><br><span class="line">        <span class="keyword">long</span> bufferCapacity = getCurrentBufferCapacity(mask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果消费指针加上容量值如果超过了生产指针，那么则会尝试进行扩容处理</span></span><br><span class="line">        <span class="keyword">if</span> (cIndex + bufferCapacity &gt; pIndex)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (!casProducerLimit(producerLimit, cIndex + bufferCapacity))</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// retry from top</span></span><br><span class="line">                <span class="keyword">return</span> RETRY;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// continue to pIndex CAS</span></span><br><span class="line">                <span class="keyword">return</span> CONTINUE_TO_P_INDEX_CAS;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// full and cannot grow 子类MpscUnboundedArrayQueue默认返回Integer.MAX_VALUE值，所以不会进入此分支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (availableInQueue(pIndex, cIndex) &lt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// offer should return false;</span></span><br><span class="line">            <span class="keyword">return</span> QUEUE_FULL;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// grab index for resize -&gt; set lower bit 尝试扩容队列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casProducerIndex(pIndex, pIndex + <span class="number">1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// trigger a resize</span></span><br><span class="line">            <span class="keyword">return</span> QUEUE_RESIZE;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// failed resize attempt, retry from top</span></span><br><span class="line">            <span class="keyword">return</span> RETRY;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MpscUnboundedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getCurrentBufferCapacity</span><span class="params">(<span class="keyword">long</span> mask)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 获取当前缓冲区的容量值</span></span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casProducerLimit</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> newValue)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 通过CAS尝试对阈值进行修改扩容处理</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, P_LIMIT_OFFSET, expect, newValue);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MpscUnboundedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">availableInQueue</span><span class="params">(<span class="keyword">long</span> pIndex, <span class="keyword">long</span> cIndex)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 获取可用容量值</span></span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueueProducerFields.java</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casProducerIndex</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> newValue)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 通过CAS操作更新生产者指针</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, P_INDEX_OFFSET, expect, newValue);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、该方法主要通过一系列的<span class="keyword">if</span>...<span class="keyword">else</span>判断，并结合子类MpscUnboundedArrayQueue的一些重写方法来判断针对该新添加的元素要做何种状态处理；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-4、resize-long-E-long-E"><a href="#3-4、resize-long-E-long-E" class="headerlink" title="3.4、resize(long, E[], long, E)"></a>3.4、resize(long, E[], long, E)</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">long</span> oldMask, E[] oldBuffer, <span class="keyword">long</span> pIndex, E e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 获取oldBuffer的长度值</span></span><br><span class="line">        <span class="keyword">int</span> newBufferLength = getNextBufferSize(oldBuffer);</span><br><span class="line">        <span class="comment">// 重新创建新的缓冲区</span></span><br><span class="line">        <span class="keyword">final</span> E[] newBuffer = allocate(newBufferLength);</span><br><span class="line"></span><br><span class="line">        producerBuffer = newBuffer; <span class="comment">// 将新创建的缓冲区赋值到生产者缓冲区对象上</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newMask = (newBufferLength - <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        producerMask = newMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据oldMask获取偏移位置值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> offsetInOld = modifiedCalcElementOffset(pIndex, oldMask);</span><br><span class="line">        <span class="comment">// 根据newMask获取偏移位置值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> offsetInNew = modifiedCalcElementOffset(pIndex, newMask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将元素e设置到新的缓冲区newBuffer的offsetInNew位置处</span></span><br><span class="line">        soElement(newBuffer, offsetInNew, e);<span class="comment">// element in new array</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过nextArrayOffset(oldMask)计算新的缓冲区将要放置旧的缓冲区的哪个位置</span></span><br><span class="line">        <span class="comment">// 将新的缓冲区newBuffer设置到旧的缓冲区oldBuffer的nextArrayOffset(oldMask)位置处</span></span><br><span class="line">        <span class="comment">// 主要是将oldBuffer中最后一个元素的位置指向新的缓冲区newBuffer</span></span><br><span class="line">        <span class="comment">// 这样就构成了一个单向链表指向的关系</span></span><br><span class="line">        soElement(oldBuffer, nextArrayOffset(oldMask), newBuffer);<span class="comment">// buffer linked</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ASSERT code</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> cIndex = lvConsumerIndex();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> availableInQueue = availableInQueue(pIndex, cIndex);</span><br><span class="line">        RangeUtil.checkPositive(availableInQueue, <span class="string">"availableInQueue"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate racing CASs</span></span><br><span class="line">        <span class="comment">// We never set the limit beyond the bounds of a buffer</span></span><br><span class="line">        <span class="comment">// 重新扩容阈值，因为availableInQueue反正都是Integer.MAX_VALUE值，所以自然就取mask值啦</span></span><br><span class="line">        <span class="comment">// 因此针对MpscUnboundedArrayQueue来说，扩容的值其实就是mask的值的大小</span></span><br><span class="line">        soProducerLimit(pIndex + Math.min(newMask, availableInQueue));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make resize visible to the other producers</span></span><br><span class="line">        <span class="comment">// 设置生产者指针加2处理</span></span><br><span class="line">        soProducerIndex(pIndex + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// INDEX visible before ELEMENT, consistent with consumer expectation</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// make resize visible to consumer</span></span><br><span class="line">        <span class="comment">// 用一个空对象来衔接新老缓冲区，凡是在缓冲区中碰到JUMP对象的话，那么就得琢磨着准备着获取下一个缓冲区的数据元素了</span></span><br><span class="line">        soElement(oldBuffer, offsetInOld, JUMP);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MpscUnboundedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNextBufferSize</span><span class="params">(E[] buffer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 获取buffer缓冲区的长度</span></span><br><span class="line">        <span class="keyword">return</span> length(buffer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LinkedArrayQueueUtil.java</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(Object[] buf)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 直接通过length属性来获取数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> buf.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CircularArrayOffsetCalculator.java</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; E[] allocate(<span class="keyword">int</span> capacity)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 根据容量值创建数组</span></span><br><span class="line">        <span class="keyword">return</span> (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、该方法主要完成新的元素的放置，同时也完成了扩容操作，采用单向链表指针关系，将原缓冲区和新创建的缓冲区衔接起来；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-5、poll"><a href="#3-5、poll" class="headerlink" title="3.5、poll()"></a>3.5、poll()</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This implementation is correct for single consumer thread use only.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">final</span> E[] buffer = consumerBuffer; <span class="comment">// 获取缓冲区的数据</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> index = consumerIndex;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> mask = consumerMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据消费指针与mask来获取当前需要从哪个位置开始来移除元素</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> offset = modifiedCalcElementOffset(index, mask);</span><br><span class="line">        <span class="comment">// 从buffer缓冲区的offset位置获取元素内容</span></span><br><span class="line">        Object e = lvElement(buffer, offset);<span class="comment">// LoadLoad</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="comment">// 如果元素为null的话</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 则再探讨看看消费指针是不是和生产指针是不是相同</span></span><br><span class="line">            <span class="keyword">if</span> (index != lvProducerIndex())</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// poll() == null iff queue is empty, null element is not strong enough indicator, so we must</span></span><br><span class="line">                <span class="comment">// check the producer index. If the queue is indeed not empty we spin until element is</span></span><br><span class="line">                <span class="comment">// visible.</span></span><br><span class="line">                <span class="comment">// 若不相同的话，则先尝试从buffer缓冲区的offset位置获取元素先，若获取元素为null则结束while处理</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                {</span><br><span class="line">                    e = lvElement(buffer, offset);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (e == <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 说明消费指针是不是和生产指针是相等的，那么则缓冲区的数据已经被消费完了，直接返回null即可</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素为JUMP空对象的话，那么意味着我们就得获取下一缓冲区进行读取数据了</span></span><br><span class="line">        <span class="keyword">if</span> (e == JUMP)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">final</span> E[] nextBuffer = getNextBuffer(buffer, mask);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">return</span> newBufferPoll(nextBuffer, index);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能执行到这里，说明需要移除的元素既不是空的，也不是JUMP空对象，那么则就按照正常处理置空即可</span></span><br><span class="line">        <span class="comment">// 移除元素时，则将buffer缓冲区的offset位置的元素置为空即可</span></span><br><span class="line">        soElement(buffer, offset, <span class="keyword">null</span>); <span class="comment">// release element null</span></span><br><span class="line">        <span class="comment">// 同时也通过CAS操作增加消费指针的关系，加2操作</span></span><br><span class="line">        soConsumerIndex(index + <span class="number">2</span>); <span class="comment">// release cIndex</span></span><br><span class="line">        <span class="keyword">return</span> (E) e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueueProducerFields.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">lvProducerIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 通过Unsafe对象调用native方法，获取当前生产者指针值</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getLongVolatile(<span class="keyword">this</span>, P_INDEX_OFFSET);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UnsafeRefArrayAccess.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A volatile load (load + LoadLoad barrier) of an element from a given offset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer this.buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset computed via {<span class="doctag">@link</span> UnsafeRefArrayAccess#calcElementOffset(long)}</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element at the offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">lvElement</span><span class="params">(E[] buffer, <span class="keyword">long</span> offset)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 通过Unsafe对象调用native方法，获取buffer缓冲区offset位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> (E) UNSAFE.getObjectVolatile(buffer, offset);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> E[] getNextBuffer(<span class="keyword">final</span> E[] buffer, <span class="keyword">final</span> <span class="keyword">long</span> mask)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取下一个缓冲区的偏移位置值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> offset = nextArrayOffset(mask);</span><br><span class="line">        <span class="comment">// 从buffer缓冲区的offset位置获取下一个缓冲区数组</span></span><br><span class="line">        <span class="keyword">final</span> E[] nextBuffer = (E[]) lvElement(buffer, offset);</span><br><span class="line">        <span class="comment">// 获取出来后，同时将buffer缓冲区的offset位置置为空，代表指针已经被取出，原来位置没用了，清空即可</span></span><br><span class="line">        soElement(buffer, offset, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> nextBuffer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">newBufferPoll</span><span class="params">(E[] nextBuffer, <span class="keyword">long</span> index)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 从下一个新的缓冲区中找到需要移除数据的指针位置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> offset = newBufferAndOffset(nextBuffer, index);</span><br><span class="line">        <span class="comment">// 从newBuffer新的缓冲区中offset位置取出元素</span></span><br><span class="line">        <span class="keyword">final</span> E n = lvElement(nextBuffer, offset);<span class="comment">// LoadLoad</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) <span class="comment">// 若取出的元素为空，则直接抛出异常</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"new buffer must have at least one element"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果取出的元素不为空，那么先将这个元素原先的位置内容先清空掉</span></span><br><span class="line">        soElement(nextBuffer, offset, <span class="keyword">null</span>);<span class="comment">// StoreStore</span></span><br><span class="line">        <span class="comment">// 然后通过Unsafe对象调用native方法，修改消费指针的数值偏移加2处理</span></span><br><span class="line">        soConsumerIndex(index + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、该方法主要阐述了该队列是如何的移除数据的；取出的数据如果为JUMP空对象的话，那么则准备从下一个缓冲区获取数据元素，否则还是从当前的缓冲区对象中移除元素，并且更新消费指针；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-6、size"><a href="#3-6、size" class="headerlink" title="3.6、size()"></a>3.6、size()</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> because indices are on even numbers we cannot use the size util.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * It is possible for a thread to be interrupted or reschedule between the read of the producer and</span></span><br><span class="line"><span class="comment">         * consumer indices, therefore protection is required to ensure size is within valid range. In the</span></span><br><span class="line"><span class="comment">         * event of concurrent polls/offers to this method the size is OVER estimated as we read consumer</span></span><br><span class="line"><span class="comment">         * index BEFORE the producer index.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> after = lvConsumerIndex(); <span class="comment">// 获取消费指针</span></span><br><span class="line">        <span class="keyword">long</span> size;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) <span class="comment">// 为了防止在获取大小的时候指针发生变化，那么则死循环自旋方式获取大小数值</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> before = after;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentProducerIndex = lvProducerIndex(); <span class="comment">// 获取生产者指针</span></span><br><span class="line">            after = lvConsumerIndex(); <span class="comment">// 获取消费指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果后获取的消费指针after和之前获取的消费指针before相等的话，那么说明此刻还没有指针变化</span></span><br><span class="line">            <span class="keyword">if</span> (before == after)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 那么则直接通过生产指针直接减去消费指针，然后向偏移一位，即除以2，得出最后size大小</span></span><br><span class="line">                size = ((currentProducerIndex - after) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算完了之后则直接break中断处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若消费指针前后不一致，那么可以说是由于并发原因导致了指针发生了变化；</span></span><br><span class="line">            <span class="comment">// 那么则进行下一次循环继续获取最新的指针值再次进行判断</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Long overflow is impossible, so size is always positive. Integer overflow is possible for the unbounded</span></span><br><span class="line">        <span class="comment">// indexed queues.</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt; Integer.MAX_VALUE)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) size;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、获取缓冲区数据大小其实很简单，就是拿着生产指针减去消费指针，但是为了防止并发操作计算错，才用了死循环的方式计算zise值；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-7、isEmpty"><a href="#3-7、isEmpty" class="headerlink" title="3.7、isEmpty()"></a>3.7、isEmpty()</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、源码：</span><br><span class="line">    <span class="comment">// BaseMpscLinkedArrayQueue.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// Order matters!</span></span><br><span class="line">        <span class="comment">// Loading consumer before producer allows for producer increments after consumer index is read.</span></span><br><span class="line">        <span class="comment">// This ensures this method is conservative in it's estimate. Note that as this is an MPMC there is</span></span><br><span class="line">        <span class="comment">// nothing we can do to make this an exact method.</span></span><br><span class="line">        <span class="comment">// 这个就简单了，直接判断消费指针和生产指针是不是相等就知道了</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.lvConsumerIndex() == <span class="keyword">this</span>.lvProducerIndex());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、通过前面我们已经知道了，添加数据的话生产指针在不停的累加操作，而做移除数据的时候消费指针也在不停的累加操作；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、那么这种指针总会有一天会碰面的吧，碰面的那个时候则是数据已经空空如也的时刻；</span><br></pre></td></tr></tbody></table></figure>
<h2 id="四、性能测试"><a href="#四、性能测试" class="headerlink" title="四、性能测试"></a>四、性能测试</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、测试Demo：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较队列的消耗情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hmilyylimh</span></span><br><span class="line"><span class="comment"> * ^_^</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 0.0.1</span></span><br><span class="line"><span class="comment"> * ^_^</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/3/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareQueueCosts</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生产者数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> COUNT_OF_PRODUCER = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 消费者数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_OF_CONSUMER = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 准备添加的任务数量值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_OF_TASK = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 线程池对象 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">7</span>; j++) {</span><br><span class="line">            COUNT_OF_PRODUCER = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, j);</span><br><span class="line">            executorService = Executors.newFixedThreadPool(COUNT_OF_PRODUCER * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> basePow = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {</span><br><span class="line">                capacity = <span class="number">1</span> &lt;&lt; (basePow + i);</span><br><span class="line">                System.out.print(<span class="string">"Producers: "</span> + COUNT_OF_PRODUCER + <span class="string">"\t\t"</span>);</span><br><span class="line">                System.out.print(<span class="string">"Consumers: "</span> + COUNT_OF_CONSUMER + <span class="string">"\t\t"</span>);</span><br><span class="line">                System.out.print(<span class="string">"Capacity: "</span> + capacity + <span class="string">"\t\t"</span>);</span><br><span class="line">                System.out.print(<span class="string">"LinkedBlockingQueue: "</span> + testQueue(<span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;(capacity), COUNT_OF_TASK) + <span class="string">"s"</span> + <span class="string">"\t\t"</span>);</span><br><span class="line">                <span class="comment">// System.out.print("ArrayList: " + testQueue(new ArrayList&lt;Integer&gt;(capacity), COUNT_OF_TASK) + "s" + "\t\t");</span></span><br><span class="line">                <span class="comment">// System.out.print("LinkedList: " + testQueue(new LinkedList&lt;Integer&gt;(), COUNT_OF_TASK) + "s" + "\t\t");</span></span><br><span class="line">                System.out.print(<span class="string">"MpscUnboundedArrayQueue: "</span> + testQueue(<span class="keyword">new</span> MpscUnboundedArrayQueue&lt;Integer&gt;(capacity), COUNT_OF_TASK) + <span class="string">"s"</span> + <span class="string">"\t\t"</span>);</span><br><span class="line">                System.out.print(<span class="string">"MpscChunkedArrayQueue: "</span> + testQueue(<span class="keyword">new</span> MpscChunkedArrayQueue&lt;Integer&gt;(capacity), COUNT_OF_TASK) + <span class="string">"s"</span> + <span class="string">"\t\t"</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Double <span class="title">testQueue</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; queue, <span class="keyword">final</span> <span class="keyword">int</span> taskCount)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        CompletionService&lt;Long&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;Long&gt;(executorService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT_OF_PRODUCER; i++) {</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Producer(queue, taskCount / COUNT_OF_PRODUCER));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT_OF_CONSUMER; i++) {</span><br><span class="line">            completionService.submit((<span class="keyword">new</span> Consumer(queue, taskCount / COUNT_OF_CONSUMER)));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT_OF_CONSUMER; i++) {</span><br><span class="line">            completionService.take().get();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(<span class="string">""</span> + (end - start)) / <span class="number">1000</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> Collection&lt;Integer&gt; queue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> taskCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Collection&lt;Integer&gt; queue, <span class="keyword">int</span> taskCount)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">            <span class="keyword">this</span>.taskCount = taskCount;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">// Queue队列</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.queue <span class="keyword">instanceof</span> Queue) {</span><br><span class="line">                Queue&lt;Integer&gt; tempQueue = (Queue&lt;Integer&gt;) <span class="keyword">this</span>.queue;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.taskCount &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (tempQueue.offer(<span class="keyword">this</span>.taskCount)) {</span><br><span class="line">                        <span class="keyword">this</span>.taskCount--;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// System.out.println("Producer offer failed.");</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// List列表</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.queue <span class="keyword">instanceof</span> List) {</span><br><span class="line">                List&lt;Integer&gt; tempList = (List&lt;Integer&gt;) <span class="keyword">this</span>.queue;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.taskCount &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (tempList.add(<span class="keyword">this</span>.taskCount)) {</span><br><span class="line">                        <span class="keyword">this</span>.taskCount--;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// System.out.println("Producer offer failed.");</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>{</span><br><span class="line">        <span class="keyword">private</span> Collection&lt;Integer&gt; queue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> taskCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Collection&lt;Integer&gt; queue, <span class="keyword">int</span> taskCount)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">            <span class="keyword">this</span>.taskCount = taskCount;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">// Queue队列</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.queue <span class="keyword">instanceof</span> Queue) {</span><br><span class="line">                Queue&lt;Integer&gt; tempQueue = (Queue&lt;Integer&gt;) <span class="keyword">this</span>.queue;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.taskCount &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> ((tempQueue.poll()) != <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="keyword">this</span>.taskCount--;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// List列表</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.queue <span class="keyword">instanceof</span> List) {</span><br><span class="line">                List&lt;Integer&gt; tempList = (List&lt;Integer&gt;) <span class="keyword">this</span>.queue;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.taskCount &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (!tempList.isEmpty() &amp;&amp; (tempList.remove(<span class="number">0</span>)) != <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="keyword">this</span>.taskCount--;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、指标结果：</span><br><span class="line">Producers: <span class="number">2</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">512</span>       LinkedBlockingQueue: <span class="number">1.399</span>s     MpscUnboundedArrayQueue: <span class="number">0.109</span>s     MpscChunkedArrayQueue: <span class="number">0.09</span>s</span><br><span class="line">Producers: <span class="number">2</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">1024</span>      LinkedBlockingQueue: <span class="number">1.462</span>s     MpscUnboundedArrayQueue: <span class="number">0.041</span>s     MpscChunkedArrayQueue: <span class="number">0.048</span>s</span><br><span class="line">Producers: <span class="number">2</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">2048</span>      LinkedBlockingQueue: <span class="number">0.281</span>s     MpscUnboundedArrayQueue: <span class="number">0.037</span>s     MpscChunkedArrayQueue: <span class="number">0.082</span>s</span><br><span class="line"></span><br><span class="line">Producers: <span class="number">4</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">512</span>       LinkedBlockingQueue: <span class="number">0.681</span>s     MpscUnboundedArrayQueue: <span class="number">0.085</span>s     MpscChunkedArrayQueue: <span class="number">0.133</span>s</span><br><span class="line">Producers: <span class="number">4</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">1024</span>      LinkedBlockingQueue: <span class="number">0.405</span>s     MpscUnboundedArrayQueue: <span class="number">0.094</span>s     MpscChunkedArrayQueue: <span class="number">0.172</span>s</span><br><span class="line">Producers: <span class="number">4</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">2048</span>      LinkedBlockingQueue: <span class="number">0.248</span>s     MpscUnboundedArrayQueue: <span class="number">0.107</span>s     MpscChunkedArrayQueue: <span class="number">0.153</span>s</span><br><span class="line"></span><br><span class="line">Producers: <span class="number">8</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">512</span>       LinkedBlockingQueue: <span class="number">1.523</span>s     MpscUnboundedArrayQueue: <span class="number">0.093</span>s     MpscChunkedArrayQueue: <span class="number">0.172</span>s</span><br><span class="line">Producers: <span class="number">8</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">1024</span>      LinkedBlockingQueue: <span class="number">0.668</span>s     MpscUnboundedArrayQueue: <span class="number">0.094</span>s     MpscChunkedArrayQueue: <span class="number">0.281</span>s</span><br><span class="line">Producers: <span class="number">8</span>        Consumers: <span class="number">1</span>        Capacity: <span class="number">2048</span>      LinkedBlockingQueue: <span class="number">0.555</span>s     MpscUnboundedArrayQueue: <span class="number">0.078</span>s     MpscChunkedArrayQueue: <span class="number">0.455</span>s</span><br><span class="line"></span><br><span class="line">Producers: <span class="number">16</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">512</span>       LinkedBlockingQueue: <span class="number">2.676</span>s     MpscUnboundedArrayQueue: <span class="number">0.093</span>s     MpscChunkedArrayQueue: <span class="number">0.753</span>s</span><br><span class="line">Producers: <span class="number">16</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">1024</span>      LinkedBlockingQueue: <span class="number">2.135</span>s     MpscUnboundedArrayQueue: <span class="number">0.093</span>s     MpscChunkedArrayQueue: <span class="number">0.792</span>s</span><br><span class="line">Producers: <span class="number">16</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">2048</span>      LinkedBlockingQueue: <span class="number">0.944</span>s     MpscUnboundedArrayQueue: <span class="number">0.098</span>s     MpscChunkedArrayQueue: <span class="number">0.64</span>s</span><br><span class="line"></span><br><span class="line">Producers: <span class="number">32</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">512</span>       LinkedBlockingQueue: <span class="number">6.647</span>s     MpscUnboundedArrayQueue: <span class="number">0.078</span>s     MpscChunkedArrayQueue: <span class="number">2.109</span>s</span><br><span class="line">Producers: <span class="number">32</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">1024</span>      LinkedBlockingQueue: <span class="number">3.893</span>s     MpscUnboundedArrayQueue: <span class="number">0.095</span>s     MpscChunkedArrayQueue: <span class="number">1.797</span>s</span><br><span class="line">Producers: <span class="number">32</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">2048</span>      LinkedBlockingQueue: <span class="number">2.019</span>s     MpscUnboundedArrayQueue: <span class="number">0.109</span>s     MpscChunkedArrayQueue: <span class="number">2.427</span>s</span><br><span class="line"></span><br><span class="line">Producers: <span class="number">64</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">512</span>       LinkedBlockingQueue: <span class="number">26.59</span>s     MpscUnboundedArrayQueue: <span class="number">0.078</span>s     MpscChunkedArrayQueue: <span class="number">3.627</span>s</span><br><span class="line">Producers: <span class="number">64</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">1024</span>      LinkedBlockingQueue: <span class="number">22.566</span>s    MpscUnboundedArrayQueue: <span class="number">0.093</span>s     MpscChunkedArrayQueue: <span class="number">3.047</span>s</span><br><span class="line">Producers: <span class="number">64</span>       Consumers: <span class="number">1</span>        Capacity: <span class="number">2048</span>      LinkedBlockingQueue: <span class="number">1.719</span>s     MpscUnboundedArrayQueue: <span class="number">0.093</span>s     MpscChunkedArrayQueue: <span class="number">2.549</span>s</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、结果分析(一)：</span><br><span class="line">通过结果打印耗时可以明显看到MpscUnboundedArrayQueue耗时几乎大多数都是不超过<span class="number">0.1</span>s的，这添加、删除的操作效率不是一般的高，这也难怪人家netty要舍弃自己写的队列框架了；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、结果分析(二)：</span><br><span class="line">CompareQueueCosts代码里面我将ArrayList、LinkedList注释掉了，那是因为队列数量太大，List的操作太慢，效率低下，所以在大量并发的场景下，大家还是能避免则尽量避免，否则就遭殃了；</span><br></pre></td></tr></tbody></table></figure>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、通过底层无锁的Unsafe操作方式实现了多生产者同时访问队列的线程安全模型；</span><br><span class="line"></span><br><span class="line">2、由于使用锁会造成的线程切换，特别消耗资源，因此使用无锁而是采用CAS的操作方式，虽然会在一定程度上造成CPU使用率过高，但是整体上将效率还是听可观的；</span><br><span class="line"></span><br><span class="line">3、队列的数据结构是一种单向链表式的结构，通过生产、消费指针来标识添加、移除元素的指针位置，缓冲区与缓冲区之间通过指针指向，避免的数组的复制，较少了大量内存的占用情况；</span><br></pre></td></tr></tbody></table></figure>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Util-5-MpscUnboundedArrayQueue/" data-id="ck4pl3fpg00eqfgcf5ajpzi1v" class="article-share-link">分享</a>



</footer>
-->
</div>