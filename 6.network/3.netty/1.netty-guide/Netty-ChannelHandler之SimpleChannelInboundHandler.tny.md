<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelHandler（三）之 SimpleChannelInboundHandler
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在本文，我们来分享 SimpleChannelInboundHandler 处理器。考虑到 Simple<strong>UserEvent</strong>ChannelHandler 和 SimpleChannelInboundHandler 的实现基本一致，所以也会在本文中分享。</p>
<p>如果胖友对 SimpleChannelInboundHandler 的使用不了解，请先看下 <a href="https://blog.csdn.net/linuu/article/details/51307060" rel="external nofollow noopener noreferrer" target="_blank">《一起学Netty（三）之 SimpleChannelInboundHandler》</a> ，嘿嘿。</p>
<h1 id="2-SimpleChannelInboundHandler"><a href="#2-SimpleChannelInboundHandler" class="headerlink" title="2. SimpleChannelInboundHandler"></a>2. SimpleChannelInboundHandler</h1><p><code>io.netty.channel.SimpleChannelInboundHandler</code> ，继承 ChannelInboundHandlerAdapter 类，抽象类，处理<strong>指定类型</strong>的消息。应用程序中，我们可以实现 SimpleChannelInboundHandler 后，实现对<strong>指定类型</strong>的消息的自定义处理。</p>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型匹配器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用完消息，是否自动释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #channelRead(ChannelHandlerContext, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoRelease;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * see {<span class="doctag">@link</span> #SimpleChannelInboundHandler(boolean)} with {<span class="doctag">@code</span> true} as boolean parameter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleChannelInboundHandler</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance which will try to detect the types to match out of the type parameter of the class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoRelease   {<span class="doctag">@code</span> true} if handled messages should be released automatically by passing them to</span></span><br><span class="line"><span class="comment">     *                      {<span class="doctag">@link</span> ReferenceCountUtil#release(Object)}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleChannelInboundHandler</span><span class="params">(<span class="keyword">boolean</span> autoRelease)</span> </span>{</span><br><span class="line">        <span class="comment">// &lt;1&gt; 获得 matcher</span></span><br><span class="line">        matcher = TypeParameterMatcher.find(<span class="keyword">this</span>, SimpleChannelInboundHandler.class, <span class="string">"I"</span>);</span><br><span class="line">        <span class="keyword">this</span>.autoRelease = autoRelease;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * see {<span class="doctag">@link</span> #SimpleChannelInboundHandler(Class, boolean)} with {<span class="doctag">@code</span> true} as boolean value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleChannelInboundHandler</span><span class="params">(Class&lt;? extends I&gt; inboundMessageType)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(inboundMessageType, <span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inboundMessageType    The type of messages to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoRelease           {<span class="doctag">@code</span> true} if handled messages should be released automatically by passing them to</span></span><br><span class="line"><span class="comment">     *                              {<span class="doctag">@link</span> ReferenceCountUtil#release(Object)}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleChannelInboundHandler</span><span class="params">(Class&lt;? extends I&gt; inboundMessageType, <span class="keyword">boolean</span> autoRelease)</span> </span>{</span><br><span class="line">        <span class="comment">// &lt;2&gt; 获得 matcher</span></span><br><span class="line">        matcher = TypeParameterMatcher.get(inboundMessageType);</span><br><span class="line">        <span class="keyword">this</span>.autoRelease = autoRelease;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略其它方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>matcher</code> 属性，有<strong>两种</strong>方式赋值。<ul>
<li>【常用】<code>&lt;1&gt;</code> 处，使用类的 <code>I</code> 泛型对应的 TypeParameterMatcher 类型匹配器。</li>
<li><code>&lt;2&gt;</code> 处，使用 <code>inboundMessageType</code> 参数对应的 TypeParameterMatcher 类型匹配器。</li>
<li>在大多数情况下，我们不太需要特别详细的了解 <code>io.netty.util.internal.TypeParameterMatcher</code> 的代码实现，感兴趣的胖友可以自己看看 <a href="http://donald-draper.iteye.com/blog/2387772" rel="external nofollow noopener noreferrer" target="_blank">《netty 简单Inbound通道处理器（SimpleChannelInboundHandler）》</a> 的 <a href="#">「TypeParameterMatcher」</a> 部分。</li>
</ul>
</li>
<li><code>autoRelease</code> 属性，使用完消息，是否自动释放。</li>
</ul>
<h2 id="2-2-acceptInboundMessage"><a href="#2-2-acceptInboundMessage" class="headerlink" title="2.2 acceptInboundMessage"></a>2.2 acceptInboundMessage</h2><p><code>#acceptInboundMessage(Object msg)</code> 方法，判断消息是否匹配。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if the given message should be handled. If {<span class="doctag">@code</span> false} it will be passed to the next</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptInboundMessage</span><span class="params">(Object msg)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> matcher.match(msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一般情况下，<code>matcher</code> 的类型是 ReflectiveMatcher( 它是 TypeParameterMatcher 的内部类 )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMatcher</span> <span class="keyword">extends</span> <span class="title">TypeParameterMatcher</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    </span><br><span class="line">    ReflectiveMatcher(Class&lt;?&gt; type) {</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Object msg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(msg); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>匹配逻辑，看 <code>&lt;1&gt;</code> 处，使用 <code>Class#isInstance(Object obj)</code> 方法。对于这个方法，如果我们定义的 <code>I</code> 泛型是个父类，那可以匹配所有的子类。例如 <code>I</code> 设置为 Object 类，那么所有消息，都可以被匹配列。</li>
</ul>
<h2 id="2-3-channelRead"><a href="#2-3-channelRead" class="headerlink" title="2.3 channelRead"></a>2.3 channelRead</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 是否要释放消息</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// 判断是否为匹配的消息</span></span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (acceptInboundMessage(msg)) {</span><br><span class="line"> <span class="number">8</span>:             <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="number">9</span>:             I imsg = (I) msg;</span><br><span class="line"><span class="number">10</span>:             <span class="comment">// 处理消息</span></span><br><span class="line"><span class="number">11</span>:             channelRead0(ctx, imsg);</span><br><span class="line"><span class="number">12</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">13</span>:             <span class="comment">// 不需要释放消息</span></span><br><span class="line"><span class="number">14</span>:             release = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">15</span>:             <span class="comment">// 触发 Channel Read 到下一个节点</span></span><br><span class="line"><span class="number">16</span>:             ctx.fireChannelRead(msg);</span><br><span class="line"><span class="number">17</span>:         }</span><br><span class="line"><span class="number">18</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">19</span>:         <span class="comment">// 判断，是否要释放消息</span></span><br><span class="line"><span class="number">20</span>:         <span class="keyword">if</span> (autoRelease &amp;&amp; release) {</span><br><span class="line"><span class="number">21</span>:             ReferenceCountUtil.release(msg);</span><br><span class="line"><span class="number">22</span>:         }</span><br><span class="line"><span class="number">23</span>:     }</span><br><span class="line"><span class="number">24</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：<code>release</code> 属性，是否需要释放消息。</li>
<li><p>第 7 行：调用 <code>#acceptInboundMessage(Object msg)</code> 方法，判断是否为匹配的消息。</p>
<ul>
<li><p>① <strong>匹配</strong>，调用 <code>#channelRead0(ChannelHandlerContext ctx, I msg)</code> <strong>抽象</strong>方法，处理消息。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;Please keep in mind that this method will be renamed to</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> messageReceived(ChannelHandlerContext, I)} in 5.0.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Is called for each message of type {<span class="doctag">@link</span> I}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx           the {<span class="doctag">@link</span> ChannelHandlerContext} which this {<span class="doctag">@link</span> SimpleChannelInboundHandler}</span></span><br><span class="line"><span class="comment"> *                      belongs to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg           the message to handle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception    is thrown if an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, I msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>子类实现 SimpleChannelInboundHandler 类后，实现该方法，就能很方便的处理消息。</li>
</ul>
</li>
<li>② <strong>不匹配</strong>，标记不需要释放消息，并触发 Channel Read 到<strong>下一个节点</strong>。</li>
</ul>
</li>
<li>第 18 至 23 行：通过 <code>release</code> 变量 + <code>autoRelease</code> 属性，判断是否需要释放消息。若需要，调用 <code>ReferenceCountUtil#release(Object msg)</code> 方法，释放消息。😈 还是蛮方便的。</li>
</ul>
<h1 id="3-SimpleUserEventChannelHandler"><a href="#3-SimpleUserEventChannelHandler" class="headerlink" title="3. SimpleUserEventChannelHandler"></a>3. SimpleUserEventChannelHandler</h1><p><code>io.netty.channel.SimpleUserEventChannelHandler</code> ，继承 ChannelInboundHandlerAdapter 类，抽象类，处理<strong>指定事件</strong>的消息。</p>
<p>SimpleUserEventChannelHandler 和 SimpleChannelInboundHandler 基本一致，差别在于将指定类型的消息，改成了制定类型的事件。😈 所以，笔者就不详细解析了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUserEventChannelHandler</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型匹配器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用完消息，是否自动释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #channelRead(ChannelHandlerContext, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoRelease;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * see {<span class="doctag">@link</span> #SimpleUserEventChannelHandler(boolean)} with {<span class="doctag">@code</span> true} as boolean parameter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleUserEventChannelHandler</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance which will try to detect the types to match out of the type parameter of the class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoRelease   {<span class="doctag">@code</span> true} if handled events should be released automatically by passing them to</span></span><br><span class="line"><span class="comment">     *                      {<span class="doctag">@link</span> ReferenceCountUtil#release(Object)}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleUserEventChannelHandler</span><span class="params">(<span class="keyword">boolean</span> autoRelease)</span> </span>{</span><br><span class="line">        matcher = TypeParameterMatcher.find(<span class="keyword">this</span>, SimpleUserEventChannelHandler.class, <span class="string">"I"</span>);</span><br><span class="line">        <span class="keyword">this</span>.autoRelease = autoRelease;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * see {<span class="doctag">@link</span> #SimpleUserEventChannelHandler(Class, boolean)} with {<span class="doctag">@code</span> true} as boolean value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleUserEventChannelHandler</span><span class="params">(Class&lt;? extends I&gt; eventType)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(eventType, <span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType      The type of events to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoRelease    {<span class="doctag">@code</span> true} if handled events should be released automatically by passing them to</span></span><br><span class="line"><span class="comment">     *                       {<span class="doctag">@link</span> ReferenceCountUtil#release(Object)}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleUserEventChannelHandler</span><span class="params">(Class&lt;? extends I&gt; eventType, <span class="keyword">boolean</span> autoRelease)</span> </span>{</span><br><span class="line">        matcher = TypeParameterMatcher.get(eventType);</span><br><span class="line">        <span class="keyword">this</span>.autoRelease = autoRelease;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns {<span class="doctag">@code</span> true} if the given user event should be handled. If {<span class="doctag">@code</span> false} it will be passed to the next</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">acceptEvent</span><span class="params">(Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> matcher.match(evt);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 是否要释放消息</span></span><br><span class="line">        <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断是否为匹配的消息</span></span><br><span class="line">            <span class="keyword">if</span> (acceptEvent(evt)) {</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                I ievt = (I) evt;</span><br><span class="line">                <span class="comment">// 处理消息</span></span><br><span class="line">                eventReceived(ctx, ievt);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 不需要释放消息</span></span><br><span class="line">                release = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 触发 Channel Read 到下一个节点</span></span><br><span class="line">                ctx.fireUserEventTriggered(evt);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 判断，是否要释放消息</span></span><br><span class="line">            <span class="keyword">if</span> (autoRelease &amp;&amp; release) {</span><br><span class="line">                ReferenceCountUtil.release(evt);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is called for each user event triggered of type {<span class="doctag">@link</span> I}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx the {<span class="doctag">@link</span> ChannelHandlerContext} which this {<span class="doctag">@link</span> SimpleUserEventChannelHandler} belongs to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt the user event to handle</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception is thrown if an error occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(ChannelHandlerContext ctx, I evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>木有彩蛋，hoho 。</p>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ChannelHandler-3-SimpleChannelInboundHandler/" data-id="ck4pl3fp800eafgcfs0vk8nsu" class="article-share-link">分享</a>



</footer>
-->
</div>