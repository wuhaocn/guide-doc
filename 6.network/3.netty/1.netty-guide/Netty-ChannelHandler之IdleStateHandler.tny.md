<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelHandler（五）之 IdleStateHandler
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <code>netty-handler</code> 模块的 <code>timeout</code> 包，实现 Channel 的读写操作的<strong>空闲</strong>检测。可能有胖友不太了解空闲检测的具体用途。请先研读理解下 <a href="https://www.cnblogs.com/ASPNET2008/p/7615973.html" rel="external nofollow noopener noreferrer" target="_blank">《简易RPC框架-心跳与重连机制》</a> 。</p>
<h1 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h1><p><code>timeout</code> 包，包含的类，如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_10_13/01.png" title="`timeout` 包" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_10_13/01.png" alt="`timeout` 包"></a><span class="caption">`timeout` 包</span></p>
<p>一共有 3 个 ChannelHandler 实现类：</p>
<ul>
<li>IdleStateHandler ，当 Channel 的<strong>读或者写</strong>空闲时间太长时，将会触发一个 IdleStateEvent 事件。然后，你可以自定义一个 ChannelInboundHandler ，重写 <code>#userEventTriggered(ChannelHandlerContext ctx, Object evt)</code> 方法，处理该事件。<ul>
<li>ReadTimeoutHandler ，继承 IdleStateHandler 类，当 Channel 的<strong>读</strong>空闲时间( 读或者写 )太长时，抛出 ReadTimeoutException 异常，并自动关闭该 Channel 。然后，你可以自定一个 ChannelInboundHandler ，重写 <code>#exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code> 方法，处理该异常。</li>
</ul>
</li>
<li>WriteTimeoutHandler ，当一个<strong>写</strong>操作不能在指定时间内完成时，抛出 WriteTimeoutException 异常，并自动关闭对应 Channel 。然后，你可以自定一个 ChannelInboundHandler ，重写 <code>#exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code> 方法，处理该异常。</li>
</ul>
<p>😈 从 WriteTimeoutHandler 可以看出，本文实际不仅仅分享 IdleStateHandler ，更准确的是分享 Timeout 相关的 ChannelHandler 。考虑到大多数胖友对 IdleStateHandler 比较熟悉，也相对常用，所以标题才取了 <a href="#">《精尽 Netty 源码解析 —— ChannelHandler（五）之 IdleStateHandler》</a> 。</p>
<h1 id="3-IdleState"><a href="#3-IdleState" class="headerlink" title="3. IdleState"></a>3. IdleState</h1><p><code>io.netty.handler.timeout.IdleState</code> ，空闲状态<strong>枚举</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲状态枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An {<span class="doctag">@link</span> Enum} that represents the idle state of a {<span class="doctag">@link</span> Channel}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IdleState {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * No data was received for a while.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 读空闲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    READER_IDLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * No data was sent for a while.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 写空闲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WRITER_IDLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * No data was either received or sent for a while.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 读或写任一空闲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALL_IDLE</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一共有 3 种状态。其中，<code>ALL_IDLE</code> 表示的是，读<strong>或</strong>写任一空闲，注意是“或”。</li>
</ul>
<h2 id="3-1-IdleStateEvent"><a href="#3-1-IdleStateEvent" class="headerlink" title="3.1 IdleStateEvent"></a>3.1 IdleStateEvent</h2><p><code>io.netty.handler.timeout.IdleStateEvent</code> ，空闲事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleStateEvent</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// READ</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IdleStateEvent FIRST_READER_IDLE_STATE_EVENT = <span class="keyword">new</span> IdleStateEvent(IdleState.READER_IDLE, <span class="keyword">true</span>); <span class="comment">// 首次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IdleStateEvent READER_IDLE_STATE_EVENT = <span class="keyword">new</span> IdleStateEvent(IdleState.READER_IDLE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// WRITE</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IdleStateEvent FIRST_WRITER_IDLE_STATE_EVENT = <span class="keyword">new</span> IdleStateEvent(IdleState.WRITER_IDLE, <span class="keyword">true</span>); <span class="comment">// 首次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IdleStateEvent WRITER_IDLE_STATE_EVENT = <span class="keyword">new</span> IdleStateEvent(IdleState.WRITER_IDLE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// ALL</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IdleStateEvent FIRST_ALL_IDLE_STATE_EVENT = <span class="keyword">new</span> IdleStateEvent(IdleState.ALL_IDLE, <span class="keyword">true</span>); <span class="comment">// 首次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IdleStateEvent ALL_IDLE_STATE_EVENT = <span class="keyword">new</span> IdleStateEvent(IdleState.ALL_IDLE, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空闲状态类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IdleState state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否首次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for sub-classes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state the {<span class="doctag">@link</span> IdleStateEvent} which triggered the event.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first {<span class="doctag">@code</span> true} if its the first idle event for the {<span class="doctag">@link</span> IdleStateEvent}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">IdleStateEvent</span><span class="params">(IdleState state, <span class="keyword">boolean</span> first)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.state = ObjectUtil.checkNotNull(state, <span class="string">"state"</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the idle state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdleState <span class="title">state</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns {<span class="doctag">@code</span> true} if this was the first event for the {<span class="doctag">@link</span> IdleState}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>3 <strong>类</strong>( <code>state</code> )空闲事件，再组合上是否首次( <code>first</code> )，一共有 6 种空闲事件。</li>
</ul>
<h1 id="4-TimeoutException"><a href="#4-TimeoutException" class="headerlink" title="4. TimeoutException"></a>4. TimeoutException</h1><p><code>io.netty.handler.timeout.TimeoutException</code> ，继承 ChannelException 类，超时异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutException</span> <span class="keyword">extends</span> <span class="title">ChannelException</span> </span>{</span><br><span class="line"></span><br><span class="line">    TimeoutException() { }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-1-ReadTimeoutException"><a href="#4-1-ReadTimeoutException" class="headerlink" title="4.1 ReadTimeoutException"></a>4.1 ReadTimeoutException</h2><p><code>io.netty.handler.timeout.ReadTimeoutException</code> ，继承 TimeoutException 类，读超时( 空闲 )异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTimeoutException</span> <span class="keyword">extends</span> <span class="title">TimeoutException</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReadTimeoutException INSTANCE = <span class="keyword">new</span> ReadTimeoutException();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReadTimeoutException</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-2-WriteTimeoutException"><a href="#4-2-WriteTimeoutException" class="headerlink" title="4.2 WriteTimeoutException"></a>4.2 WriteTimeoutException</h2><p><code>io.netty.handler.timeout.WriteTimeoutException</code> ，继承 TimeoutException 类，写超时( 空闲 )异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteTimeoutException</span> <span class="keyword">extends</span> <span class="title">TimeoutException</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> WriteTimeoutException INSTANCE = <span class="keyword">new</span> WriteTimeoutException();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WriteTimeoutException</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="5-IdleStateHandler"><a href="#5-IdleStateHandler" class="headerlink" title="5. IdleStateHandler"></a>5. IdleStateHandler</h1><p><code>io.netty.handler.timeout.IdleStateHandler</code> ，继承 ChannelDuplexHandler 类，当 Channel 的<strong>读或者写</strong>空闲时间太长时，将会触发一个 IdleStateEvent 事件。</p>
<h2 id="5-1-构造方法"><a href="#5-1-构造方法" class="headerlink" title="5.1 构造方法"></a>5.1 构造方法</h2><blockquote>
<p>老艿艿：高能预警，IdleStateHandler 的属性有点点多。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小的超时时间，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入任务监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Not create a new ChannelFutureListener per write operation to reduce GC pressure.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelFutureListener writeListener = <span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 记录最后写时间</span></span><br><span class="line">        lastWriteTime = ticksInNanos();</span><br><span class="line">        <span class="comment">// 重置 firstWriterIdleEvent 和 firstAllIdleEvent 为 true</span></span><br><span class="line">        firstWriterIdleEvent = firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否观察 {<span class="doctag">@link</span> ChannelOutboundBuffer} 写入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> observeOutput;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置的读空闲时间，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> readerIdleTimeNanos;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置的写空闲时间，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> writerIdleTimeNanos;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置的All( 读或写任一 )，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> allIdleTimeNanos;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读空闲的定时检测任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ScheduledFuture&lt;?&gt; readerIdleTimeout;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后读时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastReadTime;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否首次读空闲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> firstReaderIdleEvent = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写空闲的定时检测任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ScheduledFuture&lt;?&gt; writerIdleTimeout;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后写时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastWriteTime;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否首次写空闲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> firstWriterIdleEvent = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All 空闲时间，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ScheduledFuture&lt;?&gt; allIdleTimeout;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否首次 All 空闲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 - none ，未初始化</span></span><br><span class="line"><span class="comment"> * 1 - initialized ，已经初始化</span></span><br><span class="line"><span class="comment"> * 2 - destroyed ，已经销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> state; <span class="comment">// 0 - none, 1 - initialized, 2 - destroyed</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否正在读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> reading;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后检测到 {<span class="doctag">@link</span> ChannelOutboundBuffer} 发生变化的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastChangeCheckTimeStamp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一条准备 flash 到对端的消息( {<span class="doctag">@link</span> ChannelOutboundBuffer#current()} )的 HashCode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lastMessageHashCode;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总共等待 flush 到对端的内存大小( {<span class="doctag">@link</span> ChannelOutboundBuffer#totalPendingWriteBytes()} )</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastPendingWriteBytes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">int</span> readerIdleTimeSeconds, <span class="keyword">int</span> writerIdleTimeSeconds, <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new instance firing {<span class="doctag">@link</span> IdleStateEvent}s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> observeOutput</span></span><br><span class="line"><span class="comment"> *        whether or not the consumption of {<span class="doctag">@code</span> bytes} should be taken into</span></span><br><span class="line"><span class="comment"> *        consideration when assessing write idleness. The default is {<span class="doctag">@code</span> false}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readerIdleTime</span></span><br><span class="line"><span class="comment"> *        an {<span class="doctag">@link</span> IdleStateEvent} whose state is {<span class="doctag">@link</span> IdleState#READER_IDLE}</span></span><br><span class="line"><span class="comment"> *        will be triggered when no read was performed for the specified</span></span><br><span class="line"><span class="comment"> *        period of time.  Specify {<span class="doctag">@code</span> 0} to disable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> writerIdleTime</span></span><br><span class="line"><span class="comment"> *        an {<span class="doctag">@link</span> IdleStateEvent} whose state is {<span class="doctag">@link</span> IdleState#WRITER_IDLE}</span></span><br><span class="line"><span class="comment"> *        will be triggered when no write was performed for the specified</span></span><br><span class="line"><span class="comment"> *        period of time.  Specify {<span class="doctag">@code</span> 0} to disable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allIdleTime</span></span><br><span class="line"><span class="comment"> *        an {<span class="doctag">@link</span> IdleStateEvent} whose state is {<span class="doctag">@link</span> IdleState#ALL_IDLE}</span></span><br><span class="line"><span class="comment"> *        will be triggered when neither read nor write was performed for</span></span><br><span class="line"><span class="comment"> *        the specified period of time.  Specify {<span class="doctag">@code</span> 0} to disable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> *        the {<span class="doctag">@link</span> TimeUnit} of {<span class="doctag">@code</span> readerIdleTime},</span></span><br><span class="line"><span class="comment"> *        {<span class="doctag">@code</span> writeIdleTime}, and {<span class="doctag">@code</span> allIdleTime}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">boolean</span> observeOutput, <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.observeOutput = observeOutput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readerIdleTime &lt;= <span class="number">0</span>) {</span><br><span class="line">        readerIdleTimeNanos = <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS); <span class="comment">// 保证大于等于 MIN_TIMEOUT_NANOS</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTime &lt;= <span class="number">0</span>) {</span><br><span class="line">        writerIdleTimeNanos = <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS); <span class="comment">// 保证大于等于 MIN_TIMEOUT_NANOS</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (allIdleTime &lt;= <span class="number">0</span>) {</span><br><span class="line">        allIdleTimeNanos = <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS); <span class="comment">// 保证大于等于 MIN_TIMEOUT_NANOS</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>属性比较多，保持耐心和淡定，我们继续来整理一波。</li>
<li><code>MIN_TIMEOUT_NANOS</code> 静态属性，最小的超时时间为 <strong>1</strong> ，单位：纳秒。因为 IdleStateHandler 创建的，检测定时任务的时间，以纳秒为单位。</li>
<li><code>state</code> 属性，IdleStateHandler 的状态。一共有三种，见注释。</li>
<li>Read 空闲相关属性<ul>
<li><code>readerIdleTimeNanos</code> 属性，配置的读空闲时间，单位：纳秒。</li>
<li><code>readerIdleTimeout</code> 属性，读空闲的定时检测任务。</li>
<li><code>lastReadTime</code> 属性，读空闲的定时检测任务。</li>
<li><code>firstReaderIdleEvent</code> 属性，是否首次读空闲。</li>
<li>【<strong>独有</strong>】 <code>reading</code> 属性，是否正在读取。</li>
</ul>
</li>
<li>Write 空闲相关属性<ul>
<li><code>writerIdleTimeNanos</code> 属性，配置的写空闲时间，单位：纳秒。</li>
<li><code>writerIdleTimeout</code> 属性，写空闲的定时检测任务。</li>
<li><code>lastWriteTime</code> 属性，最后写时间。</li>
<li><code>writeListener</code> 属性，写入操作，完成 flush 到对端的回调监听器。初始时，创建好，避免重复创建，从而减轻 GC 压力。</li>
<li>【<strong>独有</strong>】ChannelOutboundBuffer 相关属性<ul>
<li><code>observeOutput</code> 属性， 是否观察 ChannelOutboundBuffer 写入队列。</li>
<li><code>lastChangeCheckTimeStamp</code> 属性，最后检测到 ChannelOutboundBuffer 发生变化的时间。</li>
<li><code>lastMessageHashCode</code> 属性，第一条准备 flash 到对端的消息的 HashCode 。</li>
<li><code>lastPendingWriteBytes</code> 属性，总共等待 flush 到对端的内存大小。</li>
<li>关于这几个属性，跟着 <a href="#">「5.7 hasOutputChanged」</a> 一起理解。</li>
</ul>
</li>
</ul>
</li>
<li>ALL 空闲相关属性<ul>
<li>因为 ALL 是 Write 和 Read 任一，所以共用它们的一些属性。</li>
<li><code>allIdleTimeNanos</code> 属性，配置的All( 读或写任一 )，单位：纳秒。 </li>
</ul>
</li>
</ul>
<h2 id="5-2-initialize"><a href="#5-2-initialize" class="headerlink" title="5.2 initialize"></a>5.2 initialize</h2><p><code>#initialize(ChannelHandlerContext ctx)</code> 方法，初始化 IdleStateHandler 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 校验状态，避免因为 `#destroy()` 方法在 `#initialize(ChannelHandlerContext ctx)` 方法，执行之前</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// See: https://github.com/netty/netty/issues/143</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">switch</span> (state) {</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">9</span>:     }</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 标记为已初始化</span></span><br><span class="line"><span class="number">12</span>:     state = <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span>:     <span class="comment">// 初始化 ChannelOutboundBuffer 相关属性</span></span><br><span class="line"><span class="number">14</span>:     initOutputChanged(ctx);</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="comment">// 初始相应的定时任务</span></span><br><span class="line"><span class="number">17</span>:     lastReadTime = lastWriteTime = ticksInNanos();</span><br><span class="line"><span class="number">18</span>:     <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">19</span>:         readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">20</span>:     }</span><br><span class="line"><span class="number">21</span>:     <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">22</span>:         writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">23</span>:     }</span><br><span class="line"><span class="number">24</span>:     <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">25</span>:         allIdleTimeout = schedule(ctx, <span class="keyword">new</span> AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">26</span>:     }</span><br><span class="line"><span class="number">27</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 9 行：校验状态，避免因为 <code>#destroy()</code> 方法在 <code>#initialize(ChannelHandlerContext ctx)</code> 方法，执行之前。</li>
<li>第 12 行：标记 <code>state</code> 为已初始化。</li>
<li><p>第 14 行：调用 <code>#initOutputChanged(ChannelHandlerContext ctx)</code> 方法，初始化 ChannelOutboundBuffer 相关属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initOutputChanged</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (observeOutput) {</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        Unsafe unsafe = channel.unsafe();</span><br><span class="line">        ChannelOutboundBuffer buf = unsafe.outboundBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 记录第一条准备 flash 到对端的消息的 HashCode</span></span><br><span class="line">            lastMessageHashCode = System.identityHashCode(buf.current());</span><br><span class="line">            <span class="comment">// 记录总共等待 flush 到对端的内存大小</span></span><br><span class="line">            lastPendingWriteBytes = buf.totalPendingWriteBytes();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化 <code>lastMessageHashCode</code> 和 <code>lastPendingWriteBytes</code> 属性。</li>
</ul>
</li>
<li><p>第 17 至 26 行：根据配置，分别调用 <code>#schedule(hannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit)</code> 方法，初始相应的定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt; schedule(ChannelHandlerContext ctx, Runnable task, <span class="keyword">long</span> delay, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">return</span> ctx.executor().schedule(task, delay, unit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li>一共有 ReaderIdleTimeoutTask、WriterIdleTimeoutTask、AllIdleTimeoutTask 三种任务，下文我们详细解析。 </li>
</ul>
<hr>
<p>该方法，会在多个 Channel <strong>事件</strong>中被调用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;2&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) {</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// channelActive() event has been fired already, which means this.channelActive() will</span></span><br><span class="line">        <span class="comment">// not be invoked. We have to initialize here instead.</span></span><br><span class="line">        initialize(ctx);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// channelActive() event has not been fired yet.  this.channelActive() will be invoked</span></span><br><span class="line">        <span class="comment">// and initialization will occur there.</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;3&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// Initialize early if channel is active already.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isActive()) {</span><br><span class="line">        initialize(ctx);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 继续传播 Channel Registered 事件到下一个节点</span></span><br><span class="line">    <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// This method will be invoked only if this handler was added</span></span><br><span class="line">    <span class="comment">// before channelActive() event is fired.  If a user adds this handler</span></span><br><span class="line">    <span class="comment">// after the channelActive() event, initialize() will be called by beforeAdd().</span></span><br><span class="line">    initialize(ctx);</span><br><span class="line">    <span class="comment">// 继续传播 Channel Registered 事件到下一个节点</span></span><br><span class="line">    <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> ：当客户端与服务端成功建立连接后，Channel 被激活，此时 channelActive 方法，的初始化被调用。</li>
<li><code>&lt;2&gt;</code> ：当 Channel 被激活后，动态添加此 Handler ，则 handlerAdded 方法的初始化被调用。</li>
<li><code>&lt;3&gt;</code> ：当 Channel 被激活后，用户主动切换 Channel 的所在的 EventLoop ，则 channelRegistered 方法的初始化被调用。</li>
</ul>
<h2 id="5-3-destroy"><a href="#5-3-destroy" class="headerlink" title="5.3 destroy"></a>5.3 destroy</h2><p><code>#destroy()</code> 方法，销毁 IdleStateHandler 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记为销毁</span></span><br><span class="line">    state = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁相应的定时任务</span></span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeout != <span class="keyword">null</span>) {</span><br><span class="line">        readerIdleTimeout.cancel(<span class="keyword">false</span>);</span><br><span class="line">        readerIdleTimeout = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeout != <span class="keyword">null</span>) {</span><br><span class="line">        writerIdleTimeout.cancel(<span class="keyword">false</span>);</span><br><span class="line">        writerIdleTimeout = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeout != <span class="keyword">null</span>) {</span><br><span class="line">        allIdleTimeout.cancel(<span class="keyword">false</span>);</span><br><span class="line">        allIdleTimeout = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>标记 <code>state</code> 为已销毁。</li>
<li>销毁响应的定时任务。</li>
</ul>
<hr>
<p>该方法，会在多个 Channel <strong>事件</strong>中被调用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    destroy();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    destroy();</span><br><span class="line">    <span class="comment">// 继续传播 Channel Incative 事件到下一个节点</span></span><br><span class="line">    <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-4-channelIdle"><a href="#5-4-channelIdle" class="headerlink" title="5.4 channelIdle"></a>5.4 channelIdle</h2><p>在定时任务中，如果检测到<strong>空闲</strong>：</p>
<p>① 首先，调用 <code>#newIdleStateEvent(IdleState state, boolean first)</code> 方法，创建对应的空闲事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> IdleStateEvent <span class="title">newIdleStateEvent</span><span class="params">(IdleState state, <span class="keyword">boolean</span> first)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (state) {</span><br><span class="line">        <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">            <span class="keyword">return</span> first ? IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT : IdleStateEvent.ALL_IDLE_STATE_EVENT;</span><br><span class="line">        <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">            <span class="keyword">return</span> first ? IdleStateEvent.FIRST_READER_IDLE_STATE_EVENT : IdleStateEvent.READER_IDLE_STATE_EVENT;</span><br><span class="line">        <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">            <span class="keyword">return</span> first ? IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT : IdleStateEvent.WRITER_IDLE_STATE_EVENT;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled: state="</span> + state + <span class="string">", first="</span> + first);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>② 然后，调用 <code>#channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt)</code> 方法，在 pipeline 中，触发 UserEvent 事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is called when an {<span class="doctag">@link</span> IdleStateEvent} should be fired. This implementation calls</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ctx.fireUserEventTriggered(evt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-5-channelRead"><a href="#5-5-channelRead" class="headerlink" title="5.5 channelRead"></a>5.5 channelRead</h2><p><code>#channelRead(ChannelHandlerContext ctx, Object msg)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 开启了 read 或 all 的空闲检测</span></span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span> || allIdleTimeNanos &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 标记正在读取</span></span><br><span class="line">        reading = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 重置 firstWriterIdleEvent 和 firstAllIdleEvent 为 true</span></span><br><span class="line">        firstReaderIdleEvent = firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 继续传播 Channel Read 事件到下一个节点</span></span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 read 或 all 的空闲检测的情况下，在【继续传播 Channel Read 事件到下一个节点】<strong>之前</strong>，会：</p>
<ul>
<li>标记 <code>reading</code> 为正在读取。</li>
<li>重置 <code>firstWriterIdleEvent</code> 和 <code>firstAllIdleEvent</code> 为 <code>true</code> ，即又变成<strong>首次</strong>。</li>
</ul>
<hr>
<p>那么什么时候记录 <code>lastReadTime</code> 最后读取时间呢？答案在 <code>#channelReadComplete(ChannelHandlerContext ctx)</code> 方法中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 开启了 read 或 all 的空闲检测</span></span><br><span class="line">    <span class="keyword">if</span> ((readerIdleTimeNanos &gt; <span class="number">0</span> || allIdleTimeNanos &gt; <span class="number">0</span>) &amp;&amp; reading) {</span><br><span class="line">        <span class="comment">// 记录最后读时间</span></span><br><span class="line">        lastReadTime = ticksInNanos();</span><br><span class="line">        <span class="comment">// 标记不在读取</span></span><br><span class="line">        reading = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 继续传播 Channel ReadComplete 事件到下一个节点</span></span><br><span class="line">    ctx.fireChannelReadComplete();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 read 或 all 的空闲检测的情况下，在【继续传播 Channel ReadComplete 事件到下一个节点】<strong>之前</strong>，会：</p>
<ul>
<li><p>记录 <code>lastReadTime</code> 最后读取时间为 <code>#ticksInNanos()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ticksInNanos</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> System.nanoTime();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当前时间，单位：纳秒。</li>
</ul>
</li>
<li><p>标记 <code>reading</code> 为不在读取。</p>
</li>
</ul>
<h2 id="5-6-write"><a href="#5-6-write" class="headerlink" title="5.6 write"></a>5.6 write</h2><p><code>#write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 开启了 write 或 all 的空闲检测</span></span><br><span class="line">    <span class="comment">// Allow writing with void promise if handler is only configured for read timeout events.</span></span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span> || allIdleTimeNanos &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 写入，并添加写入监听器</span></span><br><span class="line">        ctx.write(msg, promise.unvoid()).addListener(writeListener);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 写入，不添加监听器</span></span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 write 或 all 的空闲检测的情况下，写入的时候，会添加写入监听器 <code>writeListener</code> 。该监听器会在消息( 数据 ) flush 到对端后，<strong>回调</strong>，修改最后写入时间 <code>lastWriteTime</code> 为 <code>#ticksInNanos()</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Not create a new ChannelFutureListener per write operation to reduce GC pressure.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelFutureListener writeListener = <span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 记录最后写时间</span></span><br><span class="line">        lastWriteTime = ticksInNanos();</span><br><span class="line">        <span class="comment">// 重置 firstWriterIdleEvent 和 firstAllIdleEvent 为 true</span></span><br><span class="line">        firstWriterIdleEvent = firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-7-hasOutputChanged"><a href="#5-7-hasOutputChanged" class="headerlink" title="5.7 hasOutputChanged"></a>5.7 hasOutputChanged</h2><blockquote>
<p>老艿艿：关于这个方法，看完 <a href="#">「5.8.2 WriterIdelTimeoutTask」</a> 后，再回过头理解。</p>
</blockquote>
<p><code>#hasOutputChanged(ChannelHandlerContext ctx, boolean first)</code> 方法，判断 ChannelOutboundBuffer 是否发生变化。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns {<span class="doctag">@code</span> true} if and only if the {<span class="doctag">@link</span> IdleStateHandler} was constructed</span></span><br><span class="line"><span class="comment">    * with {<span class="doctag">@link</span> #observeOutput} enabled and there has been an observed change in the</span></span><br><span class="line"><span class="comment">    * {<span class="doctag">@link</span> ChannelOutboundBuffer} between two consecutive calls of this method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * https://github.com/netty/netty/issues/6150</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOutputChanged</span><span class="params">(ChannelHandlerContext ctx, <span class="keyword">boolean</span> first)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 开启观察 ChannelOutboundBuffer 队列</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (observeOutput) {</span><br><span class="line"> <span class="number">4</span>: </span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// We can take this shortcut if the ChannelPromises that got passed into write()</span></span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// appear to complete. It indicates "change" on message level and we simply assume</span></span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// that there's change happening on byte level. If the user doesn't observe channel</span></span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// writability events then they'll eventually OOME and there's clearly a different</span></span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// problem and idleness is least of their concerns.</span></span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 如果 lastChangeCheckTimeStamp 和 lastWriteTime 不一样，说明写操作进行过了，则更新此值</span></span><br><span class="line"><span class="number">11</span>:         <span class="keyword">if</span> (lastChangeCheckTimeStamp != lastWriteTime) {</span><br><span class="line"><span class="number">12</span>:             lastChangeCheckTimeStamp = lastWriteTime;</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:             <span class="comment">// But this applies only if it's the non-first call.</span></span><br><span class="line"><span class="number">15</span>:             <span class="keyword">if</span> (!first) { <span class="comment">// 非首次</span></span><br><span class="line"><span class="number">16</span>:                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">17</span>:             }</span><br><span class="line"><span class="number">18</span>:         }</span><br><span class="line"><span class="number">19</span>: </span><br><span class="line"><span class="number">20</span>:         Channel channel = ctx.channel();</span><br><span class="line"><span class="number">21</span>:         Unsafe unsafe = channel.unsafe();</span><br><span class="line"><span class="number">22</span>:         ChannelOutboundBuffer buf = unsafe.outboundBuffer();</span><br><span class="line"><span class="number">23</span>: </span><br><span class="line"><span class="number">24</span>:         <span class="keyword">if</span> (buf != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">25</span>:             <span class="comment">// 获得新的 messageHashCode 和 pendingWriteBytes</span></span><br><span class="line"><span class="number">26</span>:             <span class="keyword">int</span> messageHashCode = System.identityHashCode(buf.current());</span><br><span class="line"><span class="number">27</span>:             <span class="keyword">long</span> pendingWriteBytes = buf.totalPendingWriteBytes();</span><br><span class="line"><span class="number">28</span>: </span><br><span class="line"><span class="number">29</span>:             <span class="comment">// 发生了变化</span></span><br><span class="line"><span class="number">30</span>:             <span class="keyword">if</span> (messageHashCode != lastMessageHashCode || pendingWriteBytes != lastPendingWriteBytes) {</span><br><span class="line"><span class="number">31</span>:                 <span class="comment">// 修改最后一次的 lastMessageHashCode 和 lastPendingWriteBytes</span></span><br><span class="line"><span class="number">32</span>:                 lastMessageHashCode = messageHashCode;</span><br><span class="line"><span class="number">33</span>:                 lastPendingWriteBytes = pendingWriteBytes;</span><br><span class="line"><span class="number">34</span>: </span><br><span class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (!first) { <span class="comment">// 非首次</span></span><br><span class="line"><span class="number">36</span>:                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">37</span>:                 }</span><br><span class="line"><span class="number">38</span>:             }</span><br><span class="line"><span class="number">39</span>:         }</span><br><span class="line"><span class="number">40</span>:     }</span><br><span class="line"><span class="number">41</span>: </span><br><span class="line"><span class="number">42</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">43</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：判断开启观察 ChannelOutboundBuffer 队列。<ul>
<li>如果 <code>lastChangeCheckTimeStamp</code> 和 <code>lastWriteTime</code> 不一样，说明写操作进行过了，则更新此值。  </li>
<li>第 14 至 17 行：这段逻辑，理论来说不会发生。因为 <code>lastWriteTime</code> 属性，只会在 <code>writeListener</code> 回调中修改，那么如果发生 <code>lastChangeCheckTimeStamp</code> 和 <code>lastWriteTime</code> 不相等，<code>first</code> 必然为 <code>true</code> 。因为，Channel 相关的事件逻辑，都在它所在的 EventLoop 中，不会出现并发的情况。关于这一块，基友【莫那一鲁道】在 <a href="https://github.com/netty/netty/issues/8251" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/netty/netty/issues/8251</a> 已经进行提问，坐等结果。</li>
</ul>
</li>
<li>第 25 至 27 行：获得新的 <code>messageHashCode</code> 和 <code>pendingWriteBytes</code> 的。</li>
<li>第 29 至 33 行：若发生了变化，则修改最后一次的 <code>lastMessageHashCode</code> 和 <code>lastPendingWriteBytes</code> 。<ul>
<li><code>messageHashCode != lastMessageHashCode</code> 成立，① 有可能对端接收数据比较慢，导致一个消息发送了一部分；② 又或者，发送的消息<strong>非常非常非常大</strong>，导致一个消息发送了一部分，就将发送缓存区写满。如果是这种情况下，可以使用 ChunkedWriteHandler ，一条大消息，拆成多条小消息。</li>
<li><code>pendingWriteBytes != lastPendingWriteBytes</code> 成立，① 有新的消息，写到 ChannelOutboundBuffer 内存队列中；② 有几条消息成功写到对端。这种情况，此处不会发生。</li>
</ul>
</li>
<li>第 35 至 37 行：当且仅当 <code>first</code> 为 <code>true</code> 时，即非首次，才返回 <code>true</code> ，表示 ChannelOutboundBuffer 发生变化。<ul>
<li>这是一个有点“神奇”的设定，笔者表示不太理解。理论来说，ChannelOutboundBuffer 是否发生变化，只需要考虑【第 30 行】代码的判断。如果加了 <code>!first</code> 的判断，导致的结果是在 WriterIdleTimeoutTask 和 AllIdleTimeoutTask 任务中，ChannelOutboundBuffer 即使发生了变化，在<strong>首次</strong>还是会触发 write 和 all 空闲事件，在<strong>非首次</strong>不会触发 write 和 all 空闲事件。</li>
<li>关于上述的困惑，<a href="https://www.jianshu.com/p/8fe70d313d78" rel="external nofollow noopener noreferrer" target="_blank">《Netty 那些事儿 ——— 关于 “Netty 发送大数据包时 触发写空闲超时” 的一些思考》</a> 一文的作者，也表达了相同的困惑。后续，找闪电侠面基沟通下。</li>
<li>关于上述的困惑，<a href="https://www.jianshu.com/p/f2ed73cf4df8" rel="external nofollow noopener noreferrer" target="_blank">《Netty 心跳服务之 IdleStateHandler 源码分析》</a> 一文的作者，表达了自己的理解。感兴趣的胖友，可以看看。</li>
<li>当然，这块如果不理解的胖友，也不要方。从笔者目前了解下来，<code>observeOutput</code> 都是设置为 <code>false</code> 。也就说，不会触发这个方法的执行。</li>
</ul>
</li>
<li>第 42 行：返回 <code>false</code> ，表示 ChannelOutboundBuffer 未发生变化。</li>
</ul>
<h2 id="5-8-AbstractIdleTask"><a href="#5-8-AbstractIdleTask" class="headerlink" title="5.8 AbstractIdleTask"></a>5.8 AbstractIdleTask</h2><p>AbstractIdleTask ，实现 Runnable 接口，空闲任务抽象类。代码如下：</p>
<blockquote>
<p>AbstractIdleTask 是 IdleStateHandler 的内部静态类。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIdleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    AbstractIdleTask(ChannelHandlerContext ctx) {</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// &lt;1&gt; 忽略未打开的 Channel</span></span><br><span class="line">        <span class="keyword">if</span> (!ctx.channel().isOpen()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &lt;2&gt; 执行任务</span></span><br><span class="line">        run(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，忽略未打开的 Channel 。</li>
<li><code>&lt;2&gt;</code> 处，子类实现 <code>#run()</code> <strong>抽象</strong>方法，实现自定义的空闲检测逻辑。</li>
</ul>
<h3 id="5-8-1-ReaderIdleTimeoutTask"><a href="#5-8-1-ReaderIdleTimeoutTask" class="headerlink" title="5.8.1 ReaderIdleTimeoutTask"></a>5.8.1 ReaderIdleTimeoutTask</h3><p>ReaderIdleTimeoutTask ，继承 AbstractIdleTask 抽象类，检测 Read 空闲超时<strong>定时</strong>任务。代码如下：</p>
<blockquote>
<p>ReaderIdleTimeoutTask 是 IdleStateHandler 的内部静态类。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderIdleTimeoutTask</span> <span class="keyword">extends</span> <span class="title">AbstractIdleTask</span> </span>{</span><br><span class="line"> <span class="number">2</span>: </span><br><span class="line"> <span class="number">3</span>:     ReaderIdleTimeoutTask(ChannelHandlerContext ctx) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">super</span>(ctx);</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">8</span>:     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 计算下一次检测的定时任务的延迟</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">long</span> nextDelay = readerIdleTimeNanos;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">if</span> (!reading) {</span><br><span class="line"><span class="number">12</span>:             nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line"><span class="number">13</span>:         }</span><br><span class="line"><span class="number">14</span>: </span><br><span class="line"><span class="number">15</span>:         <span class="comment">// 如果小于等于 0 ，说明检测到读空闲</span></span><br><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) {</span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 延迟时间为 readerIdleTimeNanos ，即再次检测</span></span><br><span class="line"><span class="number">18</span>:             <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line"><span class="number">19</span>:             readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">20</span>: </span><br><span class="line"><span class="number">21</span>:             <span class="comment">// 获得当前是否首次检测到读空闲</span></span><br><span class="line"><span class="number">22</span>:             <span class="keyword">boolean</span> first = firstReaderIdleEvent;</span><br><span class="line"><span class="number">23</span>:             <span class="comment">// 标记 firstReaderIdleEvent 为 false 。也就说，下次检测到空闲，就非首次了。</span></span><br><span class="line"><span class="number">24</span>:             firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">27</span>:                 <span class="comment">// 创建读空闲事件</span></span><br><span class="line"><span class="number">28</span>:                 IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line"><span class="number">29</span>:                 <span class="comment">// 通知通道空闲事件</span></span><br><span class="line"><span class="number">30</span>:                 channelIdle(ctx, event);</span><br><span class="line"><span class="number">31</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">32</span>:                 <span class="comment">// 触发 Exception Caught 到下一个节点</span></span><br><span class="line"><span class="number">33</span>:                 ctx.fireExceptionCaught(t);</span><br><span class="line"><span class="number">34</span>:             }</span><br><span class="line"><span class="number">35</span>:         <span class="comment">// 如果大于 0 ，说明未检测到读空闲</span></span><br><span class="line"><span class="number">36</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">37</span>:             <span class="comment">// 延迟时间为 nextDelay ，即按照最后一次读的时间作为开始计数</span></span><br><span class="line"><span class="number">38</span>:             <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line"><span class="number">39</span>:             readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">40</span>:         }</span><br><span class="line"><span class="number">41</span>:     }</span><br><span class="line"><span class="number">42</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 9 至 13 行：计算下一次检测的定时任务的<strong>延迟</strong>。<ul>
<li><code>reading</code> 为 <code>true</code> 时，意味着正在读取，<strong>不会</strong>被检测为读空闲。 </li>
<li><code>reading</code> 为 <code>false</code> 时，实际 <code>nextDelay</code> 的计算为 <code>readerIdleTimeNanos - (ticksInNanos() - lastReadTime)</code> 。如果小于等于 0 ，意味着 <code>ticksInNanos() - lastReadTime &gt;=  readerIdleTimeNanos</code> ，超时。</li>
</ul>
</li>
<li>① 第 35 至 40 行：如果<strong>大于</strong> 0 ，说明未检测到读空闲。<ul>
<li>第 39 行：调用 <code>#schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit)</code> 方法，初始<strong>下一次</strong>的 ReaderIdleTimeoutTask 定时任务。其中，延迟时间为 <code>nextDelay</code> ，即按照最后一次读的时间作为开始计数。</li>
</ul>
</li>
<li>② 第 15 至 34 行：如果<strong>小于等于</strong> 0 ，说明检测到读空闲。<ul>
<li>第 19 行：调用 <code>#schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit)</code> 方法，初始<strong>下一次</strong>的 ReaderIdleTimeoutTask 定时任务。其中，延迟时间为 <code>readerIdleTimeNanos</code> ，即重新计数。</li>
<li>第 21 行：获得当前是否首次检测到读空闲。<ul>
<li>第 24 行：标记 <code>firstReaderIdleEvent</code> 为 <code>false</code> 。也就说，下次检测到空闲，就<strong>非首次</strong>了。</li>
</ul>
</li>
<li>第 28 行：调用 <code>#newIdleStateEvent(IdleState state, boolean first)</code> 方法，创建创建<strong>读</strong>空闲事件。<ul>
<li>第 30 行： 调用 <code>#channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt)</code> 方法，在 pipeline 中，触发 UserEvent 事件。</li>
</ul>
</li>
<li>第 31 至 34 行：如果<strong>发生异常</strong>，触发 Exception Caught 事件到下一个节点，处理异常。</li>
</ul>
</li>
</ul>
<h3 id="5-8-2-WriterIdleTimeoutTask"><a href="#5-8-2-WriterIdleTimeoutTask" class="headerlink" title="5.8.2 WriterIdleTimeoutTask"></a>5.8.2 WriterIdleTimeoutTask</h3><p>WriterIdleTimeoutTask ，继承 AbstractIdleTask 抽象类，检测 Write 空闲超时<strong>定时</strong>任务。代码如下：</p>
<blockquote>
<p>WriterIdleTimeoutTask 是 IdleStateHandler 的内部静态类。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterIdleTimeoutTask</span> <span class="keyword">extends</span> <span class="title">AbstractIdleTask</span> </span>{</span><br><span class="line"> <span class="number">2</span>: </span><br><span class="line"> <span class="number">3</span>:     WriterIdleTimeoutTask(ChannelHandlerContext ctx) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">super</span>(ctx);</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">8</span>:     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 计算下一次检测的定时任务的延迟</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">long</span> lastWriteTime = IdleStateHandler.<span class="keyword">this</span>.lastWriteTime;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">long</span> nextDelay = writerIdleTimeNanos - (ticksInNanos() - lastWriteTime);</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 如果小于等于 0 ，说明检测到写空闲</span></span><br><span class="line"><span class="number">14</span>:         <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) {</span><br><span class="line"><span class="number">15</span>:             <span class="comment">// 延迟时间为 writerIdleTimeout ，即再次检测</span></span><br><span class="line"><span class="number">16</span>:             <span class="comment">// Writer is idle - set a new timeout and notify the callback.</span></span><br><span class="line"><span class="number">17</span>:             writerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">18</span>: </span><br><span class="line"><span class="number">19</span>:             <span class="comment">// 获得当前是否首次检测到写空闲</span></span><br><span class="line"><span class="number">20</span>:             <span class="keyword">boolean</span> first = firstWriterIdleEvent;</span><br><span class="line"><span class="number">21</span>:             <span class="comment">// 标记 firstWriterIdleEvent 为 false 。也就说，下次检测到空闲，就非首次了。</span></span><br><span class="line"><span class="number">22</span>:             firstWriterIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">23</span>: </span><br><span class="line"><span class="number">24</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">25</span>:                 <span class="comment">// 判断 ChannelOutboundBuffer 是否发生变化</span></span><br><span class="line"><span class="number">26</span>:                 <span class="keyword">if</span> (hasOutputChanged(ctx, first)) {</span><br><span class="line"><span class="number">27</span>:                     <span class="keyword">return</span>;</span><br><span class="line"><span class="number">28</span>:                 }</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:                 <span class="comment">// 创建写空闲事件</span></span><br><span class="line"><span class="number">31</span>:                 IdleStateEvent event = newIdleStateEvent(IdleState.WRITER_IDLE, first);</span><br><span class="line"><span class="number">32</span>:                 <span class="comment">// 通知通道空闲事件</span></span><br><span class="line"><span class="number">33</span>:                 channelIdle(ctx, event);</span><br><span class="line"><span class="number">34</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">35</span>:                 <span class="comment">// 触发 Exception Caught 到下一个节点</span></span><br><span class="line"><span class="number">36</span>:                 ctx.fireExceptionCaught(t);</span><br><span class="line"><span class="number">37</span>:             }</span><br><span class="line"><span class="number">38</span>:         <span class="comment">// 如果大于 0 ，说明未检测到读空闲</span></span><br><span class="line"><span class="number">39</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">40</span>:             <span class="comment">// Write occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line"><span class="number">41</span>:             writerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="number">42</span>:         }</span><br><span class="line"><span class="number">43</span>:     }</span><br><span class="line"><span class="number">44</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 9 至 11 行：计算下一次检测的定时任务的<strong>延迟</strong>。</li>
<li>① 第 38 至 42 行：如果<strong>大于</strong> 0 ，说明未检测到写空闲。<ul>
<li>第 39 行：调用 <code>#schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit)</code> 方法，初始<strong>下一次</strong>的 WriterIdleTimeoutTask 定时任务。其中，延迟时间为 <code>nextDelay</code> ，即按照最后一次写的时间作为开始计数。</li>
</ul>
</li>
<li>② 第 13 至 37 行：如果<strong>小于等于</strong> 0 ，说明检测到写空闲。<ul>
<li>第 17 行：调用 <code>#schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit)</code> 方法，初始<strong>下一次</strong>的 WriterIdleTimeoutTask 定时任务。其中，延迟时间为 <code>readerIdleTimeNanos</code> ，即重新计数。</li>
<li>第 20 行：获得当前是否首次检测到写空闲。<ul>
<li>第 22 行：标记 <code>firstWriterIdleEvent</code> 为 <code>false</code> 。也就说，下次检测到空闲，就<strong>非首次</strong>了。</li>
</ul>
</li>
<li>第 25 至 28 行：判断 ChannelOutboundBuffer 是否发生变化。如果有变化，不触发写空闲时间。</li>
<li>第 31 行：调用 <code>#newIdleStateEvent(IdleState state, boolean first)</code> 方法，创建创建<strong>写</strong>空闲事件。<ul>
<li>第 33 行： 调用 <code>#channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt)</code> 方法，在 pipeline 中，触发 UserEvent 事件。</li>
</ul>
</li>
<li>第 34 至 37 行：如果<strong>发生异常</strong>，触发 Exception Caught 事件到下一个节点，处理异常。</li>
</ul>
</li>
</ul>
<h3 id="5-8-3-AllIdleTimeoutTask"><a href="#5-8-3-AllIdleTimeoutTask" class="headerlink" title="5.8.3 AllIdleTimeoutTask"></a>5.8.3 AllIdleTimeoutTask</h3><p>AllIdleTimeoutTask ，继承 AbstractIdleTask 抽象类，检测 All 空闲超时<strong>定时</strong>任务。代码如下：</p>
<blockquote>
<p>AllIdleTimeoutTask 是 IdleStateHandler 的内部静态类。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AllIdleTimeoutTask</span> <span class="keyword">extends</span> <span class="title">AbstractIdleTask</span> </span>{</span><br><span class="line"></span><br><span class="line">    AllIdleTimeoutTask(ChannelHandlerContext ctx) {</span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">        <span class="comment">// 计算下一次检测的定时任务的延迟</span></span><br><span class="line">        <span class="keyword">long</span> nextDelay = allIdleTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (!reading) {</span><br><span class="line">            nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime); <span class="comment">// &lt;1&gt; 取大值</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果小于等于 0 ，说明检测到 all 空闲</span></span><br><span class="line">        <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 延迟时间为 allIdleTimeNanos ，即再次检测</span></span><br><span class="line">            <span class="comment">// Both reader and writer are idle - set a new timeout and</span></span><br><span class="line">            <span class="comment">// notify the callback.</span></span><br><span class="line">            allIdleTimeout = schedule(ctx, <span class="keyword">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得当前是否首次检测到 all 空闲</span></span><br><span class="line">            <span class="keyword">boolean</span> first = firstAllIdleEvent;</span><br><span class="line">            <span class="comment">// 标记 firstAllIdleEvent 为 false 。也就说，下次检测到空闲，就非首次了。</span></span><br><span class="line">            firstAllIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 判断 ChannelOutboundBuffer 是否发生变化</span></span><br><span class="line">                <span class="keyword">if</span> (hasOutputChanged(ctx, first)) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建 all 空闲事件</span></span><br><span class="line">                IdleStateEvent event = newIdleStateEvent(IdleState.ALL_IDLE, first);</span><br><span class="line">                <span class="comment">// 通知通道空闲事件</span></span><br><span class="line">                channelIdle(ctx, event);</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                ctx.fireExceptionCaught(t);</span><br><span class="line">            }</span><br><span class="line">        <span class="comment">// 如果大于 0 ，说明未检测到 all 空闲</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Either read or write occurred before the timeout - set a new</span></span><br><span class="line">            <span class="comment">// timeout with shorter delay.</span></span><br><span class="line">            allIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 All 是 Write 和 Read <strong>任一</strong>一种空闲即可，所以 AllIdleTimeoutTask 是 ReaderIdleTimeoutTask 和 WriterIdleTimeoutTask 的<strong>综合</strong>。</li>
<li><code>&lt;1&gt;</code> 处，取 <code>lastReadTime</code> 和 <code>lastWriteTime</code> 中的<strong>大</strong>值，从而来判断，是否有 Write 和 Read <strong>任一</strong>一种空闲。</li>
<li>WriterIdleTimeoutTask 就不详细解析，胖友自己读读代码即可。</li>
</ul>
<h1 id="6-ReadTimeoutHandler"><a href="#6-ReadTimeoutHandler" class="headerlink" title="6. ReadTimeoutHandler"></a>6. ReadTimeoutHandler</h1><p><code>io.netty.handler.timeout.ReadTimeoutHandler</code> ，继承 IdleStateHandler 类，当 Channel 的<strong>读</strong>空闲时间( 读或者写 )太长时，抛出 ReadTimeoutException 异常，并自动关闭该 Channel 。</p>
<h2 id="6-1-构造方法"><a href="#6-1-构造方法" class="headerlink" title="6.1 构造方法"></a>6.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Channel 是否关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReadTimeoutHandler</span><span class="params">(<span class="keyword">int</span> timeoutSeconds)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(timeoutSeconds, TimeUnit.SECONDS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReadTimeoutHandler</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="comment">// 禁用 Write / All 的空闲检测</span></span><br><span class="line">    <span class="keyword">super</span>(timeout, <span class="number">0</span>, <span class="number">0</span>, unit); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>closed</code> 属性，Channel 是否关闭。</li>
<li><code>&lt;1&gt;</code> 处，禁用 Write / All 的空闲检测，只根据 <code>timeout</code> 方法参数，开启 Read 的空闲检测。</li>
</ul>
<h2 id="6-2-channelIdle"><a href="#6-2-channelIdle" class="headerlink" title="6.2 channelIdle"></a>6.2 channelIdle</h2><p><code>#channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt)</code> 方法，覆写父类方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">assert</span> evt.state() == IdleState.READER_IDLE;</span><br><span class="line">    readTimedOut(ctx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is called when a read timeout was detected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readTimedOut</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (!closed) {</span><br><span class="line">        <span class="comment">// &lt;1&gt; 触发 Exception Caught 事件到 pipeline 中，异常为 ReadTimeoutException</span></span><br><span class="line">        ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);</span><br><span class="line">        <span class="comment">// &lt;2&gt; 关闭 Channel 通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">        <span class="comment">// &lt;3&gt; 标记 Channel 为已关闭</span></span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，触发 Exception Caught 事件到 pipeline 中，异常为 ReadTimeoutException 。</li>
<li><code>&lt;2&gt;</code> 处，关闭 Channel 通道。</li>
<li><code>&lt;3&gt;</code> 处，标记 Channel 为已关闭。</li>
</ul>
<h1 id="7-WriteTimeoutHandler"><a href="#7-WriteTimeoutHandler" class="headerlink" title="7. WriteTimeoutHandler"></a>7. WriteTimeoutHandler</h1><p><code>io.netty.handler.timeout.WriteTimeoutHandler</code> ，继承 ChannelOutboundHandlerAdapter 类，当一个<strong>写</strong>操作不能在指定时间内完成时，抛出 WriteTimeoutException 异常，并自动关闭对应 Channel 。</p>
<p>😈 <strong>注意，这里写入，指的是 flush 到对端 Channel ，而不仅仅是写到 ChannelOutboundBuffer 队列</strong>。</p>
<h2 id="7-1-构造方法"><a href="#7-1-构造方法" class="headerlink" title="7.1 构造方法"></a>7.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小的超时时间，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超时时间，单位：纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeoutNanos;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WriteTimeoutTask 双向链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * lastTask 为链表的尾节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A doubly-linked list to track all WriteTimeoutTasks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> WriteTimeoutTask lastTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Channel 是否关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WriteTimeoutHandler</span><span class="params">(<span class="keyword">int</span> timeoutSeconds)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(timeoutSeconds, TimeUnit.SECONDS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WriteTimeoutHandler</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) {</span><br><span class="line">        timeoutNanos = <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        timeoutNanos = Math.max(unit.toNanos(timeout), MIN_TIMEOUT_NANOS); <span class="comment">// 保证大于等于 MIN_TIMEOUT_NANOS</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>timeoutNanos</code> 属性，写入超时时间，单位：纳秒。<ul>
<li><code>MIN_TIMEOUT_NANOS</code> 属性，最小的超时时间，单位：纳秒。</li>
</ul>
</li>
<li><code>lastTask</code> 属性，WriteTimeoutTask 双向链表。其中，<code>lastTask</code> 为链表的<strong>尾节点</strong>。</li>
<li><code>closed</code> 属性，Channel 是否关闭。</li>
</ul>
<h2 id="7-2-handlerRemoved"><a href="#7-2-handlerRemoved" class="headerlink" title="7.2 handlerRemoved"></a>7.2 handlerRemoved</h2><p><code>#handlerRemoved(ChannelHandlerContext ctx)</code> 方法，移除所有 WriteTimeoutTask 任务，并取消。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    WriteTimeoutTask task = lastTask;</span><br><span class="line">    <span class="comment">// 置空 lastTask</span></span><br><span class="line">    lastTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 循环移除，知道为空</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 取消当前任务的定时任务</span></span><br><span class="line">        task.scheduledFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 记录前一个任务</span></span><br><span class="line">        WriteTimeoutTask prev = task.prev;</span><br><span class="line">        <span class="comment">// 置空当前任务的前后节点</span></span><br><span class="line">        task.prev = <span class="keyword">null</span>;</span><br><span class="line">        task.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 跳到前一个任务</span></span><br><span class="line">        task = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。</li>
</ul>
<h2 id="7-3-write"><a href="#7-3-write" class="headerlink" title="7.3 write"></a>7.3 write</h2><p><code>#write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (timeoutNanos &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果 promise 是 VoidPromise ，则包装成非 VoidPromise ，为了后续的回调。</span></span><br><span class="line">        promise = promise.unvoid(); &lt;<span class="number">1</span>》</span><br><span class="line">        <span class="comment">// 创建定时任务</span></span><br><span class="line">        scheduleTimeout(ctx, promise);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    ctx.write(msg, promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，如果 <code>promise</code> 类型是 VoidPromise ，则包装成非 VoidPromise ，为了后续的回调。因为 VoidPromise 无法接收到回调。</li>
<li><code>&lt;2&gt;</code> 处，调用 <code>#scheduleTimeout(final ChannelHandlerContext ctx, final ChannelPromise promise)</code> 方法，创建定时任务。详细解析，见 <a href="#">「7.4 scheduleTimeout」</a> 。</li>
</ul>
<h2 id="7-4-scheduleTimeout"><a href="#7-4-scheduleTimeout" class="headerlink" title="7.4 scheduleTimeout"></a>7.4 scheduleTimeout</h2><p><code>#scheduleTimeout(final ChannelHandlerContext ctx, final ChannelPromise promise)</code> 方法，创建定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleTimeout</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// Schedule a timeout.</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 创建 WriteTimeoutTask 任务</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">final</span> WriteTimeoutTask task = <span class="keyword">new</span> WriteTimeoutTask(ctx, promise);</span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 定时任务</span></span><br><span class="line"> <span class="number">6</span>:     task.scheduledFuture = ctx.executor().schedule(task, timeoutNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"> <span class="number">7</span>: </span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (!task.scheduledFuture.isDone()) {</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 添加到链表</span></span><br><span class="line"><span class="number">10</span>:         addWriteTimeoutTask(task);</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:         <span class="comment">// Cancel the scheduled timeout if the flush promise is complete.</span></span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 将 task 作为监听器，添加到 promise 中。在写入完成后，可以移除该定时任务</span></span><br><span class="line"><span class="number">14</span>:         promise.addListener(task);</span><br><span class="line"><span class="number">15</span>:     }</span><br><span class="line"><span class="number">16</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 6 行：创建 WriteTimeoutTask 任务，并发起<strong>定时任务</strong>。</li>
<li>第 8 行：如果定时任务<strong>已经执行完成</strong>，则不需要进行监听。否则，需要执行【第 10 至 14 行】的代码逻辑。</li>
<li>第 10 行：调用 <code>#addWriteTimeoutTask(WriteTimeoutTask task)</code> 方法，添加到链表。详细解析，见 <a href="#">「7.5 addWriteTimeoutTask」</a> 。 </li>
<li>第 14 行：将 <code>task</code> 作为监听器，添加到 <code>promise</code> 中。在写入完成后，可以移除该定时任务。也就说，调用链是 <code>flush =&gt; 回调 =&gt; promise =&gt; 回调 =&gt; task</code> 。</li>
</ul>
<h2 id="7-5-addWriteTimeoutTask"><a href="#7-5-addWriteTimeoutTask" class="headerlink" title="7.5 addWriteTimeoutTask"></a>7.5 addWriteTimeoutTask</h2><p><code>#addWriteTimeoutTask(WriteTimeoutTask task)</code> 方法，添加到链表。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWriteTimeoutTask</span><span class="params">(WriteTimeoutTask task)</span> </span>{</span><br><span class="line">    <span class="comment">// 添加到链表的尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (lastTask != <span class="keyword">null</span>) {</span><br><span class="line">        lastTask.next = task;</span><br><span class="line">        task.prev = lastTask;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 修改 lastTask 为当前任务</span></span><br><span class="line">    lastTask = task;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>添加到链表的尾节点，并修改 <code>lastTask</code> 为<strong>当前</strong>任务。</p>
<h2 id="7-6-removeWriteTimeoutTask"><a href="#7-6-removeWriteTimeoutTask" class="headerlink" title="7.6 removeWriteTimeoutTask"></a>7.6 removeWriteTimeoutTask</h2><p><code>#removeWriteTimeoutTask(WriteTimeoutTask task)</code> 方法，移除出链表。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWriteTimeoutTask</span><span class="params">(WriteTimeoutTask task)</span> </span>{</span><br><span class="line">    <span class="comment">// 从双向链表中，移除自己</span></span><br><span class="line">    <span class="keyword">if</span> (task == lastTask) { <span class="comment">// 尾节点</span></span><br><span class="line">        <span class="comment">// task is the tail of list</span></span><br><span class="line">        <span class="keyword">assert</span> task.next == <span class="keyword">null</span>;</span><br><span class="line">        lastTask = lastTask.prev;</span><br><span class="line">        <span class="keyword">if</span> (lastTask != <span class="keyword">null</span>) {</span><br><span class="line">            lastTask.next = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (task.prev == <span class="keyword">null</span> &amp;&amp; task.next == <span class="keyword">null</span>) { <span class="comment">// 已经被移除</span></span><br><span class="line">        <span class="comment">// Since task is not lastTask, then it has been removed or not been added.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (task.prev == <span class="keyword">null</span>) { <span class="comment">// 头节点</span></span><br><span class="line">        <span class="comment">// task is the head of list and the list has at least 2 nodes</span></span><br><span class="line">        task.next.prev = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 中间的节点</span></span><br><span class="line">        task.prev.next = task.next;</span><br><span class="line">        task.next.prev = task.prev;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 重置 task 前后节点为空</span></span><br><span class="line">    task.prev = <span class="keyword">null</span>;</span><br><span class="line">    task.next = <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该方法的调用，在 <a href="#">「7.8 WriteTimeoutTask」</a> 会看到。</p>
<h2 id="7-7-writeTimedOut"><a href="#7-7-writeTimedOut" class="headerlink" title="7.7 writeTimedOut"></a>7.7 writeTimedOut</h2><p><code>#writeTimedOut(ChannelHandlerContext ctx)</code> 方法，写入超时，关闭 Channel 通道。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is called when a write timeout was detected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeTimedOut</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (!closed) {</span><br><span class="line">        <span class="comment">// 触发 Exception Caught 事件到 pipeline 中，异常为 WriteTimeoutException</span></span><br><span class="line">        ctx.fireExceptionCaught(WriteTimeoutException.INSTANCE);</span><br><span class="line">        <span class="comment">// 关闭 Channel 通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">        <span class="comment">// 标记 Channel 为已关闭</span></span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>和 <code>ReadTimeoutHandler#readTimeout(ChannelHandlerContext ctx)</code> 方法，基本类似。</li>
</ul>
<p>该方法的调用，在 <a href="#">「7.8 WriteTimeoutTask」</a> 会看到。</p>
<h2 id="7-8-WriteTimeoutTask"><a href="#7-8-WriteTimeoutTask" class="headerlink" title="7.8 WriteTimeoutTask"></a>7.8 WriteTimeoutTask</h2><p>WriteTimeoutTask ，实现 Runnable 和 ChannelFutureListener 接口，写入超时任务。</p>
<blockquote>
<p>WriteTimeoutTask 是 WriteTimeoutHandler 的内部类。</p>
</blockquote>
<h3 id="7-8-1-构造方法"><a href="#7-8-1-构造方法" class="headerlink" title="7.8.1 构造方法"></a>7.8.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入任务的 Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelPromise promise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteTimeoutTask is also a node of a doubly-linked list</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前一个 task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WriteTimeoutTask prev;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后一个 task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WriteTimeoutTask next;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduledFuture;</span><br><span class="line"></span><br><span class="line">WriteTimeoutTask(ChannelHandlerContext ctx, ChannelPromise promise) {</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    <span class="keyword">this</span>.promise = promise;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-8-2-run"><a href="#7-8-2-run" class="headerlink" title="7.8.2 run"></a>7.8.2 run</h3><p>当定时任务执行，说明写入任务执行超时。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Was not written yet so issue a write timeout</span></span><br><span class="line">    <span class="comment">// The promise itself will be failed with a ClosedChannelException once the close() was issued</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/2159</span></span><br><span class="line">    <span class="keyword">if</span> (!promise.isDone()) { <span class="comment">// 未完成，说明写入超时</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// &lt;1&gt; 写入超时，关闭 Channel 通道</span></span><br><span class="line">            writeTimedOut(ctx);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="comment">// 触发 Exception Caught 事件到 pipeline 中</span></span><br><span class="line">            ctx.fireExceptionCaught(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;2&gt; 移除出链表</span></span><br><span class="line">    removeWriteTimeoutTask(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>#writeTimedOut(ChannelHandlerContext ctx)</code> 方法，写入超时，关闭 Channel 通道。</li>
<li><code>&lt;2&gt;</code> 处，调用 <code>#removeWriteTimeoutTask(WriteTimeoutTask task)</code> 方法，移除出链表。</li>
</ul>
<h3 id="7-8-3-operationComplete"><a href="#7-8-3-operationComplete" class="headerlink" title="7.8.3 operationComplete"></a>7.8.3 operationComplete</h3><p>当回调方法执行，说明写入任务执行完成。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// scheduledFuture has already be set when reaching here</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 取消定时任务</span></span><br><span class="line">    scheduledFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 移除出链表</span></span><br><span class="line">    removeWriteTimeoutTask(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，取消定时任务。</li>
<li><code>&lt;2&gt;</code> 处，调用 <code>#removeWriteTimeoutTask(WriteTimeoutTask task)</code> 方法，移除出链表。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>和 「5.7 hasOutputChanged」(#) 小节，这个方法较真了好久。感谢中间，基友【莫那一鲁道】的沟通。</p>
<p>推荐阅读文章：</p>
<ul>
<li>莫那一鲁道 <a href="https://www.jianshu.com/p/f2ed73cf4df8" rel="external nofollow noopener noreferrer" target="_blank">《Netty 心跳服务之 IdleStateHandler 源码分析》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/a9bcd89553f5" rel="external nofollow noopener noreferrer" target="_blank">自顶向下深入分析Netty（八）–ChannelHandler</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ChannelHandler-5-idle/" data-id="ck4pl3fpa00effgcf42gighgh" class="article-share-link">分享</a>



</footer>
-->
</div>