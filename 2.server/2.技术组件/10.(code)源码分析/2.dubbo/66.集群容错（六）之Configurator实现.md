# é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆäº”ï¼‰ä¹‹ Merger å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-5-impl-merger/?self) ä¸€æ–‡ï¼Œåˆ†äº«

dubbo-cluster
æ¨¡å—ï¼Œ

configurator
åŒ…ï¼Œå®ç° Dubbo çš„**é…ç½®è§„åˆ™**åŠŸèƒ½ã€‚

Configurator ç›¸å…³ç±»ï¼Œå¦‚ä¸‹å›¾ï¼š

![Configurator ç›¸å…³ç±»](http://static2.iocoder.cn/images/Dubbo/2019_04_25/01.png)
è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” é…ç½®è§„åˆ™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html) æ–‡æ¡£ã€‚å¦‚æœä¹‹å‰æ²¡äº†è§£è¿‡è¯¥åŠŸèƒ½çš„èƒ–å‹ï¼Œè¯·å…ˆé˜…è¯»äº†è§£ä¸‹å“ˆã€‚

# 2. ConfiguratorFactory

com.alibaba.dubbo.rpc.cluster.ConfiguratorFactory
ï¼ŒConfigurator å·¥å‚æ¥å£ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
@SPI
public interface ConfiguratorFactory{
//*/*
/* get the configurator instance.
/*
/* @param url - configurator url.
/* @return configurator instance.
/*/
@Adaptive("protocol")
Configurator getConfigurator(URL url);
}
```

* @SPI
æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œæ— é»˜è®¤å€¼ã€‚
* @Adaptive("protocol")
æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Configurator å®ç°ï¼Œä½¿ç”¨

URL.protocol
å±æ€§ã€‚
* /#getConfigurator(URL url)
æ¥å£æ–¹æ³•ï¼Œè·å¾— Configurator å¯¹è±¡ã€‚

## 2.1 OverrideConfiguratorFactory

com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfiguratorFactory
ï¼Œå®ç° ConfiguratorFactory æ¥å£ï¼Œ**OverrideConfigurator** å·¥å‚ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class OverrideConfiguratorFactory implements ConfiguratorFactory{
@Override
public Configurator getConfigurator(URL url){
return new OverrideConfigurator(url);
}
}
```

## 2.2 AbsentConfiguratorFactory

com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfiguratorFactory
ï¼Œå®ç° ConfiguratorFactory æ¥å£ï¼Œ**AbsentConfigurator** å·¥å‚ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class AbsentConfiguratorFactory implements ConfiguratorFactory{
@Override
public Configurator getConfigurator(URL url){
return new AbsentConfigurator(url);
}
}
```

# 3. Configurator

com.alibaba.dubbo.rpc.cluster.Configurator
ï¼Œå®ç° Comparable æ¥å£ï¼Œ**é…ç½®è§„åˆ™**æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public interface Configurator extends Comparable<Configurator>{
//*/*
/* get the configurator url.
/*
/* é…ç½®è§„åˆ™
/*
/* @return configurator url.
/*/
URL getUrl();
//*/*
/* Configure the provider url.
/*
/* é…ç½®åˆ° URL ä¸­
/*
/* @param url - old rovider url.
/* @return new provider url.
/*/
URL configure(URL url);
}
```

* **ä¸€ä¸ª Configurator å¯¹è±¡ï¼Œå¯¹åº”ä¸€æ¡é…ç½®è§„åˆ™**ã€‚
* Configurator æœ‰**ä¼˜å…ˆçº§**çš„è¦æ±‚ï¼Œæ‰€ä»¥å®ç° Comparable æ¥å£ã€‚
* /#getUrl()
æ¥å£æ–¹æ³•ï¼Œè·å¾—é…ç½® URL ï¼Œé‡Œé¢å¸¦æœ‰é…ç½®è§„åˆ™ã€‚
* /#configure(Url url)
æ¥å£æ–¹æ³•ï¼Œ**è®¾ç½®**é…ç½®è§„åˆ™åˆ°æŒ‡å®š URL ä¸­ã€‚

## 3.1 AbstractConfigurator

com.alibaba.dubbo.rpc.cluster.configurator.AbstractConfigurator
ï¼Œå®ç° Configurator æ¥å£ï¼Œå®ç°å…¬ç”¨çš„é…ç½®è§„åˆ™çš„**åŒ¹é…**ã€**æ’åº**çš„é€»è¾‘ã€‚

### 3.1.1 getUrl

```
//*/*
/* é…ç½®è§„åˆ™ URL
/*/
private final URL configuratorUrl;
public AbstractConfigurator(URL url){
if (url == null) {
throw new IllegalArgumentException("configurator url == null");
}
this.configuratorUrl = url;
}
@Override
public URL getUrl(){
return configuratorUrl;
}
```

### 3.1.2 configure

```
1: @Override
2: public URL configure(URL url){
3: if (configuratorUrl.getHost() == null || url == null || url.getHost() == null) {
4: return url;
5: }
6: // If override url has port, means it is a provider address. We want to control a specific provider with this override url, it may take effect on the specific provider instance or on consumers holding this provider instance.
7: // é…ç½®è§„åˆ™ï¼ŒURL å¸¦æœ‰ç«¯å£( port )ï¼Œæ„å›¾æ˜¯æ§åˆ¶æä¾›è€…æœºå™¨ã€‚å¯ä»¥åœ¨æä¾›ç«¯ç”Ÿæ•ˆ ä¹Ÿå¯ä»¥åœ¨æ¶ˆè´¹ç«¯ç”Ÿæ•ˆ
8: if (configuratorUrl.getPort() != 0) {
9: if (url.getPort() == configuratorUrl.getPort()) {
10: return configureIfMatch(url.getHost(), url);
11: }
12: // override url don't have a port, means the ip override url specify is a consumer address or 0.0.0.0
13: // é…ç½®è§„åˆ™ï¼ŒURL æ²¡æœ‰ç«¯å£ï¼Œoverride è¾“å…¥æ¶ˆè´¹ç«¯åœ°å€ æˆ–è€… 0.0.0.0
14: } else {
15: // 1.If it is a consumer ip address, the intention is to control a specific consumer instance, it must takes effect at the consumer side, any provider received this override url should ignore;
16: // 2.If the ip is 0.0.0.0, this override url can be used on consumer, and also can be used on provider
17: // 1. å¦‚æœæ˜¯æ¶ˆè´¹ç«¯åœ°å€ï¼Œåˆ™æ„å›¾æ˜¯æ§åˆ¶æ¶ˆè´¹è€…æœºå™¨ï¼Œå¿…å®šåœ¨æ¶ˆè´¹ç«¯ç”Ÿæ•ˆï¼Œæä¾›ç«¯å¿½ç•¥ï¼›
18: // 2. å¦‚æœæ˜¯0.0.0.0å¯èƒ½æ˜¯æ§åˆ¶æä¾›ç«¯ï¼Œä¹Ÿå¯èƒ½æ˜¯æ§åˆ¶æä¾›ç«¯
19: if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {
20: // NetUtils.getLocalHostæ˜¯æ¶ˆè´¹ç«¯æ³¨å†Œåˆ°zkçš„æ¶ˆè´¹è€…åœ°å€
21: return configureIfMatch(NetUtils.getLocalHost(), url);// NetUtils.getLocalHost is the ip address consumer registered to registry.
22: } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {
23: // æ§åˆ¶æ‰€æœ‰æä¾›ç«¯ï¼Œåœ°å€å¿…å®šæ˜¯0.0.0.0ï¼Œå¦åˆ™å°±è¦é…ç«¯å£ä»è€Œæ‰§è¡Œä¸Šé¢çš„ifåˆ†æ”¯äº†
24: return configureIfMatch(Constants.ANYHOST_VALUE, url);// take effect on all providers, so address must be 0.0.0.0, otherwise it won't flow to this if branch
25: }
26: }
27: return url;
28: }
```

* æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œã€ç¬¬ 6 è‡³ 26 è¡Œã€‘ä¸€å…±æœ‰**ä¸‰ç§**æƒ…å†µçš„åˆ¤æ–­ï¼š

* ã€ç¬¬ä¸€ç§ã€‘ç¬¬ 8 è¡Œï¼š

configuratorUrl
å¸¦æœ‰**ç«¯å£( port )**ï¼Œæ„å›¾æ˜¯åŒ¹é…**æŒ‡å®šä¸€ä¸ª**æœåŠ¡æä¾›è€…ï¼Œå› æ­¤ä½¿ç”¨

url.host
å±æ€§ã€‚
* ã€ç¬¬äºŒç§ã€‘ç¬¬ 19 è¡Œï¼š

url
çš„

side = consumer
ï¼Œæ„å›¾æ˜¯åŒ¹é…æœåŠ¡æ¶ˆè´¹è€…ï¼Œå› æ­¤ä½¿ç”¨

NetUtils/#getLocalHost()
å±æ€§ã€‚
* ã€ç¬¬ä¸‰ç§ã€‘ç¬¬ 22 è¡Œï¼š

url
çš„

side = provider
ï¼Œæ„å›¾æ˜¯åŒ¹é…**å…¨éƒ¨**æœåŠ¡æä¾›è€…ï¼Œå› æ­¤ä½¿ç”¨

Constants.ANYHOST_VALUE = /*
å±æ€§ã€‚ğŸ™‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œç›®å‰æš‚ä¸æ”¯æŒ**æŒ‡å®šæœºå™¨**æœåŠ¡æä¾›è€…ã€‚
* ç¬¬ 10 è¡Œ || ç¬¬ 21 è¡Œ || ç¬¬ 24 è¡Œï¼šè°ƒç”¨

/#configureIfMatch(host, url)
æ–¹æ³•ï¼Œé…ç½®åˆ°

url
ä¸­ï¼Œè‹¥é…ç½®è§„åˆ™åŒ¹é…ã€‚

### 3.1.2.1 configureIfMatch

```
1: private URL configureIfMatch(String host, URL url){
2: // åŒ¹é… Host
3: if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) {
4: // åŒ¹é… "application"
5: String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY, configuratorUrl.getUsername()); // TODO èŠ‹è‰¿ï¼Œä¸ºå•¥ username
6: String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());
7: if (configApplication == null || Constants.ANY_VALUE.equals(configApplication)
8: || configApplication.equals(currentApplication)) {
9: // é…ç½® URL ä¸­çš„æ¡ä»¶ KEYS é›†åˆã€‚å…¶ä¸­ä¸‹é¢å››ä¸ª KEY ï¼Œä¸ç®—æ˜¯æ¡ä»¶ï¼Œè€Œæ˜¯å†…ç½®å±æ€§ã€‚è€ƒè™‘åˆ°ä¸‹é¢è¦ç§»é™¤ï¼Œæ‰€ä»¥æ·»åŠ åˆ°è¯¥é›†åˆä¸­ã€‚
10: Set<String> conditionKeys = new HashSet<String>();
11: conditionKeys.add(Constants.CATEGORY_KEY);
12: conditionKeys.add(Constants.CHECK_KEY);
13: conditionKeys.add(Constants.DYNAMIC_KEY);
14: conditionKeys.add(Constants.ENABLED_KEY);
15: // åˆ¤æ–­ä¼ å…¥çš„ url æ˜¯å¦åŒ¹é…é…ç½®è§„åˆ™ URL çš„æ¡ä»¶ã€‚é™¤äº† "application" å’Œ "side" ä¹‹å¤–ï¼Œå¸¦æœ‰ `"~"` å¼€å¤´çš„ KEY ï¼Œä¹Ÿæ˜¯æ¡ä»¶ã€‚
16: for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {
17: String key = entry.getKey();
18: String value = entry.getValue();
19: if (key.startsWith("~") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) {
20: conditionKeys.add(key);
21: // è‹¥ä¸ç›¸ç­‰ï¼Œåˆ™ä¸åŒ¹é…é…ç½®è§„åˆ™ï¼Œç›´æ¥è¿”å›
22: if (value != null && !Constants.ANY_VALUE.equals(value)
23: && !value.equals(url.getParameter(key.startsWith("~") ? key.substring(1) : key))) {
24: return url;
25: }
26: }
27: }
28: // ç§»é™¤æ¡ä»¶ KEYS é›†åˆï¼Œå¹¶é…ç½®åˆ° URL ä¸­
29: return doConfigure(url, configuratorUrl.removeParameters(conditionKeys));
30: }
31: }
32: return url;
33: }
```

* ç¬¬ 3 è¡Œï¼šåŒ¹é… **HOST** ã€‚
* ç¬¬ 4 è‡³ 8 è¡Œï¼šåŒ¹é… **
"application"
** ã€‚
* ç¬¬ 9 è‡³ 14 è¡Œï¼šé…ç½® URL ä¸­çš„**æ¡ä»¶ KEYS é›†åˆ**ã€‚å…¶ä¸­ä¸‹é¢å››ä¸ª KEY ï¼Œä¸ç®—æ˜¯æ¡ä»¶ï¼Œè€Œæ˜¯**å†…ç½®å±æ€§**ã€‚è€ƒè™‘åˆ°ä¸‹é¢è¦ç§»é™¤ï¼Œæ‰€ä»¥æ·»åŠ åˆ°è¯¥é›†åˆä¸­ã€‚
* ç¬¬ 15 è‡³ 27 è¡Œï¼šåˆ¤æ–­ä¼ å…¥çš„

url
æ˜¯å¦åŒ¹é…é…ç½®è§„åˆ™ URL çš„æ¡ä»¶ã€‚é™¤äº†

"application"
å’Œ

"side"
ä¹‹å¤–ï¼Œ**å¸¦æœ‰

"~"
å¼€å¤´çš„ KEY ï¼Œä¹Ÿæ˜¯æ¡ä»¶**ã€‚

* ç¬¬ 21 è‡³ 25 è¡Œï¼š è‹¥**ä¸ç›¸ç­‰**ï¼Œåˆ™**ä¸åŒ¹é…**é…ç½®è§„åˆ™ï¼Œç›´æ¥è¿”å›

url
ã€‚
* ç¬¬ 29 è¡Œï¼šä»

configuratorUrl
**ç§»é™¤**æ¡ä»¶ KEYS é›†åˆï¼Œå¹¶è°ƒç”¨

/#doConfigure(URL currentUrl, URL configUrl)
**æŠ½è±¡**æ–¹æ³•ï¼Œå®ç°**å­ç±»**è®¾ç½®**é…ç½®è§„åˆ™**åˆ°

url
ä¸­ã€‚

### 3.1.2.2 doConfigure

```
protected abstract URL doConfigure(URL currentUrl, URL configUrl);
```

### 3.1.3 compareTo

```
@Override
public int compareTo(Configurator o){
if (o == null) {
return -1;
}
// host å‡åº
int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());
// è‹¥ host ç›¸åŒï¼ŒæŒ‰ç…§ priority é™åº
if (ipCompare == 0) {//host is the same, sort by priority
int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0);
int j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);
if (i < j) {
return -1;
} else if (i > j) {
return 1;
} else {
return 0;
}
} else {
return ipCompare;
}
}
```

* ä¼˜å…ˆï¼ŒæŒ‰ç…§ host **å‡åº**ï¼Œå³**ç‰¹å®š** host **é«˜**äº **anyhost**(

"0.0.0.0"
) ã€‚
* å…¶æ¬¡ï¼ŒæŒ‰ç…§

"priority"
**é™åº**ã€‚

## 3.2 OverrideConfigurator

com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfigurator
ï¼Œå®ç° AbstractConfigurator æŠ½è±¡ç±»ï¼Œ

override
Configurator å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class OverrideConfigurator extends AbstractConfigurator{
public OverrideConfigurator(URL url){
super(url);
}
@Override
public URL doConfigure(URL currentUrl, URL configUrl){
return currentUrl.addParameters(configUrl.getParameters()); // è¦†ç›–æ·»åŠ 
}
}
```

* **è¦†ç›–**æ·»åŠ ã€‚

## 3.3 AbsentConfigurator

com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfigurator
ï¼Œå®ç° AbstractConfigurator æŠ½è±¡ç±»ï¼Œ

absent
Configurator å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class AbsentConfigurator extends AbstractConfigurator{
public AbsentConfigurator(URL url){
super(url);
}
@Override
public URL doConfigure(URL currentUrl, URL configUrl){
return currentUrl.addParametersIfAbsent(configUrl.getParameters()); // ä¸å­˜åœ¨æ—¶æ·»åŠ 
}
}
```

* **ä¸å­˜åœ¨æ—¶**æ·»åŠ ã€‚

ä»ç›®å‰

dubbo-admin
é¡¹ç›®æ¥çœ‹ï¼Œç›®å‰**æš‚æœªä½¿ç”¨**

absent
çš„é…ç½®è§„åˆ™ã€‚

# 4. é›†æˆ Configurator æ¨¡å—

å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ‰**ä¸‰ä¸ªç±»**ï¼Œè°ƒç”¨

Configurator/#configure(URL url)
æ–¹æ³•ï¼Œé›†æˆ Configurator æ¨¡å—ã€‚

![é›†æˆ](http://static2.iocoder.cn/images/Dubbo/2019_04_25/02.png)

## 4.1 RegistryDirectory

RegistryDirectory å°†é…ç½®è§„åˆ™é›†æˆåˆ°å…¶ä¸­ï¼Œä»è€Œé›†æˆåˆ°**æœåŠ¡æ¶ˆè´¹è€…**ä¸­ã€‚

### 4.1.1 toConfigurators

/#toConfigurators(List<URL> urls)
æ–¹æ³•ï¼Œå®˜æ–¹æ³¨é‡Šå¦‚ä¸‹ï¼š
```
//*/*
/* å°†overrideURL è½¬æ¢ä¸º mapï¼Œä¾›é‡æ–° refer æ—¶ä½¿ç”¨.
/* æ¯æ¬¡ä¸‹å‘å…¨éƒ¨è§„åˆ™ï¼Œå…¨éƒ¨é‡æ–°ç»„è£…è®¡ç®—
/*
/* @param urls å¥‘çº¦ï¼š
/* </br>1.override://0.0.0.0/...(æˆ–override://ip:port...?anyhost=true)&para1=value1...è¡¨ç¤ºå…¨å±€è§„åˆ™(å¯¹æ‰€æœ‰çš„æä¾›è€…å…¨éƒ¨ç”Ÿæ•ˆ)
/* </br>2.override://ip:port...?anyhost=false ç‰¹ä¾‹è§„åˆ™ï¼ˆåªé’ˆå¯¹æŸä¸ªæä¾›è€…ç”Ÿæ•ˆï¼‰
/* </br>3.ä¸æ”¯æŒoverride://è§„åˆ™... éœ€è¦æ³¨å†Œä¸­å¿ƒè‡ªè¡Œè®¡ç®—.
/* </br>4.ä¸å¸¦å‚æ•°çš„override://0.0.0.0/ è¡¨ç¤ºæ¸…é™¤override
/*
/* @return Configurator é›†åˆ
/*/
public static List<Configurator> toConfigurators(List<URL> urls){
// ...çœç•¥ä»£ç 
}
```

* å®é™…ä¸Šï¼Œè¯¥æ³¨é‡Šè¯´æ˜äº†é…ç½®è§„åˆ™ï¼Œåœ¨ RegistryDirectory ä¸­ï¼Œæ˜¯**å¦‚ä½•é›†æˆé…ç½®è§„åˆ™æ¨¡å—**ã€‚ç‰¹åˆ«æ˜¯**å››æ¡**å¥‘çº¦ï¼Œèƒ–å‹å¥½å¥½ç†è§£ä¸‹ã€‚

è¯¥æ–¹æ³•çš„çœŸæ­£æ³¨é‡Šï¼Œåº”è¯¥æ˜¯ï¼šå°†é…ç½®è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: public static List<Configurator> toConfigurators(List<URL> urls){
2: // å¿½ç•¥ï¼Œè‹¥é…ç½®è§„åˆ™ URL é›†åˆä¸ºç©º
3: if (urls == null || urls.isEmpty()) {
4: return Collections.emptyList();
5: }
6:
7: // åˆ›å»º Configurator é›†åˆ
8: List<Configurator> configurators = new ArrayList<Configurator>(urls.size());
9: for (URL url : urls) {
10: // è‹¥åè®®ä¸º `empty://` ï¼Œæ„å‘³ç€æ¸…ç©ºæ‰€æœ‰é…ç½®è§„åˆ™ï¼Œå› æ­¤è¿”å›ç©º Configurator é›†åˆ
11: if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {
12: configurators.clear();
13: break;
14: }
15: // å¯¹åº”ç¬¬ 4 æ¡å¥‘çº¦ï¼Œä¸å¸¦å‚æ•°çš„ override://0.0.0.0/ è¡¨ç¤ºæ¸…é™¤ override
16: Map<String, String> override = new HashMap<String, String>(url.getParameters());
17: // The anyhost parameter of override may be added automatically, it can't change the judgement of changing url
18: // override ä¸Šçš„ anyhost å¯èƒ½æ˜¯è‡ªåŠ¨æ·»åŠ çš„ï¼Œä¸èƒ½å½±å“æ”¹å˜urlåˆ¤æ–­
19: override.remove(Constants.ANYHOST_KEY);
20: if (override.size() == 0) {
21: configurators.clear();
22: continue;
23: }
24: // è·å¾— Configurator å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° `configurators` ä¸­
25: configurators.add(configuratorFactory.getConfigurator(url));
26: }
27: // æ’åº
28: Collections.sort(configurators);
29: return configurators;
30: }
```

* ç¬¬ 2 è‡³ 5 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥

urls
é›†åˆä¸ºç©ºã€‚
* çš„ 8 è¡Œï¼šåˆ›å»º Configurator é›†åˆ

configurators
å˜é‡ã€‚
* ç¬¬ 9 è‡³ 26 è¡Œï¼š**å¾ªç¯**

urls
é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆã€‚ğŸ™‚ ä¸­é—´çš„è¿‡ç¨‹ï¼Œèƒ–å‹çœ‹ä¸‹æ³¨é‡Šã€‚
* ç¬¬ 28 è¡Œï¼šå°†

configurators
é›†åˆï¼Œ**æ’åº**ã€‚å…·ä½“çš„æ’åºè§„åˆ™ï¼Œåœ¨ [ã€Œ3.13 compareToã€](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/) å·²ç»è§£æã€‚

### 4.1.2 mergeUrl

```
1: private URL mergeUrl(URL providerUrl){
2: // åˆå¹¶æ¶ˆè´¹ç«¯å‚æ•°
3: providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
4:
5: // åˆå¹¶é…ç½®è§„åˆ™
6: List<Configurator> localConfigurators = this.configurators; // local reference
7: if (localConfigurators != null && !localConfigurators.isEmpty()) {
8: for (Configurator configurator : localConfigurators) {
9: providerUrl = configurator.configure(providerUrl);
10: }
11: }
12:
13: // ä¸æ£€æŸ¥è¿æ¥æ˜¯å¦æˆåŠŸï¼Œæ€»æ˜¯åˆ›å»º Invoker ï¼
14: providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
15:
16: // The combination of directoryUrl and override is at the end of notify, which can't be handled here
17: // ä»…åˆå¹¶æä¾›è€…å‚æ•°ï¼Œå› ä¸º directoryUrl ä¸ override åˆå¹¶æ˜¯åœ¨ notify çš„æœ€åï¼Œè¿™é‡Œä¸èƒ½å¤Ÿå¤„ç†
18: this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters
19:
20: // ã€å¿½ç•¥ã€‘å› ä¸ºæ˜¯å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹
21: if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0)
22: && "dubbo".equals(providerUrl.getProtocol())) { // Compatible version 1.0
23: //fix by tony.chenl DUBBO-44
24: String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);
25: if (path != null) {
26: int i = path.indexOf('/');
27: if (i >= 0) {
28: path = path.substring(i + 1);
29: }
30: i = path.lastIndexOf(':');
31: if (i >= 0) {
32: path = path.substring(0, i);
33: }
34: providerUrl = providerUrl.setPath(path);
35: }
36: }
37:
38: // è¿”å›æœåŠ¡æä¾›è€… URL
39: return providerUrl;
40: }
```

* ç¬¬ 5 è‡³ 11 è¡Œï¼šå¾ªç¯

configurators
é›†åˆï¼Œè°ƒç”¨

Configurator/#configure(URL url)
æ–¹æ³•ï¼Œåˆå¹¶**é…ç½®è§„åˆ™**åˆ°

providerUrl
ä¸­ã€‚
* ç¬¬ 14 è¡Œï¼š**ä»…**åˆå¹¶æä¾›è€…å‚æ•°åˆ°

overrideDirectoryUrl
ä¸­ï¼Œå› ä¸º

directoryUrl
ä¸é…ç½®è§„åˆ™çš„åˆå¹¶æ˜¯åœ¨

/#notify(List<URL> urls)
æ–¹æ³•çš„**æœ€å**ï¼Œå› è€Œè¿™é‡Œä¸èƒ½å¤Ÿå¤„ç†ã€‚ä»£ç å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![notify](http://static2.iocoder.cn/images/Dubbo/2019_04_25/03.png)

## 4.2 RegistryProtocol

RegistryProtocol é€šè¿‡å‘**æ³¨å†Œä¸­å¿ƒ**æ³¨å†Œ OverrideListener ç›‘å¬å™¨ï¼Œä»è€Œé›†æˆé…ç½®è§„åˆ™åˆ°**æœåŠ¡æä¾›è€…**ä¸­ã€‚

### 4.2.1 export

```
1: @Override
2: public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException{
3: // æš´éœ²æœåŠ¡
4: // export invoker
5: final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);
6:
7: // è·å¾—æ³¨å†Œä¸­å¿ƒ URL
8: URL registryUrl = getRegistryUrl(originInvoker);
9:
10: // è·å¾—æ³¨å†Œä¸­å¿ƒå¯¹è±¡
11: // registry provider
12: final Registry registry = getRegistry(originInvoker);
13:
14: // è·å¾—æœåŠ¡æä¾›è€… URL
15: final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);
16:
17: //to judge to delay publish whether or not
18: boolean register = registedProviderUrl.getParameter("register", true);
19:
20: // å‘æ³¨å†Œä¸­å¿ƒè®¢é˜…æœåŠ¡æ¶ˆè´¹è€…
21: ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);
22:
23: // å‘æ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡æä¾›è€…ï¼ˆè‡ªå·±ï¼‰
24: if (register) {
25: register(registryUrl, registedProviderUrl);
26: ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true); // // æ ‡è®°å‘æœ¬åœ°æ³¨å†Œè¡¨çš„æ³¨å†ŒæœåŠ¡æä¾›è€…ï¼Œå·²ç»æ³¨å†Œ
27: }
28:
29: // ä½¿ç”¨ OverrideListener å¯¹è±¡ï¼Œè®¢é˜…é…ç½®è§„åˆ™
30: // Subscribe the override data
31: // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.
32: // åˆ›å»ºè®¢é˜…é…ç½®è§„åˆ™çš„ URL
33: final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);
34: // åˆ›å»º OverrideListener å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° `overrideListeners` ä¸­
35: final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
36: overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
37: // å‘æ³¨å†Œä¸­å¿ƒï¼Œå‘èµ·è®¢é˜…
38: registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
39: //Ensure that a new exporter instance is returned every time export
40: return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);
41: }
```

* ç¬¬ 29 è‡³ 38 è¡Œï¼šä½¿ç”¨ **OverrideListener** å¯¹è±¡ï¼Œè®¢é˜…é…ç½®è§„åˆ™ã€‚

* ç¬¬ 33 è¡Œï¼šè°ƒç”¨

/#getSubscribedOverrideUrl(registedProviderUrl)
æ–¹æ³•ï¼Œåˆ›å»º**è®¢é˜…é…ç½®è§„åˆ™**çš„ URL ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private URL getSubscribedOverrideUrl(URL registedProviderUrl){
return registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)
.addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY, // configurators
Constants.CHECK_KEY, String.valueOf(false)); // è®¢é˜…å¤±è´¥ï¼Œä¸æ ¡éªŒ
}
```

* x
* ç¬¬ 34 è‡³ 36 è¡Œï¼šåˆ›å»º **OverrideListener** å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ°

overrideListeners
ä¸­ã€‚
* ç¬¬ 38 è¡Œï¼šè°ƒç”¨

Registry/#subscribe(overrideSubscribeUrl, overrideSubscribeListener)
æ–¹æ³•ï¼Œå‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œ **OverrideListener** ç›‘å¬å™¨ï¼Œè®¢é˜…é…ç½®è§„åˆ™çš„å˜åŒ–ã€‚

### 4.2.2 OverrideListener

OverrideListener æ˜¯ RegistryProtocol **å†…éƒ¨ç±»**ï¼Œå®ç° NotifyListener æ¥å£ï¼Œå®˜æ–¹æ³¨é‡Šå¦‚ä¸‹ï¼š
```
//*/*
/* é‡æ–° export ï¼šprotocol ä¸­çš„ exporter destroy é—®é¢˜
/*
/* 1. è¦æ±‚ registry protocol è¿”å›çš„ exporter å¯ä»¥æ­£å¸¸ destroy
/* 2. notify åä¸éœ€è¦é‡æ–°å‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œ
/* 3. export æ–¹æ³•ä¼ å…¥çš„ invoker æœ€å¥½èƒ½ä¸€ç›´ä½œä¸º exporter çš„ invoker.
/*/
```

* åˆçœ‹æœ‰ç‚¹ç»•ï¼Œæˆ‘ä»¬æ¥ç…ç…ä»£ç ã€‚

### 4.2.2.1 æ„é€ æ–¹æ³•

```
//*/*
/* è®¢é˜… URL å¯¹è±¡
/*/
private final URL subscribeUrl;
//*/*
/* åŸå§‹ Invoker å¯¹è±¡
/*/
private final Invoker originInvoker;
public OverrideListener(URL subscribeUrl, Invoker originalInvoker){
this.subscribeUrl = subscribeUrl;
this.originInvoker = originalInvoker;
}
```

### 4.2.2.2 notify

```
1: @Override
2: public synchronized void notify(List<URL> urls){
3: // è·å¾—åŒ¹é…çš„è§„åˆ™é…ç½® URL é›†åˆ
4: logger.debug("original override urls: " + urls);
5: List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl);
6: logger.debug("subscribe url: " + subscribeUrl + ", override urls: " + matchedUrls);
7: // No matching results
8: if (matchedUrls.isEmpty()) {
9: return;
10: }
11: // å°†é…ç½®è§„åˆ™ URL é›†åˆï¼Œ/*/*è½¬æ¢/*/*æˆå¯¹åº”çš„ Configurator é›†åˆ
12: List<Configurator> configurators = RegistryDirectory.toConfigurators(matchedUrls);
13:
14: // è·å¾—çœŸå®çš„ Invoker å¯¹è±¡
15: final Invoker<?> invoker;
16: if (originInvoker instanceof InvokerDelegete) {
17: invoker = ((InvokerDelegete<?>) originInvoker).getInvoker();
18: } else {
19: invoker = originInvoker;
20: }
21: // The origin invoker
22: // è·å¾—çœŸå®çš„ Invoker çš„ URL å¯¹è±¡
23: URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);
24:
25: // å¿½ç•¥ï¼Œè‹¥å¯¹åº”çš„ Exporter å¯¹è±¡ä¸å­˜åœ¨
26: String key = getCacheKey(originInvoker);
27: ExporterChangeableWrapper<?> exporter = bounds.get(key);
28: if (exporter == null) {
29: logger.warn(new IllegalStateException("error state, exporter should not be null"));
30: return;
31: }
32:
33: // The current, may have been merged many times
34: // è·å¾— Invoker å½“å‰çš„ URL å¯¹è±¡ï¼Œå¯èƒ½å·²ç»è¢«ä¹‹å‰çš„é…ç½®è§„åˆ™åˆå¹¶è¿‡
35: URL currentUrl = exporter.getInvoker().getUrl();
36: // Merged with this configuration
37: // åŸºäº originUrl å¯¹è±¡ï¼Œåˆå¹¶é…ç½®è§„åˆ™ï¼Œç”Ÿæˆæ–°çš„ newUrl å¯¹è±¡
38: URL newUrl = getConfigedInvokerUrl(configurators, originUrl);
39: // åˆ¤æ–­æ–°è€ Url ä¸åŒ¹é…ï¼Œé‡æ–°æš´éœ² Invoker
40: if (!currentUrl.equals(newUrl)) {
41: RegistryProtocol.this.doChangeLocalExport(originInvoker, newUrl);
42: logger.info("exported provider url changed, origin url: " + originUrl + ", old export url: " + currentUrl + ", new export url: " + newUrl);
43: }
44: }
```

* ç¬¬ 3 è‡³ 10 è¡Œï¼šè°ƒç”¨

/#getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe)
æ–¹æ³•ï¼Œè·å¾—åŒ¹é…çš„**è§„åˆ™é…ç½®** URL é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe){
List<URL> result = new ArrayList<URL>();
for (URL url : configuratorUrls) {
URL overrideUrl = url;
// ã€å¿½ç•¥ã€‘ï¼Œå…¼å®¹è€ç‰ˆæœ¬
// Compatible with the old version
if (url.getParameter(Constants.CATEGORY_KEY) == null
&& Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) {
overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);
}
// åˆ¤æ–­æ˜¯å¦åŒ¹é…
// Check whether url is to be applied to the current service
if (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {
result.add(url);
}
}
return result;
}
```

* é€šè¿‡è°ƒç”¨

UrlUtils/#isMatch(currentSubscribe, overrideUrl)
æ–¹æ³•ï¼Œè¿›è¡Œåˆ¤æ–­**æ˜¯å¦åŒ¹é…**ã€‚è¯¥æ–¹æ³•å…·ä½“å®ç°çš„é€»è¾‘ï¼Œæ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥åˆ¤æ–­è‡ªå·±æŸ¥çœ‹ã€‚
* ç¬¬ 12 è¡Œï¼šè°ƒç”¨

RegistryDirectory/#toConfigurators(matchedUrls)
æ–¹æ³•ï¼Œå°†é…ç½®è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆã€‚
* ç¬¬ 14 è‡³ 23 è¡Œï¼šè·å¾—**çœŸå®**çš„ Invoker å’Œ**å¯¹åº”**çš„ URL å¯¹åº”ã€‚
* ç¬¬ 25 è‡³ 31 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥å¯¹åº”çš„ Exporter å¯¹è±¡ä¸å­˜åœ¨ã€‚
* ========== **é‡ç‚¹** ==========
* ç¬¬ 35 è¡Œï¼šé€šè¿‡

exporter
çš„ Invoker ï¼Œè·å¾— Invoker **å½“å‰**çš„ URL å¯¹è±¡ï¼Œ**å¯èƒ½å·²ç»è¢«ä¹‹å‰çš„é…ç½®è§„åˆ™åˆå¹¶è¿‡**ã€‚
* ç¬¬ 38 è¡Œï¼šè°ƒç”¨

/#getConfigedInvokerUrl(configurators,originUrl)
æ–¹æ³•ï¼ŒåŸºäº

originUrl
å¯¹è±¡ï¼Œ**åˆå¹¶é…ç½®è§„åˆ™**ï¼Œç”Ÿæˆ**æ–°çš„**

newUrl
å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private URL getConfigedInvokerUrl(List<Configurator> configurators, URL url){
for (Configurator configurator : configurators) {
// åˆå¹¶é…ç½®è§„åˆ™
url = configurator.configure(url);
}
return url;
}
```
* ç¬¬ 39 è‡³ 43 è¡Œï¼šåˆ¤æ–­æ–°è€ URL è‹¥**ä¸åŒ¹é…**ï¼Œè°ƒç”¨

RegistryProtocol/#doChangeLocalExport(originInvoker, newUrl)
æ–¹æ³•ï¼Œ**é‡æ–°æš´éœ²** Invoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.2.3 doChangeLocalExportã€](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/) ã€‚

### 4.2.3 doChangeLocalExport

```
1: private <T> void doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl){
2: // æ ¡éªŒå¯¹åº”çš„ Exporter æ˜¯å¦å­˜åœ¨ã€‚è‹¥ä¸å­˜åœ¨ï¼Œæ‰“å°å‘Šè­¦æ—¥å¿—ã€‚
3: String key = getCacheKey(originInvoker);
4: final ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);
5: if (exporter == null) {
6: logger.warn(new IllegalStateException("error state, exporter should not be null"));
7: } else {
8: // åˆ›å»º InvokerDelegete å¯¹è±¡
9: final Invoker<T> invokerDelegete = new InvokerDelegete<T>(originInvoker, newInvokerUrl);
10: // é‡æ–°æš´éœ² Invoker
11: // è®¾ç½®åˆ° ExporterChangeableWrapper ä¸­
12: exporter.setExporter(protocol.export(invokerDelegete));
13: }
14: }
```

* ç¬¬ 2 è‡³ 6 è¡Œï¼š**æ ¡éªŒ**å¯¹åº”çš„ ExporterChangeableWrapper æ˜¯å¦å­˜åœ¨ã€‚è‹¥ä¸å­˜åœ¨ï¼Œæ‰“å°**å‘Šè­¦**æ—¥å¿—ã€‚
* ç¬¬ 9 è¡Œï¼šåˆ›å»º InvokerDelegete å¯¹è±¡ã€‚
* ç¬¬ 12 è¡Œï¼šè°ƒç”¨

Protocol$Adaptive/#export(Invoker)
æ–¹æ³•ï¼Œ**é‡æ–°æš´éœ²** Invoker å¯¹è±¡ã€‚
ğŸ˜ˆ å¯èƒ½ä¼šæœ‰æœºæ™ºçš„èƒ–å‹ä¼šé—®ï¼ŒåŸæ¥çš„ Exporter ä¸è¿›è¡Œ**é”€æ¯**ä¹ˆ?å®é™…ä¸Š**ä¸éœ€è¦**ï¼ŒåŸå› æœ‰ä¸¤ç‚¹ï¼š

* 1ã€æ¯ä¸ªåè®®åˆå§‹åŒ–çš„ Server æœ‰**ç¼“å­˜** ï¼Œæ‰€ä»¥é‡æ–°åˆå§‹åŒ–ï¼Œå¯ä»¥é‡ç”¨**ç¼“å­˜**ä¸­çš„ Server ã€‚
* 2ã€å¦‚æœ**é”€æ¯**åŸæœ‰ Exporter ï¼Œä¼šå¯¼è‡´**ç¼“å­˜**çš„ Server ä¹Ÿä¸€èµ·é”€æ¯ã€‚**è€Œä¸”ï¼Œå³ä½¿ä¸é”€æ¯ï¼ŒåŸæœ‰ Exporter ä¹Ÿå°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¯ä»¥è¢«å›æ”¶æ‰**ã€‚
* ç¬¬ 12 è¡Œï¼šè°ƒç”¨

ExporterChangeableWrapper/#setExporter(exporter)
æ–¹æ³•ï¼Œè®¾ç½®**æ–°çš„** Exporter å¯¹è±¡ã€‚

## 4.3 ServiceConfig

TODO 8038 ServiceConfig ä¸ºå•¥åˆ¤æ–­äº† url.protocol