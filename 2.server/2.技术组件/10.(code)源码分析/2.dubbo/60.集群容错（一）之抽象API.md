# é›†ç¾¤å®¹é”™ï¼ˆä¸€ï¼‰ä¹‹æŠ½è±¡ API

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

ä»æœ¬æ–‡å¼€å§‹ï¼Œæˆ‘ä»¬æ¥åˆ†äº« Dubbo çš„**é›†ç¾¤å®¹é”™**åŠŸèƒ½çš„å®ç°ã€‚

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” é¡¹ç›®ç»“æ„ä¸€è§ˆã€‹](http://svip.iocoder.cn/Dubbo/intro/?self) çš„ [ã€Œ3.4 dubbo-clusterã€](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/) ä¸­ï¼Œæˆ‘ä»¬å¯¹ Dubbo çš„

dubbo-cluster
é¡¹ç›®ï¼Œåšäº†æ•´ä½“çš„ä»£ç ç»“æ„åšäº†ä»‹ç»ã€‚å¦‚æœå·²ç»æ²¡ä»€ä¹ˆå°è±¡çš„èƒ–å‹ï¼Œè¯·å…ˆå›è¿‡å¤´æ‰¾å›å¤±æ•£çš„è®°å¿†ã€‚

Dubbo å¯¹é›†ç¾¤å®¹é”™åŠŸèƒ½ï¼Œå®ç°äº†å¾ˆå¥½çš„

package
æ‹†åˆ†ï¼Œå› æ­¤æˆ‘ä»¬æŒ‰ç…§å¦‚ä¸‹é¡ºåºï¼š

1. æŠ½è±¡ API

* Cluster å®ç°
* Directory å®ç°
* LoadBalance å®ç°
* Merger å®ç°
* Router å®ç°
* Configurator å®ç°

**ä¸€ä¸ªä¸»é¢˜ï¼Œå¯¹åº”ä¸€ç¯‡æ–‡ç« **ã€‚é‚£ä¹ˆï¼Œæœ¬æ–‡å½“ç„¶æ˜¯åˆ†äº«**æŠ½è±¡ API**ã€‚è€ƒè™‘åˆ°å¹²å·´å·´çš„çœ‹æŠ½è±¡ API ä¼šå¾ˆå®¹æ˜“ä¸€è„¸æ‡µé€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šä½¿ç”¨ **FailoverCluster** è´¯ç©¿æœ¬æ–‡ã€‚

# 2. æ•´ä½“æµç¨‹

![é›†ç¾¤å®¹é”™](http://static2.iocoder.cn/images/Dubbo/2018_01_04/09.png)

* ğŸ™‚ åªçœ‹çº¢çº¿ã€‚
* **å·¦è¾¹ invoke** ï¼šé€šè¿‡ Cluster æš´éœ² **Invoker** å¯¹è±¡ï¼Œä»è€Œå®ç°**ç»Ÿä¸€**ã€**é€æ˜**çš„è°ƒç”¨è¿‡ç¨‹ã€‚

* æ— æ³•ç†è§£ï¼Ÿè¯¦ç»†è§£æï¼Œè§ [ã€Œ3. Clusterã€](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/) ã€‚
* **å³è¾¹ list** ï¼šé€šè¿‡ Directory ä¸­ï¼Œ**è·å–**å¯è°ƒç”¨çš„ Invoker é›†åˆã€‚
* **å³è¾¹ route** ï¼šé€šè¿‡ Router ï¼Œ**è¿‡æ»¤**ç¬¦åˆ**è·¯ç”±è§„åˆ™**çš„ Invoker é›†åˆã€‚
* **å³è¾¹ select** ï¼šé€šè¿‡ LoadBalance ï¼Œæ ¹æ®**è´Ÿè½½å‡è¡¡æœºåˆ¶**ï¼Œ**é€‰æ‹©**ä¸€ä¸ªç¬¦åˆçš„ Invoker å¯¹è±¡ã€‚
* **å³è¾¹ invoke** ï¼šè°ƒç”¨è¯¥ Invoker å¯¹è±¡ã€‚

# 3. Cluster

com.alibaba.dubbo.rpc.cluster.Cluster
ï¼Œé›†ç¾¤æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
@SPI(FailoverCluster.NAME)
public interface Cluster{
//*/*
/* Merge the directory invokers to a virtual invoker.
/*
/* åŸºäº Directory ï¼Œåˆ›å»º Invoker å¯¹è±¡ï¼Œå®ç°ç»Ÿä¸€ã€é€æ˜çš„ Invoker è°ƒç”¨è¿‡ç¨‹
/*
/* @param directory Directory å¯¹è±¡
/* @param <T> æ³›å‹
/* @return cluster invoker
/* @throws RpcException
/*/
@Adaptive
<T> Invoker<T> join(Directory<T> directory) throws RpcException;
}
```

* @SPI(FailoverCluster.NAME)
æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œé»˜è®¤ä¸º

"failover"
ï¼Œå³**å¤±è´¥é‡è¯•**ï¼Œä¹Ÿå°±æ˜¯ä¼šè´¯ç©¿æœ¬æ–‡çš„ FailoverCluster ç±»ã€‚
* @Adaptive
æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Cluster å®ç°ï¼Œä½¿ç”¨

URL.cluster
å±æ€§ã€‚
* /#join(Directory<T>)
æ¥å£æ–¹æ³•ï¼ŒåŸºäº Directory ï¼Œåˆ›å»º Invoker å¯¹è±¡ï¼Œå®ç°ç»Ÿä¸€ã€é€æ˜çš„ Invoker è°ƒç”¨è¿‡ç¨‹ã€‚

## 3.1 join æ–¹æ³•

åœ¨ RegistryProtocol çš„

/#doRefer(Cluster, Registry, type, url)
æ–¹æ³•ä¸­ï¼Œä¼šè°ƒç”¨

Cluster/#join(directory)
æ–¹æ³•ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private Cluster cluster; // <1>
private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url){
// åˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œå¹¶è®¾ç½®æ³¨å†Œä¸­å¿ƒ <2>
RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
directory.setRegistry(registry);
directory.setProtocol(protocol);
// ... çœç•¥æ— å…³ä»£ç 
// åˆ›å»º Invoker å¯¹è±¡ <3>
Invoker invoker = cluster.join(directory);
// å‘æœ¬åœ°æ³¨å†Œè¡¨ï¼Œæ³¨å†Œæ¶ˆè´¹è€…
ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
return invoker;
}
```

* <1>
ï¼š

cluster
å±æ€§ï¼Œ

Cluster$Adaptive
å¯¹è±¡
* <2>
ï¼šåˆ›å»º RegistryDirectory å¯¹è±¡ã€‚é€šè¿‡å®ƒï¼Œå¯ä»¥æ³¨å†Œåˆ°**ä¸€ä¸ª**æ³¨å†Œä¸­å¿ƒçš„æ‰€æœ‰æœåŠ¡**æä¾›è€…**ï¼Œå³ä¸Šæ–‡æåˆ°çš„ã€å³è¾¹ listã€‘ã€‚
* <3>
ï¼šè°ƒç”¨

Cluster/#join(directory)
æ–¹æ³•ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚å› ä¸º

cluster
æ˜¯ Dubbo SPI Adaptive ç±»ï¼Œæ‰€ä»¥å¯ä»¥è‡ªåŠ¨è·å–åˆ°**å¯¹åº”çš„** Cluster å®ç°ç±»ã€‚

## 3.2 å­ç±»

![Cluster å­ç±»](http://static2.iocoder.cn/images/Dubbo/2019_04_01/01.png)

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ¯ä¸ª Cluster å®ç°ç±»ï¼Œå¯¹åº”ä¸€ä¸ª**ä¸“å±**äºå…¶çš„ Invoker å®ç°ç±»ã€‚æœ¬æ–‡åˆ†äº«çš„ FailoverCluster çš„å¯¹åº”çš„ Invoker ä¸º FailoverClusterInvoker ã€‚åœ¨çœ‹å…·ä½“çš„ä»£ç ä¹‹å‰ï¼Œå…ˆä¸€èµ·æ¥çœ‹çœ‹**é›†ç¾¤å®¹é”™çš„è°ƒç”¨( invoke )è¿‡ç¨‹**ã€‚

# 4. è°ƒç”¨é¡ºåºå›¾

å¦‚ä¸‹æ˜¯æœåŠ¡**æ¶ˆè´¹è€…**çš„è°ƒç”¨é¡ºåºå›¾ï¼š

![é¡ºåºå›¾](http://static2.iocoder.cn/images/Dubbo/2019_04_01/02.png)

* åœ¨ InvokerInvocationHandler çš„ ã€4ã€‘

/#invoke(invocation)
å¤„**æ’å…¥**ï¼š**å…ˆ**è°ƒç”¨**é›†ç¾¤å®¹é”™ Invoker** çš„

/#invoke(invocation)
ï¼Œ**å†**è°ƒç”¨

ProtocolFilterWrapper$Invoker
çš„

/#invoke(invocation)
ã€‚
* **è°ƒç”¨æ ˆ**å¦‚ä¸‹å›¾ï¼š![è°ƒç”¨æ ˆ](http://static2.iocoder.cn/images/Dubbo/2019_04_01/03.png)

* MockClusterInvoker ï¼Œèƒ–å‹å…ˆæ— è§†ï¼Œåç»­æœ‰è¯¦ç»†æ–‡ç« ï¼Œè¿›è¡Œåˆ†äº«ã€‚

# 5. FailoverCluster

com.alibaba.dubbo.rpc.cluster.support.FailoverCluster
ï¼Œå®ç° Cluster æ¥å£ï¼Œå¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œå½“å‡ºç°å¤±è´¥ï¼Œé‡è¯•å…¶å®ƒæœåŠ¡å™¨ã€‚é€šå¸¸ç”¨äº**è¯»æ“ä½œ**ï¼Œä½†é‡è¯•ä¼šå¸¦æ¥æ›´é•¿å»¶è¿Ÿã€‚å¯é€šè¿‡

retries="2"
æ¥è®¾ç½®é‡è¯•æ¬¡æ•°(ä¸å«ç¬¬ä¸€æ¬¡)ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class FailoverCluster implements Cluster{
public final static String NAME = "failover";
@Override
public <T> Invoker<T> join(Directory<T> directory) throws RpcException{
return new FailoverClusterInvoker<T>(directory);
}
}
```

* å¯¹åº” Invoker ä¸º FailoverClusterInvoker ã€‚

# 6. AbstractClusterInvoker

å› ä¸ºï¼ŒFailoverClusterInvoker ç»§æ‰¿ AbstractClusterInvoker ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¥åˆ†äº«å®ƒã€‚

com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker
ï¼Œå®ç° Invoker æ¥å£ï¼ŒCluster Invoker æŠ½è±¡ç±»ï¼š

* **å®ç°**ä¾‹å¦‚é€‰æ‹©ä¸€ä¸ªç¬¦åˆ Invoker å¯¹è±¡ç­‰ç­‰**å…¬ç”¨**æ–¹æ³•
* **å®šä¹‰**

/#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)
**æŠ½è±¡**æ–¹æ³•ï¼Œå®ç°å­ Cluster çš„ Invoker å®ç°ç±»çš„**æœåŠ¡è°ƒç”¨**çš„å·®å¼‚é€»è¾‘ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
protected abstract Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException;
```

## 6.1 æ„é€ æ–¹æ³•

```
//*/*
/* Directory å¯¹è±¡
/*/
protected final Directory<T> directory;
//*/*
/* é›†ç¾¤æ—¶æ˜¯å¦æ’é™¤éå¯ç”¨( available )çš„ Invoker ï¼Œé»˜è®¤ä¸º true
/*/
protected final boolean availablecheck;
//*/*
/* æ˜¯å¦å·²ç»é”€æ¯
/*/
private AtomicBoolean destroyed = new AtomicBoolean(false);
//*/*
/* ç²˜æ»è¿æ¥ Invoker
/*
/* http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html
/* ç²˜æ»è¿æ¥ç”¨äºæœ‰çŠ¶æ€æœåŠ¡ï¼Œå°½å¯èƒ½è®©å®¢æˆ·ç«¯æ€»æ˜¯å‘åŒä¸€æä¾›è€…å‘èµ·è°ƒç”¨ï¼Œé™¤éè¯¥æä¾›è€…æŒ‚äº†ï¼Œå†è¿å¦ä¸€å°ã€‚
/* ç²˜æ»è¿æ¥å°†è‡ªåŠ¨å¼€å¯å»¶è¿Ÿè¿æ¥ï¼Œä»¥å‡å°‘é•¿è¿æ¥æ•°ã€‚
/*/
private volatile Invoker<T> stickyInvoker = null;
public AbstractClusterInvoker(Directory<T> directory){
this(directory, directory.getUrl());
}
public AbstractClusterInvoker(Directory<T> directory, URL url){
// åˆå§‹åŒ– directory
if (directory == null) {
throw new IllegalArgumentException("service directory == null");
}
this.directory = directory;
// sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.
// åˆå§‹åŒ– availablecheck
this.availablecheck = url.getParameter(Constants.CLUSTER_AVAILABLE_CHECK_KEY, Constants.DEFAULT_CLUSTER_AVAILABLE_CHECK);
}
```

* directory
å­—æ®µï¼ŒDirectory å¯¹è±¡ã€‚é€šè¿‡å®ƒï¼Œå¯ä»¥è·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€…çš„ Invoker å¯¹è±¡ã€‚
* availablecheck
å­—æ®µï¼Œé›†ç¾¤æ—¶æ˜¯å¦æ’é™¤éå¯ç”¨( available )çš„ Invoker ï¼Œé»˜è®¤ä¸º

"true"
ï¼Œé€šè¿‡

"cluster.availablecheck"
é…ç½®é¡¹è®¾ç½®ã€‚
* destroyed
å­—æ®µï¼Œæ˜¯å¦å·²ç»é”€æ¯ã€‚è‹¥å·²ç»é”€æ¯ï¼Œåˆ™ä¸å…è®¸åœ¨è°ƒç”¨ã€‚
* stickyInvoker
å­—æ®µï¼Œç²˜æ»è¿æ¥ Invoker ï¼Œå‚è§ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” ç²˜æ»è¿æ¥
ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html) æ–‡æ¡£ã€‚
ç²˜æ»è¿æ¥ç”¨äºæœ‰çŠ¶æ€æœåŠ¡ï¼Œå°½å¯èƒ½è®©å®¢æˆ·ç«¯æ€»æ˜¯å‘åŒä¸€æä¾›è€…å‘èµ·è°ƒç”¨ï¼Œé™¤éè¯¥æä¾›è€…æŒ‚äº†ï¼Œå†è¿å¦ä¸€å°ã€‚

## 6.2 list

/#list(Invocation)
æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
protected List<Invoker<T>> list(Invocation invocation) throws RpcException {
return directory.list(invocation);
}
```

## 6.3 select

/#select(LoadBalance, Invocation, invokers, selected)
æ–¹æ³•ï¼Œä»**å€™é€‰**çš„ Invoker é›†åˆï¼Œé€‰æ‹©ä¸€ä¸ª**æœ€ç»ˆè°ƒç”¨**çš„ Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* ä½¿ç”¨ loadbalance é€‰æ‹© invoker.
/*
/* @param loadbalance Loadbalance å¯¹è±¡ï¼Œæä¾›è´Ÿè´£å‡è¡¡ç­–ç•¥
/* @param invocation Invocation å¯¹è±¡
/* @param invokers å€™é€‰çš„ Invoker é›†åˆ
/* @param selected å·²é€‰è¿‡çš„ Invoker é›†åˆ. æ³¨æ„ï¼šè¾“å…¥ä¿è¯ä¸é‡å¤
/* @return æœ€ç»ˆçš„ Invoker å¯¹è±¡
/* @throws RpcException å½“å‘ç”Ÿ RpcException æ—¶
/*/
1: protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException{
2: if (invokers == null || invokers.isEmpty()) {
3: return null;
4: }
5: // è·å¾— sticky é…ç½®é¡¹ï¼Œæ–¹æ³•çº§
6: String methodName = invocation == null ? "" : invocation.getMethodName();
7: boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);
8: {
9: // ignore overloaded method
10: // è‹¥ stickyInvoker ä¸å­˜åœ¨äº invokers ä¸­ï¼Œè¯´æ˜ä¸åœ¨å€™é€‰ä¸­ï¼Œéœ€è¦ç½®ç©ºï¼Œé‡æ–°é€‰æ‹©
11: if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
12: stickyInvoker = null;
13: }
14: // ignore cucurrent problem
15: // è‹¥å¼€å¯ç²˜æ»è¿æ¥çš„ç‰¹æ€§ï¼Œä¸” stickyInvoker ä¸å­˜åœ¨äº selected ä¸­ï¼Œåˆ™è¿”å› stickyInvoker è¿™ä¸ª Invoker å¯¹è±¡
16: if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {
17: // è‹¥å¼€å¯æ’é™¤éå¯ç”¨çš„ Invoker çš„ç‰¹æ€§ï¼Œåˆ™æ ¡éªŒ stickyInvoker æ˜¯å¦å¯ç”¨ã€‚è‹¥å¯ç”¨ï¼Œåˆ™è¿›è¡Œè¿”å›
18: if (availablecheck && stickyInvoker.isAvailable()) {
19: return stickyInvoker;
20: }
21: }
22: }
23:
24: // æ‰§è¡Œé€‰æ‹©
25: Invoker<T> invoker = doselect(loadbalance, invocation, invokers, selected);
26:
27: // è‹¥å¼€å¯ç²˜æ»è¿æ¥çš„ç‰¹æ€§ï¼Œè®°å½•æœ€ç»ˆé€‰æ‹©çš„ Invoker åˆ° stickyInvoker
28: if (sticky) {
29: stickyInvoker = invoker;
30: }
31: return invoker;
32: }
```

* è¯¥æ–¹æ³•ä¸»è¦å¤„ç†**ç²˜æ»è¿æ¥**çš„ç‰¹æ€§ï¼Œå…·ä½“ä½¿ç”¨ Loadbalance é€‰æ‹© Invoker å¯¹è±¡çš„é€»è¾‘ï¼Œåœ¨

/#doselect(loadbalance, invocation, invokers, selected)
æ–¹æ³•ä¸­ã€‚
* ç¬¬ 5 è‡³ 22 è¡Œï¼šè·å¾—**ç²˜æ»è¿æ¥**

stickyInvoker
å¯¹è±¡ã€‚

* ç¬¬ 6 è‡³ 7 è¡Œï¼šè·å¾—æ–¹æ³•çº§çš„

sticky
é…ç½®é¡¹ã€‚
* ç¬¬ 9 è‡³ 13 è¡Œï¼šè‹¥

stickyInvoker
ä¸å­˜åœ¨äº

invokers
ä¸­ï¼Œè¯´æ˜ä¸åœ¨å€™é€‰ä¸­ï¼Œéœ€è¦ç½®ç©ºï¼Œé‡æ–°é€‰æ‹©ã€‚
* ç¬¬ 14 è‡³ 21 è¡Œï¼šè·å¾—**ç²˜æ»è¿æ¥**

stickyInvoker
å¯¹è±¡ã€‚å¦‚è¦æ»¡è¶³å¦‚ä¸‹**æ¡ä»¶**ï¼š

* ç¬¬ 16 è¡Œï¼š1ï¼‰å¼€å¯ç²˜æ»è¿æ¥çš„ç‰¹æ€§ï¼›2ï¼‰

stickyInvoker
ä¸å­˜åœ¨äº

selected
ä¸­ã€‚
* ç¬¬ 18 è¡Œï¼šè‹¥å¼€å¯**æ’é™¤éå¯ç”¨**çš„ Invoker çš„ç‰¹æ€§ï¼Œåˆ™æ ¡éªŒ

stickyInvoker
æ˜¯å¦å¯ç”¨ã€‚
* ç¬¬ 25 è¡Œï¼šè°ƒç”¨

/#doselect(loadbalance, invocation, invokers, selected)
æ–¹æ³•ï¼Œæ‰§è¡Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
* ç¬¬ 27 è‡³ 30 è¡Œï¼šè‹¥å¼€å¯**ç²˜æ»è¿æ¥**çš„ç‰¹æ€§ï¼Œè®°å½•æœ€ç»ˆé€‰æ‹©çš„ Invoker å¯¹è±¡ï¼Œåˆ°

stickyInvoker
ä¸­ã€‚

### 6.3.1 doselect

/#doselect(loadbalance, invocation, invokers, selected)
æ–¹æ³•ï¼Œä»**å€™é€‰**çš„ Invoker é›†åˆï¼Œé€‰æ‹©ä¸€ä¸ª**æœ€ç»ˆè°ƒç”¨**çš„ Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private Invoker<T> doselect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException{
2: if (invokers == null || invokers.isEmpty()) {
3: return null;
4: }
5: // ã€ç¬¬ä¸€ç§ã€‘å¦‚æœåªæœ‰ä¸€ä¸ª Invoker ï¼Œç›´æ¥é€‰æ‹©
6: if (invokers.size() == 1) {
7: return invokers.get(0);
8: }
9: // ã€ç¬¬äºŒç§ã€‘å¦‚æœåªæœ‰ä¸¤ä¸ª Invoker ï¼Œé€€åŒ–æˆè½®å¾ª
10: // If we only have two invokers, use round-robin instead.
11: if (invokers.size() == 2 && selected != null && !selected.isEmpty()) {
12: return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0);
13: }
14:
15: // ã€ç¬¬ä¸‰ç§ã€‘ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
16: Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
17:
18: // If the `invoker` is in the `selected` or invoker is unavailable && availablecheck is true, reselect.
19: // å¦‚æœ selectedä¸­åŒ…å«ï¼ˆä¼˜å…ˆåˆ¤æ–­ï¼‰ æˆ–è€… ä¸å¯ç”¨&&availablecheck=true åˆ™é‡è¯•.
20: if ((selected != null && selected.contains(invoker))
21: || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
22: try {
23: //ã€ç¬¬å››ç§ã€‘é‡é€‰ä¸€ä¸ª Invoker å¯¹è±¡
24: Invoker<T> rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
25: if (rinvoker != null) {
26: invoker = rinvoker;
27: } else {
28: // Check the index of current selected invoker, if it's not the last one, choose the one at index+1.
29: // ã€ç¬¬äº”ç§ã€‘çœ‹ä¸‹ç¬¬ä¸€æ¬¡é€‰çš„ä½ç½®ï¼Œå¦‚æœä¸æ˜¯æœ€åï¼Œé€‰+1ä½ç½®.
30: int index = invokers.indexOf(invoker);
31: try {
32: // Avoid collision
33: // æœ€ååœ¨é¿å…ç¢°æ’
34: invoker = index < invokers.size() - 1 ? invokers.get(index + 1) : invoker;
35: } catch (Exception e) {
36: logger.warn(e.getMessage() + " may because invokers list dynamic change, ignore.", e);
37: }
38: }
39: } catch (Throwable t) {
40: logger.error("clustor relselect fail reason is :" + t.getMessage() + " if can not slove ,you can set cluster.availablecheck=false in url", t);
41: }
42: }
43: return invoker;
44: }
```

* æœ‰**äº”ç§**é€‰æ‹©æœ€ç»ˆè°ƒç”¨çš„ Invoker å¯¹è±¡çš„æ–¹å¼ã€‚
* ã€ç¬¬ä¸€ç§ã€‘ç¬¬ 5 è‡³ 8 è¡Œï¼šå¦‚æœåªæœ‰**ä¸€ä¸ªå€™é€‰**çš„ Invoker å¯¹è±¡ï¼Œç›´æ¥é€‰æ‹©è¿”å›ã€‚ğŸ˜ˆ å› ä¸ºæ²¡çš„é€‰æ‹©äº†ã€‚
* ã€ç¬¬äºŒç§ã€‘ç¬¬ 9 è‡³ 13 è¡Œï¼šå¦‚æœåªæœ‰**ä¸¤ä¸ªå€™é€‰**çš„ Invoker é›†åˆï¼Œé€€åŒ–ä¸ºè½®è¯¢ã€‚æ­¤å¤„å­˜åœ¨ä¸€ä¸ª BUG ï¼š
è½¬è½½è‡ªæˆ‘**é£å“¥**ï¼Œ[ã€Šdubbo æºç  - è´Ÿè½½å‡è¡¡ã€‹](https://www.jianshu.com/p/10c30d7b8b6a)

è¿™é‡Œé€€åŒ–æˆè½®è¯¢çš„å®ç°æœ‰é—®é¢˜ï¼Œå¯¹åº”æºç 

return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0)ï¼›
å¦‚æœretries=4ï¼Œå³æœ€å¤šè°ƒç”¨5æ¬¡ï¼Œä¸”ä¸¤ä¸ªå¯é€‰invokeåˆ†åˆ«ä¸ºï¼š

10.0.0.1:20884ï¼Œ10.0.0.1:20886ï¼›

é‚£ä¹ˆ5æ¬¡é€‰æ‹©çš„invokeä¸ºï¼š

* 10.0.0.1:20884
* 10.0.0.1:20886
* 10.0.0.1:20886
* 10.0.0.1:20886
* 10.0.0.1:20886ï¼Œ

å³é™¤äº†ç¬¬1æ¬¡å¤–åé¢çš„é€‰æ‹©éƒ½æ˜¯é€‰æ‹©**ç¬¬äºŒä¸ª**invoker;

å› æ¬¡éœ€è¦æŠŠselected.get(0)ä¿®æ”¹ä¸ºï¼šselected.get(selected.size()-1)ï¼›

å³æ¯æ¬¡æ‹¿å‰ä¸€æ¬¡é€‰æ‹©çš„invokerä¸ invokers.get(0)æ¯”è¾ƒï¼Œå¦‚æœç›¸åŒï¼Œåˆ™é€‰åˆ™å¦ä¸€ä¸ªinvokerï¼›å¦åˆ™å°±é€‰ invokers.get(0)ï¼›

* æ¯”è¾ƒæœ‰è¶£çš„æ˜¯ï¼Œ[ISSUE/#934ï¼šExtension of LoadBalance (a small suggestion for loadbalance policy when thereâ€™s less than 2 providers)](https://github.com/apache/incubator-dubbo/issues/934)ã€‚å’Œä¸Šè¿° BUG æ— å…³ï¼Œèƒ–å‹è‡ªå·±ç†è§£ä¸‹ã€‚
* ã€ç¬¬ä¸‰ç§ã€‘ç¬¬ 16 è‡³ 21 è¡Œï¼šè°ƒç”¨

Loadbalance/#select(invokers, url, invocation)
æ–¹æ³•ï¼Œä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚å…·ä½“çš„ä»£ç å®ç°ï¼Œè§ Loadbalance çš„æ–‡ç« ã€‚

* è¿™ç§æ–¹å¼çš„è¿”å›ï¼Œé€‰æ‹©çš„ Invoker å¯¹è±¡ï¼Œéœ€è¦æ»¡è¶³**ä¸¤ä¸ª**æ¡ä»¶ï¼š1ï¼‰ä¸å­˜åœ¨äº

selected
ä¸­ã€‚2ï¼‰Invoker æ˜¯å¯ç”¨çš„ï¼Œè‹¥å¼€å¯æ’é™¤éå¯ç”¨çš„ Invoker çš„ç‰¹æ€§ã€‚
* ã€ç¬¬å››ç§ã€‘è°ƒç”¨

/#reselect(loadbalance, invocation, invokers, selected, availablecheck)
æ–¹æ³•ï¼Œé‡æ–°é€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚ğŸ˜ˆ å› ä¸ºæ­¤æ—¶

invokers
ä¸­ï¼Œæ— æ³•æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ Invoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6.3.2 reselectã€](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/) ã€‚
* ã€ç¬¬äº”ç§ã€‘**é¡ºåº**ä»å€™é€‰çš„

invokers
é›†åˆä¸­ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ï¼Œä¸è€ƒè™‘æ˜¯å¦**å¯ç”¨**ï¼Œåˆæˆ–è€…**å·²ç»é€‰æ‹©è¿‡**ï¼Œç±»ä¼¼ã€ç¬¬ä¸€ç§ã€‘ã€ç¬¬äºŒç§ã€‘çš„æ–¹å¼ã€‚ğŸ˜ˆæ€»ä¹‹ï¼Œä¿è¯èƒ½è·å–åˆ°ä¸€ä¸ª Invoker å¯¹è±¡ã€‚

### 6.3.2 reselect

/#reselect(loadbalance, invocation, invokers, selected, availablecheck)
æ–¹æ³•ï¼Œé‡æ–°é€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected, boolean availablecheck) throws RpcException{
2: // Allocating one in advance, this list is certain to be used.
3: // é¢„å…ˆåˆ†é…ä¸€ä¸ªï¼Œè¿™ä¸ªåˆ—è¡¨æ˜¯ä¸€å®šä¼šç”¨åˆ°çš„.
4: List<Invoker<T>> reselectInvokers = new ArrayList<Invoker<T>>(invokers.size() > 1 ? (invokers.size() - 1) : invokers.size());
5:
6: // First, try picking a invoker not in `selected`.
7: // å…ˆä»éselectä¸­é€‰
8: if (availablecheck) { // invoker.isAvailable() should be checked
9: // è·å¾—éé€‰æ‹©è¿‡ï¼Œå¹¶ä¸”å¯ç”¨çš„ Invoker é›†åˆ
10: for (Invoker<T> invoker : invokers) {
11: if (invoker.isAvailable()) { // å¹¶ä¸”å¯ç”¨
12: if (selected == null || !selected.contains(invoker)) {
13: reselectInvokers.add(invoker);
14: }
15: }
16: }
17: // ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
18: if (!reselectInvokers.isEmpty()) {
19: return loadbalance.select(reselectInvokers, getUrl(), invocation);
20: }
21: } else { // do not check invoker.isAvailable()
22: // è·å¾—éé€‰æ‹©è¿‡çš„ Invoker é›†åˆ
23: for (Invoker<T> invoker : invokers) {
24: if (selected == null || !selected.contains(invoker)) {
25: reselectInvokers.add(invoker);
26: }
27: }
28: // ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
29: if (!reselectInvokers.isEmpty()) {
30: return loadbalance.select(reselectInvokers, getUrl(), invocation);
31: }
32: }
33: // Just pick an available invoker using loadbalance policy
34: // æœ€åä»selectä¸­é€‰å¯ç”¨çš„.
35: {
36: // è·å¾—é€‰æ‹©è¿‡çš„ï¼Œå¹¶ä¸”å¯ç”¨çš„ Invoker é›†åˆ
37: if (selected != null) {
38: for (Invoker<T> invoker : selected) {
39: if ((invoker.isAvailable()) // available first
40: && !reselectInvokers.contains(invoker)) {
41: reselectInvokers.add(invoker);
42: }
43: }
44: }
45: // ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
46: if (!reselectInvokers.isEmpty()) {
47: return loadbalance.select(reselectInvokers, getUrl(), invocation);
48: }
49: }
50: return null;
51: }
```

* ç¬¬ 4 è¡Œï¼šé¢„å…ˆåˆ›å»ºä¸€ä¸ªé‡é€‰ Invoker é›†åˆï¼Œæˆ‘ä»¬ä¼šå‘ç°å¾ˆå¥‡æ€ªçš„ä¸€æ®µ

invokers.size() - 1
ä»£ç ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿç¬”è€…çš„ç†è§£æ˜¯ï¼Œå‡ºç°é‡é€‰

/#reselect(...)
çš„åŸå› ï¼Œè¯´æ˜

/#doselect(...)
çš„ã€ç¬¬ä¸‰ç§ã€‘é€‰æ‹©çš„ Invoker å¯¹è±¡ï¼Œåœ¨

selected
ä¸­ï¼Œå› æ­¤éœ€è¦**å»æ‰ä¸€ä¸ª**ã€‚
* ä¸€å…±æœ‰**ä¸¤ç±»ä¸‰ç§**çš„é€‰æ‹©æ–¹å¼ï¼š

* ã€ç¬¬ä¸€ç§ã€‘ç¬¬ 10 è‡³ 16 è¡Œï¼šè·å¾—**éé€‰æ‹©è¿‡**(

invokers
)ï¼Œ å¹¶ä¸”**å¿…é¡»**å¯ç”¨çš„ Invoker é›†åˆã€‚
* ã€ç¬¬äºŒç§ã€‘ç¬¬ 22 è‡³ 27 è¡Œï¼šè·å¾—**éé€‰æ‹©è¿‡**(

invokers
)ï¼Œ å¹¶ä¸”**ä¸è€ƒè™‘**å¯ç”¨çš„ Invoker é›†åˆã€‚
* ã€ç¬¬ä¸‰ç§ã€‘ç¬¬ 36 è‡³ 44 è¡Œï¼šè·å¾—**é€‰æ‹©è¿‡**(

selected
)ï¼Œå¹¶ä¸”**å¿…é¡»**å¯ç”¨çš„ Invoker é›†åˆã€‚
* ç¬¬ 19 è¡Œ || ç¬¬ 30 è¡Œ || ç¬¬ 47 è¡Œï¼šè°ƒç”¨

Loadbalance/#select(invokers, url, invocation)
æ–¹æ³•ï¼Œä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚

## 6.4 invoke

/#invoke(invocation)
æ–¹æ³•ï¼Œè°ƒç”¨æœåŠ¡**æä¾›è€…**çš„é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: @Override
2: public Result invoke(final Invocation invocation) throws RpcException{
3: // æ ¡éªŒæ˜¯å¦é”€æ¯
4: checkWhetherDestroyed();
5:
6: // è·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆ
7: List<Invoker<T>> invokers = list(invocation);
8:
9: // è·å¾— LoadBalance å¯¹è±¡
10: LoadBalance loadbalance;
11: if (invokers != null && !invokers.isEmpty()) {
12: loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()
13: .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));
14: } else {
15: loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);
16: }
17:
18: // è®¾ç½®è°ƒç”¨ç¼–å·ï¼Œè‹¥æ˜¯å¼‚æ­¥è°ƒç”¨
19: RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
20:
21: // æ‰§è¡Œè°ƒç”¨
22: return doInvoke(invocation, invokers, loadbalance);
23: }
```

* ç¬¬ 4 è¡Œï¼šè°ƒç”¨

/#checkWhetherDestroyed()
æ–¹æ³•ï¼Œ**æ ¡éªŒ**æ˜¯å¦å·²ç»é”€æ¯ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
protected void checkWhetherDestroyed(){
if (destroyed.get()) {
throw new RpcException("Rpc cluster invoker for " + getInterface() + " on consumer " + NetUtils.getLocalHost()
+ " use dubbo version " + Version.getVersion()
+ " is now destroyed! Can not invoke any more.");
}
}
```
* ç¬¬ 7 è¡Œï¼šè°ƒç”¨

/#list(invocation)
æ–¹æ³•ï¼ŒåŸºäº Directory ï¼Œè·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆã€‚
* ç¬¬ 9 è‡³ 16 è¡Œï¼šè·å¾— Loadbalance å¯¹è±¡ã€‚
* ç¬¬ 19 è¡Œï¼šè°ƒç”¨

RpcUtils/#attachInvocationIdIfAsync(url, invocation)
æ–¹æ³•ï¼Œè®¾ç½®**è°ƒç”¨ç¼–å·**ï¼Œè‹¥æ˜¯å¼‚æ­¥è°ƒç”¨ã€‚
* ç¬¬ 22 è¡Œï¼šè°ƒç”¨

/#doInvoke(invocation, invokers, loadbalance)
**æŠ½è±¡**æ–¹æ³•ï¼Œæ‰§è¡Œè°ƒç”¨ã€‚ğŸ™‚ å­ Cluster çš„ Invoker å®ç°ç±»çš„**æœåŠ¡è°ƒç”¨**çš„å·®å¼‚é€»è¾‘ã€‚

## 6.5 å…¶å®ƒå®ç°æ–¹æ³•

### 6.5.1 getInterface

```
@Override
public Class<T> getInterface(){
return directory.getInterface();
}
```

### 6.5.2 getUrl

```
@Override
public URL getUrl(){
return directory.getUrl();
}
```

### 6.5.3 isAvailable

```
@Override
public boolean isAvailable(){
// å¦‚æœ‰ç²˜æ»è¿æ¥ Invoker ï¼ŒåŸºäºå®ƒåˆ¤æ–­ã€‚
Invoker<T> invoker = stickyInvoker; // æŒ‡å‘ï¼Œé¿å…å¹¶å‘
if (invoker != null) {
return invoker.isAvailable();
}
// åŸºäº Directory åˆ¤æ–­
return directory.isAvailable();
}
```

### 6.5.4 checkInvokers

```
protected void checkInvokers(List<Invoker<T>> invokers, Invocation invocation){
if (invokers == null || invokers.isEmpty()) {
throw new RpcException("Failed to invoke the method "
+ invocation.getMethodName() + " in the service " + getInterface().getName()
+ ". No provider available for the service " + directory.getUrl().getServiceKey()
+ " from registry " + directory.getUrl().getAddress()
+ " on the consumer " + NetUtils.getLocalHost()
+ " using the dubbo version " + Version.getVersion()
+ ". Please check if the providers have been started and registered.");
}
}
```

### 6.5.5 destroy

```
@Override
public void destroy(){
if (destroyed.compareAndSet(false, true)) {
directory.destroy();
}
}
```

# 7. FailoverClusterInvoker

com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker
ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼Œ**FailoverCluster** Invoker å®ç°ç±»ã€‚

å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œå½“å‡ºç°å¤±è´¥ï¼Œé‡è¯•å…¶å®ƒæœåŠ¡å™¨ã€‚é€šå¸¸ç”¨äº**è¯»æ“ä½œ**ï¼Œä½†é‡è¯•ä¼šå¸¦æ¥æ›´é•¿å»¶è¿Ÿã€‚å¯é€šè¿‡

retries="2"
æ¥è®¾ç½®é‡è¯•æ¬¡æ•°(ä¸å«ç¬¬ä¸€æ¬¡)ã€‚

åœ¨çœ‹å…·ä½“çš„

/#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)
çš„å®ç°ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥ç…ç…**è°ƒç”¨é¡ºåºå›¾**ï¼š

![è°ƒç”¨é¡ºåºå›¾](http://static2.iocoder.cn/images/Dubbo/2019_04_01/04.png)

* å®é™…é€»è¾‘å¾ˆç®€å•ï¼š**å¾ªç¯**ï¼ŒæŸ¥æ‰¾ä¸€ä¸ª Invoker å¯¹è±¡ï¼Œè¿›è¡Œè°ƒç”¨ï¼Œç›´åˆ°**æˆåŠŸ**ã€‚

/#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
1: @Override
2: public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException{
3: List<Invoker<T>> copyinvokers = invokers;
4: // æ£€æŸ¥copyinvokerså³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
5: checkInvokers(copyinvokers, invocation);
6: // å¾—åˆ°æœ€å¤§å¯è°ƒç”¨æ¬¡æ•°ï¼šæœ€å¤§å¯é‡è¯•æ¬¡æ•°+1ï¼Œé»˜è®¤æœ€å¤§å¯é‡è¯•æ¬¡æ•°Constants.DEFAULT_RETRIES=2
7: int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;
8: if (len <= 0) {
9: len = 1;
10: }
11: // ä¿å­˜æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸
12: RpcException le = null;
13: // ä¿å­˜å·²ç»è°ƒç”¨è¿‡çš„Invoker
14: List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.
15: Set<String> providers = new HashSet<String>(len);
16: // failoveræœºåˆ¶æ ¸å¿ƒå®ç°ï¼šå¦‚æœå‡ºç°è°ƒç”¨å¤±è´¥ï¼Œé‚£ä¹ˆé‡è¯•å…¶ä»–æœåŠ¡å™¨
17: for (int i = 0; i < len; i++) {
18: // é‡è¯•æ—¶ï¼Œè¿›è¡Œé‡æ–°é€‰æ‹©ï¼Œé¿å…é‡è¯•æ—¶invokeråˆ—è¡¨å·²å‘ç”Ÿå˜åŒ–.
19: // æ³¨æ„ï¼šå¦‚æœåˆ—è¡¨å‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£ä¹ˆinvokedåˆ¤æ–­ä¼šå¤±æ•ˆï¼Œå› ä¸ºinvokerç¤ºä¾‹å·²ç»æ”¹å˜
20: if (i > 0) {
21: checkWhetherDestroyed();
22: // æ ¹æ®Invocationè°ƒç”¨ä¿¡æ¯ä»Directoryä¸­è·å–æ‰€æœ‰å¯ç”¨Invoker
23: copyinvokers = list(invocation);
24: // check again
25: // é‡æ–°æ£€æŸ¥ä¸€ä¸‹
26: checkInvokers(copyinvokers, invocation);
27: }
28: // æ ¹æ®è´Ÿè½½å‡è¡¡æœºåˆ¶ä»copyinvokersä¸­é€‰æ‹©ä¸€ä¸ªInvoker
29: Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);
30: // ä¿å­˜æ¯æ¬¡è°ƒç”¨çš„Invoker
31: invoked.add(invoker);
32: // è®¾ç½®å·²ç»è°ƒç”¨çš„ Invoker é›†åˆï¼Œåˆ° Context ä¸­
33: RpcContext.getContext().setInvokers((List) invoked);
34: try {
35: // RPC è°ƒç”¨å¾—åˆ° Result
36: Result result = invoker.invoke(invocation);
37: // é‡è¯•è¿‡ç¨‹ä¸­ï¼Œå°†æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸ä¿¡æ¯ä»¥ warn çº§åˆ«æ—¥å¿—è¾“å‡º
38: if (le != null && logger.isWarnEnabled()) {
39: logger.warn("Although retry the method " + invocation.getMethodName()
40: + " in the service " + getInterface().getName()
41: + " was successful by the provider " + invoker.getUrl().getAddress()
42: + ", but there have been failed providers " + providers
43: + " (" + providers.size() + "/" + copyinvokers.size()
44: + ") from the registry " + directory.getUrl().getAddress()
45: + " on the consumer " + NetUtils.getLocalHost()
46: + " using the dubbo version " + Version.getVersion() + ". Last error is: "
47: + le.getMessage(), le);
48: }
49: return result;
50: } catch (RpcException e) {
51: // å¦‚æœæ˜¯ä¸šåŠ¡æ€§è´¨çš„å¼‚å¸¸ï¼Œä¸å†é‡è¯•ï¼Œç›´æ¥æŠ›å‡º
52: if (e.isBiz()) { // biz exception.
53: throw e;
54: }
55: // å…¶ä»–æ€§è´¨çš„å¼‚å¸¸ç»Ÿä¸€å°è£…æˆRpcException
56: le = e;
57: } catch (Throwable e) {
58: le = new RpcException(e.getMessage(), e);
59: } finally {
60: providers.add(invoker.getUrl().getAddress());
61: }
62: }
63: // æœ€å¤§å¯è°ƒç”¨æ¬¡æ•°ç”¨å®Œè¿˜å¾—åˆ°Resultçš„è¯ï¼ŒæŠ›å‡ºRpcExceptionå¼‚å¸¸ï¼šé‡è¯•äº†Næ¬¡è¿˜æ˜¯å¤±è´¥ï¼Œå¹¶è¾“å‡ºæœ€åä¸€æ¬¡å¼‚å¸¸ä¿¡æ¯
64: throw new RpcException(le != null ? le.getCode() : 0, "Failed to invoke the method "
65: + invocation.getMethodName() + " in the service " + getInterface().getName()
66: + ". Tried " + len + " times of the providers " + providers
67: + " (" + providers.size() + "/" + copyinvokers.size()
68: + ") from the registry " + directory.getUrl().getAddress()
69: + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
70: + Version.getVersion() + ". Last error is: "
71: + (le != null ? le.getMessage() : ""), le != null && le.getCause() != null ? le.getCause() : le);
72: }
```

* ç¬¬ 3 è¡Œï¼š

copyinvokers
å˜é‡ï¼Œå€™é€‰çš„ Invoker é›†åˆã€‚
* ç¬¬ 5 è¡Œï¼šè°ƒç”¨**çˆ¶**

/#checkInvokers(copyinvokers, invocation)
æ–¹æ³•ï¼Œ**æ ¡éªŒ**å€™é€‰çš„ Invoker é›†åˆ**éç©º**ã€‚å¦‚æœä¸ºç©ºï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚
* ç¬¬ 6 è‡³ 10 è¡Œï¼šè·å¾—**æœ€å¤§å¯è°ƒç”¨æ¬¡æ•°**ï¼šæœ€å¤§**å¯é‡è¯•**æ¬¡æ•° +1 ã€‚é»˜è®¤æœ€å¤§å¯é‡è¯•æ¬¡æ•°

Constants.DEFAULT_RETRIES = 2
ã€‚
* ç¬¬ 12 è¡Œï¼š

le
å˜é‡ï¼Œä¿å­˜æœ€åä¸€æ¬¡è°ƒç”¨çš„**å¼‚å¸¸**ã€‚
* ç¬¬ 14 è¡Œï¼š

invoked
å˜é‡ï¼Œä¿å­˜å·²ç»è°ƒç”¨çš„ Invoker é›†åˆã€‚
* ç¬¬ 15 è¡Œï¼š

providers
å˜é‡ï¼Œä¿å­˜å·²ç»è°ƒç”¨çš„**ç½‘ç»œåœ°å€**é›†åˆã€‚
* ç¬¬ 16 è‡³ 62 è¡Œï¼š**failover æœºåˆ¶æ ¸å¿ƒå®ç°ï¼šå¦‚æœå‡ºç°è°ƒç”¨å¤±è´¥ï¼Œé‚£ä¹ˆé‡è¯•å…¶ä»–æœåŠ¡å™¨**ã€‚

* ç¬¬ 20 è‡³ 27 è¡Œï¼š**é‡è¯•æ—¶**(

i > 0
)ï¼Œ è¿›è¡Œé‡æ–°é€‰æ‹©ï¼Œé¿å…é‡è¯•æ—¶ï¼Œå€™é€‰ Invoker é›†åˆï¼Œå·²å‘ç”Ÿå˜åŒ–ã€‚
* ã€é‡è¦ã€‘ç¬¬ 29 è¡Œï¼šè°ƒç”¨**çˆ¶**

/#select(loadbalance, invocation, copyinvokers, invoked)
æ–¹æ³•ï¼Œæ ¹æ® Loadbalance è´Ÿè½½å‡è¡¡æœºåˆ¶ï¼Œä»

copyinvokers
ä¸­ï¼Œé€‰æ‹©ä¸€ä¸ªè¢«è°ƒç”¨çš„ Invoker å¯¹è±¡ã€‚
* ç¬¬ 31 è¡Œï¼šä¿å­˜æ¯æ¬¡è°ƒç”¨çš„ Invoker å¯¹è±¡ï¼Œåˆ°

invoked
ä¸­ã€‚
* ç¬¬ 33 è¡Œï¼šä¿å­˜å·²ç»è°ƒç”¨çš„ Invoker é›†åˆï¼Œåˆ° Context ä¸­ã€‚
* ã€é‡è¦ã€‘ç¬¬ 36 è¡Œï¼šè°ƒç”¨

Invoker/#invoke(invocation)
æ–¹æ³•ï¼Œ**å‘èµ· RPC è°ƒç”¨**ã€‚
* ç¬¬ 37 è‡³ 48 è¡Œï¼šè‹¥

le
éç©ºï¼Œè¯´æ˜æ­¤æ—¶æ˜¯**é‡è¯•è°ƒç”¨æˆåŠŸ**ï¼Œå°†æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸ä¿¡æ¯ä»¥ **warn** çº§åˆ«æ—¥å¿—è¾“å‡ºï¼Œæ–¹ä¾¿æœªæ¥è¿½æº¯ã€‚
* ========== å¼‚å¸¸ç›¸å…³ ===========
* ç¬¬ 55 è‡³ 54 è¡Œï¼šå¦‚æœæ˜¯ä¸šåŠ¡æ€§è´¨çš„å¼‚å¸¸ï¼Œä¸å†é‡è¯•ï¼Œç›´æ¥æŠ›å‡ºã€‚
* ç¬¬ 56 è¡Œï¼šä¿å­˜å¼‚å¸¸åˆ°

le
ã€‚
* ç¬¬ 58 è¡Œï¼šé RpcException å¼‚å¸¸ï¼Œ**å°è£…**æˆ RpcException å¼‚å¸¸ã€‚
* ç¬¬ 59 è‡³ 61 è¡Œï¼šä¿å­˜æ¯æ¬¡è°ƒç”¨çš„**ç½‘ç»œåœ°å€**ï¼Œåˆ°

providers
ä¸­ã€‚
* ç¬¬ 63 è‡³ 71 è¡Œï¼šè¶…è¿‡æœ€å¤§è°ƒç”¨æ¬¡æ•°ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚è¯¥å¼‚å¸¸ä¸­ï¼Œå¸¦æœ‰æœ€åä¸€æ¬¡è°ƒç”¨å¼‚å¸¸çš„ä¿¡æ¯ã€‚