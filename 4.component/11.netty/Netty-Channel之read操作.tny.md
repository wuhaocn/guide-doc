<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Channel（二）之 accept 操作
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 Netty NIO 服务端 NioServerSocketChannel 接受( <strong>accept</strong> )客户端连接的过程。简单来说：</p>
<ol>
<li>服务端 NioServerSocketChannel 的 boss EventLoop 线程轮询是否有新的客户端连接接入。</li>
<li>当轮询到有新的连接接入，封装连入的客户端的 SocketChannel 为 Netty NioSocketChannel 对象。</li>
<li>选择一个服务端 NioServerSocketChannel 的 worker EventLoop ，将客户端的 NioSocketChannel 注册到其上。并且，注册客户端的 NioSocketChannel 的读事件，开始轮询该客户端是否有数据写入。</li>
</ol>
<p>下面，让我们来看看具体的代码实现。</p>
<h1 id="2-NioMessageUnsafe-read"><a href="#2-NioMessageUnsafe-read" class="headerlink" title="2. NioMessageUnsafe#read"></a>2. NioMessageUnsafe#read</h1><blockquote>
<p>老艿艿：有点不知道怎么取标题好，直接用方法名吧。</p>
</blockquote>
<p>在 NioEventLoop 的 <code>#processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法中，我们会看到这样一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SelectionKey.OP_READ 或 SelectionKey.OP_ACCEPT 就绪</span></span><br><span class="line"><span class="comment">// readyOps == 0 是对 JDK Bug 的处理，防止空的死循环</span></span><br><span class="line"><span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line"><span class="comment">// to a spin loop</span></span><br><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) {</span><br><span class="line">    unsafe.read();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当 <code>(readyOps &amp; SelectionKey.OP_ACCEPT) != 0</code> 时，这就是服务端 NioServerSocketChannel 的 boss EventLoop 线程<strong>轮询到</strong>有新的客户端连接接入。</li>
<li>然后，调用 <code>NioMessageUnsafe#read()</code> 方法，“读取”( 😈 这个抽象很灵性 )新的客户端连接连入。</li>
</ul>
<hr>
<p><code>NioMessageUnsafe#read()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioMessageUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractNioUnsafe</span> </span>{</span><br><span class="line"> <span class="number">2</span>: </span><br><span class="line"> <span class="number">3</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 4:      * 新读取的客户端连接数组</span></span><br><span class="line"><span class="comment"> 5:      */</span></span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; readBuf = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"> <span class="number">7</span>: </span><br><span class="line"> <span class="number">8</span>:     <span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br><span class="line"> <span class="number">9</span>:     <span class="meta">@Override</span></span><br><span class="line"><span class="number">10</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">11</span>:         <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">12</span>:         <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 获得 RecvByteBufAllocator.Handle 对象</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line"><span class="number">16</span>:         <span class="comment">// 重置 RecvByteBufAllocator.Handle 对象</span></span><br><span class="line"><span class="number">17</span>:         allocHandle.reset(config);</span><br><span class="line"><span class="number">18</span>: </span><br><span class="line"><span class="number">19</span>:         <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">20</span>:         Throwable exception = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">21</span>:         <span class="keyword">try</span> {</span><br><span class="line"><span class="number">22</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">23</span>:                 <span class="keyword">do</span> {</span><br><span class="line"><span class="number">24</span>:                     <span class="comment">// 读取客户端的连接到 readBuf 中</span></span><br><span class="line"><span class="number">25</span>:                     <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line"><span class="number">26</span>:                     <span class="comment">// 无可读取的客户端的连接，结束</span></span><br><span class="line"><span class="number">27</span>:                     <span class="keyword">if</span> (localRead == <span class="number">0</span>) {</span><br><span class="line"><span class="number">28</span>:                         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">29</span>:                     }</span><br><span class="line"><span class="number">30</span>:                     <span class="comment">// 读取出错</span></span><br><span class="line"><span class="number">31</span>:                     <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">32</span>:                         closed = <span class="keyword">true</span>; <span class="comment">// 标记关闭</span></span><br><span class="line"><span class="number">33</span>:                         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">34</span>:                     }</span><br><span class="line"><span class="number">35</span>: </span><br><span class="line"><span class="number">36</span>:                     <span class="comment">// 读取消息数量 + localRead</span></span><br><span class="line"><span class="number">37</span>:                     allocHandle.incMessagesRead(localRead);</span><br><span class="line"><span class="number">38</span>:                 } <span class="keyword">while</span> (allocHandle.continueReading()); <span class="comment">// 循环判断是否继续读取</span></span><br><span class="line"><span class="number">39</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">40</span>:                 <span class="comment">// 记录异常</span></span><br><span class="line"><span class="number">41</span>:                 exception = t;</span><br><span class="line"><span class="number">42</span>:             }</span><br><span class="line"><span class="number">43</span>: </span><br><span class="line"><span class="number">44</span>:             <span class="comment">// 循环 readBuf 数组，触发 Channel read 事件到 pipeline 中。</span></span><br><span class="line"><span class="number">45</span>:             <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line"><span class="number">46</span>:             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) {</span><br><span class="line"><span class="number">47</span>:                 <span class="comment">// TODO 芋艿</span></span><br><span class="line"><span class="number">48</span>:                 readPending = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">49</span>:                 <span class="comment">// 在内部，会通过 ServerBootstrapAcceptor ，将客户端的 Netty NioSocketChannel 注册到 EventLoop 上</span></span><br><span class="line"><span class="number">50</span>:                 pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"><span class="number">51</span>:             }</span><br><span class="line"><span class="number">52</span>:             <span class="comment">// 清空 readBuf 数组</span></span><br><span class="line"><span class="number">53</span>:             readBuf.clear();</span><br><span class="line"><span class="number">54</span>:             <span class="comment">// 读取完成</span></span><br><span class="line"><span class="number">55</span>:             allocHandle.readComplete();</span><br><span class="line"><span class="number">56</span>:             <span class="comment">// 触发 Channel readComplete 事件到 pipeline 中。</span></span><br><span class="line"><span class="number">57</span>:             pipeline.fireChannelReadComplete();</span><br><span class="line"><span class="number">58</span>: </span><br><span class="line"><span class="number">59</span>:             <span class="comment">// 发生异常</span></span><br><span class="line"><span class="number">60</span>:             <span class="keyword">if</span> (exception != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">61</span>:                 <span class="comment">// 判断是否要关闭 TODO 芋艿</span></span><br><span class="line"><span class="number">62</span>:                 closed = closeOnReadError(exception);</span><br><span class="line"><span class="number">63</span>: </span><br><span class="line"><span class="number">64</span>:                 <span class="comment">// 触发 exceptionCaught 事件到 pipeline 中。</span></span><br><span class="line"><span class="number">65</span>:                 pipeline.fireExceptionCaught(exception);</span><br><span class="line"><span class="number">66</span>:             }</span><br><span class="line"><span class="number">67</span>: </span><br><span class="line"><span class="number">68</span>:             <span class="keyword">if</span> (closed) {</span><br><span class="line"><span class="number">69</span>:                 <span class="comment">// TODO 芋艿</span></span><br><span class="line"><span class="number">70</span>:                 inputShutdown = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">71</span>:                 <span class="comment">// TODO 芋艿</span></span><br><span class="line"><span class="number">72</span>:                 <span class="keyword">if</span> (isOpen()) {</span><br><span class="line"><span class="number">73</span>:                     close(voidPromise());</span><br><span class="line"><span class="number">74</span>:                 }</span><br><span class="line"><span class="number">75</span>:             }</span><br><span class="line"><span class="number">76</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">77</span>:             <span class="comment">// Check if there is a readPending which was not processed yet.</span></span><br><span class="line"><span class="number">78</span>:             <span class="comment">// This could be for two reasons:</span></span><br><span class="line"><span class="number">79</span>:             <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class="line"><span class="number">80</span>:             <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span></span><br><span class="line"><span class="number">81</span>:             <span class="comment">//</span></span><br><span class="line"><span class="number">82</span>:             <span class="comment">// See https://github.com/netty/netty/issues/2254</span></span><br><span class="line"><span class="number">83</span>:             <span class="comment">// TODO 芋艿</span></span><br><span class="line"><span class="number">84</span>:             <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) {</span><br><span class="line"><span class="number">85</span>:                 removeReadOp();</span><br><span class="line"><span class="number">86</span>:             }</span><br><span class="line"><span class="number">87</span>:         }</span><br><span class="line"><span class="number">88</span>:     }</span><br><span class="line"><span class="number">89</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 NioMessageUnsafe 只有一个 <code>#read()</code> 方法，而该方法，“读取”新的客户端连接连入。</li>
<li><p>第 15 行：调用 <code>Unsafe#recvBufAllocHandle()</code> 方法，获得 获得 RecvByteBufAllocator.Handle 对象。默认情况下，返回的是 AdaptiveRecvByteBufAllocator.HandleImpl 对象。关于它的内容，我们放在 ByteBuf 相关的文章，详细解析。</p>
<ul>
<li><p>第 17 行：调用 <code>DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#reset(ChannelConfig)</code> 方法，重置 RecvByteBufAllocator.Handle 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(ChannelConfig config)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.config = config; <span class="comment">// 重置 ChannelConfig 对象</span></span><br><span class="line">    maxMessagePerRead = maxMessagesPerRead(); <span class="comment">// 重置 maxMessagePerRead 属性</span></span><br><span class="line">    totalMessages = totalBytesRead = <span class="number">0</span>; <span class="comment">// 重置 totalMessages 和 totalBytesRead 属性</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>注意，AdaptiveRecvByteBufAllocator.HandleImpl 继承 DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle 抽象类。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 22 至 42 行：<strong>while 循环</strong> “读取”新的客户端连接连入。</p>
<ul>
<li>第 25 行： 调用 <code>NioServerSocketChannel#doReadMessages(List&lt;Object&gt; buf)</code> 方法，读取客户端的连接到 <code>readBuf</code> 中。详细解析，胖友先跳到 <a href="#">「3. AbstractNioMessageChannel#doReadMessages」</a> 中，看完记得回到此处。</li>
<li>第 25 至 29 行：无可读取的客户端的连接，结束循环。</li>
<li>第 30 至 34 行：读取出错，<strong>标记关闭服务端</strong>，并结束循环。目前我们看到 <code>NioServerSocketChannel#doReadMessages(List&lt;Object&gt; buf)</code> 方法的实现，返回的结果只会存在 0 和 1 ，也就是说不会出现这种情况。笔者又去翻了别的实现类，例如 <code>NioDatagramChannel#doReadMessages(List&lt;Object&gt; buf)</code> 方法，在发生异常时，会返回 -1 。</li>
<li><p>第 37 行：调用 <code>AdaptiveRecvByteBufAllocator.HandleImpl#incMessagesRead(int amt)</code> 方法，读取消息( 客户端 )数量 + <code>localRead</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incMessagesRead</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>{</span><br><span class="line">    totalMessages += amt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 AdaptiveRecvByteBufAllocator.HandleImpl 来说，考虑到<strong>抽象</strong>的需要，所以统一使用“消息”的说法。</li>
</ul>
</li>
<li><p>第 38 行：调用 <code>AdaptiveRecvByteBufAllocator.HandleImpl#incMessagesRead(int amt)#continueReading()</code> 方法，判断是否循环是否继续，读取( 接受 )新的客户端连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AdaptiveRecvByteBufAllocator.HandleImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> continueReading(defaultMaybeMoreSupplier);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> config.isAutoRead() &amp;&amp;</span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>; <span class="comment">// &lt;1&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 <code>&lt;1&gt;</code> 处，此时 <code>totalBytesRead</code> 等于 0 ，所以会返回 <strong>false</strong> 。因此，循环会结束。也因此，对于 NioServerSocketChannel 来说，<strong>每次只接受一个新的客户端连接</strong>。😈 当然，因为服务端 NioServerSocketChannel 对 <code>Selectionkey.OP_ACCEPT</code> 事件感兴趣，所以<strong>后续的新的客户端连接还是会被接受的</strong>。</li>
</ul>
</li>
<li>第 39 至 42 行：读取过程中发生异常，记录该异常到 <code>exception</code> 中，同时结束循环。</li>
</ul>
</li>
<li>第 44 至 51 行：循环 <code>readBuf</code> 数组，触发 Channel read 事件到 pipeline 中。<ul>
<li>第 48 行：TODO 芋艿 细节</li>
<li>第 50 行：调用 <code>ChannelPipeline#fireChannelRead(Object msg)</code> 方法，触发 Channel read 事件到 pipeline 中。<ul>
<li><strong>注意</strong>，传入的方法参数是新接受的客户端 NioSocketChannel 连接。</li>
<li>在内部，会通过 ServerBootstrapAcceptor ，将客户端的 Netty NioSocketChannel 注册到 EventLoop 上。详细解析，胖友先跳到 <a href="#">「4. ServerBootstrapAcceptor」</a> 中，看完记得回到此处。</li>
</ul>
</li>
</ul>
</li>
<li>第 53 行：清空 <code>readBuf</code> 数组。</li>
<li>第 55 行：调用 <code>RecvByteBufAllocator.Handle#readComplete()</code> 方法，读取完成。暂无重要的逻辑，不详细解析。</li>
<li><p>第 57 行：调用 <code>ChannelPipeline#fireChannelReadComplete()</code> 方法，触发 Channel readComplete 事件到 pipeline 中。</p>
<ul>
<li><em>如果有需要，胖友可以自定义处理器，处理该事件。一般情况下，不需要</em>。</li>
<li><p>如果没有自定义 ChannelHandler 进行处理，最终会被 pipeline 中的尾节点  TailContext 所处理。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// TailContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    onUnhandledInboundChannelReadComplete();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundChannelReadComplete</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的调用是<strong>空方法</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>第 60 至 66 行：<code>exception</code> 非空，说明在接受连接过程中发生异常。<ul>
<li>第 62 行：TODO 芋艿 细节</li>
<li>第 65 行： 调用 <code>ChannelPipeline#fireExceptionCaught(Throwable)</code> 方法，触发 exceptionCaught 事件到 pipeline 中。<ul>
<li>默认情况下，会使用 ServerBootstrapAcceptor 处理该事件。详细解析，见 <a href="#">「4.3 exceptionCaught」</a> 。</li>
<li><em>如果有需要，胖友可以自定义处理器，处理该事件。一般情况下，不需要</em>。</li>
</ul>
</li>
</ul>
</li>
<li>第 68 至 75 行：TODO 芋艿 细节</li>
<li>第 76 至 87 行：TODO 芋艿 细节</li>
</ul>
<h1 id="3-AbstractNioMessageChannel-doReadMessages"><a href="#3-AbstractNioMessageChannel-doReadMessages" class="headerlink" title="3. AbstractNioMessageChannel#doReadMessages"></a>3. AbstractNioMessageChannel#doReadMessages</h1><p><code>doReadMessages(List&lt;Object&gt; buf)</code> <strong>抽象</strong>方法，读取客户端的连接到方法参数 <code>buf</code> 中。它是一个<strong>抽象</strong>方法，定义在 AbstractNioMessageChannel 抽象类中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read messages into the given array and return the amount which was read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>返回值为读取到的数量。</li>
</ul>
<p>NioServerSocketChannel 对该方法的实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">  <span class="number">3</span>:     <span class="comment">// 接受客户端连接</span></span><br><span class="line">  <span class="number">4</span>:     SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">  <span class="number">5</span>: </span><br><span class="line">  <span class="number">6</span>:     <span class="keyword">try</span> {</span><br><span class="line">  <span class="number">7</span>:         <span class="comment">// 创建 Netty NioSocketChannel 对象</span></span><br><span class="line">  <span class="number">8</span>:         <span class="keyword">if</span> (ch != <span class="keyword">null</span>) {</span><br><span class="line">  <span class="number">9</span>:             buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line"> <span class="number">10</span>:             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="number">11</span>:         }</span><br><span class="line"> <span class="number">12</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"> <span class="number">13</span>:         logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line"> <span class="number">14</span>:         <span class="comment">// 发生异常，关闭客户端的 SocketChannel 连接</span></span><br><span class="line"> <span class="number">15</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">16</span>:             ch.close();</span><br><span class="line"> <span class="number">17</span>:         } <span class="keyword">catch</span> (Throwable t2) {</span><br><span class="line"> <span class="number">18</span>:             logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line"> <span class="number">19</span>:         }</span><br><span class="line"> <span class="number">20</span>:     }</span><br><span class="line"> <span class="number">21</span>: </span><br><span class="line"> <span class="number">22</span>:     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">23</span>: }</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServerSocketChannel <span class="title">javaChannel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (ServerSocketChannel) <span class="keyword">super</span>.javaChannel();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 4 行：调用 <code>SocketUtils#accept(ServerSocketChannel serverSocketChannel)</code> 方法，接受客户端连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ServerSocketChannel serverSocketChannel)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;SocketChannel&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">                <span class="keyword">return</span> serverSocketChannel.accept(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    } <span class="keyword">catch</span> (PrivilegedActionException e) {</span><br><span class="line">        <span class="keyword">throw</span> (IOException) e.getCause();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>重点是看 <code>&lt;1&gt;</code> 处，调用 <code>ServerSocketChannel#accept()</code> 方法，接受客户端连接。</li>
</ul>
</li>
<li>第 9 行：基于客户端的 NIO ServerSocket ，创建 Netty NioSocketChannel 对象。整个过程，就是 <a href="http://svip.iocoder.cn/Netty/bootstrap-2-client/">《精尽 Netty 源码分析 —— 启动（二）之客户端》</a> 的 <a href="#">「3.7.1 创建 Channel 对象」</a> 小节。<ul>
<li>第 10 行：返回 1 ，表示成功接受了 1 个新的客户端连接。</li>
</ul>
</li>
<li>第 12 至 20 行：发生异常，关闭客户端的 SocketChannel 连接，并打印<strong>告警</strong>日志。<ul>
<li>第 22 行：返回 0 ，表示成功接受 0 个新的客户端连接。</li>
</ul>
</li>
</ul>
<h1 id="4-ServerBootstrapAcceptor"><a href="#4-ServerBootstrapAcceptor" class="headerlink" title="4. ServerBootstrapAcceptor"></a>4. ServerBootstrapAcceptor</h1><p>ServerBootstrapAcceptor ，继承 ChannelInboundHandlerAdapter 类，服务器接收器( acceptor )，负责将接受的客户端的 NioSocketChannel 注册到 EventLoop 中。</p>
<p>另外，从继承的是 ChannelInboundHandlerAdapter 类，可以看出它是 Inbound 事件处理器。</p>
<h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h2><p>在服务端的启动过程中，我们看到 ServerBootstrapAcceptor 注册到服务端的 NioServerSocketChannel 的 pipeline 的尾部，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 记录当前的属性</span></span><br><span class="line"><span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line"><span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line"><span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line"><span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line"><span class="keyword">synchronized</span> (childOptions) {</span><br><span class="line">    currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">synchronized</span> (childAttrs) {</span><br><span class="line">    currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 ChannelInitializer 对象到 pipeline 中，用于后续初始化 ChannelHandler 到 pipeline 中。</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加配置的 ChannelHandler 到 pipeline 中。</span></span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 ServerBootstrapAcceptor 到 pipeline 中。</span></span><br><span class="line">        <span class="comment">// 使用 EventLoop 执行的原因，参见 https://github.com/lightningMan/netty/commit/4638df20628a8987c8709f0f8e5f3679a914ce1a</span></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>即 <code>&lt;1&gt;</code> 处。也是在此处，创建了 ServerBootstrapAcceptor 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler childHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动恢复接受客户端连接的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable enableAutoReadTask;</span><br><span class="line"></span><br><span class="line">ServerBootstrapAcceptor(</span><br><span class="line">        <span class="keyword">final</span> Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,</span><br><span class="line">        Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) {</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">    <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">    <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Task which is scheduled to re-enable auto-read.</span></span><br><span class="line">    <span class="comment">// It's important to create this Runnable before we try to submit it as otherwise the URLClassLoader may</span></span><br><span class="line">    <span class="comment">// not be able to load the class because of the file limit it already reached.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/1328</span></span><br><span class="line">    enableAutoReadTask = <span class="keyword">new</span> Runnable() { <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            channel.config().setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>enableAutoReadTask</code> 属性，自动恢复接受客户端连接的任务，在 <code>&lt;2&gt;</code> 处初始化。具体的使用，我们在 <a href="#">「4.3 exceptionCaught」</a> 中，详细解析。</li>
</ul>
</li>
</ul>
<h2 id="4-2-channelRead"><a href="#4-2-channelRead" class="headerlink" title="4.2 channelRead"></a>4.2 channelRead</h2><p><code>#channelRead(ChannelHandlerContext ctx, Object msg)</code> 方法，将接受的客户端的 NioSocketChannel 注册到 EventLoop 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 老艿艿：如下的注释，先暂时认为是接受的客户端的 NioSocketChannel</span></span><br><span class="line"> <span class="number">4</span>: </span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 接受的客户端的 NioSocketChannel 对象</span></span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 添加 NioSocketChannel 的处理器</span></span><br><span class="line"> <span class="number">8</span>:     child.pipeline().addLast(childHandler);</span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// 设置 NioSocketChannel 的配置项</span></span><br><span class="line"><span class="number">10</span>:     setChannelOptions(child, childOptions, logger);</span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 设置 NioSocketChannel 的属性</span></span><br><span class="line"><span class="number">12</span>:     <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) {</span><br><span class="line"><span class="number">13</span>:         child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line"><span class="number">14</span>:     }</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="keyword">try</span> {</span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 注册客户端的 NioSocketChannel 到 work EventLoop 中。</span></span><br><span class="line"><span class="number">18</span>:         childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line"><span class="number">19</span>: </span><br><span class="line"><span class="number">20</span>:             <span class="meta">@Override</span></span><br><span class="line"><span class="number">21</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="number">22</span>:                 <span class="comment">// 注册失败，关闭客户端的 NioSocketChannel</span></span><br><span class="line"><span class="number">23</span>:                 <span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line"><span class="number">24</span>:                     forceClose(child, future.cause());</span><br><span class="line"><span class="number">25</span>:                 }</span><br><span class="line"><span class="number">26</span>:             }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:         });</span><br><span class="line"><span class="number">29</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">30</span>:         <span class="comment">// 发生异常，强制关闭客户端的 NioSocketChannel</span></span><br><span class="line"><span class="number">31</span>:         forceClose(child, t);</span><br><span class="line"><span class="number">32</span>:     }</span><br><span class="line"><span class="number">33</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>为了方便描述，我们统一认为接受的客户端连接为 NioSocketChannel 对象。</li>
<li>第 6 行：接受的客户端的 NioSocketChannel 对象。<ul>
<li>第 8 行：调用 <code>ChannelPipeline#addLast(childHandler)</code> 方法，将配置的子 Channel 的处理器，添加到 NioSocketChannel 中。</li>
<li>第 10 至 14 行：设置 NioSocketChannel 的配置项、属性。</li>
</ul>
</li>
<li><p>第 17 至 28 行：调用 <code>EventLoopGroup#register(Channel channel)</code> 方法，将客户端的 NioSocketChannel 对象，从 worker EventLoopGroup 中选择一个 EventLoop ，注册到其上。</p>
<ul>
<li>后续的逻辑，就和 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/">《精尽 Netty 源码分析 —— 启动（一）之服务端》</a> 的注册逻辑<strong>基本一致</strong>( 虽然说，文章写的是 NioServerSocketChannel 的注册逻辑 )。</li>
<li>在注册完成之后，该 worker EventLoop 就会开始轮询该客户端是否有数据写入。</li>
<li><p>第 18 至 28 行：添加监听器，如果注册失败，则调用 <code>#forceClose(Channel child, Throwable t)</code> 方法，强制关闭客户端的 NioSocketChannel 连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceClose</span><span class="params">(Channel child, Throwable t)</span> </span>{</span><br><span class="line">    child.unsafe().closeForcibly();</span><br><span class="line">    logger.warn(<span class="string">"Failed to register an accepted channel: {}"</span>, child, t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在该方法内部，会调用 <code>Unsafe#closeForcibly()</code> 方法，强制关闭客户端的 NioSocketChannel 。</li>
</ul>
</li>
<li>第 29 至 32 行：发生异常，则调用 <code>#forceClose(Channel child, Throwable t)</code> 方法，强制关闭客户端的 NioSocketChannel 连接。 </li>
</ul>
</li>
</ul>
<h2 id="4-3-exceptionCaught"><a href="#4-3-exceptionCaught" class="headerlink" title="4.3 exceptionCaught"></a>4.3 exceptionCaught</h2><p><code>#exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code> 方法，当捕获到异常时，<strong>暂停 1 秒</strong>，不再接受新的客户端连接；而后，再恢复接受新的客户端连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">final</span> ChannelConfig config = ctx.channel().config();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (config.isAutoRead()) {</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 关闭接受新的客户端连接</span></span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// stop accept new connections for 1 second to allow the channel to recover</span></span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// See https://github.com/netty/netty/issues/1328</span></span><br><span class="line"> <span class="number">8</span>:         config.setAutoRead(<span class="keyword">false</span>);</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 发起 1 秒的延迟任务，恢复重启开启接受新的客户端连接</span></span><br><span class="line"><span class="number">10</span>:         ctx.channel().eventLoop().schedule(enableAutoReadTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="number">11</span>:     }</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:     <span class="comment">// 继续传播 exceptionCaught 给下一个节点</span></span><br><span class="line"><span class="number">14</span>:     <span class="comment">// still let the exceptionCaught event flow through the pipeline to give the user</span></span><br><span class="line"><span class="number">15</span>:     <span class="comment">// a chance to do something with it</span></span><br><span class="line"><span class="number">16</span>:     ctx.fireExceptionCaught(cause);</span><br><span class="line"><span class="number">17</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 8 行：调用 <code>ChannelConfig#setAutoRead(false)</code> 方法，关闭接受新的客户端连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelConfig.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #autoRead} 的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;DefaultChannelConfig&gt; AUTOREAD_UPDATER = AtomicIntegerFieldUpdater.newUpdater(DefaultChannelConfig.class, <span class="string">"autoRead"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否开启自动读取的开关</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1 - 开启</span></span><br><span class="line"><span class="comment"> * 0 - 关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"FieldMayBeFinal"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> autoRead = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelConfig <span class="title">setAutoRead</span><span class="params">(<span class="keyword">boolean</span> autoRead)</span> </span>{</span><br><span class="line">    <span class="comment">// 原子更新，并且获得更新前的值 &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">boolean</span> oldAutoRead = AUTOREAD_UPDATER.getAndSet(<span class="keyword">this</span>, autoRead ? <span class="number">1</span> : <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 发起读取 &lt;2.1&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (autoRead &amp;&amp; !oldAutoRead) {</span><br><span class="line">        channel.read();</span><br><span class="line">    <span class="comment">// 关闭读取 &lt;2.2&gt;</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!autoRead &amp;&amp; oldAutoRead) {</span><br><span class="line">        autoReadCleared();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>autoRead</code> 字段，是否开启自动读取的开关。😈 笔者原本以为是个 <code>boolean</code> 类型，是不是胖友也是。其中，1 表示开启，0 表示关闭。<ul>
<li><code>AUTOREAD_UPDATER</code> 静态变量，对 <code>autoRead</code> 字段的原子更新器。</li>
</ul>
</li>
<li><code>&lt;1&gt;</code> 处，使用 <code>AUTOREAD_UPDATER</code> 更新 <code>autoRead</code> 字段，并获得更新前的值。为什么需要获取更新前的值呢？在后续的 <code>&lt;2.1&gt;</code> 和 <code>&lt;2.2&gt;</code> 中，当 <code>autoRead</code> 有变化时候，才进行后续的逻辑。</li>
<li>😈 下面的逻辑，我们按照 <code>channel</code> 的类型为 NioServerSocketChannel 来分享。</li>
<li><code>&lt;2.1&gt;</code> 处，<code>autoRead &amp;&amp; !oldAutoRead</code> 返回 <code>true</code> ，意味着恢复重启开启接受新的客户端连接。所以调用 <code>NioServerSocketChannel#read()</code> 方法，后续的逻辑，就是 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/">《精尽 Netty 源码分析 —— 启动（一）之服务端》</a> 的 <a href="#">「3.13.3 beginRead」</a> 的逻辑。</li>
<li><p><code>&lt;2.2&gt;</code> 处，<code>!autoRead &amp;&amp; oldAutoRead</code> 返回 <code>false</code> ，意味着关闭接受新的客户端连接。所以调用 <code>#autoReadCleared()</code> 方法，移除对 <code>SelectionKey.OP_ACCEPT</code> 事件的感兴趣。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// NioServerSocketChannel.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autoReadCleared</span><span class="params">()</span> </span>{</span><br><span class="line">    clearReadPending();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>在方法内部，会调用 <code>#clearReadPending()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clearReadPending</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) {</span><br><span class="line">        EventLoop eventLoop = eventLoop();</span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) {</span><br><span class="line">            clearReadPending0();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            eventLoop.execute(clearReadPendingRunnable);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Best effort if we are not registered yet clear readPending. This happens during channel initialization.</span></span><br><span class="line">        <span class="comment">// NB: We only set the boolean field instead of calling clearReadPending0(), because the SelectionKey is</span></span><br><span class="line">        <span class="comment">// not set yet so it would produce an assertion failure.</span></span><br><span class="line">        readPending = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable clearReadPendingRunnable = <span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        clearReadPending0();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearReadPending0</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// TODO 芋艿</span></span><br><span class="line">    readPending = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 移除对“读”事件的感兴趣。</span></span><br><span class="line">    ((AbstractNioUnsafe) unsafe()).removeReadOp();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>最终的结果，是在 EventLoop 的线程中，调用 <code>AbstractNioUnsafe#clearReadPending0()</code> 方法，移除对“<strong>读</strong>”事件的感兴趣( 对于 NioServerSocketChannel 的 “<strong>读</strong>“事件就是 <code>SelectionKey.OP_ACCEPT</code> )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractNioUnsafe.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeReadOp</span><span class="params">()</span> </span>{</span><br><span class="line">    SelectionKey key = selectionKey();</span><br><span class="line">    <span class="comment">// 忽略，如果 SelectionKey 不合法，例如已经取消</span></span><br><span class="line">    <span class="comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span></span><br><span class="line">    <span class="comment">// from the EventLoop</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/2104</span></span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 移除对“读”事件的感兴趣。</span></span><br><span class="line">    <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// only remove readInterestOp if needed</span></span><br><span class="line">        key.interestOps(interestOps &amp; ~readInterestOp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过取反求并，后调用 <code>SelectionKey#interestOps(interestOps)</code> 方法，<strong>仅</strong>移除对“读”事件的感兴趣。</li>
<li>😈 整个过程的调用链，有丢丢长，胖友可以回看，或者多多调试。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第 10 行：调用 <code>EventLoop#schedule(Runnable command, long delay, TimeUnit unit)</code> 方法，发起 1 秒的延迟任务，恢复重启开启接受新的客户端连接。该定时任务会调用 <code>ChannelConfig#setAutoRead(true)</code> 方法，即对应 <code>&lt;2.1&gt;</code> 情况。</li>
<li>第 16 行：调用 <code>ChannelHandlerContext#fireExceptionCaught(cause)</code> 方法，继续传播 exceptionCaught 给下一个节点。具体的原因，可看英文注释。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>推荐阅读文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/0242b1d4dd21" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之新连接接入全解析》</a></li>
<li>占小狼 <a href="https://www.jianshu.com/p/ffc6fd82e32b" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 accept 过程》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Channel-2-accept/" data-id="ck4pl3fp200dufgcfhtu1pwap" class="article-share-link">分享</a>



</footer>
-->
</div>