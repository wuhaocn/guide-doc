<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelPipeline（二）之添加 ChannelHandler
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们来分享，<strong>添加</strong> ChannelHandler 到 pipeline 中的代码具体实现。</p>
<p>在 <a href="http://svip.iocoder.cn/Netty/ChannelPipeline-1-init">《精尽 Netty 源码解析 —— ChannelPipeline（一）之初始化》</a> 中，我们看到 ChannelPipeline 定义了一大堆<strong>添加</strong> ChannelHandler 的接口方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addBefore</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addBefore</span><span class="params">(EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addAfter</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addAfter</span><span class="params">(EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(ChannelHandler... handlers)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, ChannelHandler... handlers)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, ChannelHandler... handlers)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>考虑到实际当中，我们使用 <code>#addLast(ChannelHandler... handlers)</code> 方法较多，所以本文只分享这个方法的具体实现。</li>
</ul>
<h1 id="2-addLast"><a href="#2-addLast" class="headerlink" title="2. addLast"></a>2. addLast</h1><p><code>#addLast(ChannelHandler... handlers)</code> 方法，添加任意数量的 ChannelHandler 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handlers"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) {</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>#addLast(EventExecutorGroup group, String name, ChannelHandler handler)</code> 方法，添加一个 ChannelHandler 对象到 pipeline 中。</li>
</ul>
<p><code>#addLast(EventExecutorGroup group, String name, ChannelHandler handler)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br><span class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>{</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { <span class="comment">// 同步，为了防止多线程并发操作 pipeline 底层的双向链表</span></span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// 检查是否有重复 handler</span></span><br><span class="line"> <span class="number">7</span>:         checkMultiplicity(handler);</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 创建节点名</span></span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 创建节点</span></span><br><span class="line"><span class="number">11</span>:         newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 添加节点</span></span><br><span class="line"><span class="number">14</span>:         addLast0(newCtx);</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:         <span class="comment">// &lt;1&gt; pipeline 暂未注册，添加回调。再注册完成后，执行回调。详细解析，见 {@link #invokeHandlerAddedIfNeeded} 方法。</span></span><br><span class="line"><span class="number">17</span>:         <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line"><span class="number">18</span>:         <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line"><span class="number">19</span>:         <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line"><span class="number">20</span>:         <span class="keyword">if</span> (!registered) {</span><br><span class="line"><span class="number">21</span>:             <span class="comment">// 设置 AbstractChannelHandlerContext 准备添加中</span></span><br><span class="line"><span class="number">22</span>:             newCtx.setAddPending();</span><br><span class="line"><span class="number">23</span>:             <span class="comment">// 添加 PendingHandlerCallback 回调</span></span><br><span class="line"><span class="number">24</span>:             callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">25</span>:             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">26</span>:         }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:         <span class="comment">// &lt;2&gt; 不在 EventLoop 的线程中，提交 EventLoop 中，执行回调用户方法</span></span><br><span class="line"><span class="number">29</span>:         EventExecutor executor = newCtx.executor();</span><br><span class="line"><span class="number">30</span>:         <span class="keyword">if</span> (!executor.inEventLoop()) {</span><br><span class="line"><span class="number">31</span>:             <span class="comment">// 设置 AbstractChannelHandlerContext 准备添加中</span></span><br><span class="line"><span class="number">32</span>:             newCtx.setAddPending();</span><br><span class="line"><span class="number">33</span>:             <span class="comment">// 提交 EventLoop 中，执行回调 ChannelHandler added 事件</span></span><br><span class="line"><span class="number">34</span>:             executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line"><span class="number">35</span>:                 <span class="meta">@Override</span></span><br><span class="line"><span class="number">36</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">37</span>:                     callHandlerAdded0(newCtx);</span><br><span class="line"><span class="number">38</span>:                 }</span><br><span class="line"><span class="number">39</span>:             });</span><br><span class="line"><span class="number">40</span>:             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">41</span>:         }</span><br><span class="line"><span class="number">42</span>:     }</span><br><span class="line"><span class="number">43</span>: </span><br><span class="line"><span class="number">44</span>:     <span class="comment">// &lt;3&gt; 回调 ChannelHandler added 事件</span></span><br><span class="line"><span class="number">45</span>:     callHandlerAdded0(newCtx);</span><br><span class="line"><span class="number">46</span>:     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">47</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 行：<code>synchronized</code> 同步，为了防止多线程并发操作 pipeline 底层的双向链表。</li>
<li>第 7 行：调用 <code>#checkMultiplicity(ChannelHandler)</code> 方法，校验是否重复的 ChannelHandler 。详细解析，见 <a href="#">「3. checkMultiplicity」</a> 。</li>
<li>第 11 行：调用 <code>#filterName(String name, ChannelHandler handler)</code> 方法，获得 ChannelHandler 的名字。详细解析，见 <a href="#">「4. filterName」</a> 。</li>
<li>第 11 行：调用 <code>#newContext(EventExecutorGroup group, String name, ChannelHandler handler)</code> 方法，创建 <strong>DefaultChannelHandlerContext</strong> 节点。详细解析，见 <a href="#">「5. newContext」</a> 。</li>
<li>第 14 行：<code>#addLast0(AbstractChannelHandlerContext newCtx)</code> 方法，添加到最后一个节点。详细解析，见 <a href="#">「6. addLast0」</a> 。</li>
<li>========== 后续分成 3 种情况 ==========</li>
<li><code>&lt;1&gt;</code></li>
<li>第 20 行：Channel 并未注册。这种情况，发生于 ServerBootstrap 启动的过程中。在 <code>ServerBootstrap#init(Channel channel)</code> 方法中，会添加 ChannelInitializer 对象到 pipeline 中，恰好此时 Channel 并未注册。</li>
<li>第 22 行：调用 <code>AbstractChannelHandlerContext#setAddPending()</code> 方法，设置 AbstractChannelHandlerContext <strong>准备添加中</strong>。</li>
<li>第 24 行：调用 <code>#callHandlerCallbackLater(AbstractChannelHandlerContext, added)</code> 方法，添加 PendingHandlerAddedTask 回调。在 Channel 注册完成后，执行该回调。详细解析，见 <a href="#">「8. PendingHandlerCallback」</a> 。</li>
<li><code>&lt;2&gt;</code></li>
<li>第 30 行：不在 EventLoop 的线程中。</li>
<li>第 32 行：调用 <code>AbstractChannelHandlerContext#setAddPending()</code> 方法，设置 AbstractChannelHandlerContext <strong>准备添加中</strong>。</li>
<li>第 34 至 39 行：提交 EventLoop 中，调用 <code>#callHandlerAdded0(AbstractChannelHandlerContext)</code> 方法，执行回调 ChannelHandler 添加完成( added )事件。详细解析，见 <a href="#">「7. callHandlerAdded0」</a> 。</li>
<li><code>&lt;3&gt;</code> </li>
<li>这种情况，是 <code>&lt;2&gt;</code> 在 EventLoop 的线程中的版本。也因为此，已经确认在 EventLoop 的线程中，所以不需要在 <code>synchronized</code> 中。</li>
<li>第 45 行：和【第 37 行】的代码一样，调用 <code>#callHandlerAdded0(AbstractChannelHandlerContext)</code> 方法，执行回调 ChannelHandler 添加完成( added )事件。</li>
</ul>
<h1 id="3-checkMultiplicity"><a href="#3-checkMultiplicity" class="headerlink" title="3. checkMultiplicity"></a>3. checkMultiplicity</h1><p><code>#checkMultiplicity(ChannelHandler handler)</code> 方法，校验是否重复的 ChannelHandler 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) {</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="comment">// 若已经添加，并且未使用 @Sharable 注解，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                    <span class="string">" is not a @Sharable handler, so can't be added or removed multiple times."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 标记已经添加</span></span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 pipeline 中，一个创建的 ChannelHandler 对象，如果不使用 Netty <code>@Sharable</code> 注解，则只能添加到一个 Channel 的 pipeline 中。所以，如果我们想要重用一个 ChannelHandler 对象( 例如在 Spring 环境中 )，则必须给这个 ChannelHandler 添加 <code>@Sharable</code> 注解。</li>
</ul>
<p>例如，在 Dubbo 的 <code>com.alibaba.dubbo.remoting.transport.netty.NettyHandler</code> 处理器，它就使用了 <code>@Sharable</code> 注解。</p>
<h1 id="4-filterName"><a href="#4-filterName" class="headerlink" title="4. filterName"></a>4. filterName</h1><p><code>#filterName(String name, ChannelHandler handler)</code> 方法，获得 ChannelHandler 的名字。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">filterName</span><span class="params">(String name, ChannelHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) { <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">return</span> generateName(handler);</span><br><span class="line">    }</span><br><span class="line">    checkDuplicateName(name); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，若<strong>未</strong>传入默认的名字 <code>name</code> ，则调用 <code>#generateName(ChannelHandler)</code> 方法，根据 ChannelHandler 生成一个<strong>唯一</strong>的名字。详细解析，见 <a href="#">「4.1 generateName」</a> 。</li>
<li><code>&lt;2&gt;</code> 处，若<strong>已</strong>传入默认的名字 <code>name</code> ，则调用 <code>#checkDuplicateName(String name)</code> 方法，校验名字唯一。详细解析，见 <a href="#">「4.2 checkDuplicateName」</a> 。</li>
</ul>
<h2 id="4-1-generateName"><a href="#4-1-generateName" class="headerlink" title="4.1 generateName"></a>4.1 generateName</h2><p><code>#generateName(ChannelHandler)</code> 方法，根据 ChannelHandler 生成一个<strong>唯一</strong>名字。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> String <span class="title">generateName</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 从缓存中查询，是否已经生成默认名字</span></span><br><span class="line"> <span class="number">3</span>:     Map&lt;Class&lt;?&gt;, String&gt; cache = nameCaches.get();</span><br><span class="line"> <span class="number">4</span>:     Class&lt;?&gt; handlerType = handler.getClass();</span><br><span class="line"> <span class="number">5</span>:     String name = cache.get(handlerType);</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 若未生成过，进行生成</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (name == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">8</span>:         name = generateName0(handlerType);</span><br><span class="line"> <span class="number">9</span>:         cache.put(handlerType, name);</span><br><span class="line"><span class="number">10</span>:     }</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 判断是否存在相同名字的节点</span></span><br><span class="line"><span class="number">13</span>:     <span class="comment">// It's not very likely for a user to put more than one handler of the same type, but make sure to avoid</span></span><br><span class="line"><span class="number">14</span>:     <span class="comment">// any name conflicts.  Note that we don't cache the names generated here.</span></span><br><span class="line"><span class="number">15</span>:     <span class="keyword">if</span> (context0(name) != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">16</span>:         <span class="comment">// 若存在，则使用基础名字 + 编号，循环生成，直到一个是唯一的</span></span><br><span class="line"><span class="number">17</span>:         String baseName = name.substring(<span class="number">0</span>, name.length() - <span class="number">1</span>); <span class="comment">// Strip the trailing '0'.</span></span><br><span class="line"><span class="number">18</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i ++) {</span><br><span class="line"><span class="number">19</span>:             String newName = baseName + i;</span><br><span class="line"><span class="number">20</span>:             <span class="keyword">if</span> (context0(newName) == <span class="keyword">null</span>) { <span class="comment">// // 判断是否存在相同名字的节点</span></span><br><span class="line"><span class="number">21</span>:                 name = newName;</span><br><span class="line"><span class="number">22</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">23</span>:             }</span><br><span class="line"><span class="number">24</span>:         }</span><br><span class="line"><span class="number">25</span>:     }</span><br><span class="line"><span class="number">26</span>:     <span class="keyword">return</span> name;</span><br><span class="line"><span class="number">27</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 5 行：从缓存 <code>nameCaches</code> 中，查询是否已经生成<strong>默认</strong>名字。<ul>
<li>若未生成过，调用 <code>#generateName0(ChannelHandler)</code> 方法，进行生成。而后，添加到缓存 <code>nameCaches</code> 中。</li>
</ul>
</li>
<li><p>第 15 行：调用 <code>#context0(String name)</code> 方法，判断是否存在相同名字的节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">context0</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    AbstractChannelHandlerContext context = head.next;</span><br><span class="line">    <span class="comment">// 顺序向下遍历节点，判断是否有指定名字的节点。如果有，则返回该节点。</span></span><br><span class="line">    <span class="keyword">while</span> (context != tail) {</span><br><span class="line">        <span class="keyword">if</span> (context.name().equals(name)) {</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        }</span><br><span class="line">        context = context.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>顺序向下遍历节点，判断是否有指定名字的节点。如果有，则返回该节点。</li>
</ul>
</li>
<li>第 15 至 25 行：若存在相同名字的节点，则使用<strong>基础</strong>名字 + 编号，循环生成，直到一个名字是<strong>唯一</strong>的，然后结束循环。</li>
</ul>
<h2 id="4-2-checkDuplicateName"><a href="#4-2-checkDuplicateName" class="headerlink" title="4.2 checkDuplicateName"></a>4.2 checkDuplicateName</h2><p><code>#checkDuplicateName(String name)</code> 方法，校验名字唯一。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkDuplicateName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (context0(name) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Duplicate handler name: "</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过调用 <code>#context0(String name)</code> 方法，获得指定名字的节点。若存在节点，意味着<strong>不唯一</strong>，抛出 IllegalArgumentException 异常。</li>
</ul>
<h1 id="5-newContext"><a href="#5-newContext" class="headerlink" title="5. newContext"></a>5. newContext</h1><p><code>#newContext(EventExecutorGroup group, String name, ChannelHandler handler)</code> 方法，创建 <strong>DefaultChannelHandlerContext</strong> 节点。而这个节点，<strong>内嵌</strong>传入的 ChannelHandler 参数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group) <span class="comment">/** &lt;1&gt; **/</span>, name, handler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#childExecutor(EventExecutorGroup group)</code> 方法，创建<strong>子</strong>执行器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> EventExecutor <span class="title">childExecutor</span><span class="params">(EventExecutorGroup group)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 不创建子执行器</span></span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;2&gt; 根据配置项 SINGLE_EVENTEXECUTOR_PER_GROUP ，每个 Channel 从 EventExecutorGroup 获得不同 EventExecutor 执行器</span></span><br><span class="line">    Boolean pinEventExecutor = channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP);</span><br><span class="line">    <span class="keyword">if</span> (pinEventExecutor != <span class="keyword">null</span> &amp;&amp; !pinEventExecutor) {</span><br><span class="line">        <span class="keyword">return</span> group.next();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3&gt; 通过 childExecutors 缓存实现，一个 Channel 从 EventExecutorGroup 获得相同 EventExecutor 执行器</span></span><br><span class="line">    Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors = <span class="keyword">this</span>.childExecutors;</span><br><span class="line">    <span class="keyword">if</span> (childExecutors == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// Use size of 4 as most people only use one extra EventExecutor.</span></span><br><span class="line">        childExecutors = <span class="keyword">this</span>.childExecutors = <span class="keyword">new</span> IdentityHashMap&lt;EventExecutorGroup, EventExecutor&gt;(<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Pin one of the child executors once and remember it so that the same child executor</span></span><br><span class="line">    <span class="comment">// is used to fire events for the same channel.</span></span><br><span class="line">    EventExecutor childExecutor = childExecutors.get(group);</span><br><span class="line">    <span class="comment">// 缓存不存在，进行 从 EventExecutorGroup 获得 EventExecutor 执行器</span></span><br><span class="line">    <span class="keyword">if</span> (childExecutor == <span class="keyword">null</span>) {</span><br><span class="line">        childExecutor = group.next();</span><br><span class="line">        childExecutors.put(group, childExecutor); <span class="comment">// 进行缓存</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> childExecutor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一共有三种情况：<ul>
<li><code>&lt;1&gt;</code> ，当<strong>不传入</strong> EventExecutorGroup 时，不创建<strong>子</strong>执行器。即，使用 Channel 所注册的 EventLoop 作为执行器。<strong>对于我们日常使用，基本完全都是这种情况</strong>。所以，下面两种情况，胖友不理解也是没关系的。</li>
<li><code>&lt;2&gt;</code> ，根据配置项 <code>ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP</code> ，每个 Channel 从 EventExecutorGroup 获得<strong>不同</strong> EventExecutor 执行器。</li>
<li><code>&lt;3&gt;</code> ，通过 <code>childExecutors</code> 缓存实现，每个 Channel 从 EventExecutorGroup 获得<strong>相同</strong> EventExecutor 执行器。是否获得相同的 EventExecutor 执行器，这就是 <code>&lt;2&gt;</code>、<code>&lt;3&gt;</code> 的不同。</li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>，创建的是 DefaultChannelHandlerContext 对象。</li>
</ul>
<h1 id="6-addLast0"><a href="#6-addLast0" class="headerlink" title="6. addLast0"></a>6. addLast0</h1><p><code>#addLast0(AbstractChannelHandlerContext newCtx)</code> 方法，添加到最后一个节点。<strong>注意</strong>，实际上，是添加到 <code>tail</code> 节点<strong>之前</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得 tail 节点的前一个节点</span></span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    <span class="comment">// 新节点，指向 prev 和 tail 节点</span></span><br><span class="line">    newCtx.prev = prev; <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    newCtx.next = tail; <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    <span class="comment">// 在 prev 和 tail ，指向新节点</span></span><br><span class="line">    prev.next = newCtx; <span class="comment">// &lt;3&gt;</span></span><br><span class="line">    tail.prev = newCtx; <span class="comment">// &lt;4&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>FROM 闪电侠 <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之pipeline(一)》</a></p>
<ul>
<li><p>用下面这幅图可见简单的表示这段过程，说白了，其实就是一个双向链表的插入操作：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_04/01.png" title="添加节点过程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_04/01.png" alt="添加节点过程"></a><span class="caption">添加节点过程</span></p>
</li>
<li><p>操作完毕，该节点就加入到 pipeline 中：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_04/02.png" title="添加节点之后" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_04/02.png" alt="添加节点之后"></a><span class="caption">添加节点之后</span></p>
</li>
</ul>
</blockquote>
<h1 id="7-callHandlerAdded0"><a href="#7-callHandlerAdded0" class="headerlink" title="7. callHandlerAdded0"></a>7. callHandlerAdded0</h1><p><code>#callHandlerAdded0(AbstractChannelHandlerContext)</code> 方法，执行回调 ChannelHandler 添加完成( added )事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates</span></span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// any pipeline events ctx.handler() will miss them because the state will not allow it.</span></span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 设置 AbstractChannelHandlerContext 已添加</span></span><br><span class="line"> <span class="number">6</span>:         ctx.setAddComplete();</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 回调 ChannelHandler 添加完成( added )事件</span></span><br><span class="line"> <span class="number">8</span>:         ctx.handler().handlerAdded(ctx);</span><br><span class="line"> <span class="number">9</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 发生异常，移除该节点</span></span><br><span class="line"><span class="number">11</span>:         <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">12</span>:         <span class="keyword">try</span> {</span><br><span class="line"><span class="number">13</span>:             remove0(ctx); <span class="comment">// 移除</span></span><br><span class="line"><span class="number">14</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">15</span>:                 ctx.handler().handlerRemoved(ctx); <span class="comment">// 回调 ChannelHandler 移除完成( removed )事件</span></span><br><span class="line"><span class="number">16</span>:             } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">17</span>:                 ctx.setRemoved(); <span class="comment">// 标记节点已移除</span></span><br><span class="line"><span class="number">18</span>:             }</span><br><span class="line"><span class="number">19</span>:             removed = <span class="keyword">true</span>; <span class="comment">// 标记移除成功</span></span><br><span class="line"><span class="number">20</span>:         } <span class="keyword">catch</span> (Throwable t2) {</span><br><span class="line"><span class="number">21</span>:             <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line"><span class="number">22</span>:                 logger.warn(<span class="string">"Failed to remove a handler: "</span> + ctx.name(), t2);</span><br><span class="line"><span class="number">23</span>:             }</span><br><span class="line"><span class="number">24</span>:         }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:         <span class="comment">// 触发异常的传播</span></span><br><span class="line"><span class="number">27</span>:         <span class="keyword">if</span> (removed) {</span><br><span class="line"><span class="number">28</span>:             fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line"><span class="number">29</span>:                     ctx.handler().getClass().getName() +</span><br><span class="line"><span class="number">30</span>:                     <span class="string">".handlerAdded() has thrown an exception; removed."</span>, t));</span><br><span class="line"><span class="number">31</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">32</span>:             fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line"><span class="number">33</span>:                     ctx.handler().getClass().getName() +</span><br><span class="line"><span class="number">34</span>:                     <span class="string">".handlerAdded() has thrown an exception; also failed to remove."</span>, t));</span><br><span class="line"><span class="number">35</span>:         }</span><br><span class="line"><span class="number">36</span>:     }</span><br><span class="line"><span class="number">37</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 6 行：调用 <code>AbstractChannelHandlerContext#setAddComplete()</code> 方法，设置 AbstractChannelHandlerContext 已添加。</li>
<li>第 8 行：调用 <code>ChannelHandler#handlerAdded(AbstractChannelHandlerContext)</code> 方法，回调 ChannelHandler 添加完成( added )事件。一般来说，通过这个方法，来初始化 ChannelHandler 。<strong>注意</strong>，因为这个方法的执行在 EventLoop 的线程中，所以要尽量避免执行时间过长。</li>
<li>第 9 行：发生异常。<ul>
<li>第 10 至 24 行：移除该节点( ChannelHandler )。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ChannelPipeline-3-remove-channel-handler">《精尽 Netty 源码解析 —— ChannelPipeline（三）之移除 ChannelHandler》</a> 。<ul>
<li>😈 所以，<code>ChannelHandler#handlerAdded(AbstractChannelHandlerContext)</code> 方法的执行<strong>异常</strong>时，将被移除。</li>
</ul>
</li>
<li>第 26 至 35 行：触发异常的传播。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ChannelPipeline-6-exception">《精尽 Netty 源码解析 —— ChannelPipeline（六）之异常事件的传播》</a> 。</li>
</ul>
</li>
</ul>
<h1 id="8-PendingHandlerCallback"><a href="#8-PendingHandlerCallback" class="headerlink" title="8. PendingHandlerCallback"></a>8. PendingHandlerCallback</h1><p>PendingHandlerCallback ，实现 Runnable 接口，等待添加 ChannelHandler 回调抽象类。代码如下：</p>
<blockquote>
<p>PendingHandlerCallback 是 DefaultChannelPipeline 的内部静态类。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractChannelHandlerContext 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个回调 PendingHandlerCallback 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PendingHandlerCallback next;</span><br><span class="line"></span><br><span class="line">    PendingHandlerCallback(AbstractChannelHandlerContext ctx) {</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>ctx</code> 和 <code>next</code> 字段，形成<strong>回调链</strong>。</li>
<li><code>#execute()</code> 抽象方法，通过实现它，执行回调逻辑。</li>
</ul>
<hr>
<p><strong>为什么会有 PendingHandlerCallback 呢</strong>？</p>
<p>因为 ChannelHandler 添加到 pipeline 中，会触发 ChannelHandler 的添加完成( added )事件，并且该事件需要在 Channel 所属的 EventLoop 中执行。</p>
<p>但是 Channel 并未注册在 EventLoop 上时，需要暂时将“触发 ChannelHandler 的添加完成( added )事件”的逻辑，作为一个 PendingHandlerCallback 进行“缓存”。在 Channel 注册到 EventLoop 上时，进行回调执行。</p>
<hr>
<p>PendingHandlerCallback 有两个实现类：</p>
<ul>
<li>PendingHandlerAddedTask</li>
<li>PendingHandlerRemovedTask</li>
</ul>
<p>本文只分享 PendingHandlerAddedTask 的代码实现。</p>
<h2 id="8-1-PendingHandlerAddedTask"><a href="#8-1-PendingHandlerAddedTask" class="headerlink" title="8.1 PendingHandlerAddedTask"></a>8.1 PendingHandlerAddedTask</h2><p>PendingHandlerAddedTask 实现 PendingHandlerCallback 抽象类，用于回调添加 ChannelHandler 节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerAddedTask</span> <span class="keyword">extends</span> <span class="title">PendingHandlerCallback</span> </span>{</span><br><span class="line"></span><br><span class="line">    PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) {</span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        callHandlerAdded0(ctx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{</span><br><span class="line">        EventExecutor executor = ctx.executor();</span><br><span class="line">        <span class="comment">// 在 EventLoop 的线程中，回调 ChannelHandler added 事件</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) {</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 提交 EventLoop 中，执行回调 ChannelHandler added 事件</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                executor.execute(<span class="keyword">this</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">            } <span class="keyword">catch</span> (RejectedExecutionException e) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Can't invoke handlerAdded() as the EventExecutor {} rejected it, removing handler {}."</span>,</span><br><span class="line">                            executor, ctx.name(), e);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 发生异常，进行移除</span></span><br><span class="line">                remove0(ctx);</span><br><span class="line">                <span class="comment">// 标记 AbstractChannelHandlerContext 为已移除</span></span><br><span class="line">                ctx.setRemoved();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <code>#execute()</code> 实现方法中，我们可以看到，和 <code>#addLast(EventExecutorGroup group, String name, ChannelHandler handler)</code> 方法的【第 28 至 45 行】的代码比较类似，目的是，在 EventLoop 的线程中，执行 <code>#callHandlerAdded0(AbstractChannelHandlerContext)</code> 方法，回调 ChannelHandler 添加完成( added )事件。</li>
<li><code>&lt;1&gt;</code> 处，为什么 PendingHandlerAddedTask 可以直接提交到 EventLoop 中呢？因为 PendingHandlerAddedTask 是个 Runnable ，这也就是为什么 PendingHandlerCallback 实现 Runnable 接口的原因。</li>
</ul>
<blockquote>
<p>老艿艿：下面开始分享的方法，属于 DefaultChannelPipeline 类。</p>
</blockquote>
<h2 id="8-2-callHandlerCallbackLater"><a href="#8-2-callHandlerCallbackLater" class="headerlink" title="8.2 callHandlerCallbackLater"></a>8.2 callHandlerCallbackLater</h2><p><code>#callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added)</code> 方法，添加 PendingHandlerCallback 回调。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the head of a linked list that is processed by {<span class="doctag">@link</span> #callHandlerAddedForAllHandlers()} and so process</span></span><br><span class="line"><span class="comment"> * all the pending {<span class="doctag">@link</span> #callHandlerAdded0(AbstractChannelHandlerContext)}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We only keep the head because it is expected that the list is used infrequently and its size is small.</span></span><br><span class="line"><span class="comment"> * Thus full iterations to do insertions is assumed to be a good compromised to saving memory and tail management</span></span><br><span class="line"><span class="comment"> * complexity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 准备添加 ChannelHandler 的回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #callHandlerCallbackLater(AbstractChannelHandlerContext, boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    </span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="keyword">boolean</span> added)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="keyword">assert</span> !registered;</span><br><span class="line">  <span class="number">3</span>: </span><br><span class="line">  <span class="number">4</span>:     <span class="comment">// 创建 PendingHandlerCallback 对象</span></span><br><span class="line">  <span class="number">5</span>:     PendingHandlerCallback task = added ? <span class="keyword">new</span> PendingHandlerAddedTask(ctx) : <span class="keyword">new</span> PendingHandlerRemovedTask(ctx);</span><br><span class="line">  <span class="number">6</span>:     PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">  <span class="number">7</span>:     <span class="comment">// 若原 pendingHandlerCallbackHead 不存在，则赋值给它</span></span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">if</span> (pending == <span class="keyword">null</span>) {</span><br><span class="line">  <span class="number">9</span>:         pendingHandlerCallbackHead = task;</span><br><span class="line"> <span class="number">10</span>:     <span class="comment">// 若原 pendingHandlerCallbackHead 已存在，则最后一个回调指向新创建的回调</span></span><br><span class="line"> <span class="number">11</span>:     } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">12</span>:         <span class="comment">// Find the tail of the linked-list.</span></span><br><span class="line"> <span class="number">13</span>:         <span class="keyword">while</span> (pending.next != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">14</span>:             pending = pending.next;</span><br><span class="line"> <span class="number">15</span>:         }</span><br><span class="line"> <span class="number">16</span>:         pending.next = task;</span><br><span class="line"> <span class="number">17</span>:     }</span><br><span class="line"> <span class="number">18</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>added</code> 方法参数，表示是否是添加 ChannelHandler 的回调。所以在【第 5 行】的代码，根据 <code>added</code> 是否为 <code>true</code> ，创建 PendingHandlerAddedTask 或 PendingHandlerRemovedTask 对象。在本文中，当然创建的是 PendingHandlerAddedTask 。</li>
<li>第 7 至 17 行：将创建的 PendingHandlerCallback 对象，“添加”到 <code>pendingHandlerCallbackHead</code> 中。</li>
</ul>
<h2 id="8-3-invokeHandlerAddedIfNeeded"><a href="#8-3-invokeHandlerAddedIfNeeded" class="headerlink" title="8.3 invokeHandlerAddedIfNeeded"></a>8.3 invokeHandlerAddedIfNeeded</h2><p><code>#invokeHandlerAddedIfNeeded()</code> 方法，执行<strong>在 PendingHandlerCallback 中</strong>的 ChannelHandler 添加完成( added )事件。它被两个方法所调用：</p>
<ul>
<li><p><code>AbstractUnsafe#register0(ChannelPromise promise)</code> 方法</p>
<ul>
<li><p>原因是：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line"><span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>例如 ServerBootstrap 通过 ChannelInitializer 注册自定义的 ChannelHandler 到 pipeline 上的情况。</li>
</ul>
</li>
<li>调用栈如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_06_04/03.png" title="register0" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_04/03.png" alt="register0"></a><span class="caption">register0</span></li>
</ul>
</li>
<li><code>HeadContext#channelRegistered(ChannelHandlerContext ctx)</code> 方法。<ul>
<li>笔者调试下来，对于 Netty NIO Server 和 NIO Client 貌似没啥作用，因为已经在 <code>AbstractUnsafe#register0(ChannelPromise promise)</code> 中触发。胖友也可以自己调试下。</li>
<li>调用栈如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_06_04/04.png" title="channelRegistered" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_04/04.png" alt="channelRegistered"></a><span class="caption">channelRegistered</span></li>
</ul>
</li>
</ul>
<hr>
<p><code>#invokeHandlerAddedIfNeeded()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否首次注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #invokeHandlerAddedIfNeeded()}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> firstRegistration = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop(); <span class="comment">// 必须在 EventLoop 的线程中</span></span><br><span class="line">    <span class="comment">// 仅有首次注册有效 &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) {</span><br><span class="line">        <span class="comment">// 标记非首次注册</span></span><br><span class="line">        firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行在 PendingHandlerCallback 中的 ChannelHandler 添加完成( added )事件 // &lt;2&gt;</span></span><br><span class="line">        <span class="comment">// We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">        <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，仅有首次注册有效( <code>firstRegistration = true</code> ) 时。而后，标记 <code>firstRegistration = false</code> 。<ul>
<li>这也就是笔者为什么说，<code>HeadContext#channelRegistered(ChannelHandlerContext ctx)</code> 方法对这个方法的调用，是没有效果的。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#callHandlerAddedForAllHandlers()</code> 方法，执行<strong>在 PendingHandlerCallback 中</strong>的 ChannelHandler 添加完成( added )事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAddedForAllHandlers</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 获得 pendingHandlerCallbackHead</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">assert</span> !registered;</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// This Channel itself was registered.</span></span><br><span class="line"> <span class="number">8</span>:         registered = <span class="keyword">true</span>; <span class="comment">// 标记已注册</span></span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:         pendingHandlerCallbackHead = <span class="keyword">this</span>.pendingHandlerCallbackHead;</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// Null out so it can be GC'ed.</span></span><br><span class="line"><span class="number">12</span>:         <span class="keyword">this</span>.pendingHandlerCallbackHead = <span class="keyword">null</span>; <span class="comment">// 置空，help gc</span></span><br><span class="line"><span class="number">13</span>:     }</span><br><span class="line"><span class="number">14</span>: </span><br><span class="line"><span class="number">15</span>:     <span class="comment">// 顺序向下，执行 PendingHandlerCallback 的回调</span></span><br><span class="line"><span class="number">16</span>:     <span class="comment">// This must happen outside of the synchronized(...) block as otherwise handlerAdded(...) may be called while</span></span><br><span class="line"><span class="number">17</span>:     <span class="comment">// holding the lock and so produce a deadlock if handlerAdded(...) will try to add another handler from outside</span></span><br><span class="line"><span class="number">18</span>:     <span class="comment">// the EventLoop.</span></span><br><span class="line"><span class="number">19</span>:     PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line"><span class="number">20</span>:     <span class="keyword">while</span> (task != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">21</span>:         task.execute();</span><br><span class="line"><span class="number">22</span>:         task = task.next;</span><br><span class="line"><span class="number">23</span>:     }</span><br><span class="line"><span class="number">24</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 13 行：获得 <code>pendingHandlerCallbackHead</code> 变量。<ul>
<li>第 8 行：标记 <code>registered = true</code> ，表示已注册。</li>
<li>第 10 至 12 行：置空对象的 <code>pendingHandlerCallbackHead</code> 属性，help GC 。</li>
<li>使用 <code>synchronized</code> 的原因，和 <code>#addLast(EventExecutorGroup group, String name, ChannelHandler handler)</code> 的【第 16 至 26 行】的代码需要对 <code>pendingHandlerCallbackHead</code> 互斥，避免并发修改的问题。</li>
</ul>
</li>
<li>第 15 至 23 行：顺序循环向下，调用 <code>PendingHandlerCallback#execute()</code> 方法，执行 PendingHandlerCallback 的回调，从而将 ChannelHandler 添加到 pipeline 中。<ul>
<li>这里不适用 <code>synchronized</code> 的原因，看英文注释哈。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p><strong>添加</strong> ChannelHandler 到 pipeline 中的代码，大部分的比较简单。比较复杂的可能是，<a href="#">「8. PendingHandlerCallback」</a> 中，调用的过程涉及<strong>回调</strong>，所以理解上稍微可能困难。胖友可以多多调试进行解决噢。</p>
<p>推荐阅读文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 pipeline(一)》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/0e15165714fc" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析 Netty（七）–ChannelPipeline 源码实现》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler/" data-id="ck4pl3foy00dkfgcf5y268937" class="article-share-link">分享</a>



</footer>
-->
</div>