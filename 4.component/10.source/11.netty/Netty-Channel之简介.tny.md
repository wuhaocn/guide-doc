<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Channel（一）之简介
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在前面的文章中，我们已经不断看到 Netty Channel 的身影，例如：</p>
<ul>
<li>在 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/">《精尽 Netty 源码分析 —— 启动（一）之服务端》</a> 中，我们看了服务端 NioServerSocketChannel <strong>对象创建</strong>的过程。</li>
<li>在 <a href="http://svip.iocoder.cn/Netty/bootstrap-2-client/">《精尽 Netty 源码分析 —— 启动（二）之客户端》</a> 中，我们看了客户端 NioSocketChannel <strong>对象创建</strong>的过程。 </li>
</ul>
<p>但是，考虑到本小节的后续文章，我们还是需要这样一篇文章，整体性的再看一次 Channel 的面貌。</p>
<h1 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h1><p><code>io.netty.channel.Channel</code> ，实现 AttributeMap、ChannelOutboundInvoker、Comparable 接口，Netty Channel 接口。</p>
<p>在 <a href="http://svip.iocoder.cn/Netty/intro-1/">《精尽 Netty 源码分析 —— Netty 简介（一）之项目结构》</a> 中，我们对 Channel 的组件定义如下：</p>
<blockquote>
<p>Channel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channel 的 EventLoop 。</p>
<p>在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而 Netty 的 Channel 则提供的一系列的 API ，它大大降低了直接与 Socket 进行操作的复杂性。而相对于原生 NIO 的 Channel，Netty 的 Channel 具有如下优势( 摘自《Netty权威指南( 第二版 )》) ：</p>
<ul>
<li>在 Channel 接口层，采用 Facade 模式进行统一封装，将网络 I/O 操作、网络 I/O 相关联的其他操作封装起来，统一对外提供。</li>
<li>Channel 接口的定义尽量大而全，为 SocketChannel 和 ServerSocketChannel 提供统一的视图，由不同子类实现不同的功能，公共功能在抽象父类中实现，最大程度地实现功能和接口的重用。</li>
<li>具体实现采用聚合而非包含的方式，将相关的功能类聚合在 Channel 中，由 Channel 统一负责和调度，功能实现更加灵活。</li>
</ul>
</blockquote>
<h2 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the globally unique identifier of this {<span class="doctag">@link</span> Channel}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 的编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelId <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> EventLoop} this {<span class="doctag">@link</span> Channel} was registered to.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 注册到的 EventLoop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">EventLoop <span class="title">eventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the parent of this channel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父 Channel 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the parent channel.</span></span><br><span class="line"><span class="comment"> *         {<span class="doctag">@code</span> null} if this channel does not have a parent channel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Channel <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the configuration of this channel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 配置参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelConfig <span class="title">config</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &lt;em&gt;internal-use-only&lt;/em&gt; object that provides unsafe operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unsafe 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Unsafe <span class="title">unsafe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the assigned {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ChannelPipeline 对象，用于处理 Inbound 和 Outbound 事件的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the assigned {<span class="doctag">@link</span> ByteBufAllocator} which will be used to allocate {<span class="doctag">@link</span> ByteBuf}s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ByteBuf 分配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the local address where this channel is bound to.  The returned</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> SocketAddress} is supposed to be down-cast into more concrete</span></span><br><span class="line"><span class="comment"> * type such as {<span class="doctag">@link</span> InetSocketAddress} to retrieve the detailed</span></span><br><span class="line"><span class="comment"> * information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本地地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the local address of this channel.</span></span><br><span class="line"><span class="comment"> *         {<span class="doctag">@code</span> null} if this channel is not bound.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the remote address where this channel is connected to.  The</span></span><br><span class="line"><span class="comment"> * returned {<span class="doctag">@link</span> SocketAddress} is supposed to be down-cast into more</span></span><br><span class="line"><span class="comment"> * concrete type such as {<span class="doctag">@link</span> InetSocketAddress} to retrieve the detailed</span></span><br><span class="line"><span class="comment"> * information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 远端地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the remote address of this channel.</span></span><br><span class="line"><span class="comment"> *         {<span class="doctag">@code</span> null} if this channel is not connected.</span></span><br><span class="line"><span class="comment"> *         If this channel is not connected but it can receive messages</span></span><br><span class="line"><span class="comment"> *         from arbitrary remote addresses (e.g. {<span class="doctag">@link</span> DatagramChannel},</span></span><br><span class="line"><span class="comment"> *         use {<span class="doctag">@link</span> DatagramPacket#recipient()} to determine</span></span><br><span class="line"><span class="comment"> *         the origination of the received message as this method will</span></span><br><span class="line"><span class="comment"> *         return {<span class="doctag">@code</span> null}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SocketAddress <span class="title">remoteAddress</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>自身基本信息有 <code>#id()</code>、<code>#parent()</code>、<code>#config()</code>、<code>#localAddress()</code>、<code>#remoteAddress()</code> 方法。</li>
<li>每个 Channel 都有的核心组件有 <code>#eventLoop()</code>、<code>#unsafe()</code>、<code>#pipeline()</code>、<code>#alloc()</code> 方法。</li>
</ul>
<h2 id="2-2-状态查询"><a href="#2-2-状态查询" class="headerlink" title="2.2 状态查询"></a>2.2 状态查询</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if the {<span class="doctag">@link</span> Channel} is open and may get active later</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 是否打开。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * true 表示 Channel 可用</span></span><br><span class="line"><span class="comment"> * false 表示 Channel 已关闭，不可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if the {<span class="doctag">@link</span> Channel} is registered with an {<span class="doctag">@link</span> EventLoop}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 是否注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * true 表示 Channel 已注册到 EventLoop 上</span></span><br><span class="line"><span class="comment"> * false 表示 Channel 未注册到 EventLoop 上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRegistered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return {<span class="doctag">@code</span> true} if the {<span class="doctag">@link</span> Channel} is active and so connected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 是否激活</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于服务端 ServerSocketChannel ，true 表示 Channel 已经绑定到端口上，可提供服务</span></span><br><span class="line"><span class="comment"> * 对于客户端 SocketChannel ，true 表示 Channel 连接到远程服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if and only if the I/O thread will perform the</span></span><br><span class="line"><span class="comment"> * requested write operation immediately.  Any write requests made when</span></span><br><span class="line"><span class="comment"> * this method returns {<span class="doctag">@code</span> false} are queued until the I/O thread is</span></span><br><span class="line"><span class="comment"> * ready to process the queued write requests.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 是否可写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当 Channel 的写缓存区 outbound 非 null 且可写时，返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得距离不可写还有多少字节数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Get how many bytes can be written until {<span class="doctag">@link</span> #isWritable()} returns {<span class="doctag">@code</span> false}.</span></span><br><span class="line"><span class="comment"> * This quantity will always be non-negative. If {<span class="doctag">@link</span> #isWritable()} is {<span class="doctag">@code</span> false} then 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">bytesBeforeUnwritable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得距离可写还要多少字节数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Get how many bytes must be drained from underlying buffers until {<span class="doctag">@link</span> #isWritable()} returns {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment"> * This quantity will always be non-negative. If {<span class="doctag">@link</span> #isWritable()} is {<span class="doctag">@code</span> true} then 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">bytesBeforeWritable</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>一个<strong>正常结束</strong>的 Channel 状态转移有<strong>两</strong>种情况：</p>
<ul>
<li><p>服务端用于绑定( bind )的 Channel 、或者客户端发起连接( connect )的 Channel 。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">REGISTERED -&gt; CONNECT/BIND -&gt; ACTIVE -&gt; CLOSE -&gt; INACTIVE -&gt; UNREGISTERED</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>服务端接受( accept )客户端的 Channel 。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">REGISTERED -&gt; ACTIVE -&gt; CLOSE -&gt; INACTIVE -&gt; UNREGISTERED</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>一个<strong>异常关闭</strong>的 Channel 状态转移不符合上面的。</p>
<h2 id="2-3-IO-操作"><a href="#2-3-IO-操作" class="headerlink" title="2.3 IO 操作"></a>2.3 IO 操作</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Channel <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Channel <span class="title">flush</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>这两个方法，继承自 ChannelOutboundInvoker 接口。实际还有如下几个：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">deregister</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">deregister</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对比下来，我们会发现 Channel 重写 ChannelOutboundInvoker 这两个接口的原因是：将返回值从 ChannelOutboundInvoker 修改成 Channel 。</p>
</li>
<li>我们看到除了 <code>#read()</code> 和 <code>#flush()</code> 方法，其它方法的返回值的类型都是 ChannelFuture ，这表明这些操作是<strong>异步</strong> IO 的过程。</li>
</ul>
<h2 id="2-4-异步结果-Future"><a href="#2-4-异步结果-Future" class="headerlink" title="2.4 异步结果 Future"></a>2.4 异步结果 Future</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the {<span class="doctag">@link</span> ChannelFuture} which will be notified when this</span></span><br><span class="line"><span class="comment"> * channel is closed.  This method always returns the same future instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Channel 关闭的 Future 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">closeFuture</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>除了自定义的 <code>#closeFuture()</code> 方法，也从 ChannelOutboundInvoker 接口继承了几个接口方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ChannelPromise <span class="title">newPromise</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelProgressivePromise <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelFuture <span class="title">newSucceededFuture</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">newFailedFuture</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过这些接口方法，可创建或获得和该 Channel 相关的 Future / Promise 对象。</li>
</ul>
</li>
</ul>
<h2 id="2-5-类图"><a href="#2-5-类图" class="headerlink" title="2.5 类图"></a>2.5 类图</h2><p>Channel 的子接口和实现类如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_07_01/01.png" title="Channel 的子接口和实现类" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_07_01/01.png" alt="Channel 的子接口和实现类"></a><span class="caption">Channel 的子接口和实现类</span></p>
<ul>
<li>本图包含了 NIO、OIO、Local、Embedded 四种 Channel 实现类。说明如下：<a href="http://static2.iocoder.cn/images/Netty/2018_07_01/02.png" title="Channel 四种 Channel 实现类的说明" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_07_01/02.png" alt="Channel 四种 Channel 实现类的说明"></a><span class="caption">Channel 四种 Channel 实现类的说明</span></li>
<li>本系列仅分享 NIO 部分，所以裁剪类图如下：<a href="http://static2.iocoder.cn/images/Netty/2018_07_01/03.png" title="NIO Channel 类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_07_01/03.png" alt="NIO Channel 类图"></a><span class="caption">NIO Channel 类图</span></li>
</ul>
<h1 id="3-Unsafe"><a href="#3-Unsafe" class="headerlink" title="3. Unsafe"></a>3. Unsafe</h1><p>Unsafe <strong>接口</strong>，定义在在 <code>io.netty.channel.Channel</code> 内部，和 Channel 的操作<strong>紧密结合</strong>，下文我们将看到。</p>
<p>Unsafe 直译中文为“不安全”，就是告诉我们，<strong>无需</strong>且<strong>不必要</strong>在我们使用 Netty 的代码中，<strong>不能直接</strong>调用 Unsafe 相关的方法。Netty 注释说明如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;Unsafe&lt;/em&gt; operations that should &lt;em&gt;never&lt;/em&gt; be called from user-code. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * These methods are only provided to implement the actual transport, and must be invoked from an I/O thread except for the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;{<span class="doctag">@link</span> #localAddress()}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;{<span class="doctag">@link</span> #remoteAddress()}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;{<span class="doctag">@link</span> #closeForcibly()}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;{<span class="doctag">@link</span> #register(EventLoop, ChannelPromise)}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;{<span class="doctag">@link</span> #deregister(ChannelPromise)}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;{<span class="doctag">@link</span> #voidPromise()}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<p>😈 当然，对于我们想要了解 Netty 内部实现的胖友，那必须开扒它的代码实现落。因为它和 Channel 密切相关，所以我们也对它的接口做下分类。</p>
<h2 id="3-1-基础查询"><a href="#3-1-基础查询" class="headerlink" title="3.1 基础查询"></a>3.1 基础查询</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the assigned {<span class="doctag">@link</span> RecvByteBufAllocator.Handle} which will be used to allocate {<span class="doctag">@link</span> ByteBuf}'s when</span></span><br><span class="line"><span class="comment"> * receiving data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ByteBuf 分配器的处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RecvByteBufAllocator.<span class="function">Handle <span class="title">recvBufAllocHandle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> SocketAddress} to which is bound local or</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> null} if none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本地地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> SocketAddress} to which is bound remote or</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> null} if none is bound yet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 远端地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SocketAddress <span class="title">remoteAddress</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-2-状态查询"><a href="#3-2-状态查询" class="headerlink" title="3.2 状态查询"></a>3.2 状态查询</h2><p>无 😈</p>
<h2 id="3-3-IO-操作"><a href="#3-3-IO-操作" class="headerlink" title="3.3 IO 操作"></a>3.3 IO 操作</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeForcibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the {<span class="doctag">@link</span> ChannelOutboundBuffer} of the {<span class="doctag">@link</span> Channel} where the pending write requests are stored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelOutboundBuffer <span class="title">outboundBuffer</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-4-异步结果-Future"><a href="#3-4-异步结果-Future" class="headerlink" title="3.4 异步结果 Future"></a>3.4 异步结果 Future</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a special ChannelPromise which can be reused and passed to the operations in {<span class="doctag">@link</span> Unsafe}.</span></span><br><span class="line"><span class="comment"> * It will never be notified of a success or error and so is only a placeholder for operations</span></span><br><span class="line"><span class="comment"> * that take a {<span class="doctag">@link</span> ChannelPromise} as argument but for which you not want to get notified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-5-类图"><a href="#3-5-类图" class="headerlink" title="3.5 类图"></a>3.5 类图</h2><p>Unsafe 的子接口和实现类如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_07_01/04.png" title="Unsafe 的子接口和实现类" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_07_01/04.png" alt="Unsafe 的子接口和实现类"></a><span class="caption">Unsafe 的子接口和实现类</span></p>
<ul>
<li>已经经过裁剪，仅保留 NIO Channel 相关的 Unsafe 的子接口和实现类部分。</li>
<li>我们会发现，对于 Channel 和 Unsafe 来说，类名中包含 Byte 是属于客户端的，Message 是属于服务端的。</li>
</ul>
<h1 id="4-ChanelId"><a href="#4-ChanelId" class="headerlink" title="4. ChanelId"></a>4. ChanelId</h1><p><code>io.netty.channel.ChannelId</code> 实现 Serializable、Comparable 接口，Channel 编号接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelId</span> <span class="keyword">extends</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">ChannelId</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the short but globally non-unique string representation of the {<span class="doctag">@link</span> ChannelId}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 全局非唯一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">asShortText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the long yet globally unique string representation of the {<span class="doctag">@link</span> ChannelId}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 全局唯一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">asLongText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#asShortText()</code> 方法，返回的编号，短，但是全局非唯一。</li>
<li><code>#asLongText()</code> 方法，返回的编号，长，但是全局唯一。</li>
</ul>
<p>ChanelId 的<strong>默认</strong>实现类为 <code>io.netty.channel.DefaultChannelId</code> ，我们主要看看它是如何生成 Channel 的<strong>两种</strong>编号的。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">asShortText</span><span class="params">()</span> </span>{</span><br><span class="line">    String shortValue = <span class="keyword">this</span>.shortValue;</span><br><span class="line">    <span class="keyword">if</span> (shortValue == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.shortValue = shortValue = ByteBufUtil.hexDump(data, data.length - RANDOM_LEN, RANDOM_LEN);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> shortValue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">asLongText</span><span class="params">()</span> </span>{</span><br><span class="line">    String longValue = <span class="keyword">this</span>.longValue;</span><br><span class="line">    <span class="keyword">if</span> (longValue == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.longValue = longValue = newLongValue();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> longValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 <code>#asShortText()</code> 方法，仅使用最后 4 字节的随机数字，并转换成 16 进制的数字字符串。也因此，短，但是全局非唯一。</li>
<li><p>对于 <code>#asLongText()</code> 方法，通过调用 <code>#newLongValue()</code> 方法生成。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">newLongValue</span><span class="params">()</span> </span>{</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">2</span> * data.length + <span class="number">5</span>); <span class="comment">// + 5 的原因是有 5 个 '-'</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i = appendHexDumpField(buf, i, MACHINE_ID.length); <span class="comment">// MAC 地址。</span></span><br><span class="line">    i = appendHexDumpField(buf, i, PROCESS_ID_LEN); <span class="comment">// 进程 ID 。4 字节。</span></span><br><span class="line">    i = appendHexDumpField(buf, i, SEQUENCE_LEN); <span class="comment">// 32 位数字，顺序增长。4 字节。</span></span><br><span class="line">    i = appendHexDumpField(buf, i, TIMESTAMP_LEN); <span class="comment">// 时间戳。8 字节。</span></span><br><span class="line">    i = appendHexDumpField(buf, i, RANDOM_LEN); <span class="comment">// 32 位数字，随机。4 字节。</span></span><br><span class="line">    <span class="keyword">assert</span> i == data.length;</span><br><span class="line">    <span class="keyword">return</span> buf.substring(<span class="number">0</span>, buf.length() - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">appendHexDumpField</span><span class="params">(StringBuilder buf, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    buf.append(ByteBufUtil.hexDump(data, i, length));</span><br><span class="line">    buf.append(<span class="string">'-'</span>);</span><br><span class="line">    i += length;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的生成规则，见代码。最终也是 16 进制的数字。也因此，长，但是全局唯一。</li>
</ul>
</li>
</ul>
<h1 id="5-ChannelConfig"><a href="#5-ChannelConfig" class="headerlink" title="5. ChannelConfig"></a>5. ChannelConfig</h1><p><code>io.netty.channel.ChannelConfig</code> ，Channel 配置接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Map&lt;ChannelOption&lt;?&gt;, Object&gt; getOptions();</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getOption</span><span class="params">(ChannelOption&lt;T&gt; option)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">setOptions</span><span class="params">(Map&lt;ChannelOption&lt;?&gt;, ?&gt; options)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">setOption</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getConnectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setConnectTimeoutMillis</span><span class="params">(<span class="keyword">int</span> connectTimeoutMillis)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxMessagesPerRead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function">ChannelConfig <span class="title">setMaxMessagesPerRead</span><span class="params">(<span class="keyword">int</span> maxMessagesPerRead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWriteSpinCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setWriteSpinCount</span><span class="params">(<span class="keyword">int</span> writeSpinCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ByteBufAllocator <span class="title">getAllocator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setAllocator</span><span class="params">(ByteBufAllocator allocator)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T extends RecvByteBufAllocator&gt; <span class="function">T <span class="title">getRecvByteBufAllocator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setRecvByteBufAllocator</span><span class="params">(RecvByteBufAllocator allocator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutoRead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setAutoRead</span><span class="params">(<span class="keyword">boolean</span> autoRead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutoClose</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setAutoClose</span><span class="params">(<span class="keyword">boolean</span> autoClose)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWriteBufferHighWaterMark</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setWriteBufferHighWaterMark</span><span class="params">(<span class="keyword">int</span> writeBufferHighWaterMark)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWriteBufferLowWaterMark</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setWriteBufferLowWaterMark</span><span class="params">(<span class="keyword">int</span> writeBufferLowWaterMark)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MessageSizeEstimator <span class="title">getMessageSizeEstimator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setMessageSizeEstimator</span><span class="params">(MessageSizeEstimator estimator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">WriteBufferWaterMark <span class="title">getWriteBufferWaterMark</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelConfig <span class="title">setWriteBufferWaterMark</span><span class="params">(WriteBufferWaterMark writeBufferWaterMark)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>#setOption(ChannelOption&lt;T&gt; option, T value)</code> 方法时，会调用相应的 <code>#setXXX(...)</code> 方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelConfig.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">setOption</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>{</span><br><span class="line">    validate(option, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (option == CONNECT_TIMEOUT_MILLIS) {</span><br><span class="line">        setConnectTimeoutMillis((Integer) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == MAX_MESSAGES_PER_READ) {</span><br><span class="line">        setMaxMessagesPerRead((Integer) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_SPIN_COUNT) {</span><br><span class="line">        setWriteSpinCount((Integer) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == ALLOCATOR) {</span><br><span class="line">        setAllocator((ByteBufAllocator) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == RCVBUF_ALLOCATOR) {</span><br><span class="line">        setRecvByteBufAllocator((RecvByteBufAllocator) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == AUTO_READ) {</span><br><span class="line">        setAutoRead((Boolean) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == AUTO_CLOSE) {</span><br><span class="line">        setAutoClose((Boolean) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_BUFFER_HIGH_WATER_MARK) {</span><br><span class="line">        setWriteBufferHighWaterMark((Integer) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_BUFFER_LOW_WATER_MARK) {</span><br><span class="line">        setWriteBufferLowWaterMark((Integer) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_BUFFER_WATER_MARK) {</span><br><span class="line">        setWriteBufferWaterMark((WriteBufferWaterMark) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == MESSAGE_SIZE_ESTIMATOR) {</span><br><span class="line">        setMessageSizeEstimator((MessageSizeEstimator) value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (option == SINGLE_EVENTEXECUTOR_PER_GROUP) {</span><br><span class="line">        setPinEventExecutorPerGroup((Boolean) value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>ChannelConfig 的配置项 <code>io.netty.channel.ChannelOption</code> 很多，胖友可以看下 <a href="https://www.jianshu.com/p/0bff7c020af2" rel="external nofollow noopener noreferrer" target="_blank">《Netty：option 和 childOption 参数设置说明》</a> ，了解感兴趣的配置项。</p>
</li>
</ul>
<h2 id="5-1-类图"><a href="#5-1-类图" class="headerlink" title="5.1 类图"></a>5.1 类图</h2><p>ChannelConfig 的子接口和实现类如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_07_01/05.png" title="ChannelConfig 的子接口和实现类" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_07_01/05.png" alt="ChannelConfig 的子接口和实现类"></a><span class="caption">ChannelConfig 的子接口和实现类</span></p>
<ul>
<li>已经经过裁剪，仅保留 NIO Channel 相关的 ChannelConfig 的子接口和实现类部分。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>正如文头所说，在前面的文章中，我们已经不断看到 Netty Channel 的身影，例如：</p>
<ul>
<li>在 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/">《精尽 Netty 源码分析 —— 启动（一）之服务端》</a> 中，我们看了服务端 NioServerSocketChannel <strong>bind</strong> 的过程。</li>
<li>在 <a href="http://svip.iocoder.cn/Netty/bootstrap-2-client/">《精尽 Netty 源码分析 —— 启动（二）之客户端》</a> 中，我们看了客户端 NioSocketChannel <strong>connect</strong> 的过程。 </li>
</ul>
<p>在后续的文章中，我们会分享 Netty NIO Channel 的其他操作，😈 一篇一个操作。</p>
<hr>
<p>推荐阅读文章：</p>
<ul>
<li>Hypercube <a href="https://www.jianshu.com/p/fffc18d33159" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析 Netty（六）–Channel总述》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Channel-1-intro/" data-id="ck4pl3foz00dnfgcfyrv52nd1" class="article-share-link">分享</a>



</footer>
-->
</div>