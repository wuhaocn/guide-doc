<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（三）之 EventLoop 初始化
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们分享 EventLoop 的具体代码实现。因为 EventLoop 涉及的代码量较大，所以笔者会分成好几篇文章分别分享。而本文，我们来分享 EventLoop 的初始化。</p>
<p>但是要将 EventLoop 拆出“初始化”部分的内容，笔者又觉得是件非常困难的事情。所以本文希望能达到如下的效果：</p>
<ol>
<li>理解 EventLoop 有哪些属性</li>
<li>创建 EventLoop 的过程</li>
<li>Channel 注册到 EventLoop 的过程</li>
<li>EventLoop 的任务提交。<ul>
<li>虽然任务的提交，比较接近任务的执行，但是考虑到胖友可以更容易的理解 EventLoop ，所以放在本文。</li>
</ul>
</li>
</ol>
<h1 id="2-类结构图"><a href="#2-类结构图" class="headerlink" title="2. 类结构图"></a>2. 类结构图</h1><p>EventLoopGroup 的整体类结构如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_05_04/01.png" title="EventLoopGroup 类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_04/01.png" alt="EventLoopGroup 类图"></a><span class="caption">EventLoopGroup 类图</span></p>
<ul>
<li>红框部分，为 EventLoopGroup 相关的类关系。<strong>其他部分，为 EventLoop 相关的类关系</strong>。</li>
<li>因为我们实际上使用的是 NioEventLoopGroup 和 <strong>NioEventLoop</strong> ，所以笔者省略了其它相关的类，例如 OioEventLoopGroup、EmbeddedEventLoop 等等。</li>
</ul>
<p>下面，我们逐层看看每个接口和类的实现代码。</p>
<h1 id="3-EventExecutor"><a href="#3-EventExecutor" class="headerlink" title="3. EventExecutor"></a>3. EventExecutor</h1><p><code>io.netty.util.concurrent.EventExecutor</code> ，继承 EventExecutorGroup 接口，事件执行器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 实现自 EventExecutorGroup 接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回自己</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a reference to itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">EventExecutor <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 自定义接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 EventExecutorGroup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> EventExecutorGroup} which is the parent of this {<span class="doctag">@link</span> EventExecutor},</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">EventExecutorGroup <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否在 EventLoop 线程中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Calls {<span class="doctag">@link</span> #inEventLoop(Thread)} with {<span class="doctag">@link</span> Thread#currentThread()} as argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程是否是 EventLoop 线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return {<span class="doctag">@code</span> true} if the given {<span class="doctag">@link</span> Thread} is executed in the event loop,</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> false} otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Promise 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return a new {<span class="doctag">@link</span> Promise}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;V&gt; <span class="function">Promise&lt;V&gt; <span class="title">newPromise</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 ProgressivePromise 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> ProgressivePromise}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;V&gt; <span class="function">ProgressivePromise&lt;V&gt; <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建成功结果的 Future 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> Future} which is marked as succeeded already. So {<span class="doctag">@link</span> Future#isSuccess()}</span></span><br><span class="line"><span class="comment"> * will return {<span class="doctag">@code</span> true}. All {<span class="doctag">@link</span> FutureListener} added to it will be notified directly. Also</span></span><br><span class="line"><span class="comment"> * every call of blocking methods will just return without blocking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">newSucceededFuture</span><span class="params">(V result)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建异常的 Future 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> Future} which is marked as failed already. So {<span class="doctag">@link</span> Future#isSuccess()}</span></span><br><span class="line"><span class="comment"> * will return {<span class="doctag">@code</span> false}. All {<span class="doctag">@link</span> FutureListener} added to it will be notified directly. Also</span></span><br><span class="line"><span class="comment"> * every call of blocking methods will just return without blocking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">newFailedFuture</span><span class="params">(Throwable cause)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接口定义的方法比较简单，已经添加中文注释，胖友自己看下。</li>
</ul>
<h1 id="4-OrderedEventExecutor"><a href="#4-OrderedEventExecutor" class="headerlink" title="4. OrderedEventExecutor"></a>4. OrderedEventExecutor</h1><p><code>io.netty.util.concurrent.OrderedEventExecutor</code> ，继承 EventExecutor 接口，有序的事件执行器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker interface for {<span class="doctag">@link</span> EventExecutor}s that will process all submitted tasks in an ordered / serial fashion.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderedEventExecutor</span> <span class="keyword">extends</span> <span class="title">EventExecutor</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>没有定义任何方法，仅仅是一个标记接口，表示该执行器会有序 / 串行的方式执行。</li>
</ul>
<h1 id="5-EventLoop"><a href="#5-EventLoop" class="headerlink" title="5. EventLoop"></a>5. EventLoop</h1><p><code>io.netty.channel.EventLoop</code> ，继承 OrderedEventExecutor 和 EventLoopGroup 接口，EventLoop 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Will handle all the I/O operations for a {<span class="doctag">@link</span> Channel} once registered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * One {<span class="doctag">@link</span> EventLoop} instance will usually handle more than one {<span class="doctag">@link</span> Channel} but this may depend on</span></span><br><span class="line"><span class="comment"> * implementation details and internals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoop</span> <span class="keyword">extends</span> <span class="title">OrderedEventExecutor</span>, <span class="title">EventLoopGroup</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">EventLoopGroup <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#parent()</code> 接口方法，覆写方法的返回类型为 EventLoopGroup 。</li>
<li>接口上的英文注释，意思如下：<ul>
<li>EventLoop 将会处理注册在其上的 Channel 的所有 IO 操作。</li>
<li>通常，一个 EventLoop 上可以注册不只一个 Channel 。当然，这个也取决于具体的实现。</li>
</ul>
</li>
</ul>
<h1 id="6-AbstractEventExecutor"><a href="#6-AbstractEventExecutor" class="headerlink" title="6. AbstractEventExecutor"></a>6. AbstractEventExecutor</h1><p><code>io.netty.util.concurrent.AbstractEventExecutor</code> ，实现 EventExecutor 接口，继承 AbstractExecutorService 抽象类，EventExecutor 抽象类。</p>
<h2 id="6-1-构造方法"><a href="#6-1-构造方法" class="headerlink" title="6.1 构造方法"></a>6.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 EventExecutorGroup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorGroup parent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventExecutor 数组。只包含自己，用于 {<span class="doctag">@link</span> #iterator()}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;EventExecutor&gt; selfCollection = Collections.&lt;EventExecutor&gt;singleton(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractEventExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractEventExecutor</span><span class="params">(EventExecutorGroup parent)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-2-parent"><a href="#6-2-parent" class="headerlink" title="6.2 parent"></a>6.2 parent</h2><p><code>#parent()</code> 方法，获得所属 EventExecutorGroup 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorGroup <span class="title">parent</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-3-next"><a href="#6-3-next" class="headerlink" title="6.3 next"></a>6.3 next</h2><p><code>#next()</code> 方法，获得自己。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-4-inEventLoop"><a href="#6-4-inEventLoop" class="headerlink" title="6.4 inEventLoop()"></a>6.4 inEventLoop()</h2><p><code>#inEventLoop()</code> 方法，判断当前线程是否在 EventLoop 线程中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> inEventLoop(Thread.currentThread());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的 <code>#inEventLoop(Thread thread)</code> 方法，需要在子类实现。因为 AbstractEventExecutor 类还体现不出它所拥有的线程。</li>
</ul>
<h2 id="6-5-iterator"><a href="#6-5-iterator" class="headerlink" title="6.5 iterator"></a>6.5 iterator</h2><p><code>#iterator()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;EventExecutor&gt; <span class="title">iterator</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> selfCollection.iterator();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-6-newPromise-和-newProgressivePromise"><a href="#6-6-newPromise-和-newProgressivePromise" class="headerlink" title="6.6 newPromise 和 newProgressivePromise"></a>6.6 newPromise 和 newProgressivePromise</h2><p><code>#newPromise()</code> 和 <code>#newProgressivePromise()</code> 方法，分别创建 DefaultPromise 和 DefaultProgressivePromise 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">Promise&lt;V&gt; <span class="title">newPromise</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultPromise&lt;V&gt;(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ProgressivePromise&lt;V&gt; <span class="title">newProgressivePromise</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultProgressivePromise&lt;V&gt;(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>我们可以看到，创建的 Promise 对象，都会传入自身作为 EventExecutor 。关于 Promise 相关的，我们在后续文章详细解析。实在想了解，也可以看看 <a href="https://www.kancloud.cn/ssj234/netty-source/433215" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码笔记 —— 第四章 Future 和 Promise》</a> 。</li>
</ul>
<h2 id="6-7-newSucceededFuture-和-newFailedFuture"><a href="#6-7-newSucceededFuture-和-newFailedFuture" class="headerlink" title="6.7 newSucceededFuture 和 newFailedFuture"></a>6.7 newSucceededFuture 和 newFailedFuture</h2><p><code>#newSucceededFuture(V result)</code> 和 <code>#newFailedFuture(Throwable cause)</code> 方法，分别创建成功结果和异常的 Future 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">newSucceededFuture</span><span class="params">(V result)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SucceededFuture&lt;V&gt;(<span class="keyword">this</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">newFailedFuture</span><span class="params">(Throwable cause)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FailedFuture&lt;V&gt;(<span class="keyword">this</span>, cause);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的 Future 对象，会传入自身作为 EventExecutor ，并传入 <code>result</code> 或 <code>cause</code> 分别作为成功结果和异常。</li>
</ul>
<h2 id="6-8-newTaskFor"><a href="#6-8-newTaskFor" class="headerlink" title="6.8 newTaskFor"></a>6.8 newTaskFor</h2><p><code>#newTaskFor(...)</code> 方法，创建 PromiseTask 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseTask&lt;T&gt;(<span class="keyword">this</span>, runnable, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseTask&lt;T&gt;(<span class="keyword">this</span>, callable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的 PromiseTask 对象，会传入自身作为 EventExecutor ，并传入 Runnable + Value 或 Callable 作为任务( Task )。</li>
</ul>
<h2 id="6-9-submit"><a href="#6-9-submit" class="headerlink" title="6.9 submit"></a>6.9 submit</h2><p><code>#submit(...)</code> 方法，提交任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">return</span> (Future&lt;?&gt;) <span class="keyword">super</span>.submit(task);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (Future&lt;T&gt;) <span class="keyword">super</span>.submit(task, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (Future&lt;T&gt;) <span class="keyword">super</span>.submit(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个方法的实现上，是调用父类 AbstractExecutorService 的实现。</li>
</ul>
<h2 id="6-10-schedule"><a href="#6-10-schedule" class="headerlink" title="6.10 schedule"></a>6.10 schedule</h2><p><code>#schedule(...)</code> 方法，都不支持，交给子类 AbstractScheduledEventExecutor 实现。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-11-safeExecute"><a href="#6-11-safeExecute" class="headerlink" title="6.11 safeExecute"></a>6.11 safeExecute</h2><p><code>#safeExecute(Runnable task)</code> <strong>静态</strong>方法，安全的执行任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        task.run();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        logger.warn(<span class="string">"A task raised an exception. Task: {}"</span>, task, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>所谓“安全”指的是，当任务执行发生异常时，仅仅打印<strong>告警</strong>日志。</li>
</ul>
<h2 id="6-12-shutdown"><a href="#6-12-shutdown" class="headerlink" title="6.12 shutdown"></a>6.12 shutdown</h2><p><code>#shutdown()</code> 方法，关闭执行器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully() {</span><br><span class="line">    <span class="keyword">return</span> shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>{</span><br><span class="line">    shutdown();</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的 <code>#shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit)</code> 和 <code>#shutdown()</code> 方法的实现，在子类中。</li>
</ul>
<h1 id="7-AbstractScheduledEventExecutor"><a href="#7-AbstractScheduledEventExecutor" class="headerlink" title="7. AbstractScheduledEventExecutor"></a>7. AbstractScheduledEventExecutor</h1><p><code>io.netty.util.concurrent.AbstractScheduledEventExecutor</code> ，继承 AbstractEventExecutor 抽象类，<strong>支持定时任务</strong>的 EventExecutor 的抽象类。</p>
<p>详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-3-EventLoop-init">《精尽 Netty 源码解析 —— EventLoop（七）之 EventLoop 处理定时任务》</a> 。</p>
<h1 id="8-SingleThreadEventExecutor"><a href="#8-SingleThreadEventExecutor" class="headerlink" title="8. SingleThreadEventExecutor"></a>8. SingleThreadEventExecutor</h1><p><code>io.netty.util.concurrent.SingleThreadEventExecutor</code> ，实现 OrderedEventExecutor 接口，继承 AbstractScheduledEventExecutor 抽象类，基于单线程的 EventExecutor 抽象类，<strong>即一个 EventExecutor 对应一个线程</strong>。</p>
<h2 id="8-1-构造方法"><a href="#8-1-构造方法" class="headerlink" title="8.1 构造方法"></a>8.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #state} 字段的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;SingleThreadEventExecutor&gt; STATE_UPDATER =AtomicIntegerFieldUpdater.newUpdater(SingleThreadEventExecutor.class, <span class="string">"state"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #thread} 字段的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SingleThreadEventExecutor, ThreadProperties&gt; PROPERTIES_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SingleThreadEventExecutor.class, ThreadProperties.class, <span class="string">"threadProperties"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #newTaskQueue(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadProperties threadProperties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否已经打断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #interruptThread()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> interrupted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Semaphore threadLock = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; shutdownHooks = <span class="keyword">new</span> LinkedHashSet&lt;Runnable&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加任务时，是否唤醒线程{<span class="doctag">@link</span> #thread}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> addTaskWakesUp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大等待执行任务数量，即 {<span class="doctag">@link</span> #taskQueue} 的队列大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxPendingTasks;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝执行处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #reject()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #reject(Runnable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后执行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>({ <span class="string">"FieldMayBeFinal"</span>, <span class="string">"unused"</span> })</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_NOT_STARTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 优雅关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> gracefulShutdownQuietPeriod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优雅关闭超时时间，单位：毫秒 TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> gracefulShutdownTimeout;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优雅关闭开始时间，单位：毫秒 TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> gracefulShutdownStartTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="keyword">new</span> DefaultPromise&lt;Void&gt;(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup parent, ThreadFactory threadFactory, <span class="keyword">boolean</span> addTaskWakesUp)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(parent, <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory), addTaskWakesUp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup parent, ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedHandler)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(parent, <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory), addTaskWakesUp, maxPendingTasks, rejectedHandler);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(parent, executor, addTaskWakesUp, DEFAULT_MAX_PENDING_EXECUTOR_TASKS, RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    RejectedExecutionHandler rejectedHandler)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">"executor"</span>);</span><br><span class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">"rejectedHandler"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>属性比较多，我们耐心往下看。</li>
<li><code>taskQueue</code> 属性，任务队列。<ul>
<li><code>addTaskWakesUp</code> 属性，添加任务到 <code>taskQueue</code> 队列时，是否唤醒 <code>thread</code> 线程。详细解析，见 <a href="#">「8.11 execute」</a> 。</li>
<li><code>maxPendingTasks</code> 属性，最大等待执行任务数量，即 <code>taskQueue</code> 队列大小。</li>
<li><code>rejectedExecutionHandler</code> 属性，拒绝执行处理器。在 <code>taskQueue</code> 队列超过最大任务数量时，怎么拒绝处理新提交的任务。</li>
</ul>
</li>
<li><p><code>thread</code> 属性，线程。在 SingleThreadEventExecutor 中，任务是提交到 <code>taskQueue</code> 队列中，而执行在 <code>thread</code> 线程中。</p>
<ul>
<li><code>threadProperties</code> 属性，线程属性。详细解析，见 <a href="#">「8.15 threadProperties」</a> 。</li>
<li><code>executor</code> 属性，执行器。通过它创建 <code>thread</code> 线程。详细解析，见 <a href="#">「8.11 execute」</a> 。</li>
<li><code>interrupted</code> 属性，线程是否打断。详细解析，详细解析，见 <a href="#">「8.14 interruptThread」</a> 。 </li>
<li><code>lastExecutionTime</code> 属性，最后执行时间。</li>
<li><p><code>state</code> 属性，线程状态。SingleThreadEventExecutor 在实现上，<code>thread</code> 的初始化采用延迟启动的方式，只有在第一个任务时，<code>executor</code> 才会执行并创建该线程，从而节省资源。目前 <code>thread</code> 线程有 5 种状态，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_NOT_STARTED = <span class="number">1</span>; <span class="comment">// 未开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_STARTED = <span class="number">2</span>; <span class="comment">// 已开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_SHUTTING_DOWN = <span class="number">3</span>; <span class="comment">// 正在关闭中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_SHUTDOWN = <span class="number">4</span>; <span class="comment">// 已关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_TERMINATED = <span class="number">5</span>; <span class="comment">// 已经终止</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>状态变更流程如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_05_07/01.png" title="状态变更流程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_07/01.png" alt="状态变更流程"></a><span class="caption">状态变更流程</span></li>
</ul>
</li>
</ul>
</li>
<li>构造方法，虽然比较多，但是很简单，胖友自己看下。</li>
</ul>
<h2 id="8-2-newTaskQueue"><a href="#8-2-newTaskQueue" class="headerlink" title="8.2 newTaskQueue"></a>8.2 newTaskQueue</h2><p><code>#newTaskQueue(int maxPendingTasks)</code> 方法，创建任务队列。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> Queue} which will holds the tasks to execute. This default implementation will return a</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> LinkedBlockingQueue} but if your sub-class of {<span class="doctag">@link</span> SingleThreadEventExecutor} will not do any blocking</span></span><br><span class="line"><span class="comment"> * calls on the this {<span class="doctag">@link</span> Queue} it may make sense to {<span class="doctag">@code</span> <span class="doctag">@Override</span>} this and return some more performant</span></span><br><span class="line"><span class="comment"> * implementation that does not support blocking operations at all.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxPendingTasks);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法上有一大段注释，简单的说，这个方法默认返回的是 LinkedBlockingQueue 阻塞队列。如果子类有更好的队列选择( 例如非阻塞队列 )，可以重写该方法。在下文，我们会看到它的子类 NioEventLoop ，就重写了这个方法。</li>
</ul>
<h2 id="8-3-inEventLoop"><a href="#8-3-inEventLoop" class="headerlink" title="8.3 inEventLoop"></a>8.3 inEventLoop</h2><p><code>#inEventLoop(Thread thread)</code> 方法，判断指定线程是否是 EventLoop 线程。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">(Thread thread)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> thread == <span class="keyword">this</span>.thread;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-4-offerTask"><a href="#8-4-offerTask" class="headerlink" title="8.4 offerTask"></a>8.4 offerTask</h2><p><code>#offerTask(Runnable task)</code> 方法，添加任务到队列中。若添加失败，则返回 <code>false</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="comment">// 关闭时，拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) {</span><br><span class="line">        reject();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加任务到队列</span></span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>注意，即使对于 BlockingQueue 的 <code>#offer(E e)</code> 方法，也<strong>不是阻塞的</strong>！</li>
</ul>
<h2 id="8-5-addTask"><a href="#8-5-addTask" class="headerlink" title="8.5 addTask"></a>8.5 addTask</h2><p><code>#offerTask(Runnable task)</code> 方法，在 <code>#offerTask(Runnable task)</code> 的方法的基础上，若添加任务到队列中失败，则进行拒绝任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加任务到队列</span></span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) {</span><br><span class="line">        <span class="comment">// 添加失败，则拒绝任务</span></span><br><span class="line">        reject(task);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#reject(task)</code> 方法，拒绝任务。详细解析，见 <a href="#">「8.6 reject」</a> 。</li>
<li>该方法是 <code>void</code> ，无返回值。</li>
</ul>
<h2 id="8-6-removeTask"><a href="#8-6-removeTask" class="headerlink" title="8.6 removeTask"></a>8.6 removeTask</h2><p><code>#removeTask(Runnable task)</code> 方法，移除指定任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeTask</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> taskQueue.remove(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-7-peekTask"><a href="#8-7-peekTask" class="headerlink" title="8.7 peekTask"></a>8.7 peekTask</h2><p><code>#peekTask()</code> 方法，返回队头的任务，但是<strong>不移除</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">peekTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>; <span class="comment">// 仅允许在 EventLoop 线程中执行</span></span><br><span class="line">    <span class="keyword">return</span> taskQueue.peek();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-8-hasTasks"><a href="#8-8-hasTasks" class="headerlink" title="8.8 hasTasks"></a>8.8 hasTasks</h2><p><code>#hasTasks()</code> 方法，队列中是否有任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>; <span class="comment">// 仅允许在 EventLoop 线程中执行</span></span><br><span class="line">    <span class="keyword">return</span> !taskQueue.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-9-pendingTasks"><a href="#8-9-pendingTasks" class="headerlink" title="8.9 pendingTasks"></a>8.9 pendingTasks</h2><p><code>#pendingTasks()</code> 方法，获得队列中的任务数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pendingTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> taskQueue.size();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-10-reject"><a href="#8-10-reject" class="headerlink" title="8.10 reject"></a>8.10 reject</h2><p><code>#reject(Runnable task)</code> 方法，拒绝任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    rejectedExecutionHandler.rejected(task, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>RejectedExecutionHandler#rejected(Runnable task, SingleThreadEventExecutor executor)</code> 方法，拒绝该任务。</li>
</ul>
<p><code>#reject()</code> 方法，拒绝任何任务，用于 SingleThreadEventExecutor 已关闭( <code>#isShutdown()</code> 方法返回的结果为 <code>true</code> )的情况。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"event executor terminated"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-10-1-RejectedExecutionHandler"><a href="#8-10-1-RejectedExecutionHandler" class="headerlink" title="8.10.1 RejectedExecutionHandler"></a>8.10.1 RejectedExecutionHandler</h3><p><code>io.netty.util.concurrent.RejectedExecutionHandler</code> ，拒绝执行处理器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when someone tried to add a task to {<span class="doctag">@link</span> SingleThreadEventExecutor} but this failed due capacity</span></span><br><span class="line"><span class="comment"> * restrictions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-10-2-RejectedExecutionHandlers"><a href="#8-10-2-RejectedExecutionHandlers" class="headerlink" title="8.10.2 RejectedExecutionHandlers"></a>8.10.2 RejectedExecutionHandlers</h3><p><code>io.netty.util.concurrent.RejectedExecutionHandlers</code> ，RejectedExecutionHandler 实现类枚举，目前有 2 种实现类。</p>
<p><strong>第一种</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler REJECT = <span class="keyword">new</span> RejectedExecutionHandler() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RejectedExecutionHandler <span class="title">reject</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> REJECT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>#reject()</code> 方法，返回 <code>REJECT</code> 实现类的对象。该实现在拒绝时，直接抛出 RejectedExecutionException 异常。</li>
<li>默认情况下，使用这种实现。</li>
</ul>
<p><strong>第二种</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RejectedExecutionHandler <span class="title">backoff</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> retries, <span class="keyword">long</span> backoffAmount, TimeUnit unit)</span> </span>{</span><br><span class="line">    ObjectUtil.checkPositive(retries, <span class="string">"retries"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> backOffNanos = unit.toNanos(backoffAmount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RejectedExecutionHandler() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) { <span class="comment">// 非 EventLoop 线程中。如果在 EventLoop 线程中，就无法执行任务，这就导致完全无法重试了。</span></span><br><span class="line">                <span class="comment">// 循环多次尝试添加到队列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; retries; i++) {</span><br><span class="line">                    <span class="comment">// 唤醒执行器，进行任务执行。这样，就可能执行掉部分任务。</span></span><br><span class="line">                    <span class="comment">// Try to wake up the executor so it will empty its task queue.</span></span><br><span class="line">                    executor.wakeup(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 阻塞等待</span></span><br><span class="line">                    LockSupport.parkNanos(backOffNanos);</span><br><span class="line">                    <span class="comment">// 添加任务</span></span><br><span class="line">                    <span class="keyword">if</span> (executor.offerTask(task)) {</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Either we tried to add the task from within the EventLoop or we was not able to add it even with</span></span><br><span class="line">            <span class="comment">// backoff.</span></span><br><span class="line">            <span class="comment">// 多次尝试添加失败，抛出 RejectedExecutionException 异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>#backoff(final int retries, long backoffAmount, TimeUnit unit)</code> 方法，创建带多次尝试添加到任务队列的 RejectedExecutionHandler 实现类。</li>
<li>代码已经添加中文注释，胖友自己理解下，比较简单的。</li>
</ul>
<h2 id="8-11-execute"><a href="#8-11-execute" class="headerlink" title="8.11 execute"></a>8.11 execute</h2><p><code>#execute(Runnable task)</code> 方法，执行一个任务。但是方法名无法很完整的体现出具体的方法实现，甚至有一些出入，所以我们直接看源码，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 获得当前是否在 EventLoop 的线程中</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// 添加到任务队列</span></span><br><span class="line"><span class="number">10</span>:     addTask(task);</span><br><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (!inEventLoop) {</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 创建线程</span></span><br><span class="line"><span class="number">13</span>:         startThread();</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 若已经关闭，移除任务，并进行拒绝</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) {</span><br><span class="line"><span class="number">16</span>:             reject();</span><br><span class="line"><span class="number">17</span>:         }</span><br><span class="line"><span class="number">18</span>:     }</span><br><span class="line"><span class="number">19</span>: </span><br><span class="line"><span class="number">20</span>:     <span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="number">21</span>:     <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) {</span><br><span class="line"><span class="number">22</span>:         wakeup(inEventLoop);</span><br><span class="line"><span class="number">23</span>:     }</span><br><span class="line"><span class="number">24</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 8 行：调用 <code>#inEventLoop()</code> 方法，获得当前是否在 EventLoop 的线程中。</li>
<li>第 10 行：调用 <code>#addTask(Runnable task)</code> 方法，添加任务到队列中。</li>
<li>第 11 行：非 EventLoop 的线程<ul>
<li>第 13 行：调用 <code>#startThread()</code> 方法，启动 EventLoop <strong>独占</strong>的线程，即 <code>thread</code> 属性。详细解析，见 <a href="#">「8.12 startThread」</a> 。</li>
<li>第 14 至 17 行：若已经关闭，则移除任务，并拒绝执行。</li>
</ul>
</li>
<li><p>第 20 至 23 行：调用 <code>#wakeup(boolean inEventLoop)</code> 方法，唤醒线程。详细解析，见 <a href="#">「8.13 wakeup」</a> 。</p>
<ul>
<li>等等，第 21 行的 <code>!addTaskWakesUp</code> 有点奇怪，不是说好的 <code>addTaskWakesUp</code> 表示“添加任务时，是否唤醒线程”？！但是，怎么使用 <code>!</code> 取反了。这样反倒变成了，“添加任务时，是否【<strong>不</strong>】唤醒线程”。具体的原因是为什么呢？笔者 Google、Github Netty Issue、和基佬讨论，都未找到解答。目前笔者的理解是：<code>addTaskWakesUp</code> 真正的意思是，“添加任务后，任务是否会自动导致线程唤醒”。为什么呢？<ul>
<li>对于 Nio 使用的 NioEventLoop ，它的线程执行任务是基于 Selector 监听感兴趣的事件，所以当任务添加到 <code>taskQueue</code> 队列中时，线程是无感知的，所以需要调用 <code>#wakeup(boolean inEventLoop)</code>  方法，进行<strong>主动</strong>的唤醒。</li>
<li>对于 Oio 使用的 ThreadPerChannelEventLoop ，它的线程执行是基于 <code>taskQueue</code> 队列监听( <strong>阻塞拉取</strong> )事件和任务，所以当任务添加到 <code>taskQueue</code> 队列中时，线程是可感知的，相当于说，进行<strong>被动</strong>的唤醒。</li>
<li>感谢闪电侠，证实我的理解是正确的。参见：<ul>
<li><a href="https://github.com/netty/netty/commit/23d017849429c18e1890b0a5799e5262df4f269f" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/netty/netty/commit/23d017849429c18e1890b0a5799e5262df4f269f</a><ul>
<li><a href="http://static2.iocoder.cn/images/Netty/2018_05_07/05.png" title="提交图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_07/05.png" alt="提交图"></a><span class="caption">提交图</span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调用 <code>#wakesUpForTask(task)</code> 方法，判断该任务是否需要唤醒线程。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">wakesUpForTask</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认返回 <code>true</code> 。在 <a href="#">「9. SingleThreadEventLoop」</a> 中，我们会看到对该方法的重写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-12-startThread"><a href="#8-12-startThread" class="headerlink" title="8.12 startThread"></a>8.12 startThread</h2><p><code>#startThread()</code> 方法，启动 EventLoop <strong>独占</strong>的线程，即 <code>thread</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">3</span>:     executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line"> <span class="number">4</span>: </span><br><span class="line"> <span class="number">5</span>:         <span class="meta">@Override</span></span><br><span class="line"> <span class="number">6</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">7</span>:             <span class="comment">// 记录当前线程</span></span><br><span class="line"> <span class="number">8</span>:             thread = Thread.currentThread();</span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:             <span class="comment">// 如果当前线程已经被标记打断，则进行打断操作。</span></span><br><span class="line"><span class="number">11</span>:             <span class="keyword">if</span> (interrupted) {</span><br><span class="line"><span class="number">12</span>:                 thread.interrupt();</span><br><span class="line"><span class="number">13</span>:             }</span><br><span class="line"><span class="number">14</span>: </span><br><span class="line"><span class="number">15</span>:             <span class="keyword">boolean</span> success = <span class="keyword">false</span>; <span class="comment">// 是否执行成功</span></span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 更新最后执行时间</span></span><br><span class="line"><span class="number">18</span>:             updateLastExecutionTime();</span><br><span class="line"><span class="number">19</span>:             <span class="keyword">try</span> {</span><br><span class="line"><span class="number">20</span>:                 <span class="comment">// 执行任务</span></span><br><span class="line"><span class="number">21</span>:                 SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line"><span class="number">22</span>:                 success = <span class="keyword">true</span>; <span class="comment">// 标记执行成功</span></span><br><span class="line"><span class="number">23</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">24</span>:                 logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line"><span class="number">25</span>:             } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">26</span>:                 <span class="comment">// TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="number">27</span>:                 <span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="number">28</span>:                     <span class="keyword">int</span> oldState = state;</span><br><span class="line"><span class="number">29</span>:                     <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line"><span class="number">30</span>:                             SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) {</span><br><span class="line"><span class="number">31</span>:                         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>:                     }</span><br><span class="line"><span class="number">33</span>:                 }</span><br><span class="line"><span class="number">34</span>: </span><br><span class="line"><span class="number">35</span>:                 <span class="comment">// TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="number">36</span>:                 <span class="comment">// Check if confirmShutdown() was called at the end of the loop.</span></span><br><span class="line"><span class="number">37</span>:                 <span class="keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="number">0</span>) {</span><br><span class="line"><span class="number">38</span>:                     <span class="keyword">if</span> (logger.isErrorEnabled()) {</span><br><span class="line"><span class="number">39</span>:                         logger.error(<span class="string">"Buggy "</span> + EventExecutor.class.getSimpleName() + <span class="string">" implementation; "</span> +</span><br><span class="line"><span class="number">40</span>:                                 SingleThreadEventExecutor.class.getSimpleName() + <span class="string">".confirmShutdown() must "</span> +</span><br><span class="line"><span class="number">41</span>:                                 <span class="string">"be called before run() implementation terminates."</span>);</span><br><span class="line"><span class="number">42</span>:                     }</span><br><span class="line"><span class="number">43</span>:                 }</span><br><span class="line"><span class="number">44</span>: </span><br><span class="line"><span class="number">45</span>:                 <span class="comment">// TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line"><span class="number">46</span>:                 <span class="keyword">try</span> {</span><br><span class="line"><span class="number">47</span>:                     <span class="comment">// Run all remaining tasks and shutdown hooks.</span></span><br><span class="line"><span class="number">48</span>:                     <span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="number">49</span>:                         <span class="keyword">if</span> (confirmShutdown()) {</span><br><span class="line"><span class="number">50</span>:                             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">51</span>:                         }</span><br><span class="line"><span class="number">52</span>:                     }</span><br><span class="line"><span class="number">53</span>:                 } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">54</span>:                     <span class="keyword">try</span> {</span><br><span class="line"><span class="number">55</span>:                         cleanup(); <span class="comment">// 清理，释放资源</span></span><br><span class="line"><span class="number">56</span>:                     } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">57</span>:                         STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line"><span class="number">58</span>:                         threadLock.release();</span><br><span class="line"><span class="number">59</span>:                         <span class="keyword">if</span> (!taskQueue.isEmpty()) {</span><br><span class="line"><span class="number">60</span>:                             <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line"><span class="number">61</span>:                                 logger.warn(<span class="string">"An event executor terminated with "</span> +</span><br><span class="line"><span class="number">62</span>:                                         <span class="string">"non-empty task queue ("</span> + taskQueue.size() + <span class="string">')'</span>);</span><br><span class="line"><span class="number">63</span>:                             }</span><br><span class="line"><span class="number">64</span>:                         }</span><br><span class="line"><span class="number">65</span>: </span><br><span class="line"><span class="number">66</span>:                         terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">67</span>:                     }</span><br><span class="line"><span class="number">68</span>:                 }</span><br><span class="line"><span class="number">69</span>:             }</span><br><span class="line"><span class="number">70</span>:             </span><br><span class="line"><span class="number">71</span>:         }</span><br><span class="line"><span class="number">72</span>:     });</span><br><span class="line"><span class="number">73</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 行：断言，保证 <code>thread</code> 为空。</li>
<li>第 3 行 至 72 行：调用 <code>Executor#execute(Runnable runnable)</code> 方法，执行任务。下面，我们来详细解析。</li>
<li>第 8 行：赋值当前的线程给 <code>thread</code> 属性。这就是，每个 SingleThreadEventExecutor 独占的线程的创建方式。</li>
<li>第 10 至 13 行：如果当前线程已经被标记打断，则进行打断操作。为什么会有这样的逻辑呢？详细解析，见 <a href="#">「8.14 interruptThread」</a> 。</li>
<li><p>第 18 行：调用 <code>#updateLastExecutionTime()</code> 方法，更新最后执行时间。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Updates the internal timestamp that tells when a submitted task was executed most recently.</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #runAllTasks()} and {<span class="doctag">@link</span> #runAllTasks(long)} updates this timestamp automatically, and thus there's</span></span><br><span class="line"><span class="comment"> * usually no need to call this method.  However, if you take the tasks manually using {<span class="doctag">@link</span> #takeTask()} or</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #pollTask()}, you have to call this method at the end of task execution loop for accurate quiet period</span></span><br><span class="line"><span class="comment"> * checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateLastExecutionTime</span><span class="params">()</span> </span>{</span><br><span class="line">    lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>英文注释，自己看。😈</li>
</ul>
</li>
<li>第 21 行：调用 <code>SingleThreadEventExecutor#run()</code> 方法，执行任务。详细解析，见 <a href="#">8.X run</a> 。</li>
<li>第 25 至 69 行：TODO 1006 EventLoop 优雅关闭</li>
<li>第 55 行：调用 <code>#cleanup()</code> 方法，清理释放资源。详细解析，见 <a href="#">8.X cleanup</a> 。</li>
</ul>
<h2 id="8-13-wakeup"><a href="#8-13-wakeup" class="headerlink" title="8.13 wakeup"></a>8.13 wakeup</h2><p><code>#wakeup(boolean inEventLoop)</code> 方法，唤醒线程。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop <span class="comment">// &lt;1&gt;</span></span><br><span class="line">            || state == ST_SHUTTING_DOWN) { <span class="comment">// TODO 1006 EventLoop 优雅关闭</span></span><br><span class="line">        <span class="comment">// Use offer as we actually only need this to unblock the thread and if offer fails we do not care as there</span></span><br><span class="line">        <span class="comment">// is already something in the queue.</span></span><br><span class="line">        taskQueue.offer(WAKEUP_TASK); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处的 <code>!inEventLoop</code> 代码段，判断不在 EventLoop 的线程中。因为，如果在 EventLoop 线程中，意味着线程就在执行中，不必要唤醒。</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>Queue#offer(E e)</code> 方法，添加任务到队列中。而添加的任务是 <code>WAKEUP_TASK</code> ，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable WAKEUP_TASK = <span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是一个空的 Runnable 实现类。仅仅用于唤醒基于 <code>taskQueue</code> 阻塞拉取的 EventLoop 实现类。</li>
<li><p>对于 NioEventLoop 会重写该方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 NIO Selector 唤醒。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-14-interruptThread"><a href="#8-14-interruptThread" class="headerlink" title="8.14 interruptThread"></a>8.14 interruptThread</h2><p><code>#interruptThread()</code> 方法，打断 EventLoop 的线程。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">interruptThread</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread currentThread = thread;</span><br><span class="line">    <span class="comment">// 线程不存在，则标记线程被打断</span></span><br><span class="line">    <span class="keyword">if</span> (currentThread == <span class="keyword">null</span>) {</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 打断线程</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        currentThread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 EventLoop 的线程是延迟启动，所以可能 <code>thread</code> 并未创建，此时通过 <code>interrupted</code> 标记打断。之后在 <code>#startThread()</code> 方法中，创建完线程后，再进行打断，也就是说，“延迟打断”。</li>
</ul>
<h2 id="8-15-threadProperties"><a href="#8-15-threadProperties" class="headerlink" title="8.15 threadProperties"></a>8.15 threadProperties</h2><p><code>#threadProperties()</code> 方法，获得 EventLoop 的线程属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadProperties <span class="title">threadProperties</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     ThreadProperties threadProperties = <span class="keyword">this</span>.threadProperties;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (threadProperties == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">4</span>:         Thread thread = <span class="keyword">this</span>.thread;</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (thread == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">6</span>:             <span class="keyword">assert</span> !inEventLoop();</span><br><span class="line"> <span class="number">7</span>:             <span class="comment">// 提交空任务，促使 execute 方法执行</span></span><br><span class="line"> <span class="number">8</span>:             submit(NOOP_TASK).syncUninterruptibly();</span><br><span class="line"> <span class="number">9</span>:             <span class="comment">// 获得线程</span></span><br><span class="line"><span class="number">10</span>:             thread = <span class="keyword">this</span>.thread;</span><br><span class="line"><span class="number">11</span>:             <span class="keyword">assert</span> thread != <span class="keyword">null</span>;</span><br><span class="line"><span class="number">12</span>:         }</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 创建 DefaultThreadProperties 对象</span></span><br><span class="line"><span class="number">15</span>:         threadProperties = <span class="keyword">new</span> DefaultThreadProperties(thread);</span><br><span class="line"><span class="number">16</span>:         <span class="comment">// CAS 修改 threadProperties 属性</span></span><br><span class="line"><span class="number">17</span>:         <span class="keyword">if</span> (!PROPERTIES_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, threadProperties)) {</span><br><span class="line"><span class="number">18</span>:             threadProperties = <span class="keyword">this</span>.threadProperties;</span><br><span class="line"><span class="number">19</span>:         }</span><br><span class="line"><span class="number">20</span>:     }</span><br><span class="line"><span class="number">21</span>: </span><br><span class="line"><span class="number">22</span>:     <span class="keyword">return</span> threadProperties;</span><br><span class="line"><span class="number">23</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 3 行：获得 ThreadProperties 对象。若不存在，则进行创建 ThreadProperties 对象。<ul>
<li>第 4 至 5 行：获得 EventLoop 的线程。因为线程是延迟启动的，所以会出现线程为空的情况。若线程为空，则需要进行创建。<ul>
<li>第 8 行：调用 <code>#submit(Runnable)</code> 方法，提交任务，就能促使 <code>#execute(Runnable)</code> 方法执行。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_05_07/02.png" title="submit => execute 的流程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_07/02.png" alt="submit => execute 的流程"></a><span class="caption">submit =&gt; execute 的流程</span></li>
<li>第 8 行：调用 <code>Future#syncUninterruptibly()</code> 方法，保证 <code>execute()</code> 方法中<strong>异步</strong>创建 <code>thread</code> 完成。</li>
<li>第 10 至 11 行：获得线程，并断言保证线程存在。</li>
</ul>
</li>
<li>第 15 行：调用 DefaultThreadProperties 对象。</li>
<li>第 16 至 19 行：CAS 修改 <code>threadProperties</code> 属性。</li>
</ul>
</li>
<li>第 22 行：返回 <code>threadProperties</code> 。</li>
</ul>
<h3 id="8-15-1-ThreadProperties"><a href="#8-15-1-ThreadProperties" class="headerlink" title="8.15.1 ThreadProperties"></a>8.15.1 ThreadProperties</h3><p><code>io.netty.util.concurrent.ThreadProperties</code> ，线程属性接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread.<span class="function">State <span class="title">state</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">StackTraceElement[] stackTrace();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-15-2-DefaultThreadProperties"><a href="#8-15-2-DefaultThreadProperties" class="headerlink" title="8.15.2 DefaultThreadProperties"></a>8.15.2 DefaultThreadProperties</h3><p>DefaultThreadProperties 实现 ThreadProperties 接口，默认线程属性实现类。代码如下：</p>
<blockquote>
<p>DefaultThreadProperties 内嵌在 SingleThreadEventExecutor 中。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadProperties</span> <span class="keyword">implements</span> <span class="title">ThreadProperties</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread t;</span><br><span class="line"></span><br><span class="line">    DefaultThreadProperties(Thread t) {</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">state</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.getState();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.getPriority();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.isInterrupted();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.isDaemon();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.getName();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.getId();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StackTraceElement[] stackTrace() {</span><br><span class="line">        <span class="keyword">return</span> t.getStackTrace();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t.isAlive();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>我们可以看到，每个实现方法，实际上就是对被包装的线程 <code>t</code> 的方法的封装。</li>
<li>那为什么 <code>#threadProperties()</code> 方法不直接返回 <code>thread</code> 呢？因为如果直接返回 <code>thread</code> ，调用方可以调用到该变量的其他方法，这个是我们不希望看到的。</li>
</ul>
<h2 id="8-16-run"><a href="#8-16-run" class="headerlink" title="8.16 run"></a>8.16 run</h2><p><code>#run()</code> 方法，它是一个<strong>抽象方法</strong>，由子类实现，如何执行 <code>taskQueue</code> 队列中的任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>SingleThreadEventExecutor 提供了很多执行任务的方法，方便子类在实现自定义运行任务的逻辑时：</p>
<ul>
<li>[x] <code>#runAllTasks()</code></li>
<li>[x] <code>#runAllTasks(long timeoutNanos)</code></li>
<li>[x] <code>#runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue)</code></li>
<li>[x] <code>#afterRunningAllTasks()</code></li>
<li>[x] <code>#pollTask()</code></li>
<li>[x] <code>#pollTaskFrom(Queue&lt;Runnable&gt; taskQueue)</code></li>
<li><code>#takeTask()</code></li>
<li><code>#fetchFromScheduledTaskQueue()</code></li>
<li><code>#delayNanos(long currentTimeNanos)</code></li>
</ul>
<p>详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-4-EventLoop-run">《精尽 Netty 源码解析 —— EventLoop（四）之 EventLoop 运行》</a> 。</p>
<h2 id="8-17-cleanup"><a href="#8-17-cleanup" class="headerlink" title="8.17 cleanup"></a>8.17 cleanup</h2><p><code>#cleanup()</code> 方法，清理释放资源。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do nothing, sub-classes may override</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// NOOP</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>目前该方法为空的。在子类 NioEventLoop 中，我们会看到它覆写该方法，关闭 NIO Selector 对象。</li>
</ul>
<h2 id="8-18-invokeAll"><a href="#8-18-invokeAll" class="headerlink" title="8.18 invokeAll"></a>8.18 invokeAll</h2><p><code>#invokeAll(...)</code> 方法，在 EventExecutor 中执行<strong>多个</strong>普通任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;java.util.concurrent.Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    throwIfInEventLoop(<span class="string">"invokeAll"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.invokeAll(tasks);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;java.util.concurrent.Future&lt;T&gt;&gt; invokeAll(</span><br><span class="line">        Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    throwIfInEventLoop(<span class="string">"invokeAll"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.invokeAll(tasks, timeout, unit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>#throwIfInEventLoop(String method)</code> 方法，判断若在 EventLoop 的线程中调用该方法，抛出 RejectedExecutionException 异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwIfInEventLoop</span><span class="params">(String method)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Calling "</span> + method + <span class="string">" from within the EventLoop is not allowed"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>调用父类 AbstractScheduledEventExecutor 的 <code>#invokeAll(tasks, ...)</code> 方法，执行<strong>多个</strong>普通任务。在该方法内部，会调用 <code>#execute(Runnable task)</code> 方法，执行任务。调用栈如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_05_07/03.png" title="invokeAll => execute 的流程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_07/03.png" alt="invokeAll => execute 的流程"></a><span class="caption">invokeAll =&gt; execute 的流程</span></p>
</li>
</ul>
<h2 id="8-19-invokeAny"><a href="#8-19-invokeAny" class="headerlink" title="8.19 invokeAny"></a>8.19 invokeAny</h2><blockquote>
<p>和 <code>#invokeAll(...)</code> 方法，<strong>类似</strong>。</p>
</blockquote>
<p><code>#invokeAll(...)</code> 方法，在 EventExecutor 中执行<strong>多个</strong>普通任务，有<strong>一个</strong>执行完成即可。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    throwIfInEventLoop(<span class="string">"invokeAny"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.invokeAny(tasks);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>{</span><br><span class="line">    throwIfInEventLoop(<span class="string">"invokeAny"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.invokeAny(tasks, timeout, unit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#throwIfInEventLoop(String method)</code> 方法，判断若在 EventLoop 的线程中调用该方法，抛出 RejectedExecutionException 异常。</li>
<li>调用父类 AbstractScheduledEventExecutor 的 <code>#invokeAny(tasks, ...)</code> 方法，执行<strong>多个</strong>普通任务，有<strong>一个</strong>执行完成即可。在该方法内部，会调用 <code>#execute(Runnable task)</code> 方法，执行任务。调用栈如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_05_07/04.png" title="invokeAny => execute 的流程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_07/04.png" alt="invokeAny => execute 的流程"></a><span class="caption">invokeAny =&gt; execute 的流程</span></li>
</ul>
<h2 id="8-20-shutdown"><a href="#8-20-shutdown" class="headerlink" title="8.20 shutdown"></a>8.20 shutdown</h2><p>如下是优雅关闭，我们在 TODO 1006 EventLoop 优雅关闭</p>
<ul>
<li><code>#addShutdownHook(final Runnable task)</code></li>
<li><code>#removeShutdownHook(final Runnable task)</code></li>
<li><code>#runShutdownHooks()</code></li>
<li><code>#shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit)</code></li>
<li><code>#shutdown()</code></li>
<li><code>#terminationFuture()</code></li>
<li><code>#isShuttingDown()</code></li>
<li><code>#isShutdown()</code></li>
<li><code>#isTerminated()</code></li>
<li><code>#confirmShutdown()</code></li>
<li><code>#awaitTermination(long timeout, TimeUnit unit)</code></li>
</ul>
<h1 id="9-SingleThreadEventLoop"><a href="#9-SingleThreadEventLoop" class="headerlink" title="9. SingleThreadEventLoop"></a>9. SingleThreadEventLoop</h1><p><code>io.netty.channel.SingleThreadEventLoop</code> ，实现 EventLoop 接口，继承 SingleThreadEventExecutor 抽象类，基于单线程的 EventLoop 抽象类，主要增加了 Channel 注册到 EventLoop 上。</p>
<h2 id="9-1-构造方法"><a href="#9-1-构造方法" class="headerlink" title="9.1 构造方法"></a>9.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认任务队列最大数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_PENDING_TASKS = Math.max(<span class="number">16</span>, SystemPropertyUtil.getInt(<span class="string">"io.netty.eventLoop.maxPendingTasks"</span>, Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾部任务队列，执行在 {<span class="doctag">@link</span> #taskQueue} 之后</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Commits</span></span><br><span class="line"><span class="comment"> *  * [Ability to run a task at the end of an eventloop iteration.](https://github.com/netty/netty/pull/5513)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Issues</span></span><br><span class="line"><span class="comment"> *  * [Auto-flush for channels. (`ChannelHandler` implementation)](https://github.com/netty/netty/pull/5716)</span></span><br><span class="line"><span class="comment"> *  * [Consider removing executeAfterEventLoopIteration](https://github.com/netty/netty/issues/7833)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 老艿艿：未来会移除该队列，前提是实现了 Channel 的 auto flush 功能。按照最后一个 issue 的讨论</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; tailTasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, ThreadFactory threadFactory, <span class="keyword">boolean</span> addTaskWakesUp)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(parent, threadFactory, addTaskWakesUp, DEFAULT_MAX_PENDING_TASKS, RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(parent, executor, addTaskWakesUp, DEFAULT_MAX_PENDING_TASKS, RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                RejectedExecutionHandler rejectedExecutionHandler)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent, threadFactory, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                RejectedExecutionHandler rejectedExecutionHandler)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>新增了一条 <code>tailTasks</code> 队列，执行的顺序在 <code>taskQueue</code> 之后。详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-6-EventLoop-handle-normal-task">《精尽 Netty 源码解析 —— EventLoop（六）之 EventLoop 处理普通任务》</a> 。</li>
<li>构造方法比较简单，胖友自己看下就可以了。</li>
</ul>
<h2 id="9-2-parent"><a href="#9-2-parent" class="headerlink" title="9.2 parent"></a>9.2 parent</h2><p><code>#parent()</code> 方法，获得所属 EventLoopGroup 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoopGroup <span class="title">parent</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (EventLoopGroup) <span class="keyword">super</span>.parent();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>覆盖父类方法，将返回值转换成 EventLoopGroup 类。</li>
</ul>
<h2 id="9-3-next"><a href="#9-3-next" class="headerlink" title="9.3 next"></a>9.3 next</h2><p><code>#next()</code> 方法，获得自己。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (EventLoop) <span class="keyword">super</span>.next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>覆盖父类方法，将返回值转换成 EventLoop 类。</li>
</ul>
<h2 id="9-4-register"><a href="#9-4-register" class="headerlink" title="9.4 register"></a>9.4 register</h2><p><code>#register(Channel channel)</code> 方法，注册 Channel 到 EventLoop 上。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将 Channel 和 EventLoop 创建一个 DefaultChannelPromise 对象。通过这个 DefaultChannelPromise 对象，我们就能实现对<strong>异步</strong>注册过程的监听。</li>
<li><p>调用 <code>#register(final ChannelPromise promise)</code> 方法，注册 Channel 到 EventLoop 上。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    <span class="comment">// 注册 Channel 到 EventLoop 上</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="comment">// 返回 ChannelPromise 对象</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，我们就看到在 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server?self">《精尽 Netty 源码分析 —— 启动（一）之服务端》</a> 的 <a href="#">「3.14.3 注册 Channel 到 EventLoopGroup」</a> 章节，熟悉的内容，调用 <code>AbstractUnsafe#register(EventLoop eventLoop, final ChannelPromise promise)</code> 方法，<strong>注册 Channel 到 EventLoop 上</strong>。</li>
</ul>
</li>
</ul>
<h2 id="9-5-hasTasks"><a href="#9-5-hasTasks" class="headerlink" title="9.5 hasTasks"></a>9.5 hasTasks</h2><p><code>#hasTasks()</code> 方法，队列中是否有任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hasTasks() || !tailTasks.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>基于两个队列来判断是否还有任务。</li>
</ul>
<h2 id="9-6-pendingTasks"><a href="#9-6-pendingTasks" class="headerlink" title="9.6 pendingTasks"></a>9.6 pendingTasks</h2><p><code>#pendingTasks()</code> 方法，获得队列中的任务数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pendingTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pendingTasks() + tailTasks.size();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>计算两个队列的任务之和。</li>
</ul>
<h2 id="9-7-executeAfterEventLoopIteration"><a href="#9-7-executeAfterEventLoopIteration" class="headerlink" title="9.7 executeAfterEventLoopIteration"></a>9.7 executeAfterEventLoopIteration</h2><p><code>#executeAfterEventLoopIteration(Runnable task)</code> 方法，执行一个任务。但是方法名无法很完整的体现出具体的方法实现，甚至有一些出入，所以我们直接看源码，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@UnstableApi</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">executeAfterEventLoopIteration</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 关闭时，拒绝任务</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (isShutdown()) {</span><br><span class="line"> <span class="number">6</span>:         reject();</span><br><span class="line"> <span class="number">7</span>:     }</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// 添加到任务队列</span></span><br><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (!tailTasks.offer(task)) {</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 添加失败，则拒绝任务</span></span><br><span class="line"><span class="number">12</span>:         reject(task);</span><br><span class="line"><span class="number">13</span>:     }</span><br><span class="line"><span class="number">14</span>: </span><br><span class="line"><span class="number">15</span>:     <span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="number">16</span>:     <span class="keyword">if</span> (wakesUpForTask(task)) {</span><br><span class="line"><span class="number">17</span>:         wakeup(inEventLoop());</span><br><span class="line"><span class="number">18</span>:     }</span><br><span class="line"><span class="number">19</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 至 7 行：SingleThreadEventLoop 关闭时，拒绝任务。</li>
<li>第 10 行：调用 <code>Queue#offer(E e)</code> 方法，添加任务到队列中。<ul>
<li>第 12 行：若添加失败，调用 <code>#reject(Runnable task)</code> 方法，拒绝任务。 </li>
</ul>
</li>
<li>第 15 至 18 行：唤醒线程。<ul>
<li>第 16 行：SingleThreadEventLoop 重写了 <code>#wakesUpForTask(Runnable task)</code> 方法。详细解析，见 <a href="#">「9.9 wakesUpForTask」</a> 。</li>
</ul>
</li>
</ul>
<h2 id="9-8-removeAfterEventLoopIterationTask"><a href="#9-8-removeAfterEventLoopIterationTask" class="headerlink" title="9.8 removeAfterEventLoopIterationTask"></a>9.8 removeAfterEventLoopIterationTask</h2><p><code>#removeAfterEventLoopIterationTask(Runnable task)</code> 方法，移除指定任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@UnstableApi</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">removeAfterEventLoopIterationTask</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tailTasks.remove(ObjectUtil.checkNotNull(task, <span class="string">"task"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="9-9-wakesUpForTask"><a href="#9-9-wakesUpForTask" class="headerlink" title="9.9 wakesUpForTask"></a>9.9 wakesUpForTask</h2><p><code>#wakesUpForTask(task)</code> 方法，判断该任务是否需要唤醒线程。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">wakesUpForTask</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> !(task <span class="keyword">instanceof</span> NonWakeupRunnable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当任务类型为 NonWakeupRunnable ，则不进行唤醒线程。</li>
</ul>
<h3 id="9-9-1-NonWakeupRunnable"><a href="#9-9-1-NonWakeupRunnable" class="headerlink" title="9.9.1 NonWakeupRunnable"></a>9.9.1 NonWakeupRunnable</h3><p>NonWakeupRunnable 实现 Runnable 接口，用于标记不唤醒线程的任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker interface for {<span class="doctag">@link</span> Runnable} that will not trigger an {<span class="doctag">@link</span> #wakeup(boolean)} in all cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NonWakeupRunnable</span> <span class="keyword">extends</span> <span class="title">Runnable</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="9-10-afterRunningAllTasks"><a href="#9-10-afterRunningAllTasks" class="headerlink" title="9.10 afterRunningAllTasks"></a>9.10 afterRunningAllTasks</h2><p><code>#afterRunningAllTasks()</code> 方法，在运行完所有任务后，执行 <code>tailTasks</code> 队列中的任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRunningAllTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    runAllTasksFrom(tailTasks);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#runAllTasksFrom(queue)</code> 方法，执行 <code>tailTasks</code> 队列中的所有任务。</li>
</ul>
<h1 id="10-NioEventLoop"><a href="#10-NioEventLoop" class="headerlink" title="10. NioEventLoop"></a>10. NioEventLoop</h1><p><code>io.netty.channel.nio.NioEventLoop</code> ，继承 SingleThreadEventLoop 抽象类，NIO EventLoop 实现类，实现对注册到其中的 Channel 的就绪的 IO 事件，和对用户提交的任务进行处理。</p>
<p>详细解析，见 <a href="http://svip.iocoder.cn/Netty/EventLoop-4-EventLoop-run">《精尽 Netty 源码解析 —— EventLoop（四）之 EventLoop 运行》</a> 。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>自顶向下的过了下 EventLoop 相关的类和方法。因为仅涉及 EventLoop 初始化相关的内容，所以对于 EventLoop 运行相关的内容，就不得不省略了。</p>
<p>那么，饥渴难耐的我们，<a href="http://svip.iocoder.cn/Netty/EventLoop-4-EventLoop-run">《精尽 Netty 源码解析 —— EventLoop（四）之 EventLoop 运行》</a> ，走起！</p>
<hr>
<p>推荐阅读如下文章：</p>
<ul>
<li>永顺 <a href="https://segmentfault.com/a/1190000007403873#articleHeader7" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)》</a> 的 <a href="#">「NioEventLoop」</a> 小节。</li>
<li>Hypercube <a href="https://www.jianshu.com/p/d0f06b13e2fb" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（四）—— EventLoop-2》</a> </li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-3-EventLoop-init/" data-id="ck4pl3fp100dqfgcf8ofo6gtv" class="article-share-link">分享</a>



</footer>
-->
</div>