<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（二）FrameDecoder
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/Codec-1-1-ByteToMessageDecoder-core-impl">《精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（一）》</a> 中，我们看到 ByteToMessageDecoder 有四个 FrameDecoder 实现类：</p>
<ul>
<li>① FixedLengthFrameDecoder ，基于<strong>固定长度</strong>消息进行粘包拆包处理的。</li>
<li>② LengthFieldBasedFrameDecoder ，基于<strong>消息头指定消息长度</strong>进行粘包拆包处理的。</li>
<li>③ LineBasedFrameDecoder ，基于<strong>换行</strong>来进行消息粘包拆包处理的。</li>
<li>④ DelimiterBasedFrameDecoder ，基于<strong>指定消息边界方式</strong>进行粘包拆包处理的。</li>
</ul>
<p>实际上，上述四个 FrameDecoder 实现可以进行规整：</p>
<ul>
<li>① 是 ② 的特例，<strong>固定长度</strong>是<strong>消息头指定消息长度</strong>的一种形式。</li>
<li>③ 是 ④ 的特例，<strong>换行</strong>是于<strong>指定消息边界方式</strong>的一种形式。</li>
</ul>
<p>本文，笔者只分享 ① 和 ③ 。对于 ② 和 ④ ，会提供相关的文章。</p>
<h1 id="2-FixedLengthFrameDecoder"><a href="#2-FixedLengthFrameDecoder" class="headerlink" title="2. FixedLengthFrameDecoder"></a>2. FixedLengthFrameDecoder</h1><p><code>io.netty.handler.codec.FixedLengthFrameDecoder</code> ，继承 ByteToMessageDecoder 抽象类，基于<strong>固定长度</strong>消息进行粘包拆包处理的。</p>
<p>如果下是固定长度为 3 的数据流解码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">+---+----+------+----+      +-----+-----+-----+</span><br><span class="line">| A | BC | DEFG | HI |  -&gt;  | ABC | DEF | GHI |</span><br><span class="line">+---+----+------+----+      +-----+-----+-----+</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> frameLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> frameLength the length of the frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FixedLengthFrameDecoder</span><span class="params">(<span class="keyword">int</span> frameLength)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (frameLength &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"frameLength must be a positive integer: "</span> + frameLength);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.frameLength = frameLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>frameLength</code> 属性，固定长度。</li>
</ul>
<h2 id="2-2-decode"><a href="#2-2-decode" class="headerlink" title="2.2 decode"></a>2.2 decode</h2><p><code>#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"><span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="number">3</span>:     <span class="comment">// 解码消息</span></span><br><span class="line"><span class="number">4</span>:     Object decoded = decode(ctx, in);</span><br><span class="line"><span class="number">5</span>:     <span class="comment">// 添加到 out 结果中</span></span><br><span class="line"><span class="number">6</span>:     <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">7</span>:         out.add(decoded);</span><br><span class="line"><span class="number">8</span>:     }</span><br><span class="line"><span class="number">9</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 4 行：调用 <code>#decode(ChannelHandlerContext ctx, ByteBuf in)</code> 方法，解码消息。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a frame out of the {<span class="doctag">@link</span> ByteBuf} and return it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   ctx             the {<span class="doctag">@link</span> ChannelHandlerContext} which this {<span class="doctag">@link</span> ByteToMessageDecoder} belongs to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   in              the {<span class="doctag">@link</span> ByteBuf} from which to read data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  frame           the {<span class="doctag">@link</span> ByteBuf} which represent the frame or {<span class="doctag">@code</span> null} if no frame could</span></span><br><span class="line"><span class="comment"> *                          be created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(@SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> ChannelHandlerContext ctx, ByteBuf in) <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 可读字节不够 frameLength 长度，无法解码出消息。</span></span><br><span class="line">    <span class="keyword">if</span> (in.readableBytes() &lt; frameLength) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 可读字节足够 frameLength 长度，解码出一条消息。</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> in.readRetainedSlice(frameLength);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当可读字节足够 <code>frameLength</code> 长度时，调用 <code>ByteBuf#readRetainedSlice(int length)</code> 方法，读取一个 Slice ByteBuf 对象，并增加引用计数。并且该 Slice ByteBuf 作为解码的一条消息。另外，<code>ByteBuf#readRetainedSlice(int length)</code> 的过程，因为是共享原有 ByteBuf <code>in</code> 数组，所以不存在数据拷贝。</li>
</ul>
</li>
<li>第 5 至 8 行：若解码到消息，添加到 <code>out</code> 结果中。</li>
</ul>
<h1 id="3-LineBasedFrameDecoder"><a href="#3-LineBasedFrameDecoder" class="headerlink" title="3. LineBasedFrameDecoder"></a>3. LineBasedFrameDecoder</h1><p><code>io.netty.handler.codec.LineBasedFrameDecoder</code> ，继承 ByteToMessageDecoder 抽象类，基于<strong>换行</strong>来进行消息粘包拆包处理的。</p>
<p>它会处理 <code>"\n"</code> 和 <code>"\r\n"</code> 两种换行符。</p>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一条消息的最大长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Maximum length of a frame we're willing to decode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxLength;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否快速失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当 true 时，未找到消息，但是超过最大长度，则马上触发 Exception 到下一个节点</span></span><br><span class="line"><span class="comment"> * 当 false 时，未找到消息，但是超过最大长度，需要匹配到一条消息后，再触发 Exception 到下一个节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether or not to throw an exception as soon as we exceed maxLength.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否过滤掉换行分隔符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果为 true ，解码的消息不包含换行符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> stripDelimiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否处于废弃模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果为 true ，说明解析超过最大长度( maxLength )，结果还是找不到换行符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * True if we're discarding input because we're already over maxLength.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> discarding;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 废弃的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> discardedBytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后扫描的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Last scan position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new decoder.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLength  the maximum length of the decoded frame.</span></span><br><span class="line"><span class="comment"> *                   A {<span class="doctag">@link</span> TooLongFrameException} is thrown if</span></span><br><span class="line"><span class="comment"> *                   the length of the frame exceeds this value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LineBasedFrameDecoder</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxLength)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(maxLength, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new decoder.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxLength  the maximum length of the decoded frame.</span></span><br><span class="line"><span class="comment"> *                   A {<span class="doctag">@link</span> TooLongFrameException} is thrown if</span></span><br><span class="line"><span class="comment"> *                   the length of the frame exceeds this value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stripDelimiter  whether the decoded frame should strip out the</span></span><br><span class="line"><span class="comment"> *                        delimiter or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> failFast  If &lt;tt&gt;true&lt;/tt&gt;, a {<span class="doctag">@link</span> TooLongFrameException} is</span></span><br><span class="line"><span class="comment"> *                  thrown as soon as the decoder notices the length of the</span></span><br><span class="line"><span class="comment"> *                  frame will exceed &lt;tt&gt;maxFrameLength&lt;/tt&gt; regardless of</span></span><br><span class="line"><span class="comment"> *                  whether the entire frame has been read.</span></span><br><span class="line"><span class="comment"> *                  If &lt;tt&gt;false&lt;/tt&gt;, a {<span class="doctag">@link</span> TooLongFrameException} is</span></span><br><span class="line"><span class="comment"> *                  thrown after the entire frame that exceeds</span></span><br><span class="line"><span class="comment"> *                  &lt;tt&gt;maxFrameLength&lt;/tt&gt; has been read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LineBasedFrameDecoder</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxLength, <span class="keyword">final</span> <span class="keyword">boolean</span> stripDelimiter, <span class="keyword">final</span> <span class="keyword">boolean</span> failFast)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">    <span class="keyword">this</span>.failFast = failFast;</span><br><span class="line">    <span class="keyword">this</span>.stripDelimiter = stripDelimiter;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>maxLength</code> 属性，一条消息的最大长度。原本以为 LineBasedFrameDecoder 会比较简单，但是因为多了 <code>maxLength</code> 复杂很多。为什么这么说呢？<ul>
<li>假设 <code>maxLength = 2</code> ，接收到的数据为 <code>"abcd\nEF\n"</code>( 直接以字符串举例，为了可阅读性 )，那么 <code>"abcd"</code> 是不符合条件的消息，因为长度为 4 ，超过最大长度 <code>maxLength</code> 。</li>
<li>但是考虑到拆粘包的情况，可能初始化接收到的是 <code>"abc"</code> ，那么无法匹配到 <code>\n</code> 换行符。但是呢，<code>"abc"</code> 的长度为 3，超过最大长度 <code>maxLength</code> ，需要等待读取到 <code>"d\n"</code> 部分，然后抛弃 <code>"abcd"</code> 整条。再之后，继续读取符合条件的 <code>"EF"</code> 段。</li>
<li>😈 比较绕，胖友好好理解下。</li>
</ul>
</li>
<li><code>failFast</code> 属性，是否快速失败。<ul>
<li><code>true</code> 时，未找到消息，但是超过最大长度，则马上触发 Exception 到下一个节点。</li>
<li>当 <code>false</code> 时，未找到消息，但是超过最大长度，需要匹配到一条消息后，再触发 Exception 到下一个节点。</li>
<li>😈 也有点绕，等下结合代码具体理解。</li>
</ul>
</li>
<li><code>stripDelimiter</code> 属性，是否过滤掉换行分隔符。如果为 <code>true</code> ，解码的消息不包含换行符。</li>
<li><code>discarding</code> 属性，是否处于废弃模式。如果为 <code>true</code> ，说明解析超过最大长度( <code>maxLength</code> )，结果还是找不到换行符。<ul>
<li>😈 也有点绕，等下结合代码具体理解。</li>
<li><code>discardedBytes</code> 属性，废弃的字节数。</li>
<li><code>offset</code> 属性，最后扫描的位置。</li>
</ul>
</li>
</ul>
<h2 id="3-2-decode"><a href="#3-2-decode" class="headerlink" title="3.2 decode"></a>3.2 decode</h2><p><code>#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) {</span><br><span class="line">        out.add(decoded);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这段代码，和 <code>FixedLengthFrameDecoder#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，是一样的。</li>
</ul>
<hr>
<p><code>#decode(ChannelHandlerContext ctx, ByteBuf buffer)</code> 方法，执行解码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 获得换行符的位置</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">final</span> <span class="keyword">int</span> eol = findEndOfLine(buffer);</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (!discarding) { <span class="comment">// 未处于废弃模式</span></span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) { <span class="comment">// 找到</span></span><br><span class="line"> <span class="number">6</span>:             <span class="keyword">final</span> ByteBuf frame;</span><br><span class="line"> <span class="number">7</span>:             <span class="keyword">final</span> <span class="keyword">int</span> length = eol - buffer.readerIndex(); <span class="comment">// 读取长度</span></span><br><span class="line"> <span class="number">8</span>:             <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">'\r'</span> ? <span class="number">2</span> : <span class="number">1</span>; <span class="comment">// 分隔符的长度。2 为 `\r\n` ，1 为 `\n`</span></span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:             <span class="comment">// 超过最大长度</span></span><br><span class="line"><span class="number">11</span>:             <span class="keyword">if</span> (length &gt; maxLength) {</span><br><span class="line"><span class="number">12</span>:                 <span class="comment">// 设置新的读取位置</span></span><br><span class="line"><span class="number">13</span>:                 buffer.readerIndex(eol + delimLength);</span><br><span class="line"><span class="number">14</span>:                 <span class="comment">// 触发 Exception 到下一个节点</span></span><br><span class="line"><span class="number">15</span>:                 fail(ctx, length);</span><br><span class="line"><span class="number">16</span>:                 <span class="comment">// 返回 null ，即未解码到消息</span></span><br><span class="line"><span class="number">17</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">18</span>:             }</span><br><span class="line"><span class="number">19</span>: </span><br><span class="line"><span class="number">20</span>:             <span class="comment">// 解码出一条消息。</span></span><br><span class="line"><span class="number">21</span>:             <span class="keyword">if</span> (stripDelimiter) {</span><br><span class="line"><span class="number">22</span>:                 frame = buffer.readRetainedSlice(length);</span><br><span class="line"><span class="number">23</span>:                 buffer.skipBytes(delimLength); <span class="comment">// 忽略换行符</span></span><br><span class="line"><span class="number">24</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">25</span>:                 frame = buffer.readRetainedSlice(length + delimLength);</span><br><span class="line"><span class="number">26</span>:             }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:             <span class="comment">// 返回解码的消息</span></span><br><span class="line"><span class="number">29</span>:             <span class="keyword">return</span> frame;</span><br><span class="line"><span class="number">30</span>:         } <span class="keyword">else</span> { <span class="comment">// 未找到</span></span><br><span class="line"><span class="number">31</span>:             <span class="keyword">final</span> <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line"><span class="number">32</span>:             <span class="comment">// 超过最大长度</span></span><br><span class="line"><span class="number">33</span>:             <span class="keyword">if</span> (length &gt; maxLength) {</span><br><span class="line"><span class="number">34</span>:                 <span class="comment">// 记录 discardedBytes</span></span><br><span class="line"><span class="number">35</span>:                 discardedBytes = length;</span><br><span class="line"><span class="number">36</span>:                 <span class="comment">// 跳到写入位置</span></span><br><span class="line"><span class="number">37</span>:                 buffer.readerIndex(buffer.writerIndex());</span><br><span class="line"><span class="number">38</span>:                 <span class="comment">// 标记 discarding 为废弃模式</span></span><br><span class="line"><span class="number">39</span>:                 discarding = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">40</span>:                 <span class="comment">// 重置 offset</span></span><br><span class="line"><span class="number">41</span>:                 offset = <span class="number">0</span>;</span><br><span class="line"><span class="number">42</span>:                 <span class="comment">// 如果快速失败，则触发 Exception 到下一个节点</span></span><br><span class="line"><span class="number">43</span>:                 <span class="keyword">if</span> (failFast) {</span><br><span class="line"><span class="number">44</span>:                     fail(ctx, <span class="string">"over "</span> + discardedBytes);</span><br><span class="line"><span class="number">45</span>:                 }</span><br><span class="line"><span class="number">46</span>:             }</span><br><span class="line"><span class="number">47</span>:             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">48</span>:         }</span><br><span class="line"><span class="number">49</span>:     } <span class="keyword">else</span> { <span class="comment">// 处于废弃模式</span></span><br><span class="line"><span class="number">50</span>:         <span class="keyword">if</span> (eol &gt;= <span class="number">0</span>) { <span class="comment">// 找到</span></span><br><span class="line"><span class="number">51</span>:             <span class="keyword">final</span> <span class="keyword">int</span> length = discardedBytes + eol - buffer.readerIndex(); <span class="comment">// 读取长度</span></span><br><span class="line"><span class="number">52</span>:             <span class="keyword">final</span> <span class="keyword">int</span> delimLength = buffer.getByte(eol) == <span class="string">'\r'</span> ? <span class="number">2</span> : <span class="number">1</span>; <span class="comment">// 分隔符的长度。2 为 `\r\n` ，1 为 `\n`</span></span><br><span class="line"><span class="number">53</span>:             <span class="comment">// 设置新的读取位置</span></span><br><span class="line"><span class="number">54</span>:             buffer.readerIndex(eol + delimLength);</span><br><span class="line"><span class="number">55</span>:             <span class="comment">// 重置 discardedBytes</span></span><br><span class="line"><span class="number">56</span>:             discardedBytes = <span class="number">0</span>;</span><br><span class="line"><span class="number">57</span>:             <span class="comment">// 设置 discarding 不为废弃模式</span></span><br><span class="line"><span class="number">58</span>:             discarding = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">59</span>:             <span class="comment">// 如果不为快速失败，则触发 Exception 到下一个节点</span></span><br><span class="line"><span class="number">60</span>:             <span class="keyword">if</span> (!failFast) {</span><br><span class="line"><span class="number">61</span>:                 fail(ctx, length);</span><br><span class="line"><span class="number">62</span>:             }</span><br><span class="line"><span class="number">63</span>:         } <span class="keyword">else</span> { <span class="comment">// 未找到</span></span><br><span class="line"><span class="number">64</span>:             <span class="comment">// 增加 discardedBytes</span></span><br><span class="line"><span class="number">65</span>:             discardedBytes += buffer.readableBytes();</span><br><span class="line"><span class="number">66</span>:             <span class="comment">// 跳到写入位置</span></span><br><span class="line"><span class="number">67</span>:             buffer.readerIndex(buffer.writerIndex());</span><br><span class="line"><span class="number">68</span>:         }</span><br><span class="line"><span class="number">69</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">70</span>:     }</span><br><span class="line"><span class="number">71</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：调用 <code>#findEndOfLine(final ByteBuf buffer)</code> 方法，获得换行符的位置。详细解析，这里胖友先跳到 <a href="#">「3.3 findEndOfLine」</a> 中。</li>
<li>=============== 未处于 <code>discarding</code> 模式 ===============</li>
<li>根据是否找到换行符，分成 ① ② 两种情况。</li>
<li>① 第 5 行：<strong>找到</strong>换行符。</li>
<li>第 7 至 8 行：获得读取消息的长度、换行符的长度。</li>
<li>第 11 行：读取消息的长度，超过最大长度，则<strong>丢弃</strong>该消息。<ul>
<li>第 13 行：<code>buffer</code> 设置新的读取位置。</li>
<li>第 15 行：调用 <code>#fail(...)</code> 方法，触发 Exception 到下一个节点。详细解析，见 <a href="#">「3.4 fail」</a> 。😈 注意，此处和 <code>failFast</code> 没有关系。</li>
<li>【失败】第 17 行：返回 <code>null</code> ，即未解码到消息。</li>
</ul>
</li>
<li>【成功】第 20 至 26 行：解码出一条消息。调用 <code>ByteBuf#readRetainedSlice(int length)</code> 方法，读取一个 Slice ByteBuf 对象，并增加引用计数。并且该 Slice ByteBuf 作为解码的一条消息。另外，<code>ByteBuf#readRetainedSlice(int length)</code> 的过程，因为是共享原有 ByteBuf <code>in</code> 数组，所以不存在数据拷贝。</li>
<li>② 第 30 行：<strong>未找到</strong>换行符，说明当前 <code>buffer</code> <strong>不存在</strong>完整的消息。需要继续读取新的数据，再次解码拆包。</li>
<li>第 33 行：可读字节，超过最大长度，那么即使后续找到换行符，消息也<strong>一定</strong>超过最大长度。 </li>
<li>第 35 行：记录 <code>discardedBytes</code> 。因为【第 37 行】的代码，<code>buffer</code> 跳到写入位置，也就是抛弃了 <code>discardedBytes</code> 字节数。</li>
<li>第 39 行：标记 <code>discarding</code> 为 <code>true</code> ，进入废弃模式。那么，后续就会执行【第 49 至 70 行】的代码逻辑，寻找到换行符，解码拆包出该消息，并<strong>抛弃</strong>它。<ul>
<li>😈 这段，好好理解下。 </li>
</ul>
</li>
<li>第 41 行：重置 <code>offset</code> 为 0 。</li>
<li>第 42 至 45 行：如果快速失败( <code>failFast = true</code> )，调用 <code>#fail(...)</code> 方法，触发 Exception 到下一个节点。那么，不快速失败( <code>failFast = false</code> )呢？继续往下走，答案在【第 59 至 61 行】的代码，见分晓。</li>
<li>第 47 行：【失败】第 17 行：返回 <code>null</code> ，即未解码到消息。</li>
<li>=============== 正处于 <code>discarding</code> 模式 ===============</li>
<li><code>discarding</code> 模式是什么呢？在【第 33 至 46 行】的代码，如果已读取的字节数，超过最大长度，那么进入 <code>discarding</code> 模式，继续寻找到换行符，解码拆包出该消息，并<strong>抛弃</strong>它。😈 实际上，它的效果是【第 30 至 48 行】+【第 49 至 69 行】和【第 10 至 18 行】的代码的效果是<strong>等价的</strong>，只是说【第 30 至 48 行】的代码，因为数据包是<strong>不完整</strong>( 找不到换行符 )的，所以进入【第 49 至 69 行】的代码。</li>
<li>根据是否找到换行符，分成 ① ② 两种情况。</li>
<li>① 第 50 行：<strong>找到</strong>换行符。</li>
<li>第 51 行：读取长度。此处的长度，算上了 <code>discardedBytes</code> 的部分。<ul>
<li>第 52 行：获得换行符的长度。</li>
</ul>
</li>
<li>第 54 行：设置新的读取位置。因为，<strong>找到</strong>换行符。</li>
<li>第 56 行：重置 <code>discardedBytes</code> 为 0 。因为，<strong>找到</strong>换行符。</li>
<li>第 58 行：重置 <code>offset</code> 为 0 。因为，<strong>找到</strong>换行符。</li>
<li>第 59 至 62 行：如果不为快速失败( <code>failFast = false</code> )，调用 <code>#fail(...)</code> 方法，触发 Exception 到下一个节点。<ul>
<li>和【第 42 至 45 行】的代码，相对。</li>
<li>也就说，<code>failFast = false</code> 的情况下，只有在解析到完整的消息，<strong>才</strong>触发 Exception 到下一个节点。😈 是不是很绕，哈哈哈哈。</li>
</ul>
</li>
<li>【失败】第 69 行：返回 <code>null</code> ，虽然解码到消息，但是因为消息长度超过最大长度，所以进行<strong>丢失</strong>。和【第 17 行】的代码，是一个目的。</li>
<li>② 第 63 行：<strong>未找到</strong>换行符，说明当前 <code>buffer</code> <strong>不存在</strong>完整的消息。需要继续读取新的数据，再次解码拆包。</li>
<li>第 65 行：增加 <code>discardedBytes</code> 。</li>
<li>第 67 行：<code>buffer</code> 跳到写入位置。</li>
<li>第 69 行：返回 <code>null</code> ，即未解码到消息。</li>
</ul>
<p>😈 整体逻辑，有点绕，不过很有趣。</p>
<h2 id="3-3-findEndOfLine"><a href="#3-3-findEndOfLine" class="headerlink" title="3.3 findEndOfLine"></a>3.3 findEndOfLine</h2><p><code>#findEndOfLine(final ByteBuf buffer)</code> 方法，获得换行符的位置。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the index in the buffer of the end of line found.</span></span><br><span class="line"><span class="comment">    * Returns -1 if no end of line was found in the buffer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findEndOfLine</span><span class="params">(<span class="keyword">final</span> ByteBuf buffer)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">int</span> totalLength = buffer.readableBytes();</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">int</span> i = buffer.forEachByte(buffer.readerIndex() + offset, totalLength - offset, ByteProcessor.FIND_LF);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 找到</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// 重置 offset</span></span><br><span class="line"> <span class="number">7</span>:         offset = <span class="number">0</span>;</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 如果前一个字节位 `\r` ，说明找到的是 `\n` ，所以需要 -1 ，因为寻找的是首个换行符的位置</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; buffer.getByte(i - <span class="number">1</span>) == <span class="string">'\r'</span>) {</span><br><span class="line"><span class="number">10</span>:             i--;</span><br><span class="line"><span class="number">11</span>:         }</span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 未找到，记录 offset</span></span><br><span class="line"><span class="number">13</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">14</span>:         offset = totalLength;</span><br><span class="line"><span class="number">15</span>:     }</span><br><span class="line"><span class="number">16</span>:     <span class="keyword">return</span> i;</span><br><span class="line"><span class="number">17</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关于 <code>offset</code> 的逻辑，笔者觉得有点问题。在这里，胖友先无视掉它。稍后，我们在统一分享。</li>
<li>第 3 行：在 <code>buffer</code> 的 <code>[readerIndex, readerIndex + readableBytes)</code> 位置范围内，查找 <code>\n</code> 换行符的位置。😈 在忽略 <code>offset</code> 的前提下。</li>
<li>【有找到】<ul>
<li>第 7 行：重置 <code>offset</code> 。</li>
<li>第 8 至 11 行：如果前一个字节位 <code>\r</code> ，说明找到的是 <code>\n</code> ，所以需要 -1 ，因为寻找的是首个换行符的位置。</li>
</ul>
</li>
<li>【没找到】<ul>
<li>第 14 行：记录 <code>offset</code> 。</li>
</ul>
</li>
<li>第 16 行：返回位置 <code>i</code> 。 </li>
</ul>
<h2 id="3-4-fail"><a href="#3-4-fail" class="headerlink" title="3.4 fail"></a>3.4 fail</h2><p><code>#fail(...)</code> 方法，触发 Exception 到下一个节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    fail(ctx, String.valueOf(length));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, String length)</span> </span>{</span><br><span class="line">    ctx.fireExceptionCaught(<span class="keyword">new</span> TooLongFrameException(<span class="string">"frame length ("</span> + length + <span class="string">") exceeds the allowed maximum ("</span> + maxLength + <span class="string">')'</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-5-可能是-offset-的一个-bug"><a href="#3-5-可能是-offset-的一个-bug" class="headerlink" title="3.5 可能是 offset 的一个 bug"></a>3.5 可能是 offset 的一个 bug</h2><p>这里，只能说是 <code>offset</code> 的一个 bug ，也是笔者的一个推测。下面，我们来推导下。</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_10_01/01.png" title="代码图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_10_01/01.png" alt="代码图"></a><span class="caption">代码图</span></p>
<ul>
<li>第一根红线，在 <code>discarding</code> 模式下，如果读取不到换行符，每次 <code>buffer</code> 的读取位置，都会跳到写入位置。</li>
<li>第三根红线，<code>offset</code> 记录<strong>上一次</strong>读取的字节数。</li>
<li>第二根红线，如果查找的范围 <code>+ offset</code> ，但是 <code>buffer</code> 的读取位置已经跳到写入位置，岂不是和 <code>offset</code> 的重复了？？</li>
</ul>
<p>所以，笔者认为，应该去掉 <code>offset</code> 的相关逻辑。</p>
<hr>
<p>下面，我们以一个实际情况，举个例子。如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_12_04/02.png" title="例子" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_12_04/02.png" alt="例子"></a><span class="caption">例子</span></p>
<ul>
<li>假设 <code>maxLength</code> 等于 1 。</li>
<li>第一次接收到数据 <code>"012"</code> ，未找到换行符，但是超过最大长度，所以进入 <code>discarding</code> 模式。</li>
<li>第二次接收到数据 <code>"34"</code> ，未找到换行符，<code>r = w = 4</code> ，并且 <code>offset = 2</code> 。</li>
<li>第三次接收到数据 <code>"\n"</code> ，但是查找范围是 <code>buffer.readerIndex() + offset = 4 + 2 &gt; 5</code> ，超过范围。</li>
</ul>
<p>因此，笔者觉得，这个可能是 offset 的一个 bug 。</p>
<h1 id="4-LengthFieldBasedFrameDecoder"><a href="#4-LengthFieldBasedFrameDecoder" class="headerlink" title="4. LengthFieldBasedFrameDecoder"></a>4. LengthFieldBasedFrameDecoder</h1><p><code>io.netty.handler.codec.LengthFieldBasedFrameDecoder</code> ，继承 ByteToMessageDecoder 抽象类，基于<strong>消息头指定消息长度</strong>进行粘包拆包处理的。</p>
<p>详细解析，见基友【闪电侠】的 <a href="https://www.jianshu.com/p/a0a51fd79f62" rel="external nofollow noopener noreferrer" target="_blank">《netty源码分析之LengthFieldBasedFrameDecoder》</a> 一文。</p>
<p>或者，【Hypercube】的 <a href="https://www.jianshu.com/p/c3fbd6113dd6" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（八）– LengthFieldBasedFrameDecoder》</a> 一文。</p>
<h1 id="5-DelimiterBasedFrameDecoder"><a href="#5-DelimiterBasedFrameDecoder" class="headerlink" title="5. DelimiterBasedFrameDecoder"></a>5. DelimiterBasedFrameDecoder</h1><p><code>io.netty.handler.codec.DelimiterBasedFrameDecoder</code> ，继承 ByteToMessageDecoder 抽象类，基于<strong>指定消息边界方式</strong>进行粘包拆包处理的。</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/7c439cc7b01c" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（八）–CodecHandler》</a> 的 <a href="#">「8.1.2 DelimiterBasedFrameDecoder」</a> 小节。</p>
<p>如下内容，因为排版，所以未使用引用语法。</p>
</blockquote>
<p>该解码器是更通用的分隔符解码器，可支持多个分隔符，每个分隔符可为一个或多个字符。如果定义了多个分隔符，并且可解码出多个消息帧，则选择产生最小帧长的结果。例如，使用行分隔符<code>\r\n</code>和<code>\n</code>分隔：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">| ABC\nDEF\r\n |</span><br><span class="line">+--------------+</span><br></pre></td></tr></tbody></table></figure>
<p>可有两种结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">+-----+-----+              +----------+   </span><br><span class="line">| ABC | DEF |  (√)   和    | ABC\nDEF |  (×)</span><br><span class="line">+-----+-----+              +----------+</span><br></pre></td></tr></tbody></table></figure>
<p>该编码器可配置的变量与<code>LineBasedFrameDecoder</code>类似，只是多了一个<code>ByteBuf[] delimiters</code>用于配置具体的分隔符。<br> Netty在<code>Delimiters</code>类中定义了两种默认的分隔符，分别是NULL分隔符和行分隔符：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf[] nulDelimiter() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteBuf[] {</span><br><span class="line">            Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="keyword">byte</span>[] { <span class="number">0</span> }) };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf[] lineDelimiter() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteBuf[] {</span><br><span class="line">            Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="keyword">byte</span>[] { <span class="string">'\r'</span>, <span class="string">'\n'</span> }),</span><br><span class="line">            Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="keyword">byte</span>[] { <span class="string">'\n'</span> }),</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>在 FixedLengthFrameDecoder 那里，卡了好长时间，Netty 在细节这块，扣的真给力啊！！！</p>
<p>本文参考如下文章：</p>
<ul>
<li>简书闪电侠 <a href="https://www.jianshu.com/p/a0a51fd79f62" rel="external nofollow noopener noreferrer" target="_blank">《netty源码分析之LengthFieldBasedFrameDecoder》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/7c439cc7b01c" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（八）–CodecHandler》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Codec-1-2-ByteToMessageDecoder-FrameDecoder/" data-id="ck4pl3fp900eefgcf3362q4e9" class="article-share-link">分享</a>



</footer>
-->
</div>