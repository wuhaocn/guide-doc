# æœåŠ¡å¼•ç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹å¼•ç”¨ï¼ˆDubboï¼‰

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°å¼•ç”¨ï¼ˆInjvmï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) ä¸€æ–‡ä¸­ï¼Œæˆ‘ä»¬å·²ç»åˆ†äº«äº†**æœ¬åœ°å¼•ç”¨æœåŠ¡**ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ¥åˆ†äº«**è¿œç¨‹å¼•ç”¨æœåŠ¡**ã€‚åœ¨ Dubbo ä¸­æä¾›å¤šç§åè®®( Protocol ) çš„å®ç°ï¼Œå¤§ä½“æµç¨‹ä¸€è‡´ï¼Œæœ¬æ–‡ä»¥ [Dubbo Protocol](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html) ä¸ºä¾‹å­ï¼Œè¿™ä¹Ÿæ˜¯ Dubbo çš„**é»˜è®¤**åè®®ã€‚

å¦‚æœä¸ç†Ÿæ‚‰è¯¥åè®®çš„åŒå­¦ï¼Œå¯ä»¥å…ˆçœ‹çœ‹ [ã€ŠDubbo ä½¿ç”¨æŒ‡å— â€”â€” dubbo://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html) ï¼Œç®€å•äº†è§£å³å¯ã€‚
**ç‰¹æ€§**

ç¼ºçœåè®®ï¼Œä½¿ç”¨åŸºäº mina

1.1.7
å’Œ hessian

3.2.1
çš„ remoting äº¤äº’ã€‚

* è¿æ¥ä¸ªæ•°ï¼šå•è¿æ¥
* è¿æ¥æ–¹å¼ï¼šé•¿è¿æ¥
* ä¼ è¾“åè®®ï¼šTCP
* ä¼ è¾“æ–¹å¼ï¼šNIO å¼‚æ­¥ä¼ è¾“
* åºåˆ—åŒ–ï¼šHessian äºŒè¿›åˆ¶åºåˆ—åŒ–
* é€‚ç”¨èŒƒå›´ï¼šä¼ å…¥ä¼ å‡ºå‚æ•°æ•°æ®åŒ…è¾ƒå°ï¼ˆå»ºè®®å°äº100Kï¼‰ï¼Œæ¶ˆè´¹è€…æ¯”æä¾›è€…ä¸ªæ•°å¤šï¼Œå•ä¸€æ¶ˆè´¹è€…æ— æ³•å‹æ»¡æä¾›è€…ï¼Œå°½é‡ä¸è¦ç”¨ dubbo åè®®ä¼ è¾“å¤§æ–‡ä»¶æˆ–è¶…å¤§å­—ç¬¦ä¸²ã€‚
* é€‚ç”¨åœºæ™¯ï¼šå¸¸è§„è¿œç¨‹æœåŠ¡æ–¹æ³•è°ƒç”¨

ç›¸æ¯”**æœ¬åœ°å¼•ç”¨**ï¼Œ**è¿œç¨‹å¼•ç”¨**ä¼šå¤šåšå¦‚ä¸‹å‡ ä»¶äº‹æƒ…ï¼š

* å‘æ³¨å†Œä¸­å¿ƒ**è®¢é˜…**ï¼Œä»è€Œ**å‘ç°**æœåŠ¡æä¾›è€…åˆ—è¡¨ã€‚
* å¯åŠ¨é€šä¿¡å®¢æˆ·ç«¯ï¼Œé€šè¿‡å®ƒè¿›è¡Œ**è¿œç¨‹è°ƒç”¨**ã€‚

# 2. è¿œç¨‹å¼•ç”¨

è¿œç¨‹æš´éœ²æœåŠ¡çš„é¡ºåºå›¾å¦‚ä¸‹ï¼š

![è¿œç¨‹å¼•ç”¨é¡ºåºå›¾](http://static2.iocoder.cn/images/Dubbo/2018_05_04/02.png)

åœ¨ [
/#createProxy(map)
](https://github.com/YunaiV/dubbo/blob/c635dd1990a1803643194048f408db310f06175b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java#L621-L648) æ–¹æ³•ä¸­ï¼Œæ¶‰åŠ**è¿œç¨‹å¼•ç”¨æœåŠ¡**çš„ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* æœåŠ¡å¼•ç”¨ URL æ•°ç»„
/*/
private final List<URL> urls = new ArrayList<URL>();
//*/*
/* ç›´è¿æœåŠ¡åœ°å€
/*
/* 1. å¯ä»¥æ˜¯æ³¨å†Œä¸­å¿ƒï¼Œä¹Ÿå¯ä»¥æ˜¯æœåŠ¡æä¾›è€…
/* 2. å¯é…ç½®å¤šä¸ªï¼Œä½¿ç”¨ ; åˆ†éš”
/*/
// url for peer-to-peer invocation
private String url;
1: //*/*
2: /* åˆ›å»º Service ä»£ç†å¯¹è±¡
3: /*
4: /* @param map é›†åˆ
5: /* @return ä»£ç†å¯¹è±¡
6: /*/
7: @SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
8: private T createProxy(Map<String, String> map){
9: URL tmpUrl = new URL("temp", "localhost", 0, map);
10: // ã€çœç•¥ä»£ç ã€‘æ˜¯å¦æœ¬åœ°å¼•ç”¨
11: final boolean isJvmRefer;
12:
13: // ã€çœç•¥ä»£ç ã€‘æœ¬åœ°å¼•ç”¨
14: if (isJvmRefer) {
15: // æ­£å¸¸æµç¨‹ï¼Œä¸€èˆ¬ä¸ºè¿œç¨‹å¼•ç”¨
16: } else {
17: // å®šä¹‰ç›´è¿åœ°å€ï¼Œå¯ä»¥æ˜¯æœåŠ¡æä¾›è€…çš„åœ°å€ï¼Œä¹Ÿå¯ä»¥æ˜¯æ³¨å†Œä¸­å¿ƒçš„åœ°å€
18: if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.
19: // æ‹†åˆ†åœ°å€æˆæ•°ç»„ï¼Œä½¿ç”¨ ";" åˆ†éš”ã€‚
20: String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);
21: // å¾ªç¯æ•°ç»„ï¼Œæ·»åŠ åˆ° `url` ä¸­ã€‚
22: if (us != null && us.length > 0) {
23: for (String u : us) {
24: // åˆ›å»º URL å¯¹è±¡
25: URL url = URL.valueOf(u);
26: // è®¾ç½®é»˜è®¤è·¯å¾„
27: if (url.getPath() == null || url.getPath().length() == 0) {
28: url = url.setPath(interfaceName);
29: }
30: // æ³¨å†Œä¸­å¿ƒçš„åœ°å€ï¼Œå¸¦ä¸ŠæœåŠ¡å¼•ç”¨çš„é…ç½®å‚æ•°
31: if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
32: urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));
33: // æœåŠ¡æä¾›è€…çš„åœ°å€
34: } else {
35: urls.add(ClusterUtils.mergeUrl(url, map));
36: }
37: }
38: }
39: // æ³¨å†Œä¸­å¿ƒ
40: } else { // assemble URL from register center's configuration
41: // åŠ è½½æ³¨å†Œä¸­å¿ƒ URL æ•°ç»„
42: List<URL> us = loadRegistries(false);
43: // å¾ªç¯æ•°ç»„ï¼Œæ·»åŠ åˆ° `url` ä¸­ã€‚
44: if (us != null && !us.isEmpty()) {
45: for (URL u : us) {
46: // åŠ è½½ç›‘æ§ä¸­å¿ƒ URL
47: URL monitorUrl = loadMonitor(u);
48: // æœåŠ¡å¼•ç”¨é…ç½®å¯¹è±¡ `map`ï¼Œå¸¦ä¸Šç›‘æ§ä¸­å¿ƒçš„ URL
49: if (monitorUrl != null) {
50: map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
51: }
52: // æ³¨å†Œä¸­å¿ƒçš„åœ°å€ï¼Œå¸¦ä¸ŠæœåŠ¡å¼•ç”¨çš„é…ç½®å‚æ•°
53: urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map))); // æ³¨å†Œä¸­å¿ƒï¼Œå¸¦ä¸ŠæœåŠ¡å¼•ç”¨çš„é…ç½®å‚æ•°
54: }
55: }
56: if (urls == null || urls.isEmpty()) {
57: throw new IllegalStateException("No such any registry to reference " + interfaceName + " on the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", please config <dubbo:registry address=\"...\" /> to your spring config.");
58: }
59: }
60:
61: // å• `urls` æ—¶ï¼Œå¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡
62: if (urls.size() == 1) {
63: // å¼•ç”¨æœåŠ¡
64: invoker = refprotocol.refer(interfaceClass, urls.get(0));
65: } else {
66: // å¾ªç¯ `urls` ï¼Œå¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡
67: List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();
68: URL registryURL = null;
69: for (URL url : urls) {
70: // å¼•ç”¨æœåŠ¡
71: invokers.add(refprotocol.refer(interfaceClass, url));
72: // ä½¿ç”¨æœ€åä¸€ä¸ªæ³¨å†Œä¸­å¿ƒçš„ URL
73: if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
74: registryURL = url; // use last registry url
75: }
76: }
77: // æœ‰æ³¨å†Œä¸­å¿ƒ
78: if (registryURL != null) { // registry url is available
79: // å¯¹æœ‰æ³¨å†Œä¸­å¿ƒçš„ Cluster åªç”¨ AvailableCluster
80: // use AvailableCluster only when register's cluster is available
81: URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);
83: invoker = cluster.join(new StaticDirectory(u, invokers));
84: // æ— æ³¨å†Œä¸­å¿ƒ
85: } else { // not a registry url
87: invoker = cluster.join(new StaticDirectory(invokers));
88: }
89: }
90: }
91:
92: // ã€çœç•¥ä»£ç ã€‘å¯åŠ¨æ—¶æ£€æŸ¥
93:
94: // åˆ›å»º Service ä»£ç†å¯¹è±¡
95: // create service proxy
96: return (T) proxyFactory.getProxy(invoker);
97: }
```

* ç¬¬ 11 è¡Œï¼šçœç•¥**æ˜¯å¦æœ¬åœ°å¼•ç”¨**çš„ä»£ç ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°å¼•ç”¨ï¼ˆInjvmï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) å·²ç»æœ‰åˆ†äº«ã€‚
* ç¬¬ 13 è‡³ 15 è¡Œï¼šçœç•¥**æœ¬åœ°å¼•ç”¨**çš„ä»£ç ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°å¼•ç”¨ï¼ˆInjvmï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) å·²ç»æœ‰åˆ†äº«ã€‚
* ç¬¬ 16 è‡³ 90 è¡Œï¼šæ­£å¸¸æµç¨‹ï¼Œä¸€èˆ¬ä¸ºè¿œç¨‹å¼•ç”¨ã€‚
* ç¬¬ 18 è‡³ 38 è¡Œï¼š

url
é…ç½®é¡¹ï¼Œ**å®šä¹‰ç›´è¿åœ°å€**ï¼Œå¯ä»¥æ˜¯æœåŠ¡æä¾›è€…çš„åœ°å€ï¼Œä¹Ÿå¯ä»¥æ˜¯æ³¨å†Œä¸­å¿ƒçš„åœ°å€ã€‚

* ç¬¬ 20 è¡Œï¼šæ‹†åˆ†åœ°å€æˆæ•°ç»„ï¼Œä½¿ç”¨ â€œ;â€ åˆ†éš”ã€‚
* ç¬¬ 22 è‡³ 23 è¡Œï¼šå¾ªç¯æ•°ç»„

us
ï¼Œåˆ›å»º URL å¯¹è±¡åï¼Œæ·»åŠ åˆ°

urls
ä¸­ã€‚
* ç¬¬ 25 è¡Œï¼šåˆ›å»º URL å¯¹è±¡ã€‚
* ç¬¬ 26 è‡³ 29 è¡Œï¼šè·¯å¾„å±æ€§

url.path
æœªè®¾ç½®æ—¶ï¼Œç¼ºçœä½¿ç”¨æ¥å£å…¨å

interfaceName
ã€‚
* ç¬¬ 30 è‡³ 32 è¡Œï¼šè‹¥

url.protocol = registry
æ—¶ï¼Œ**æ³¨å†Œä¸­å¿ƒçš„åœ°å€**ï¼Œåœ¨å‚æ•°

url.parameters.refer
ä¸Šï¼Œè®¾ç½®ä¸ŠæœåŠ¡å¼•ç”¨çš„é…ç½®å‚æ•°é›†åˆ

map
ã€‚
* ç¬¬ 33 è‡³ 36 è¡Œï¼š**æœåŠ¡æä¾›è€…çš„åœ°å€**ã€‚

* ä»é€»è¾‘ä¸Šç±»ä¼¼ã€ç¬¬ 53 è¡Œã€‘çš„ä»£ç ã€‚
* ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸å»ºè®®è¿™æ ·åœ¨

url
é…ç½®æ³¨å†Œä¸­å¿ƒï¼Œè€Œæ˜¯åœ¨

registry
é…ç½®ã€‚å¦‚æœè¦é…ç½®ï¼Œæ ¼å¼ä¸º

registry://host:port?registry=
ï¼Œä¾‹å¦‚

registry://127.0.0.1?registry=zookeeper
ã€‚
* TODO ClusterUtils.mergeUrl
* ç¬¬ 39 è‡³ 59 è¡Œï¼š

protocol
é…ç½®é¡¹ï¼Œ**æ³¨å†Œä¸­å¿ƒ**ã€‚

* ç¬¬ 42 è¡Œï¼šè°ƒç”¨

/#loadRegistries(provider)
æ–¹æ³•ï¼ŒåŠ è½½æ³¨å†Œä¸­å¿ƒçš„ com.alibaba.dubbo.common.URL` æ•°ç»„ã€‚

* ğŸ™‚ åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡æš´éœ²ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°æš´éœ²ï¼ˆInjvmï¼‰ã€‹ã€Œ2.1 loadRegistriesã€](http://svip.iocoder.cn/Dubbo/service-export-local/?self) è¯¦ç»†è§£æã€‚
* ç¬¬ 43 è‡³ 58 è¡Œï¼šå¾ªç¯æ•°ç»„

us
ï¼Œåˆ›å»º URL å¯¹è±¡åï¼Œæ·»åŠ åˆ°

urls
ä¸­ã€‚

* ç¬¬ 47 è¡Œï¼šè°ƒç”¨

/#loadMonitor(registryURL)
æ–¹æ³•ï¼Œè·å¾—ç›‘æ§ä¸­å¿ƒ URL ã€‚

* ğŸ™‚ åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡æš´éœ²ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹æš´éœ²ï¼ˆDubboï¼‰ã€‹ã€Œ2.1 loadRegistriesã€](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/) å°èŠ‚ï¼Œè¯¦ç»†è§£æã€‚
* ç¬¬ 49 è‡³ 51 è¡Œï¼šæœåŠ¡å¼•ç”¨é…ç½®å¯¹è±¡

map
ï¼Œå¸¦ä¸Šç›‘æ§ä¸­å¿ƒçš„ URL ã€‚å…·ä½“ç”¨é€”ï¼Œæˆ‘ä»¬åœ¨åé¢åˆ†äº«ç›‘æ§ä¸­å¿ƒä¼šçœ‹åˆ°ã€‚
* ç¬¬ 53 è¡Œï¼šè°ƒç”¨ [
URL/#addParameterAndEncoded(key, value)
](https://github.com/YunaiV/dubbo/blob/c635dd1990a1803643194048f408db310f06175b/dubbo-common/src/main/java/com/alibaba/dubbo/common/URL.java#L891-L896) æ–¹æ³•ï¼Œå°†æœåŠ¡å¼•ç”¨é…ç½®å¯¹è±¡å‚æ•°é›†åˆ

map
ï¼Œä½œä¸º

"refer"
å‚æ•°æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒçš„ URL ä¸­ï¼Œ**å¹¶ä¸”éœ€è¦ç¼–ç **ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œæ³¨å†Œä¸­å¿ƒçš„ URL ä¸­ï¼Œ**åŒ…å«äº†æœåŠ¡å¼•ç”¨çš„é…ç½®**ã€‚
* ç¬¬ 61 è‡³ 64 è¡Œï¼šå•

urls
æ—¶ï¼Œ**ç›´æ¥è°ƒç”¨**

Protocol/#refer(type, url)
æ–¹æ³•ï¼Œå¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡ã€‚

* æ­¤å¤„ Dubbo SPI **è‡ªé€‚åº”**çš„ç‰¹æ€§çš„**å¥½å¤„**å°±å‡ºæ¥äº†ï¼Œå¯ä»¥**è‡ªåŠ¨**æ ¹æ® URL å‚æ•°ï¼Œè·å¾—å¯¹åº”çš„æ‹“å±•å®ç°ã€‚ä¾‹å¦‚ï¼Œ

invoker
ä¼ å…¥åï¼Œæ ¹æ®

invoker.url
è‡ªåŠ¨è·å¾—å¯¹åº” Protocol æ‹“å±•å®ç°ä¸º DubboProtocol ã€‚
* å®é™…ä¸Šï¼ŒProtocol æœ‰ä¸¤ä¸ª Wrapper æ‹“å±•å®ç°ç±»ï¼š ProtocolFilterWrapperã€ProtocolListenerWrapper ã€‚æ‰€ä»¥ï¼Œ

/#export(...)
æ–¹æ³•çš„è°ƒç”¨é¡ºåºæ˜¯ï¼š

* **Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => RegistryProtocol**
* =>
* **Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => DubboProtocol**
* ä¹Ÿå°±æ˜¯è¯´ï¼Œ**è¿™ä¸€æ¡å¤§çš„è°ƒç”¨é“¾ï¼ŒåŒ…å«ä¸¤æ¡å°çš„è°ƒç”¨é“¾**ã€‚åŸå› æ˜¯ï¼š

* é¦–å…ˆï¼Œä¼ å…¥çš„æ˜¯æ³¨å†Œä¸­å¿ƒçš„ URL ï¼Œé€šè¿‡ Protocol$Adaptive è·å–åˆ°çš„æ˜¯ RegistryProtocol å¯¹è±¡ã€‚
* å…¶æ¬¡ï¼ŒRegistryProtocol ä¼šåœ¨å…¶

/#refer(...)
æ–¹æ³•ä¸­ï¼Œä½¿ç”¨æœåŠ¡æä¾›è€…çš„ URL ( å³æ³¨å†Œä¸­å¿ƒçš„ URL çš„

refer
å‚æ•°å€¼)ï¼Œå†æ¬¡è°ƒç”¨ Protocol$Adaptive è·å–åˆ°çš„æ˜¯ DubboProtocol å¯¹è±¡ï¼Œè¿›è¡ŒæœåŠ¡æš´éœ²ã€‚
* **ä¸ºä»€ä¹ˆæ˜¯è¿™æ ·çš„é¡ºåº**ï¼Ÿé€šè¿‡è¿™æ ·çš„é¡ºåºï¼Œå¯ä»¥å®ç°ç±»ä¼¼ **AOP** çš„æ•ˆæœï¼Œåœ¨è·å–æœåŠ¡æä¾›è€…åˆ—è¡¨åï¼Œå†åˆ›å»ºè¿æ¥æœåŠ¡æä¾›è€…çš„å®¢æˆ·ç«¯ã€‚ä¼ªä»£ç å¦‚ä¸‹ï¼š
```
RegistryProtocol/#refer(...) {
// 1. è·å–æœåŠ¡æä¾›è€…åˆ—è¡¨ ã€å¹¶ä¸”è®¢é˜…ã€‘
// 2. åˆ›å»ºè°ƒç”¨è¿æ¥æœåŠ¡æä¾›è€…çš„å®¢æˆ·ç«¯
DubboProtocol/#refer(...);
// psï¼šå®é™…è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œè¿˜æœ‰åˆ«çš„ä»£ç ï¼Œè¯¦ç»†è§ä¸‹æ–‡ã€‚
}
```

* x
* ç¬¬ 65 è‡³ 89 è¡Œï¼šå¤š

urls
æ—¶ï¼Œ**å¾ªç¯è°ƒç”¨**

Protocol/#refer(type, url)
æ–¹æ³•ï¼Œå¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡ã€‚æ­¤æ—¶ï¼Œä¼šæœ‰å¤šä¸ª Invoker å¯¹è±¡ï¼Œéœ€è¦è¿›è¡Œåˆå¹¶ã€‚

* ä»€ä¹ˆæ—¶å€™ä¼šå‡ºç°å¤šä¸ª

urls
å‘¢ï¼Ÿä¾‹å¦‚ï¼š[ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” å¤šæ³¨å†Œä¸­å¿ƒæ³¨å†Œã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/multi-registry.html) ã€‚
* ç¬¬ 66 è‡³ 76 è¡Œï¼šå¾ªç¯

urls
ï¼Œå¼•ç”¨æœåŠ¡ã€‚

* ç¬¬ 71 è¡Œï¼šè°ƒç”¨

Protocol/#refer(type, url)
æ–¹æ³•ï¼Œå¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡ã€‚ç„¶åï¼Œæ·»åŠ åˆ°

invokers
ä¸­ã€‚
* ç¬¬ 72 ä¼š 75 è¡Œï¼šä½¿ç”¨æœ€åä¸€ä¸ªæ³¨å†Œä¸­å¿ƒçš„ URL ï¼Œèµ‹å€¼åˆ°

registryURL
ã€‚
* ç¬¬ 77 è‡³ 88 è¡Œï¼šè¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸‰ï¼‰ä¹‹ Directory å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/?self) ã€‚
* ç¬¬ 92 è¡Œï¼šçœç•¥**å¯åŠ¨æ—¶æ£€æŸ¥**çš„ä»£ç ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°å¼•ç”¨ï¼ˆInjvmï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) å·²ç»æœ‰åˆ†äº«ã€‚
* ç¬¬ 96 è¡Œï¼šçœç•¥**åˆ›å»º Service ä»£ç†å¯¹è±¡**çš„ä»£ç ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°å¼•ç”¨ï¼ˆInjvmï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) å·²ç»æœ‰åˆ†äº«ã€‚

# 3. Protocol

**æœåŠ¡å¼•ç”¨ä¸æš´éœ²çš„ Protocol å¾ˆå¤šç±»ä¼¼ç‚¹**ï¼Œæœ¬æ–‡å°±ä¸é‡å¤å™è¿°äº†ã€‚

å»ºè®®ä¸ç†Ÿæ‚‰çš„èƒ–å‹ï¼Œè¯·ç‚¹å‡» [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡æš´éœ²ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°æš´éœ²ï¼ˆInjvmï¼‰ã€‹ã€Œ3. Protocolã€](http://svip.iocoder.cn/Dubbo/service-export-local/?self) æŸ¥çœ‹ã€‚

æœ¬æ–‡æ¶‰åŠçš„ Protocol ç±»å›¾å¦‚ä¸‹ï¼š

![Protocol ç±»å›¾](http://static2.iocoder.cn/images/Dubbo/2018_05_04/03.png)

## 3.1 ProtocolFilterWrapper

æ¥ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°å¼•ç”¨ï¼ˆInjvmï¼‰ã€‹ã€Œ 3.1 ProtocolFilterWrapperã€](http://svip.iocoder.cn/Dubbo/service-reference-local/?self)å°èŠ‚ã€‚

æœ¬æ–‡æ¶‰åŠçš„

/#refer(type, url)
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
1: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException{
2: // æ³¨å†Œä¸­å¿ƒ
3: if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
4: return protocol.refer(type, url);
5: }
6: // å¼•ç”¨æœåŠ¡ï¼Œè¿”å› Invoker å¯¹è±¡
7: // ç»™æ”¹ Invoker å¯¹è±¡ï¼ŒåŒ…è£…æˆå¸¦æœ‰ Filter è¿‡æ»¤é“¾çš„ Invoker å¯¹è±¡
8: return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);
9: }
```

* ç¬¬ 2 è‡³ 5 è¡Œï¼šå½“

invoker.url.protocl = registry
ï¼Œ**æ³¨å†Œä¸­å¿ƒçš„ URL** ï¼Œæ— éœ€åˆ›å»º Filter è¿‡æ»¤é“¾ã€‚
* ç¬¬ 8 è¡Œï¼šè°ƒç”¨

protocol/#refer(type, url)
æ–¹æ³•ï¼Œç»§ç»­å¼•ç”¨æœåŠ¡ï¼Œæœ€ç»ˆè¿”å› Invoker ã€‚
* ç¬¬ 8 è¡Œï¼šåœ¨å¼•ç”¨æœåŠ¡å®Œæˆåï¼Œè°ƒç”¨

/#buildInvokerChain(invoker, key, group)
æ–¹æ³•ï¼Œåˆ›å»ºå¸¦æœ‰ Filter è¿‡æ»¤é“¾çš„ Invoker å¯¹è±¡ã€‚

## 3.2 RegistryProtocol

### 3.2.1 refer

æœ¬æ–‡æ¶‰åŠçš„

/#refer(type, url)
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* Cluster è‡ªé€‚åº”æ‹“å±•å®ç°ç±»å¯¹è±¡
/*/
private Cluster cluster;
1: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException{
2: // è·å¾—çœŸå®çš„æ³¨å†Œä¸­å¿ƒçš„ URL
3: url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);
4: // è·å¾—æ³¨å†Œä¸­å¿ƒ
5: Registry registry = registryFactory.getRegistry(url);
6: // TODO èŠ‹è‰¿
7: if (RegistryService.class.equals(type)) {
8: return proxyFactory.getInvoker((T) registry, type, url);
9: }
10:
11: // è·å¾—æœåŠ¡å¼•ç”¨é…ç½®å‚æ•°é›†åˆ
12: // group="a,b" or group="/*"
13: Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));
14: String group = qs.get(Constants.GROUP_KEY);
15: // åˆ†ç»„èšåˆï¼Œå‚è§æ–‡æ¡£ http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html
16: if (group != null && group.length() > 0) {
17: if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1
18: || "/*".equals(group)) {
19: // æ‰§è¡ŒæœåŠ¡å¼•ç”¨
20: return doRefer(getMergeableCluster(), registry, type, url);
21: }
22: }
23: // æ‰§è¡ŒæœåŠ¡å¼•ç”¨
24: return doRefer(cluster, registry, type, url);
25: }
```

* ç¬¬ 3 è¡Œï¼šè·å¾—**çœŸå®**çš„æ³¨å†Œä¸­å¿ƒçš„ URL ã€‚è¯¥è¿‡ç¨‹æ˜¯æˆ‘ä»¬åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡æš´éœ²ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°æš´éœ²ï¼ˆInjvmï¼‰ã€‹ã€Œ2.1 loadRegistriesã€](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/) çš„é‚£å¼ å›¾çš„åå‘æµç¨‹ï¼Œå³**çº¢çº¿éƒ¨åˆ†** ï¼š![getRegistryUrl](http://static2.iocoder.cn/images/Dubbo/2018_03_10/01.png)
* ç¬¬ 5 è¡Œï¼šè·å¾—æ³¨å†Œä¸­å¿ƒ Registry å¯¹è±¡ã€‚
* ç¬¬ 7è‡³ 9 è¡Œï¼šã€TODO 8018ã€‘RegistryService.class
* ç¬¬ 13 è¡Œï¼šè·å¾—æœåŠ¡å¼•ç”¨é…ç½®å‚æ•°é›†åˆ

qs
ã€‚
* ç¬¬ 16 è‡³ 22 è¡Œï¼šåˆ†ç»„èšåˆï¼Œå‚è§ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” åˆ†ç»„èšåˆã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) æ–‡æ¡£ã€‚
* ç¬¬ 24 è¡Œï¼šè°ƒç”¨

/#doRefer(cluster, registry, type, url)
æ–¹æ³•ï¼Œæ‰§è¡ŒæœåŠ¡å¼•ç”¨ã€‚ä¸åŒäºã€ç¬¬ 20 è¡Œã€‘çš„ä»£ç ï¼Œåè€…è°ƒç”¨

/#getMergeableCluster()
æ–¹æ³•ï¼Œè·å¾—**å¯åˆå¹¶çš„** Cluster å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
private Cluster getMergeableCluster(){
return ExtensionLoader.getExtensionLoader(Cluster.class).getExtension("mergeable");
}
```

### 3.2.2 doRefer

/#doRefer(cluster, registry, type, url)
æ–¹æ³•ï¼Œæ‰§è¡ŒæœåŠ¡å¼•ç”¨çš„é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: //*/*
2: /* æ‰§è¡ŒæœåŠ¡å¼•ç”¨ï¼Œè¿”å› Invoker å¯¹è±¡
3: /*
4: /* @param cluster Cluster å¯¹è±¡
5: /* @param registry æ³¨å†Œä¸­å¿ƒå¯¹è±¡
6: /* @param type æœåŠ¡æ¥å£ç±»å‹
7: /* @param url æ³¨å†Œä¸­å¿ƒ URL
8: /* @param <T> æ³›å‹
9: /* @return Invoker å¯¹è±¡
10: /*/
11: private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url){
12: // åˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œå¹¶è®¾ç½®æ³¨å†Œä¸­å¿ƒ
13: RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
14: directory.setRegistry(registry);
15: directory.setProtocol(protocol);
16: // åˆ›å»ºè®¢é˜… URL
17: // all attributes of REFER_KEY
18: Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters()); // æœåŠ¡å¼•ç”¨é…ç½®é›†åˆ
19: URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);
20: // å‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œè‡ªå·±ï¼ˆæœåŠ¡æ¶ˆè´¹è€…ï¼‰
21: if (!Constants.ANY_VALUE.equals(url.getServiceInterface())
22: && url.getParameter(Constants.REGISTER_KEY, true)) {
23: registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,
24: Constants.CHECK_KEY, String.valueOf(false)));
25: }
26: // å‘æ³¨å†Œä¸­å¿ƒè®¢é˜…æœåŠ¡æä¾›è€…
27: directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,
28: Constants.PROVIDERS_CATEGORY
29: + "," + Constants.CONFIGURATORS_CATEGORY
30: + "," + Constants.ROUTERS_CATEGORY));
31:
32: // åˆ›å»º Invoker å¯¹è±¡
33: Invoker invoker = cluster.join(directory);
34: // å‘æœ¬åœ°æ³¨å†Œè¡¨ï¼Œæ³¨å†Œæ¶ˆè´¹è€…
35: ProviderConsumerRegTable.registerConsuemr(invoker, url, subscribeUrl, directory);
36: return invoker;
37: }
```

* ç¬¬ 12 è‡³ 15 è¡Œï¼Œåˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œå¹¶è®¾ç½®æ³¨å†Œä¸­å¿ƒåˆ°å®ƒçš„å±æ€§ã€‚
* ç¬¬ 18 è¡Œï¼šè·å¾—æœåŠ¡å¼•ç”¨é…ç½®é›†åˆ

parameters
ã€‚**æ³¨æ„**ï¼Œ

url
ä¼ å…¥ RegistryDirectory åï¼Œç»è¿‡å¤„ç†å¹¶é‡æ–°åˆ›å»ºï¼Œæ‰€ä»¥

url != directory.url
ï¼Œæ‰€ä»¥è·å¾—çš„æ˜¯æœåŠ¡å¼•ç”¨é…ç½®é›†åˆã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![parameters](http://static2.iocoder.cn/images/Dubbo/2018_05_04/01.png)
* ç¬¬ 19 è¡Œï¼šåˆ›å»ºè®¢é˜… URL å¯¹è±¡ã€‚
* ç¬¬ 20 è‡³ 25 è¡Œï¼šè°ƒç”¨

RegistryService/#register(url)
æ–¹æ³•ï¼Œå‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œ**è‡ªå·±**ï¼ˆæœåŠ¡æ¶ˆè´¹è€…ï¼‰ã€‚

* åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æ³¨å†Œä¸­å¿ƒï¼ˆä¸€ï¼‰ä¹‹æŠ½è±¡ APIã€‹ã€Œ3. RegistryServiceã€](http://svip.iocoder.cn/Dubbo/registry-api/?self)ï¼Œæœ‰è¯¦ç»†è§£æã€‚
* ç¬¬ 26 ç»ˆ 30 è¡Œï¼šè°ƒç”¨

Directory/#subscribe(url)
æ–¹æ³•ï¼Œå‘æ³¨å†Œä¸­å¿ƒè®¢é˜…æœåŠ¡æä¾›è€… + è·¯ç”±è§„åˆ™ + é…ç½®è§„åˆ™ã€‚

* åœ¨è¯¥æ–¹æ³•ä¸­ï¼Œä¼šå¾ªç¯è·å¾—åˆ°çš„æœåŠ¡ä½“ç”¨è¿™åˆ—è¡¨ï¼Œè°ƒç”¨

Protocol/#refer(type, url)
æ–¹æ³•ï¼Œåˆ›å»ºæ¯ä¸ªè°ƒç”¨æœåŠ¡çš„ Invoker å¯¹è±¡ã€‚
* ç¬¬ 33 è¡Œï¼šåˆ›å»º Invoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸€ï¼‰ä¹‹æŠ½è±¡ APIã€‹](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/?self) ã€‚
* ç¬¬ 35 è¡Œï¼šè°ƒç”¨

ProviderConsumerRegTable/#registerConsuemr(invoker, url, subscribeUrl, directory)
æ–¹æ³•ï¼Œå‘æœ¬åœ°æ³¨å†Œè¡¨ï¼Œæ³¨å†Œæ¶ˆè´¹è€…ã€‚

* åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æ³¨å†Œä¸­å¿ƒï¼ˆä¸€ï¼‰ä¹‹æŠ½è±¡ APIã€‹ã€Œ5. ProviderConsumerRegTableã€](http://svip.iocoder.cn/Dubbo/registry-api/?self)ï¼Œæœ‰è¯¦ç»†è§£æã€‚
* ç¬¬ 36 è¡Œï¼šè¿”å› Invoker å¯¹è±¡ã€‚

## 3.3 DubboProtocol

### 3.3.1 refer

æœ¬æ–‡æ¶‰åŠçš„

/#refer(type, url)
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
// AbstractProtocol.java çˆ¶ç±»
//*/*
/* Invoker é›†åˆ
/*/
//TODO SOFEREFENCE
protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>();
// DubboProtocol.java
1: public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException{
2: // åˆå§‹åŒ–åºåˆ—åŒ–ä¼˜åŒ–å™¨
3: optimizeSerialization(url);
4: // è·å¾—è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„
5: // åˆ›å»º DubboInvoker å¯¹è±¡
6: // create rpc invoker.
7: DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
8: // æ·»åŠ åˆ° `invokers`
9: invokers.add(invoker);
10: return invoker;
11: }
```

* invokers
å±æ€§ï¼ŒInvoker é›†åˆã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨

/#optimizeSerialization(url)
æ–¹æ³•ï¼Œåˆå§‹åŒ–åºåˆ—åŒ–ä¼˜åŒ–å™¨ã€‚åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” åºåˆ—åŒ–ï¼ˆä¸€ï¼‰ä¹‹æ€»ä½“å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/serialize-1-all?self) ä¸­ï¼Œè¯¦ç»†è§£æã€‚
* ç¬¬ 7 è¡Œï¼šè°ƒç”¨

/#getClients(url)
æ–¹æ³•ï¼Œåˆ›å»ºè¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„ã€‚
* ç¬¬ 7 è¡Œï¼šåˆ›å»º DubboInvoker å¯¹è±¡ã€‚
* ç¬¬ 9 è¡Œï¼šæ·»åŠ åˆ°

invokers
ã€‚
* ç¬¬ 10 è¡Œï¼šè¿”å› Invoker å¯¹è±¡ã€‚

### 3.3.2 getClients

å‹æƒ…æç¤ºï¼Œæ¶‰åŠ Client çš„å†…å®¹ï¼Œèƒ–å‹å…ˆçœ‹è¿‡ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-interface/?self) æ‰€æœ‰çš„æ–‡ç« ã€‚

/#getClients(url)
æ–¹æ³•ï¼Œè·å¾—è¿æ¥æœåŠ¡æä¾›è€…çš„è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
1: //*/*
2: /* è·å¾—è¿æ¥æœåŠ¡æä¾›è€…çš„è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„
3: /*
4: /* @param url æœåŠ¡æä¾›è€… URL
5: /* @return è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯
6: /*/
7: private ExchangeClient[] getClients(URL url) {
8: // æ˜¯å¦å…±äº«è¿æ¥
9: // whether to share connection
10: boolean service_share_connect = false;
11: int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0);
12: // if not configured, connection is shared, otherwise, one connection for one service
13: if (connections == 0) { // æœªé…ç½®æ—¶ï¼Œé»˜è®¤å…±äº«
14: service_share_connect = true;
15: connections = 1;
16: }
17:
18: // åˆ›å»ºè¿æ¥æœåŠ¡æä¾›è€…çš„ ExchangeClient å¯¹è±¡æ•°ç»„
19: ExchangeClient[] clients = new ExchangeClient[connections];
20: for (int i = 0; i < clients.length; i++) {
21: if (service_share_connect) { // å…±äº«
22: clients[i] = getSharedClient(url);
23: } else { // ä¸å…±äº«
24: clients[i] = initClient(url);
25: }
26: }
27: return clients;
28: }
```

* ç¬¬ 8 è‡³ 16 è¡Œï¼šæ˜¯å¦å…±äº«è¿æ¥ã€‚
* ç¬¬ 18 è‡³ 26 è¡Œï¼šåˆ›å»ºè¿æ¥æœåŠ¡æä¾›è€…çš„ ExchangeClient å¯¹è±¡æ•°ç»„ã€‚

* **æ³¨æ„**ï¼Œè‹¥å¼€å¯å…±äº«è¿æ¥ï¼ŒåŸºäº URL ä¸ºç»´åº¦å…±äº«ã€‚
* ç¬¬ 21 è‡³ 22 è¡Œï¼šå…±äº«è¿æ¥ï¼Œè°ƒç”¨

/#getSharedClient(url)
æ–¹æ³•ï¼Œè·å¾— ExchangeClient å¯¹è±¡ã€‚
* ç¬¬ 23 è‡³ 25 è¡Œï¼šä¸å…±äº«è¿æ¥ï¼Œè°ƒç”¨

/#initClient(url)
æ–¹æ³•ï¼Œç›´æ¥åˆ›å»º ExchangeClient å¯¹è±¡ã€‚
* connections
é…ç½®é¡¹ã€‚

* é»˜è®¤ 0 ã€‚å³ï¼Œå¯¹åŒä¸€ä¸ªè¿œç¨‹æœåŠ¡å™¨ï¼Œ**å…±ç”¨**åŒä¸€ä¸ªè¿æ¥ã€‚
* å¤§äº 0 ã€‚å³ï¼Œæ¯ä¸ªæœåŠ¡å¼•ç”¨ï¼Œ**ç‹¬ç«‹**æ¯ä¸€ä¸ªè¿æ¥ã€‚
* [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” è¿æ¥æ§åˆ¶ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/config-connections.html)
* [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” dubbo:referenceã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html)

### 3.3.3 getSharedClient

/#getClients(url)
æ–¹æ³•ï¼Œè·å¾—è¿æ¥æœåŠ¡æä¾›è€…çš„è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* é€šä¿¡å®¢æˆ·ç«¯é›†åˆ
/*
/* key: æœåŠ¡å™¨åœ°å€ã€‚æ ¼å¼ä¸ºï¼šhost:port
/*/
private final Map<String, ReferenceCountExchangeClient> referenceClientMap = new ConcurrentHashMap<String, ReferenceCountExchangeClient>(); // <host:port,Exchanger>
//*/*
/* TODO 8030 ï¼Œè¿™ä¸ªæ˜¯ä»€ä¹ˆç”¨é€”å•Šã€‚
/*
/* key: æœåŠ¡å™¨åœ°å€ã€‚æ ¼å¼ä¸ºï¼šhost:port ã€‚å’Œ {@link /#referenceClientMap} Key ï¼Œæ˜¯ä¸€è‡´çš„ã€‚
/*/
private final ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap = new ConcurrentHashMap<String, LazyConnectExchangeClient>();
1: private ExchangeClient getSharedClient(URL url){
2: // ä»é›†åˆä¸­ï¼ŒæŸ¥æ‰¾ ReferenceCountExchangeClient å¯¹è±¡
3: String key = url.getAddress();
4: ReferenceCountExchangeClient client = referenceClientMap.get(key);
5: if (client != null) {
6: // è‹¥æœªå…³é—­ï¼Œå¢åŠ æŒ‡å‘è¯¥ Client çš„æ•°é‡ï¼Œå¹¶è¿”å›å®ƒ
7: if (!client.isClosed()) {
8: client.incrementAndGetCount();
9: return client;
10: // è‹¥å·²å…³é—­ï¼Œç§»é™¤
11: } else {
12: referenceClientMap.remove(key);
13: }
14: }
15: // åŒæ­¥ï¼Œåˆ›å»º ExchangeClient å¯¹è±¡ã€‚
16: synchronized (key.intern()) {
17: // åˆ›å»º ExchangeClient å¯¹è±¡
18: ExchangeClient exchangeClient = initClient(url);
19: // å°† `exchangeClient` åŒ…è£…ï¼Œåˆ›å»º ReferenceCountExchangeClient å¯¹è±¡
20: client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);
21: // æ·»åŠ åˆ°é›†åˆ
22: referenceClientMap.put(key, client);
23: // æ·»åŠ åˆ° `ghostClientMap`
24: ghostClientMap.remove(key);
25: return client;
26: }
27: }
```

* referenceClientMap
å±æ€§ï¼Œé€šä¿¡å®¢æˆ·ç«¯é›†åˆã€‚åœ¨æˆ‘ä»¬åˆ›å»ºå¥½ Client å¯¹è±¡ï¼Œâ€œ**è¿æ¥**â€æœåŠ¡å™¨åï¼Œä¼šæ·»åŠ åˆ°è¿™ä¸ªé›†åˆä¸­ï¼Œç”¨äºåç»­çš„ Client çš„**å…±äº«**ã€‚

* ReferenceCountExchangeClient ï¼Œé¡¾åæ€ä¹‰ï¼Œå¸¦æœ‰æŒ‡å‘æ•°é‡è®¡æ•°çš„ Client å°è£…ã€‚
* â€œ**è¿æ¥**â€ ï¼Œæ‰“å¼•å·çš„åŸå› ï¼Œå› ä¸ºæœ‰ LazyConnectExchangeClient ï¼Œè¿˜æ˜¯é¡¾åæ€ä¹‰ï¼Œå»¶è¿Ÿè¿æ¥çš„ Client å°è£…ã€‚
* ğŸ™‚ ReferenceCountExchangeClient å’Œ LazyConnectExchangeClient çš„å…·ä½“å®ç°ï¼Œåœ¨ [ã€Œ5. Clientã€](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/) è¯¦ç»†è§£æã€‚
* ghostClientMap
å±æ€§ï¼Œå¹½çµå®¢æˆ·ç«¯é›†åˆã€‚TODO 8030 ï¼Œè¿™ä¸ªæ˜¯ä»€ä¹ˆç”¨é€”å•Šã€‚

* ã€æ·»åŠ ã€‘æ¯æ¬¡ ReferenceCountExchangeClient **å½»åº•**å…³é—­( æŒ‡å‘å½’é›¶ ) ï¼Œå…¶å†…éƒ¨çš„

client
ä¼šæ›¿æ¢æˆ**é‡æ–°åˆ›å»º**çš„ LazyConnectExchangeClient å¯¹è±¡ï¼Œæ­¤æ—¶å«è¿™ä¸ªå¯¹è±¡ä¸º**å¹½çµå®¢æˆ·ç«¯**ï¼Œæ·»åŠ åˆ°

ghostClientMap
ä¸­ã€‚
* ã€ç§»é™¤ã€‘å½“å¹½çµå®¢æˆ·ç«¯ï¼Œå¯¹åº”çš„ URL çš„æœåŠ¡å™¨è¢«é‡æ–°è¿æ¥ä¸Šåï¼Œä¼šè¢«ç§»é™¤ã€‚
* **æ³¨æ„**ï¼Œåœ¨å¹½çµå®¢æˆ·ç«¯**è¢«ç§»é™¤ä¹‹å‰**ï¼Œ

referenceClientMap
ä¸­ï¼Œä¾ç„¶ä¿ç•™ç€å¯¹åº”çš„ URL çš„ ReferenceCountExchangeClient å¯¹è±¡ã€‚æ‰€ä»¥ï¼Œ

ghostClientMap
ç›¸å½“äºæ ‡è®°

referenceClientMap
ä¸­ï¼Œå“ªäº› LazyConnectExchangeClient å¯¹è±¡ï¼Œæ˜¯**å¹½çµ**çŠ¶æ€ã€‚ğŸ‘»
* ç¬¬ 2 è‡³ 4 è¡Œï¼šä»é›†åˆ

referenceClientMap
ä¸­ï¼ŒæŸ¥æ‰¾ ReferenceCountExchangeClient å¯¹è±¡ã€‚
* ç¬¬ 5 è‡³ 14 è¡Œï¼šæŸ¥æ‰¾åˆ°å®¢æˆ·ç«¯ã€‚

* ç¬¬ 6 è‡³ 9 è¡Œï¼šè‹¥**æœªå…³é—­**ï¼Œè°ƒç”¨

ReferenceCountExchangeClient/#incrementAndGetCount()
æ–¹æ³•ï¼Œå¢åŠ æŒ‡å‘è¯¥å®¢æˆ·ç«¯çš„æ•°é‡ï¼Œå¹¶è¿”å›ã€‚
* ç¬¬ 11 è‡³ 13 è¡Œï¼šè‹¥**å·²å…³é—­**ï¼Œé€‚ç”¨äº**å¹½çµ**çŠ¶æ€çš„ ReferenceCountExchangeClient å¯¹è±¡ï¼Œä»

referenceClientMap
ä¸­ç§»é™¤ï¼Œå‡†å¤‡ä¸‹é¢çš„ä»£ç ï¼Œåˆ›å»º**æ–°çš„** ReferenceCountExchangeClient å¯¹è±¡ã€‚
* ç¬¬ 15 è‡³ 26 è¡Œï¼š**åŒæ­¥**(

synchronized
) ï¼Œåˆ›å»ºæ–°çš„ ReferenceCountExchangeClient å¯¹è±¡ã€‚

* ç¬¬ 18 è¡Œï¼šè°ƒç”¨

/#initClient(url)
æ–¹æ³•ï¼Œåˆ›å»º ExchangeClient å¯¹è±¡ã€‚
* ç¬¬ 20 è¡Œï¼šå°† ExchangeClient å¯¹è±¡ï¼Œå°è£…åˆ›å»ºæˆ ReferenceCountExchangeClient ç‹¬äº«ã€‚
* ç¬¬ 22 è¡Œï¼šæ·»åŠ åˆ°é›†åˆ

referenceClientMap
ã€‚
* ç¬¬ 24 è¡Œï¼šç§»é™¤å‡ºé›†åˆ

ghostClientMap
ï¼Œå› ä¸ºä¸å†æ˜¯**å¹½çµ**çŠ¶æ€å•¦ã€‚

### 3.3.4 initClient

/#initClient(url)
æ–¹æ³•ï¼Œåˆ›å»º ExchangeClient å¯¹è±¡ï¼Œâ€è¿æ¥â€æœåŠ¡å™¨ã€‚
```
1: private ExchangeClient initClient(URL url){
2: // æ ¡éªŒ Client çš„ Dubbo SPI æ‹“å±•æ˜¯å¦å­˜åœ¨
3: // client type setting.
4: String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));
5: // BIO is not allowed since it has severe performance issue.
6: if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
7: throw new RpcException("Unsupported client type: " + str + "," +
8: " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));
9: }
10:
11: // è®¾ç½®ç¼–è§£ç å™¨ä¸º Dubbo ï¼Œå³ DubboCountCodec
12: url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
13:
14: // é»˜è®¤å¼€å¯ heartbeat
15: // enable heartbeat by default
16: url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));
17:
18: // è¿æ¥æœåŠ¡å™¨ï¼Œåˆ›å»ºå®¢æˆ·ç«¯
19: ExchangeClient client;
20: try {
21: // æ‡’è¿æ¥ï¼Œåˆ›å»º LazyConnectExchangeClient å¯¹è±¡
22: // connection should be lazy
23: if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) {
24: client = new LazyConnectExchangeClient(url, requestHandler);
25: // ç›´æ¥è¿æ¥ï¼Œåˆ›å»º HeaderExchangeClient å¯¹è±¡
26: } else {
27: client = Exchangers.connect(url, requestHandler);
28: }
29: } catch (RemotingException e) {
30: throw new RpcException("Fail to create remoting client for service(" + url + "): " + e.getMessage(), e);
31: }
32: return client;
33: }
```

* ç¬¬ 2 è‡³ 9 è¡Œï¼šæ ¡éªŒé…ç½®çš„ Client çš„ Dubbo SPI æ‹“å±•æ˜¯å¦å­˜åœ¨ã€‚è‹¥ä¸å­˜åœ¨ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚
* ç¬¬ 12 è¡Œï¼šè®¾ç½®ç¼–è§£ç å™¨ä¸º

"Dubbo"
åè®®ï¼Œå³ DubboCountCodec ã€‚
* ç¬¬ 16 è¡Œï¼šé»˜è®¤å¼€å¯**å¿ƒè·³**åŠŸèƒ½ã€‚
* ç¬¬ 19 è‡³ 31 è¡Œï¼šè¿æ¥æœåŠ¡å™¨ï¼Œåˆ›å»ºå®¢æˆ·ç«¯ã€‚

* ç¬¬ 21 è‡³ 24 è¡Œï¼š**æ‡’åŠ è½½**ï¼Œåˆ›å»º LazyConnectExchangeClient å¯¹è±¡ã€‚
* ç¬¬ 25 è‡³ 28 è¡Œï¼š**ç›´æ¥è¿æ¥**ï¼Œåˆ›å»º HeaderExchangeClient å¯¹è±¡ã€‚

# 4. Invoker

æœ¬æ–‡æ¶‰åŠçš„ Invoker ç±»å›¾å¦‚ä¸‹ï¼š

![Invoker ç±»å›¾](http://static2.iocoder.cn/images/Dubbo/2018_05_04/04.png)

## 4.1 DubboInvoker

[
com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker
](https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboInvoker.java) ï¼Œå®ç° AbstractExporter æŠ½è±¡ç±»ï¼ŒDubbo Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: //*/*
2: /* è¿œç¨‹é€šä¿¡å®¢æˆ·ç«¯æ•°ç»„
3: /*/
4: private final ExchangeClient[] clients;
5: //*/*
6: /* ä½¿ç”¨çš„ {@link /#clients} çš„ä½ç½®
7: /*/
8: private final AtomicPositiveInteger index = new AtomicPositiveInteger();
9: //*/*
10: /* ç‰ˆæœ¬
11: /*/
12: private final String version;
13: //*/*
14: /* é”€æ¯é”
15: /*
16: /* åœ¨ {@link /#destroy()} ä¸­ä½¿ç”¨
17: /*/
18: private final ReentrantLock destroyLock = new ReentrantLock();
19: //*/*
20: /* Invoker é›†åˆï¼Œä» {@link DubboProtocol/#invokers} è·å–
21: /*/
22: private final Set<Invoker<?>> invokers;
23:
24: public DubboInvoker(Class<T> serviceType, URL url, ExchangeClient[] clients){
25: this(serviceType, url, clients, null);
26: }
27:
28: public DubboInvoker(Class<T> serviceType, URL url, ExchangeClient[] clients, Set<Invoker<?>> invokers){
29: super(serviceType, url, new String[]{Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY});
30: this.clients = clients;
31: // get version.
32: this.version = url.getParameter(Constants.VERSION_KEY, "0.0.0");
33: this.invokers = invokers;
34: }
```

* èƒ–å‹ï¼Œè¯·çœ‹å±æ€§ä¸Šçš„ä»£ç æ³¨é‡Šã€‚
* ç¬¬ 29 è¡Œï¼šè°ƒç”¨çˆ¶ç±»æ„é€ æ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¸­ï¼Œä¼šå°†

interface

group

version

token

timeout
æ·»åŠ åˆ°å…¬ç”¨çš„éšå¼ä¼ å‚

AbstractInvoker.attachment
å±æ€§ã€‚

* ğŸ™‚ ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è¯·è‡ªå·±é˜…è¯»ã€‚

# 5. Client

å‹æƒ…æç¤ºï¼Œæ¶‰åŠ Client çš„å†…å®¹ï¼Œèƒ–å‹å…ˆçœ‹è¿‡ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-interface/?self) æ‰€æœ‰çš„æ–‡ç« ã€‚

## 5.1 ReferenceCountExchangeClient

[
com.alibaba.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/ReferenceCountExchangeClient.java) ï¼Œå®ç° ExchangeClient æ¥å£ï¼Œ**æ”¯æŒæŒ‡å‘è®¡æ•°**çš„ä¿¡æ¯äº¤æ¢å®¢æˆ·ç«¯å®ç°ç±»ã€‚

**æ„é€ æ–¹æ³•**
```
1: //*/*
2: /* URL
3: /*/
4: private final URL url;
5: //*/*
6: /* æŒ‡å‘æ•°é‡
7: /*/
8: private final AtomicInteger refenceCount = new AtomicInteger(0);
9: //*/*
10: /* å¹½çµå®¢æˆ·ç«¯é›†åˆ
11: /*/
12: private final ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap;
13: //*/*
14: /* å®¢æˆ·ç«¯
15: /*/
16: private ExchangeClient client;
17:
18: public ReferenceCountExchangeClient(ExchangeClient client, ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap){
19: this.client = client;
20: // æŒ‡å‘åŠ ä¸€
21: refenceCount.incrementAndGet();
22: this.url = client.getUrl();
23: if (ghostClientMap == null) {
24: throw new IllegalStateException("ghostClientMap can not be null, url: " + url);
25: }
26: this.ghostClientMap = ghostClientMap;
27: }
```

* refenceCount
å±æ€§ï¼ŒæŒ‡å‘è®¡æ•°ã€‚

* ã€åˆå§‹ã€‘æ„é€ æ–¹æ³•ï¼Œã€ç¬¬ 21 è¡Œã€‘ï¼Œè®¡æ•°åŠ ä¸€ã€‚
* ã€å¼•ç”¨ã€‘æ¯æ¬¡å¼•ç”¨ï¼Œè®¡æ•°åŠ ä¸€ã€‚
* ghostClientMap
å±æ€§ï¼Œå¹½çµå®¢æˆ·ç«¯é›†åˆï¼Œå’Œ

Protocol.ghostClientMap
å‚æ•°ï¼Œä¸€è‡´ã€‚
* client
å±æ€§ï¼Œå®¢æˆ·ç«¯ã€‚

* ã€åˆ›å»ºã€‘æ„é€ æ–¹æ³•ï¼Œä¼ å…¥

client
å±æ€§ï¼ŒæŒ‡å‘å®ƒã€‚
* ã€å…³é—­ã€‘å…³é—­æ–¹æ³•ï¼Œåˆ›å»º LazyConnectExchangeClient å¯¹è±¡ï¼ŒæŒ‡å‘è¯¥å¹½çµå®¢æˆ·ç«¯ã€‚

**è£…é¥°å™¨æ¨¡å¼**

åŸºäº**è£…é¥°å™¨æ¨¡å¼**ï¼Œæ‰€ä»¥ï¼Œæ¯ä¸ªå®ç°æ–¹æ³•ï¼Œéƒ½æ˜¯è°ƒç”¨

client
çš„å¯¹åº”çš„æ–¹æ³•ã€‚ä¾‹å¦‚ï¼š
```
@Override
public void send(Object message) throws RemotingException{
client.send(message);
}
```

**è®¡æ•°**

```
public void incrementAndGetCount(){
refenceCount.incrementAndGet();
}
```

**å…³é—­**

```
1: @Override
2: public void close(int timeout){
3: if (refenceCount.decrementAndGet() <= 0) {
4: // å…³é—­ `client`
5: if (timeout == 0) {
6: client.close();
7: } else {
8: client.close(timeout);
9: }
10: // æ›¿æ¢ `client` ä¸º LazyConnectExchangeClient å¯¹è±¡ã€‚
11: client = replaceWithLazyClient();
12: }
13: }
```

* ç¬¬ 3 è¡Œï¼šè®¡æ•°**å‡ä¸€**ã€‚è‹¥æ— æŒ‡å‘ï¼Œè¿›è¡ŒçœŸæ­£çš„å…³é—­ã€‚
* ç¬¬ 4 è‡³ 9 è¡Œï¼šè°ƒç”¨

client
çš„å…³é—­æ–¹æ³•ï¼Œè¿›è¡Œå…³é—­ã€‚
* ç¬¬ 11 è¡Œï¼šè°ƒç”¨

/#replaceWithLazyClient()
æ–¹æ³•ï¼Œæ›¿æ¢

client
ä¸º LazyConnectExchangeClient å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private LazyConnectExchangeClient replaceWithLazyClient(){
2: // this is a defensive operation to avoid client is closed by accident, the initial state of the client is false
3: URL lazyUrl = url.addParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.FALSE)
4: .addParameter(Constants.RECONNECT_KEY, Boolean.FALSE) // ä¸é‡è¿
5: .addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString())
6: .addParameter("warning", Boolean.TRUE.toString())
7: .addParameter(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, true)
8: .addParameter("_client_memo", "referencecounthandler.replacewithlazyclient"); // å¤‡æ³¨
9:
10: // åˆ›å»º LazyConnectExchangeClient å¯¹è±¡ï¼Œè‹¥ä¸å­˜åœ¨ã€‚
11: String key = url.getAddress();
12: // in worst case there's only one ghost connection.
13: LazyConnectExchangeClient gclient = ghostClientMap.get(key);
14: if (gclient == null || gclient.isClosed()) {
15: gclient = new LazyConnectExchangeClient(lazyUrl, client.getExchangeHandler());
16: ghostClientMap.put(key, gclient);
17: }
18: return gclient;
19: }
```

* ç¬¬ 3 è‡³ 8 è¡Œï¼šåŸºäº

url
ï¼Œåˆ›å»º LazyConnectExchangeClient çš„ URL é“¾æ¥ã€‚è®¾ç½®çš„ä¸€äº›å‚æ•°ï¼Œç»“åˆ [ã€Œ5.2 LazyConnectExchangeClientã€](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/) ä¸€èµ·çœ‹ã€‚
* ç¬¬ 10 è‡³ 17 è¡Œï¼šåˆ›å»º LazyConnectExchangeClient å¯¹è±¡ï¼Œè‹¥ä¸å­˜åœ¨ã€‚

## 5.2 LazyConnectExchangeClient

[
com.alibaba.dubbo.rpc.protocol.dubbo.LazyConnectExchangeClient
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java) ï¼Œå®ç° ExchangeClient æ¥å£ï¼Œ**æ”¯æŒæ‡’è¿æ¥æœåŠ¡å™¨**çš„ä¿¡æ¯äº¤æ¢å®¢æˆ·ç«¯å®ç°ç±»ã€‚

**æ„é€ æ–¹æ³•**
```
1: static final String REQUEST_WITH_WARNING_KEY = "lazyclient_request_with_warning";
2:
3: //*/*
4: /* URL
5: /*/
6: private final URL url;
7: //*/*
8: /* é€šé“å¤„ç†å™¨
9: /*/
10: private final ExchangeHandler requestHandler;
11: //*/*
12: /* è¿æ¥é”
13: /*/
14: private final Lock connectLock = new ReentrantLock();
15: //*/*
16: /* lazy connect å¦‚æœæ²¡æœ‰åˆå§‹åŒ–æ—¶çš„è¿æ¥çŠ¶æ€
17: /*/
18: // lazy connect, initial state for connection
19: private final boolean initialState;
20: //*/*
21: /* é€šä¿¡å®¢æˆ·ç«¯
22: /*/
23: private volatile ExchangeClient client;
24: //*/*
25: /* è¯·æ±‚æ—¶ï¼Œæ˜¯å¦æ£€æŸ¥å‘Šè­¦
26: /*/
27: protected final boolean requestWithWarning;
28: //*/*
29: /* è­¦å‘Šè®¡æ•°å™¨ã€‚æ¯è¶…è¿‡ä¸€å®šæ¬¡æ•°ï¼Œæ‰“å°å‘Šè­¦æ—¥å¿—ã€‚å‚è§ {@link /#warning(Object)}
30: /*/
31: private AtomicLong warningcount = new AtomicLong(0);
32:
33: public LazyConnectExchangeClient(URL url, ExchangeHandler requestHandler){
34: // lazy connect, need set send.reconnect = true, to avoid channel bad status.
35: this.url = url.addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString());
36: this.requestHandler = requestHandler;
37: this.initialState = url.getParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Constants.DEFAULT_LAZY_CONNECT_INITIAL_STATE);
38: this.requestWithWarning = url.getParameter(REQUEST_WITH_WARNING_KEY, false);
39: }
```

* initialState
å±æ€§ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹åŒ–å®¢æˆ·ç«¯æ—¶çš„é“¾æ¥çŠ¶æ€ã€‚æœ‰ç‚¹ç»•ï¼Œçœ‹

/#isConnected()
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
@Override
public boolean isConnected(){
if (client == null) { // å®¢æˆ·ç«¯æœªåˆå§‹åŒ–
return initialState;
} else {
return client.isConnected();
}
}
```

* æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° ReferenceCountExchangeClient å…³é—­åˆ›å»ºçš„ LazyConnectExchangeClient å¯¹è±¡çš„

initialState = false
ï¼Œæœªè¿æ¥ã€‚
* **é»˜è®¤å€¼**ï¼Œ

DEFAULT_LAZY_CONNECT_INITIAL_STATE = true
ã€‚
* requestWithWarning
å±æ€§ï¼Œè¯·æ±‚æ—¶ï¼Œæ˜¯å¦æ£€æŸ¥å‘Šè­¦ã€‚

* æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° ReferenceCountExchangeClient å…³é—­åˆ›å»ºçš„ LazyConnectExchangeClient å¯¹è±¡çš„

initialState = false
ï¼Œæœªè¿æ¥ã€‚
* **é»˜è®¤å€¼**ï¼Œ

false
ã€‚
* warningcount
å±æ€§ï¼Œè­¦å‘Šè®¡æ•°å™¨ã€‚æ¯è¶…è¿‡ä¸€å®šæ¬¡æ•°ï¼Œæ‰“å°å‘Šè­¦æ—¥å¿—ã€‚æ¯æ¬¡å‘é€è¯·æ±‚æ—¶ï¼Œä¼šè°ƒç”¨

/#warning(request)
æ–¹æ³•ï¼Œæ ¹æ®æƒ…å†µï¼Œæ‰“å°å‘Šè­¦æ—¥å¿—ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private void warning(Object request){
if (requestWithWarning) { // å¼€å¯
if (warningcount.get() % 5000 == 0) { // 5000 æ¬¡
logger.warn(new IllegalStateException("safe guard client , should not be called ,must have a bug."));
}
warningcount.incrementAndGet(); // å¢åŠ è®¡æ•°
}
}
```

* ç†è®ºæ¥è¯´ï¼Œä¸ä¼šè¢«è°ƒç”¨ã€‚å¦‚æœè¢«è°ƒç”¨ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€ä¸ª BUG å’¯ã€‚

**è£…é¥°å™¨æ¨¡å¼**

åŸºäº**è£…é¥°å™¨æ¨¡å¼**ï¼Œæ‰€ä»¥ï¼Œæ¯ä¸ªå®ç°æ–¹æ³•ï¼Œéƒ½æ˜¯è°ƒç”¨

client
çš„å¯¹åº”çš„æ–¹æ³•ã€‚ä¾‹å¦‚ï¼š
```
@Override
@Override
public void close(int timeout){
if (client != null)
client.close(timeout);
}
```

**åˆå§‹åŒ–å®¢æˆ·ç«¯**

```
private void initClient() throws RemotingException{
// å·²åˆå§‹åŒ–ï¼Œè·³è¿‡
if (client != null) {
return;
}
if (logger.isInfoEnabled()) {
logger.info("Lazy connect to " + url);
}
// è·å¾—é”
connectLock.lock();
try {
// å·²åˆå§‹åŒ–ï¼Œè·³è¿‡
if (client != null) {
return;
}
// åˆ›å»º Client ï¼Œè¿æ¥æœåŠ¡å™¨
this.client = Exchangers.connect(url, requestHandler);
} finally {
// é‡Šæ”¾é”
connectLock.unlock();
}
}
```

* å‘é€æ¶ˆæ¯/è¯·æ±‚å‰ï¼Œéƒ½ä¼šè°ƒç”¨è¯¥æ–¹æ³•ï¼Œä¿è¯å®¢æˆ·ç«¯å·²ç»åˆå§‹åŒ–ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public void send(Object message, boolean sent) throws RemotingException{
initClient();
client.send(message, sent);
}
@Override
public ResponseFuture request(Object request, int timeout) throws RemotingException{
warning(request);
initClient();
return client.request(request, timeout);
}
```