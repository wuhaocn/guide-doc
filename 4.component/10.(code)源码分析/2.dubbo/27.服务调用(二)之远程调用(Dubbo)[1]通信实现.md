# æœåŠ¡è°ƒç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆDubboï¼‰ã€1ã€‘é€šä¿¡å®ç°

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

ä»æœ¬æ–‡å¼€å§‹ï¼Œæˆ‘ä»¬å¼€å§‹åˆ†äº«

dubbo://
åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**å››ä¸ªéƒ¨åˆ†**ï¼š

1. é€šä¿¡å®ç°
1. åŒæ­¥è°ƒç”¨
1. å¼‚æ­¥è°ƒç”¨
1. å‚æ•°å›è°ƒ

æœ¬æ–‡åˆ†äº« **é€šä¿¡å®ç°** éƒ¨åˆ†ã€‚

ğŸ˜ˆ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” NIO æœåŠ¡å™¨ã€‹](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) ç³»åˆ—ï¼Œæ˜¯æœ¬æ–‡çš„**å‰ç½®æ–‡ç« **ï¼Œæ‰€ä»¥èƒ–å‹éœ€è¦å…ˆè¯»å®Œè¿™ä¸ªç³»åˆ—ã€‚å“ˆå“ˆå“ˆï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä»¥å‡‘åˆçœ‹çœ‹å…ˆã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾å¦‚ä¸‹ï¼š

![ç±»å›¾](http://static2.iocoder.cn/images/Dubbo/2018_10_04/01_01.png)

# 2. Server

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹æš´éœ²ï¼ˆDubboï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-export-dubbo/?self) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ä½¿ç”¨çš„ Server å®ç°ç±»æ˜¯ **HeaderExchangeServer** ã€‚

# 3. Client

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹å¼•ç”¨ï¼ˆDubboï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ä½¿ç”¨çš„ Client å®ç°ç±»æ˜¯ **ReferenceCountExchangeClient** å’Œ **LazyConnectExchangeClient** ã€‚

# 4. ExchangeHandler

åœ¨ DubboProtocol ä¸­ï¼Œå®ç°äº† ExchangeHandler ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {
@Override
public Object reply(ExchangeChannel channel, Object message) throws RemotingException{
// ... çœç•¥å…·ä½“å®ç°
}
@Override
public void received(Channel channel, Object message) throws RemotingException{
// ... çœç•¥å…·ä½“å®ç°
}
@Override
public void connected(Channel channel) throws RemotingException{
this.invoke(channel, Constants.ON_CONNECT_KEY);
}
@Override
public void disconnected(Channel channel) throws RemotingException{
// ... çœç•¥å…·ä½“å®ç°
}
private void invoke(Channel channel, String methodKey){
// ... çœç•¥å…·ä½“å®ç°
}
};
```

è¿™ä¸ªå¤„ç†å™¨ï¼Œè´Ÿè´£å°†è¯·æ±‚ï¼Œ**è½¬å‘åˆ°å¯¹åº”çš„ Invoker å¯¹è±¡**ï¼Œæ‰§è¡Œé€»è¾‘ï¼Œè¿”å›ç»“æœã€‚
å½“ç„¶ï¼Œæœ¬æ–‡ä¸ç»†åˆ†äº«ï¼Œæ”¾åœ¨ **åŒæ­¥è°ƒç”¨** ä¸€æ–‡è¯¦ç»†è§£æã€‚

# 5. Codec

åœ¨ [ExchangeCodec](https://github.com/apache/incubator-dubbo/blob/master/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¯¹ Request å’Œ Response çš„**é€šç”¨**è§£æã€‚ä½†æ˜¯å®ƒæ˜¯**ä¸æ»¡è¶³**åœ¨

dubbo://
åè®®ä¸­ï¼Œå¯¹ [RpcInvocation](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) å’Œ [RpcResult](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) ä½œä¸º **å†…å®¹ä½“( Body )** çš„ç¼–è§£ç çš„éœ€è¦çš„ã€‚

å¦å¤–ï¼Œåœ¨

dubbo://
åè®®ä¸­ï¼Œæ”¯æŒ [å‚æ•°å›è°ƒ](http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html) çš„ç‰¹æ€§ï¼Œä¹Ÿæ˜¯éœ€è¦åœ¨ç¼–è§£ç åšä¸€äº›**ç‰¹æ®Šé€»è¾‘**ã€‚

ä¸‹é¢ï¼Œè®©æˆ‘ä»¬æ¥ä¸€èµ·ç…ç…ä»£ç å®ç°å§ã€‚

## 5.1 DubboCountCodec

[
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java) ï¼Œå®ç° Codec2 æ¥å£ï¼Œæ”¯æŒ**å¤šæ¶ˆæ¯**çš„ç¼–è§£ç å™¨ã€‚

### 5.1.1 æ„é€ æ–¹æ³•

```
//*/*
/* ç¼–è§£ç å™¨
/*/
private DubboCodec codec = new DubboCodec();
```

* åœ¨ Dubbo Client å’Œ Server åˆ›å»ºçš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬çœ‹åˆ°è®¾ç½®äº†ç¼–è§£ç å™¨ä¸º

"dubbo"
ï¼Œä»è€Œé€šè¿‡ Dubbo SPI æœºåˆ¶ï¼ŒåŠ è½½åˆ° DubboCountCodec ã€‚ç›¸å…³å†…å®¹å¦‚ä¸‹ï¼š
```
// DubboProtocol/#createServer(...)
url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
// DubboProtocol/#initClient(...)
url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
// META-INF/dubbo/internal/com.alibaba.dubbo.remoting.Codec2
dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec
```
* å®é™…ç¼–è§£ç çš„é€»è¾‘ï¼Œä½¿ç”¨ DubboCodec ï¼Œå³

codec
å±æ€§ã€‚

### 5.1.2 ç¼–ç 

```
@Override
public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException{
codec.encode(channel, buffer, msg);
}
```

### 5.1.3 è§£ç 

```
1: @Override
2: public Object decode(Channel channel, ChannelBuffer buffer) throws IOException{
3: // è®°å½•å½“å‰è¯»ä½ç½®
4: int save = buffer.readerIndex();
5: // åˆ›å»º MultiMessage å¯¹è±¡
6: MultiMessage result = MultiMessage.create();
7: do {
8: // è§£ç 
9: Object obj = codec.decode(channel, buffer);
10: // è¾“å…¥ä¸å¤Ÿï¼Œé‡ç½®è¯»è¿›åº¦
11: if (Codec2.DecodeResult.NEED_MORE_INPUT == obj) {
12: buffer.readerIndex(save);
13: break;
14: // è§£æåˆ°æ¶ˆæ¯
15: } else {
16: // æ·»åŠ ç»“æœæ¶ˆæ¯
17: result.addMessage(obj);
18: // è®°å½•æ¶ˆæ¯é•¿åº¦åˆ°éšå¼å‚æ•°é›†åˆï¼Œç”¨äº MonitorFilter ç›‘æ§
19: logMessageLength(obj, buffer.readerIndex() - save);
20: // è®°å½•å½“å‰è¯»ä½ç½®
21: save = buffer.readerIndex();
22: }
23: } while (true);
24: // éœ€è¦æ›´å¤šçš„è¾“å…¥
25: if (result.isEmpty()) {
26: return Codec2.DecodeResult.NEED_MORE_INPUT;
27: }
28: // è¿”å›è§£æåˆ°çš„æ¶ˆæ¯
29: if (result.size() == 1) {
30: return result.get(0);
31: }
32: return result;
33: }
```

* åŒ…å«ä¸¤å—é€»è¾‘ï¼š1ï¼‰å¤šæ¶ˆæ¯è§£æçš„æ”¯æŒã€‚2ï¼‰è®°å½•æ¯æ¡æ¶ˆæ¯çš„é•¿åº¦ï¼Œç”¨äº MonitorFilter ç›‘æ§ã€‚
* ç¬¬ 4 è¡Œï¼šè®°å½•å½“å‰è¯»ä½ç½®ï¼Œç”¨äºä¸‹é¢è®¡ç®—æ¯æ¡æ¶ˆæ¯çš„é•¿åº¦ã€‚
* ç¬¬ 6 è¡Œï¼šåˆ›å»º MultiMessage å¯¹è±¡ã€‚MultiMessageHandler æ”¯æŒå¯¹å®ƒçš„å¤„ç†åˆ†å‘ã€‚
* ç¬¬ 7 è‡³ 23 è¡Œï¼š**å¾ªç¯**è§£ææ¶ˆæ¯ï¼Œç›´åˆ°ç»“æŸã€‚
* ç¬¬ 9 è¡Œï¼šè°ƒç”¨

DubboCodec/#decode(channel, buffer)
æ–¹æ³•ï¼Œè§£ç ã€‚
* ç¬¬ 11 è‡³ 13 è¡Œï¼šå­—èŠ‚æ•°ç»„ä¸å¤Ÿï¼Œé‡ç½®è¯»è¿›åº¦ï¼Œç»“æŸè§£æã€‚
* ç¬¬ 15 è‡³ 22 è¡Œï¼šè§£æåˆ°æ¶ˆæ¯ï¼Œæ·»åŠ åˆ°

result
ã€‚

* ç¬¬ 19 è¡Œï¼šè°ƒç”¨

/#logMessageLength(obj, length)
æ–¹æ³•ï¼Œè®°å½•æ¶ˆæ¯é•¿åº¦åˆ°**éšå¼å‚æ•°é›†åˆ**ï¼Œç”¨äº MonitorFilter ç›‘æ§ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private void logMessageLength(Object result, int bytes){
if (bytes <= 0) {
return;
}
if (result instanceof Request) {
try {
((RpcInvocation) ((Request) result).getData()).setAttachment(Constants.INPUT_KEY, String.valueOf(bytes)); // è¯·æ±‚
} catch (Throwable e) {
//* ignore /*/
}
} else if (result instanceof Response) {
try {
((RpcResult) ((Response) result).getResult()).setAttachment(Constants.OUTPUT_KEY, String.valueOf(bytes)); // å“åº”
} catch (Throwable e) {
//* ignore /*/
}
}
}
```

* x
* ç¬¬ 21 è¡Œï¼šè®°å½•å½“å‰è¯»ä½ç½®ï¼Œç”¨äºè®¡ç®—**ä¸‹ä¸€æ¡**æ¶ˆæ¯çš„é•¿åº¦ã€‚
* ç¬¬ 24 è‡³ 27 è¡Œï¼šéœ€è¦æ›´å¤šçš„è¾“å…¥ã€‚
* ç¬¬ 28 è‡³ 32 è¡Œï¼šè¿”å›ç»“æœã€‚

## 5.2 DubboCodec

[
com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java) ï¼Œå®ç° Codec2 æ¥å£ï¼Œç»§æ‰¿ ExchangeCodec ç±»ï¼Œ**Dubbo ç¼–è§£ç å™¨**å®ç°ç±»ã€‚

### 5.2.1 æ„é€ æ–¹æ³•

```
//*/*
/* åè®®å
/*/
public static final String NAME = "dubbo";
//*/*
/* åè®®ç‰ˆæœ¬
/*/
public static final String DUBBO_VERSION = Version.getVersion(DubboCodec.class, Version.getVersion());
//*/*
/* å“åº” - å¼‚å¸¸
/*/
public static final byte RESPONSE_WITH_EXCEPTION = 0;
//*/*
/* å“åº” - æ­£å¸¸ï¼ˆç©ºè¿”å›ï¼‰
/*/
public static final byte RESPONSE_VALUE = 1;
//*/*
/* å“åº” - æ­£å¸¸ï¼ˆæœ‰è¿”å›ï¼‰
/*/
public static final byte RESPONSE_NULL_VALUE = 2;
//*/*
/* æ–¹æ³•å‚æ•° - ç©ºï¼ˆå‚æ•°ï¼‰
/*/
public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
//*/*
/* æ–¹æ³•å‚æ•° - ç©ºï¼ˆç±»å‹ï¼‰
/*/
public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];
```

### 5.2.2 ç¼–ç å†…å®¹ä½“

### 5.2.2.1 è¯·æ±‚

```
1: @Override
2: protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException{
3: RpcInvocation inv = (RpcInvocation) data;
4:
5: // å†™å…¥ `dubbo` `path` `version`
6: out.writeUTF(inv.getAttachment(Constants.DUBBO_VERSION_KEY, DUBBO_VERSION));
7: out.writeUTF(inv.getAttachment(Constants.PATH_KEY));
8: out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));
9:
10: // å†™å…¥æ–¹æ³•ã€æ–¹æ³•ç­¾åã€æ–¹æ³•å‚æ•°é›†åˆ
11: out.writeUTF(inv.getMethodName());
12: out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));
13: Object[] args = inv.getArguments();
14: if (args != null) {
15: for (int i = 0; i < args.length; i++) {
16: out.writeObject(CallbackServiceCodec.encodeInvocationArgument(channel, inv, i));
17: }
18: }
19:
20: // å†™å…¥éšå¼ä¼ å‚é›†åˆ
21: out.writeObject(inv.getAttachments());
22: }
```

* ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚
* ç¼–ç  RpcInvocation å¯¹è±¡ï¼Œå†™å…¥éœ€è¦ç¼–ç çš„å­—æ®µã€‚
* å¯¹åº”çš„è§£ç ï¼Œåœ¨ DecodeableRpcInvocation ä¸­ã€‚
* ç¬¬ 16 è¡Œï¼šè°ƒç”¨

CallbackServiceCodec/#encodeInvocationArgument(...)
æ–¹æ³•ï¼Œç¼–ç å‚æ•°ã€‚ä¸»è¦ç”¨äº [å‚æ•°å›è°ƒ](http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html) åŠŸèƒ½ï¼Œåé¢çš„æ–‡ç« ï¼Œè¯¦ç»†è§£æã€‚

### 5.2.2.2 å“åº”

```
1: @Override
2: protected void encodeResponseData(Channel channel, ObjectOutput out, Object data) throws IOException{
3: Result result = (Result) data;
4:
5: Throwable th = result.getException();
6: // æ­£å¸¸
7: if (th == null) {
8: Object ret = result.getValue();
9: // ç©ºè¿”å›
10: if (ret == null) {
11: out.writeByte(RESPONSE_NULL_VALUE);
12: // æœ‰è¿”å›
13: } else {
14: out.writeByte(RESPONSE_VALUE);
15: out.writeObject(ret);
16: }
17: // å¼‚å¸¸
18: } else {
19: out.writeByte(RESPONSE_WITH_EXCEPTION);
20: out.writeObject(th);
21: }
22: }
```

* ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚
* ç¼–ç  Result å¯¹è±¡ï¼Œå†™å…¥éœ€è¦ç¼–ç çš„å­—æ®µã€‚
* å¯¹åº”çš„è§£ç ï¼Œåœ¨ DecodeableRpcResult ä¸­ã€‚

### 5.2.3 è§£ç å†…å®¹ä½“

```
1: @Override
2: protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException{
3: byte flag = header[2];
4: // è·å¾— Serialization å¯¹è±¡
5: byte proto = (byte) (flag & SERIALIZATION_MASK);
6: Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);
7: // è·å¾—è¯·æ±‚||å“åº”ç¼–å·
8: // get request id.
9: long id = Bytes.bytes2long(header, 4);
10: // è§£æå“åº”
11: if ((flag & FLAG_REQUEST) == 0) {
12: // decode response.
13: Response res = new Response(id);
14: // ... çœç•¥ä»£ç 
15: return res;
16: // è§£æè¯·æ±‚
17: } else {
18: // decode request.
19: Request req = new Request(id);
20: // ... çœç•¥ä»£ç 
21: return req;
22: }
23: }
```

* ç¬¬ 4 è‡³ 6 è¡Œï¼šè°ƒç”¨

CodeSupport/#getSerialization(url, proto)
æ–¹æ³•ï¼Œè·å¾— Serialization å¯¹è±¡ï¼Œç”¨äºä¸‹é¢ååºåˆ—åŒ–å†…å®¹ä½“çš„æ¯ä¸ªå­—æ®µã€‚
* ç¬¬ 9 è¡Œï¼šè·å¾—è¯·æ±‚æˆ–å“åº”çš„ç¼–å·ã€‚
* ç¬¬ 10 è‡³ 15 è¡Œï¼šè§£æå“åº”( Response )ã€‚
* ç¬¬ 16 è‡³ 22 è¡Œï¼šè§£æè¯·æ±‚( Request )ã€‚

### 5.2.3.1 è¯·æ±‚

```
1: // decode response.
2: Response res = new Response(id);
3: // è‹¥æ˜¯å¿ƒè·³äº‹ä»¶ï¼Œè¿›è¡Œè®¾ç½®
4: if ((flag & FLAG_EVENT) != 0) {
5: res.setEvent(Response.HEARTBEAT_EVENT);
6: }
7: // è®¾ç½®çŠ¶æ€
8: // get status.
9: byte status = header[3];
10: res.setStatus(status);
11: // æ­£å¸¸å“åº”çŠ¶æ€
12: if (status == Response.OK) {
13: try {
14: Object data;
15: // è§£ç å¿ƒè·³äº‹ä»¶
16: if (res.isHeartbeat()) {
17: data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
18: // è§£ç å…¶å®ƒäº‹ä»¶
19: } else if (res.isEvent()) {
20: data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
21: // è§£ç æ™®é€šå“åº”
22: } else {
23: DecodeableRpcResult result;
24: // åœ¨é€šä¿¡æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒNettyï¼‰çš„ IO çº¿ç¨‹ï¼Œè§£ç 
25: if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
26: result = new DecodeableRpcResult(channel, res, is, (Invocation) getRequestData(id), proto);
27: result.decode();
28: // åœ¨ Dubbo ThreadPool çº¿ç¨‹ï¼Œè§£ç ï¼Œä½¿ç”¨ DecodeHandler
29: } else {
30: result = new DecodeableRpcResult(channel, res, new UnsafeByteArrayInputStream(readMessageData(is)), (Invocation) getRequestData(id), proto);
31: }
32: data = result;
33: }
34: // è®¾ç½®ç»“æœ
35: res.setResult(data);
36: } catch (Throwable t) {
37: if (log.isWarnEnabled()) {
38: log.warn("Decode response failed: " + t.getMessage(), t);
39: }
40: res.setStatus(Response.CLIENT_ERROR);
41: res.setErrorMessage(StringUtils.toString(t));
42: }
43: // å¼‚å¸¸å“åº”çŠ¶æ€
44: } else {
45: res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());
46: }
47: return res;
```

* ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚æˆ‘ä»¬é‡ç‚¹è®²ä¸‹å¯èƒ½**æ¯”è¾ƒç»•**çš„åœ°æ–¹ã€‚
* ç¬¬ 21 è‡³ 33 è¡Œï¼šè§£ç æ™®é€šå“åº”ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä»£ç åˆ†æˆã€ç¬¬ 25 è‡³ 27 è¡Œã€‘ã€ç¬¬ 28 è‡³ 31 è¡Œã€‘**ä¸¤æ®µ**ã€‚

* ç›¸åŒç‚¹ï¼Œä½¿ç”¨ **DecodeableRpcResult** è§£ç ã€‚å‰è€…ï¼Œæ¯”è¾ƒå¥½ç†è§£ï¼Œã€ç¬¬ 27 è¡Œã€‘å·²ç»è°ƒç”¨ï¼›åè€…ï¼Œåœ¨ DecodeHandler ä¸­ï¼Œæ‰æœ€ç»ˆè°ƒç”¨

DecodeableRpcResult/#decode()
æ–¹æ³•ã€‚
* å·®å¼‚ç‚¹ï¼Œä½¿ç”¨**å“ªä¸ªçº¿ç¨‹**è§£ç ã€‚å‰è€…ï¼Œè¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£ï¼Œå½“å‰çº¿ç¨‹ï¼Œå³é€šä¿¡æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒNettyï¼‰çš„ IO çº¿ç¨‹ã€‚åè€…ï¼ŒDubbo ThreadPool çº¿ç¨‹ä¸­ã€‚
* decode.in.io
é…ç½®é¡¹ï¼Œç›®å‰åœ¨ Dubbo æ–‡æ¡£ä¸­ï¼Œå¹¶æœªè¯´æ˜ï¼Œåº”è¯¥æ˜¯**æ€§èƒ½è°ƒä¼˜**ï¼Œå…·ä½“ç¬”è€…è¿˜æ²¡æµ‹è¯•è¿‡ã€‚å˜¿å˜¿ã€‚

### 5.2.3.2 å“åº”

```
1: // decode request.
2: Request req = new Request(id);
3: req.setVersion("2.0.0");
4: // æ˜¯å¦éœ€è¦å“åº”
5: req.setTwoWay((flag & FLAG_TWOWAY) != 0);
6: // è‹¥æ˜¯å¿ƒè·³äº‹ä»¶ï¼Œè¿›è¡Œè®¾ç½®
7: if ((flag & FLAG_EVENT) != 0) {
8: req.setEvent(Request.HEARTBEAT_EVENT);
9: }
10: try {
11: Object data;
12: // è§£ç å¿ƒè·³äº‹ä»¶
13: if (req.isHeartbeat()) {
14: data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
15: // è§£ç å…¶å®ƒäº‹ä»¶
16: } else if (req.isEvent()) {
17: data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
18: // è§£ç æ™®é€šè¯·æ±‚
19: } else {
20: // åœ¨é€šä¿¡æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒNettyï¼‰çš„ IO çº¿ç¨‹ï¼Œè§£ç 
21: DecodeableRpcInvocation inv;
22: if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
23: inv = new DecodeableRpcInvocation(channel, req, is, proto);
24: inv.decode();
25: // åœ¨ Dubbo ThreadPool çº¿ç¨‹ï¼Œè§£ç ï¼Œä½¿ç”¨ DecodeHandler
26: } else {
27: inv = new DecodeableRpcInvocation(channel, req, new UnsafeByteArrayInputStream(readMessageData(is)), proto);
28: }
29: data = inv;
30: }
31: req.setData(data);
32: } catch (Throwable t) {
33: if (log.isWarnEnabled()) {
34: log.warn("Decode request failed: " + t.getMessage(), t);
35: }
36: // bad request
37: req.setBroken(true);
38: req.setData(t);
39: }
40: return req;
```

* å’Œ [ã€Œ5.2.3.1 è¯·æ±‚ã€](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) **ç±»ä¼¼**ï¼Œå·®å¼‚ç‚¹åœ¨ä½¿ç”¨ **DecodeableRpcInvocation** ã€‚
* ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚

## 5.3 DecodeableRpcInvocation

[
com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java) ï¼Œå®ç° Codec å’Œ Decodeable æ¥å£ï¼Œç»§æ‰¿ RpcInvocation ç±»ï¼Œ**å¯è§£ç **çš„ RpcInvocation å®ç°ç±»ã€‚

å½“æœåŠ¡æ¶ˆè´¹è€…ï¼Œè°ƒç”¨æœåŠ¡æä¾›è€…ï¼Œå‰è€…ç¼–ç çš„ RpcInvocation å¯¹è±¡ï¼Œåè€…è§£ç æˆ DecodeableRpcInvocation å¯¹è±¡ã€‚

ä»ç›®å‰çš„ä»£ç å®ç°æ¥çœ‹ï¼ŒCodec æ¥å£ï¼Œå¯ä¸å®ç°ã€‚

### 5.3.1 æ„é€ æ–¹æ³•

```
//*/*
/* é€šé“
/*/
private Channel channel;
//*/*
/* Serialization ç±»å‹ç¼–å·
/*/
private byte serializationType;
//*/*
/* è¾“å…¥æµ
/*/
private InputStream inputStream;
//*/*
/* è¯·æ±‚
/*/
private Request request;
//*/*
/* æ˜¯å¦å·²ç»è§£ç å®Œæˆ
/*/
private volatile boolean hasDecoded;
```

### 5.3.2 è§£ç 

```
@Override
public void decode(){
if (!hasDecoded && channel != null && inputStream != null) {
try {
decode(channel, inputStream);
} catch (Throwable e) {
if (log.isWarnEnabled()) {
log.warn("Decode rpc invocation failed: " + e.getMessage(), e);
}
request.setBroken(true);
request.setData(e);
} finally {
hasDecoded = true;
}
}
}
@Override
public Object decode(Channel channel, InputStream input) throws IOException{
ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);
// è§£ç  `dubbo` `path` `version`
setAttachment(Constants.DUBBO_VERSION_KEY, in.readUTF());
setAttachment(Constants.PATH_KEY, in.readUTF());
setAttachment(Constants.VERSION_KEY, in.readUTF());
// è§£ç æ–¹æ³•ã€æ–¹æ³•ç­¾åã€æ–¹æ³•å‚æ•°é›†åˆ
setMethodName(in.readUTF());
try {
Object[] args;
Class<?>[] pts;
String desc = in.readUTF();
if (desc.length() == 0) {
pts = DubboCodec.EMPTY_CLASS_ARRAY;
args = DubboCodec.EMPTY_OBJECT_ARRAY;
} else {
pts = ReflectUtils.desc2classArray(desc);
args = new Object[pts.length];
for (int i = 0; i < args.length; i++) {
try {
args[i] = in.readObject(pts[i]);
} catch (Exception e) {
if (log.isWarnEnabled()) {
log.warn("Decode argument failed: " + e.getMessage(), e);
}
}
}
}
setParameterTypes(pts);
// è§£ç éšå¼ä¼ å‚é›†åˆ
Map<String, String> map = (Map<String, String>) in.readObject(Map.class);
if (map != null && map.size() > 0) {
Map<String, String> attachment = getAttachments();
if (attachment == null) {
attachment = new HashMap<String, String>();
}
attachment.putAll(map);
setAttachments(attachment);
}
// è¿›ä¸€æ­¥è§£ç æ–¹æ³•å‚æ•°ï¼Œä¸»è¦ä¸ºäº†å‚æ•°è¿”å›
// decode argument ,may be callback
for (int i = 0; i < args.length; i++) {
args[i] = CallbackServiceCodec.decodeInvocationArgument(channel, this, pts, i, args[i]);
}
setArguments(args);
} catch (ClassNotFoundException e) {
throw new IOException(StringUtils.toString("Read invocation data failed.", e));
} finally {
if (in instanceof Cleanable) {
((Cleanable) in).cleanup();
}
}
return this;
}
```

* ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚

## 5.4 DecodeableRpcResult

å’Œ DecodeableRpcInvocation ä¸€è‡´ã€‚

[
com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java) ï¼Œå®ç° Codec å’Œ Decodeable æ¥å£ï¼Œç»§æ‰¿ RpcResult ç±»ï¼Œ**å¯è§£ç **çš„ RpcResult å®ç°ç±»ã€‚

å½“æœåŠ¡æä¾›è€…è€…ï¼Œè¿”å›æœåŠ¡æ¶ˆè´¹è€…è°ƒç”¨ç»“æœï¼Œå‰è€…ç¼–ç çš„ RpcResult å¯¹è±¡ï¼Œåè€…è§£ç æˆ DecodeableRpcResult å¯¹è±¡ã€‚

ä»ç›®å‰çš„ä»£ç å®ç°æ¥çœ‹ï¼ŒCodec æ¥å£ï¼Œå¯ä¸å®ç°ã€‚

### 5.4.1 æ„é€ æ–¹æ³•

```
//*/*
/* é€šé“
/*/
private Channel channel;
//*/*
/* Serialization ç±»å‹ç¼–å·
/*/
private byte serializationType;
//*/*
/* è¾“å…¥æµ
/*/
private InputStream inputStream;
//*/*
/* è¯·æ±‚
/*/
private Response response;
//*/*
/* Invocation å¯¹è±¡
/*/
private Invocation invocation;
//*/*
/* æ˜¯å¦å·²ç»è§£ç å®Œæˆ
/*/
private volatile boolean hasDecoded;
```

### 5.4.2 è§£ç 

```
@Override
public void decode(){
if (!hasDecoded && channel != null && inputStream != null) {
try {
decode(channel, inputStream);
} catch (Throwable e) {
if (log.isWarnEnabled()) {
log.warn("Decode rpc result failed: " + e.getMessage(), e);
}
response.setStatus(Response.CLIENT_ERROR);
response.setErrorMessage(StringUtils.toString(e));
} finally {
hasDecoded = true;
}
}
}
@Override
public Object decode(Channel channel, InputStream input) throws IOException{
ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);
// è¯»å–æ ‡è®°ä½
byte flag = in.readByte();
switch (flag) {
case DubboCodec.RESPONSE_NULL_VALUE: // æ— è¿”å›å€¼
break;
case DubboCodec.RESPONSE_VALUE: // æœ‰è¿”å›å€¼
try {
Type[] returnType = RpcUtils.getReturnTypes(invocation);
setValue(returnType == null || returnType.length == 0 ? in.readObject() :
(returnType.length == 1 ? in.readObject((Class<?>) returnType[0])
// è¿”å›ç»“æœ:Type[]{method.getReturnType(), method.getGenericReturnType()}
: in.readObject((Class<?>) returnType[0], returnType[1])));
} catch (ClassNotFoundException e) {
throw new IOException(StringUtils.toString("Read response data failed.", e));
}
break;
case DubboCodec.RESPONSE_WITH_EXCEPTION: // å¼‚å¸¸
try {
Object obj = in.readObject();
if (!(obj instanceof Throwable)) {
throw new IOException("Response data error, expect Throwable, but get " + obj);
}
setException((Throwable) obj);
} catch (ClassNotFoundException e) {
throw new IOException(StringUtils.toString("Read response data failed.", e));
}
break;
default:
throw new IOException("Unknown result flag, expect '0' '1' '2', get " + flag);
}
if (in instanceof Cleanable) {
((Cleanable) in).cleanup();
}
return this;
}
```

* ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚