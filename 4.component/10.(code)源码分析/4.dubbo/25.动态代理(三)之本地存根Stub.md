# åŠ¨æ€ä»£ç†ï¼ˆä¸‰ï¼‰ä¹‹æœ¬åœ°å­˜æ ¹ Stub

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” åŠ¨æ€ä»£ç†ï¼ˆäºŒï¼‰ä¹‹ JDKã€‹](http://svip.iocoder.cn/Dubbo/proxy-jdk/?self) ä¸€æ–‡ï¼Œåˆ†äº«ä½¿ç”¨ Dubbo **æœ¬åœ°å­˜æ ¹( Stub )**çš„ç‰¹æ€§ã€‚ğŸ˜ å½“ç„¶ï¼Œä»æ ‡é¢˜æˆ‘ä»¬å°±å¯ä»¥çœ‹å‡ºï¼Œå®ç°çš„åŸç†æ˜¯åŸºäº**åŠ¨æ€ä»£ç†**çš„æœºåˆ¶ã€‚

åœ¨ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æœ¬åœ°å­˜æ ¹ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html) ä¸­ï¼Œå·²ç»éå¸¸è¯¦å°½çš„åˆ†äº«äº†**æœ¬åœ°å­˜æ ¹**çš„æ¦‚å¿µå’Œä½¿ç”¨ï¼Œæœ¬æ–‡å°±ä¸é‡å¤ä»‹ç»å•¦ã€‚ğŸ˜ˆ æ–‡æ¡£æœ‰ä¸€ç‚¹ç‚¹å°å°çš„é”™è¯¯ï¼Œåœ¨ Spring é…ç½®æ–‡ä»¶çš„é…ç½®æ–¹å¼åº”è¯¥æ˜¯å¦‚ä¸‹ï¼š
```
<dubbo:reference interface="com.alibaba.dubbo.demo.DemoService" stub="com.alibaba.dubbo.demo.consumer.DemoServiceStub">
```

* æ˜¯æœåŠ¡å¼•ç”¨

<dubbo:reference />
ï¼Œè€Œä¸æ˜¯æœåŠ¡æš´éœ²

<dubbo:service />

# 2. StubProxyFactoryWrapper

[
com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper
](http://svip.iocoder.cn/Dubbo/proxy-local-stub/TODO) ï¼Œå®ç° ProxyFactory æ¥å£ï¼Œå­˜æ ¹ä»£ç†å·¥å‚**åŒ…è£…å™¨**å®ç°ç±»ã€‚

## 2.1 æ„é€ æ–¹æ³•

```
//*/*
/* ProxyFactory$Adaptive å¯¹è±¡
/*/
private final ProxyFactory proxyFactory;
//*/*
/* Protocol$Adaptive å¯¹è±¡
/*/
private Protocol protocol;
public StubProxyFactoryWrapper(ProxyFactory proxyFactory){
this.proxyFactory = proxyFactory;
}
public void setProtocol(Protocol protocol){
this.protocol = protocol;
}
```

* proxyFactory
å±æ€§ï¼ŒProxyFactory$Adaptive å¯¹è±¡ã€‚StubProxyFactoryWrapper åŸºäº Dubbo SPI Wrapper æœºåˆ¶ï¼Œæ‰€ä»¥ä½¿ç”¨ ProxyFactory åˆ›å»ºä»£ç†çš„æµç¨‹ï¼Œå®é™…å˜æˆå¦‚ä¸‹ï¼š![æµç¨‹](http://static2.iocoder.cn/images/Dubbo/2018_09_19/01.png)
* protocol
å±æ€§ï¼ŒProtocol$Adaptive å¯¹è±¡ã€‚

## 2.2 getProxy

```
1: @Override
2: @SuppressWarnings({"unchecked", "rawtypes"})
3: public <T> T getProxy(Invoker<T> invoker) throws RpcException{
4: // è·å¾— Service Proxy å¯¹è±¡
5: T proxy = proxyFactory.getProxy(invoker);
6: if (GenericService.class != invoker.getInterface()) { // éæ³›åŒ–å¼•ç”¨
7: // è·å¾— `stub` é…ç½®é¡¹
8: String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));
9: if (ConfigUtils.isNotEmpty(stub)) {
10: Class<?> serviceType = invoker.getInterface();
11: // `stub = true` çš„æƒ…å†µï¼Œä½¿ç”¨æ¥å£ + `Stub` å­—ç¬¦ä¸²ã€‚
12: if (ConfigUtils.isDefault(stub)) {
13: if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) {
14: stub = serviceType.getName() + "Stub";
15: } else {
16: stub = serviceType.getName() + "Local";
17: }
18: }
19: try {
20: // åŠ è½½ Stub ç±»
21: Class<?> stubClass = ReflectUtils.forName(stub);
22: if (!serviceType.isAssignableFrom(stubClass)) {
23: throw new IllegalStateException("The stub implementation class " + stubClass.getName() + " not implement interface " + serviceType.getName());
24: }
25: try {
26: // åˆ›å»º Stub å¯¹è±¡ï¼Œä½¿ç”¨å¸¦ Service Proxy å¯¹è±¡çš„æ„é€ æ–¹æ³•
27: Constructor<?> constructor = ReflectUtils.findConstructor(stubClass, serviceType);
28: proxy = (T) constructor.newInstance(new Object[]{proxy});
29:
30: // ã€TODO 8033ã€‘å‚æ•°å›è°ƒ
31: //export stub service
32: URL url = invoker.getUrl();
33: if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) {
34: url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), ","));
35: url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());
36: try {
37: export(proxy, (Class) invoker.getInterface(), url);
38: } catch (Exception e) {
39: LOGGER.error("export a stub service error.", e);
40: }
41: }
42: } catch (NoSuchMethodException e) {
43: throw new IllegalStateException("No such constructor \"public " + stubClass.getSimpleName() + "(" + serviceType.getName() + ")\" in stub implementation class " + stubClass.getName(), e);
44: }
45: } catch (Throwable t) {
46: LOGGER.error("Failed to create stub implementation class " + stub + " in consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", cause: " + t.getMessage(), t);
47: // ignore
48: }
49: }
50: }
51: return proxy;
52: }
```

* ã€**ç¬¬ä¸€æ­¥**ã€‘ç¬¬ 5 è¡Œï¼šè°ƒç”¨

proxyFactory/#getProxy(invoker)
æ–¹æ³•ï¼Œè·å¾— Service Proxy å¯¹è±¡ã€‚è¿™ä¸ªè¿‡ç¨‹ï¼Œå°±æ˜¯æˆ‘ä»¬åœ¨ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” åŠ¨æ€ä»£ç†ã€‹](http://svip.iocoder.cn/Dubbo/proxy-local-stub/) å‰ä¸¤ç¯‡çœ‹åˆ°çš„å†…å®¹ã€‚
* ç¬¬ 6 è¡Œï¼šè‹¥æ˜¯æ³›åŒ–å¼•ç”¨ï¼Œä¸æ”¯æŒä½¿ç”¨æœ¬åœ°å­˜æ ¹ã€‚
* ç¬¬ 8 è‡³ 18 è¡Œï¼šè·å¾—

stub
é…ç½®é¡¹ã€‚**æ³¨æ„**ï¼Œ

local
é…ç½®é¡¹ï¼Œå’Œ

stub
é…ç½®é¡¹æ˜¯**ç­‰ä»·**çš„ï¼Œç›®å‰ä½¿ç”¨

stub
è€Œä¸ä½¿ç”¨

local
ã€‚
* ç¬¬ 20 è‡³ 24 è¡Œï¼šè°ƒç”¨

ReflectUtils/#forName(stub)
æ–¹æ³•ï¼ŒåŠ è½½ Stub ç±»ã€‚
* ã€**ç¬¬äºŒæ­¥**ã€‘ç¬¬ 26 è‡³ 28 è¡Œï¼šåˆ›å»º Stub å¯¹è±¡ï¼Œ**ä½¿ç”¨å¸¦ Service Proxy å¯¹è±¡ä½œä¸ºå‚æ•°çš„æ„é€ æ–¹æ³•**ã€‚ä¾‹å¦‚ï¼Œ

public DemoServiceStub(DemoService demoService)
ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œæˆ‘ä»¬çš„ Stub å¯¹è±¡ï¼Œå°±å°† Proxy Service å¯¹è±¡ï¼Œ**åŒ…è£…åœ¨å†…éƒ¨**ï¼Œå¯ä»¥å®ç°å„ç§ OOXX å•¦ã€‚
* ç¬¬ 30 è‡³ 41 è¡Œï¼šã€TODO 8033ã€‘å‚æ•°å›è°ƒã€‚å…ˆæ— è§†ã€‚
* ç¬¬ 51 è¡Œï¼šè¿”å›æœ€ç»ˆçš„

proxy
ã€‚

## 2.3 getInvoker

```
@Override
public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException{
return proxyFactory.getInvoker(proxy, type, url);
}
```

* æœåŠ¡å®ç°çš„ Service ï¼Œä¸æ”¯æŒ Stub å­˜æ ¹ã€‚æ‰€ä»¥ï¼Œè™½ç„¶

<dubbo:service />
æœ‰

stub
é…ç½®é¡¹ï¼Œä½†æ˜¯å®é™…æ˜¯æ²¡æœ‰æ•ˆæœçš„ã€‚

# 3. æ ¡éªŒ Stub é…ç½®

åœ¨

/#checkStubAndMock(interfaceClass)
æ–¹æ³•ä¸­ï¼Œæœ‰æ ¡éªŒ

stub
é…ç½®é¡¹çš„ä»£ç ï¼Œå¦‚ä¸‹ï¼š
```
// `local` é…ç½®é¡¹çš„æ ¡éªŒï¼Œå’Œ `stub` ä¸€æ ·ã€‚
if (ConfigUtils.isNotEmpty(local)) {
Class<?> localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + "Local") : ReflectUtils.forName(local);
if (!interfaceClass.isAssignableFrom(localClass)) {
throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceClass.getName());
}
try {
ReflectUtils.findConstructor(localClass, interfaceClass);
} catch (NoSuchMethodException e) {
throw new IllegalStateException("No such constructor \"public " + localClass.getSimpleName() + "(" + interfaceClass.getName() + ")\" in local implementation class " + localClass.getName());
}
}
// `stub` é…ç½®é¡¹çš„æ ¡éªŒ
if (ConfigUtils.isNotEmpty(stub)) {
// `stub = true` çš„æƒ…å†µï¼Œä½¿ç”¨æ¥å£ + `Stub` å­—ç¬¦ä¸²ã€‚
Class<?> localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + "Stub") : ReflectUtils.forName(stub);
// Stub ç±»ï¼Œå¿…é¡»å®ç°æœåŠ¡æ¥å£
if (!interfaceClass.isAssignableFrom(localClass)) {
throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceClass.getName());
}
// Stub ç±»ï¼Œå¿…é¡»å¸¦æœ‰æœåŠ¡æ¥å£çš„æ„é€ æ–¹æ³•
try {
ReflectUtils.findConstructor(localClass, interfaceClass);
} catch (NoSuchMethodException e) {
throw new IllegalStateException("No such constructor \"public " + localClass.getSimpleName() + "(" + interfaceClass.getName() + ")\" in local implementation class " + localClass.getName());
}
}
```