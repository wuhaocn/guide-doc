<div class="article-inner">


<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 Jemalloc（三）PoolSubpage
</h1>


</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（一）PoolChunk》</a> 一文中，我们已经看到，为了进一步提供提高内存<strong>分配效率</strong>并减少<strong>内存碎片</strong>，Jemalloc 算法将每个 Chunk 切分成多个<strong>小块</strong> Page 。</p>
<p>但是实际应用中，Page 也是<strong>比较大</strong>的内存块，如果直接使用，明显是很浪费的。因此，Jemalloc 算法将每个 Page 更进一步的切分为<strong>多个</strong> Subpage 内存块。Page 切分成<strong>多个</strong> Subpage 内存块，并未采用相对复杂的算法和数据结构，而是直接基于<strong>数组</strong>，通过数组来<strong>标记</strong>每个 Subpage 内存块是否已经分配。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_07/01.png" title="PoolSubpage" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_07/01.png" alt="PoolSubpage"></a><span class="caption">PoolSubpage</span></p>
<ul>
<li>一个 Page ，切分出的<strong>多个</strong> Subpage 内存块<strong>大小均等</strong>。</li>
<li>每个 Page 拆分的 Subpage 内存块<strong>可以不同</strong>，以 Page 第一次拆分为 Subpage 内存块时请求分配的内存大小为准。例如：<ul>
<li>初始时，申请一个 16B 的内存块，那么 Page0 被拆成成 512( <code>8KB / 16B</code> )个 Subpage 块，使用第 0 块。</li>
<li>然后，申请一个 32B 的内存块，那么 Page1 被拆分成 256( <code>8KB / 32B</code> )个 Subpage 块，使用第 0 块。</li>
<li>最后，申请一个 16B 的内存块，那么重用 Page0 ，使用第 1 块。</li>
<li>总结来说，申请 Subpage 内存块时，先去找<strong>大小匹配</strong>，且有可分配 Subpage 内存块的 Page ：1）如果有，则使用其中的一块 Subpage ；2）如果没有，则选择一个新的 Page 拆分成多个 Subpage 内存块，使用第 0 块 Subpage 。</li>
</ul>
</li>
<li>Subpage 的内存规格，分成 Tiny 和 Small 两类，并且每类有多种大小，如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_07/02.png" title="Subpage 内存规格" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_07/02.png" alt="Subpage 内存规格"></a><span class="caption">Subpage 内存规格</span></li>
<li>为了方便描述，下文我们会继续将 <code>ele</code> 小块，描述成“Subpage 内存块”，简称“Subpage” 。</li>
</ul>
<h1 id="2-PoolSubpage"><a href="#2-PoolSubpage" class="headerlink" title="2. PoolSubpage"></a>2. PoolSubpage</h1><p><code>io.netty.buffer.PoolSubpage</code> ，实现 PoolSubpageMetric 接口，Netty 对 Jemalloc Subpage 的实现类。</p>
<p>虽然，PoolSubpage 类的命名是“Subpage”，实际描述的是，Page 切分为<strong>多个</strong> Subpage 内存块的分配情况。那么为什么不直接叫 PoolPage 呢？在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（一）PoolChunk》</a> 一文中，我们可以看到，当申请分配的内存规格为 Normal 和 Huge 时，使用的是一块或多块 Page 内存块。如果 PoolSubpage 命名成 PoolPage 后，和这块的分配策略是有所冲突的。或者说，<strong>Subpage ，只是 Page 分配内存的一种形式</strong>。</p>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 PoolChunk 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> PoolChunk&lt;T&gt; chunk;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 {<span class="doctag">@link</span> PoolChunk#memoryMap} 的节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> memoryMapIdx;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 Chunk 中，偏移字节量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> PoolChunk#runOffset(int) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> runOffset;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Page 大小 {<span class="doctag">@link</span> PoolChunk#pageSize}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subpage 分配信息数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个 long 的 bits 位代表一个 Subpage 是否分配。</span></span><br><span class="line"><span class="comment"> * 因为 PoolSubpage 可能会超过 64 个( long 的 bits 位数 )，所以使用数组。</span></span><br><span class="line"><span class="comment"> *   例如：Page 默认大小为 8KB ，Subpage 默认最小为 16 B ，所以一个 Page 最多可包含 8 * 1024 / 16 = 512 个 Subpage 。</span></span><br><span class="line"><span class="comment"> *        因此，bitmap 数组大小为 512 / 64 = 8 。</span></span><br><span class="line"><span class="comment"> * 另外，bitmap 的数组大小，使用 {<span class="doctag">@link</span> #bitmapLength} 来标记。或者说，bitmap 数组，默认按照 Subpage 的大小为 16B 来初始化。</span></span><br><span class="line"><span class="comment"> *    为什么是这样的设定呢？因为 PoolSubpage 可重用，通过 {<span class="doctag">@link</span> #init(PoolSubpage, int)} 进行重新初始化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] bitmap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表，前一个 PoolSubpage 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolSubpage&lt;T&gt; prev;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表，后一个 PoolSubpage 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolSubpage&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否未销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">boolean</span> doNotDestroy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个 Subpage 的占用内存大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> elemSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总共 Subpage 的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxNumElems;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #bitmap} 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> bitmapLength;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个可分配 Subpage 的数组位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nextAvail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剩余可用 Subpage 的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numAvail;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="comment">// 【构造方法 1】 双向链表，头节点</span></span><br><span class="line">  <span class="number">2</span>: <span class="comment">/** Special constructor that creates a linked list head */</span></span><br><span class="line">  <span class="number">3</span>: PoolSubpage(<span class="keyword">int</span> pageSize) {</span><br><span class="line">  <span class="number">4</span>:     chunk = <span class="keyword">null</span>;</span><br><span class="line">  <span class="number">5</span>:     memoryMapIdx = -<span class="number">1</span>;</span><br><span class="line">  <span class="number">6</span>:     runOffset = -<span class="number">1</span>;</span><br><span class="line">  <span class="number">7</span>:     elemSize = -<span class="number">1</span>;</span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">  <span class="number">9</span>:     bitmap = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">10</span>: }</span><br><span class="line"> <span class="number">11</span>: </span><br><span class="line"> <span class="number">12</span>: <span class="comment">// 【构造方法 2】 双向链表，Page 节点</span></span><br><span class="line"> <span class="number">13</span>: PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> memoryMapIdx, <span class="keyword">int</span> runOffset, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> elemSize) {</span><br><span class="line"> <span class="number">14</span>:     <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line"> <span class="number">15</span>:     <span class="keyword">this</span>.memoryMapIdx = memoryMapIdx;</span><br><span class="line"> <span class="number">16</span>:     <span class="keyword">this</span>.runOffset = runOffset;</span><br><span class="line"> <span class="number">17</span>:     <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line"> <span class="number">18</span>:     <span class="comment">// 创建 bitmap 数组</span></span><br><span class="line"> <span class="number">19</span>:     bitmap = <span class="keyword">new</span> <span class="keyword">long</span>[pageSize &gt;&gt;&gt; <span class="number">10</span>]; <span class="comment">// pageSize / 16 / 64</span></span><br><span class="line"> <span class="number">20</span>:     <span class="comment">// 初始化</span></span><br><span class="line"> <span class="number">21</span>:     init(head, elemSize);</span><br><span class="line"> <span class="number">22</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Chunk 相关<ul>
<li><code>chunk</code> 属性，所属 PoolChunk 对象。</li>
<li><code>memoryMapIdx</code> 属性，在 <code>PoolChunk.memoryMap</code> 的节点编号，例如节点编号 2048 。</li>
<li><code>runOffset</code> 属性，在 Chunk 中，偏移字节量，通过 <code>PoolChunk#runOffset(id)</code> 方法计算。在 PoolSubpage 中，无相关的逻辑，仅用于 <code>#toString()</code> 方法，打印信息。</li>
<li><code>pageSize</code> 属性，Page 大小。</li>
</ul>
</li>
<li>Subpage 相关<ul>
<li><code>bitmap</code> 属性，Subpage <strong>分配信息</strong>数组。<ul>
<li>1、每个 <code>long</code> 的 bits 位代表一个 Subpage 是否分配。因为 PoolSubpage 可能会超过 64 个( <code>long</code> 的 bits 位数 )，所以使用数组。例如：Page 默认大小为 <code>8KB</code> ，Subpage 默认最小为 <code>16B</code> ，所以一个 Page 最多可包含 <code>8 * 1024 / 16</code> = 512 个 Subpage 。</li>
<li>2、在【第 19 行】的代码，创建 <code>bitmap</code> 数组。我们可以看到，<code>bitmap</code> 数组的大小为 8(<code>pageSize &gt;&gt;&gt; 10 = pageSize / 16 / 64 = 512 / 64</code>) 个。<ul>
<li>为什么是<strong>固定大小</strong>呢？因为 PoolSubpage <strong>可重用</strong>，通过 <code>#init(PoolSubpage, int)</code> 进行重新初始化。</li>
<li>那么数组大小怎么获得？通过 <code>bitmapLength</code> 属性来标记<strong>真正</strong>使用的数组大小。</li>
</ul>
</li>
</ul>
</li>
<li><code>bitmapLength</code> 属性，<code>bitmap</code> 数组的<strong>真正</strong>使用的数组大小。</li>
<li><code>elemSize</code> 属性，每个 Subpage 的占用内存大小，例如 <code>16B</code>、<code>32B</code> 等等。</li>
<li><code>maxNumElems</code> 属性，总共 Subpage 的数量。例如 <code>16B</code> 为 512 个，<code>32b</code> 为 256 个。</li>
<li><code>numAvail</code> 属性，剩余可用 Subpage 的数量。</li>
<li><code>nextAvail</code> 属性，下一个可分配 Subpage 的数组( <code>bitmap</code> )位置。可能会有胖友有疑问，<code>bitmap</code> 又是数组，又考虑 bits 位，怎么计算位置呢？在 <a href="#">「2.6 getNextAvail」</a> 见分晓。</li>
<li><code>doNotDestroy</code> 属性，是否未销毁。详细解析，见 <a href="#">「2.5 free」</a> 中。</li>
</ul>
</li>
<li>Arena 相关<ul>
<li><code>prev</code> 属性，双向链表，前一个 PoolSubpage 对象。</li>
<li><code>next</code> 属性，双向链表，后一个 PoolSubpage 对象。</li>
<li>详细解析，见 <a href="#">「2.3 双向链表」</a> 。</li>
</ul>
</li>
<li>构造方法 <strong>1</strong> ，用于创建双向链表的头( head )节点。</li>
<li>构造方法 <strong>2</strong> ，用于创建双向链表的 Page 节点。<ul>
<li>第 21 行：调用 <code>#init(PoolSubpage&lt;T&gt; head, int elemSize)</code> 方法，初始化。详细解析，见 <a href="#">「2.2 init」</a> 。 </li>
</ul>
</li>
</ul>
<h2 id="2-2-init"><a href="#2-2-init" class="headerlink" title="2.2 init"></a>2.2 init</h2><p><code>#init(PoolSubpage&lt;T&gt; head, int elemSize)</code> 方法，初始化。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> elemSize)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 未销毁</span></span><br><span class="line"> <span class="number">3</span>:     doNotDestroy = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 初始化 elemSize</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">this</span>.elemSize = elemSize;</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (elemSize != <span class="number">0</span>) {</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 初始化 maxNumElems</span></span><br><span class="line"> <span class="number">8</span>:         maxNumElems = numAvail = pageSize / elemSize;</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 初始化 nextAvail</span></span><br><span class="line"><span class="number">10</span>:         nextAvail = <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 计算 bitmapLength 的大小</span></span><br><span class="line"><span class="number">12</span>:         bitmapLength = maxNumElems &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">if</span> ((maxNumElems &amp; <span class="number">63</span>) != <span class="number">0</span>) { <span class="comment">// 未整除，补 1.</span></span><br><span class="line"><span class="number">14</span>:             bitmapLength ++;</span><br><span class="line"><span class="number">15</span>:         }</span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 初始化 bitmap</span></span><br><span class="line"><span class="number">18</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) {</span><br><span class="line"><span class="number">19</span>:             bitmap[i] = <span class="number">0</span>;</span><br><span class="line"><span class="number">20</span>:         }</span><br><span class="line"><span class="number">21</span>:     }</span><br><span class="line"><span class="number">22</span>:     <span class="comment">// 添加到 Arena 的双向链表中。</span></span><br><span class="line"><span class="number">23</span>:     addToPool(head);</span><br><span class="line"><span class="number">24</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：未销毁。</li>
<li>第 5 行：初始化 <code>elemSize</code> 。<ul>
<li>第 8 行：初始化 <code>maxNumElems</code> 。</li>
</ul>
</li>
<li>第 10 行：初始化 <code>nextAvail</code> 。</li>
<li>第 11 至 15 行：初始化 <code>bitmapLength</code> 。<ul>
<li>第 17 至 20 行：初始化 <code>bitmap</code> 。</li>
</ul>
</li>
<li>第 23 行：调用 <code>#addToPool(PoolSubpage&lt;T&gt; head)</code> 方法中，添加到 Arena 的双向链表中。详细解析，见 <a href="#">「2.3.1 addToPool」</a> 中。</li>
</ul>
<h2 id="2-3-双向链表"><a href="#2-3-双向链表" class="headerlink" title="2.3 双向链表"></a>2.3 双向链表</h2><p>在每个 Arena 中，有 <code>tinySubpagePools</code> 和 <code>smallSubpagePools</code> 属性，分别表示 <strong>tiny</strong> 和 <strong>small</strong> 类型的 PoolSubpage 数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tiny 类型的 PoolSubpage 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组的每个元素，都是双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * small 类型的 SubpagePools 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组的每个元素，都是双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] smallSubpagePools;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>数组的每个元素，通过 <code>prev</code> 和 <code>next</code> 属性，形成<strong>双向</strong>链表。并且，每个元素，表示对应的 Subpage 内存规格的<strong>双向</strong>链表，例如：<code>tinySubpagePools[0]</code> 表示 <code>16B</code> ，<code>tinySubpagePools[1]</code> 表示 <code>32B</code> 。</li>
<li>通过 <code>tinySubpagePools</code> 和 <code>smallSubpagePools</code> 属性，可以从中查找，是否已经有符合分配内存规格的 Subpage 节点可分配。</li>
<li><p>初始时，每个双向链表，会创建对应的 <code>head</code> 节点，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PoolSubpage&lt;T&gt; <span class="title">newSubpagePoolHead</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>{</span><br><span class="line">    PoolSubpage&lt;T&gt; head = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(pageSize);</span><br><span class="line">    head.prev = head;</span><br><span class="line">    head.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较神奇的是，<code>head</code> 的上下节点都是<strong>自己</strong>。也就说，这是个双向环形( 循环 )链表。</li>
</ul>
</li>
</ul>
<h3 id="2-3-1-addToPool"><a href="#2-3-1-addToPool" class="headerlink" title="2.3.1 addToPool"></a>2.3.1 addToPool</h3><p><code>#addToPool(PoolSubpage&lt;T&gt; head)</code> 方法中，添加到 Arena 的双向链表中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToPool</span><span class="params">(PoolSubpage&lt;T&gt; head)</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> prev == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将当前节点，插入到 head 和 head.next 中间</span></span><br><span class="line">    prev = head;</span><br><span class="line">    next = head.next;</span><br><span class="line">    next.prev = <span class="keyword">this</span>;</span><br><span class="line">    head.next = <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将当前节点，插入到 <code>head</code> 和 <code>head.next</code> 中间。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_07/03.png" title="插入过程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_07/03.png" alt="插入过程"></a><span class="caption">插入过程</span><ul>
<li>注意，是在 <code>head</code> 和 <code>head.next</code> <strong>中间</strong>插入节点噢。</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-removeFromPool"><a href="#2-3-2-removeFromPool" class="headerlink" title="2.3.2 removeFromPool"></a>2.3.2 removeFromPool</h3><p><code>#removeFromPool()</code> 方法中，从双向链表中移除。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFromPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> prev != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前后节点，互相指向</span></span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">    <span class="comment">// 当前节点，置空</span></span><br><span class="line">    next = <span class="keyword">null</span>;</span><br><span class="line">    prev = <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-4-allocate"><a href="#2-4-allocate" class="headerlink" title="2.4 allocate"></a>2.4 allocate</h2><p><code>#allocate()</code> 方法，分配一个 Subpage 内存块，并返回该内存块的位置 <code>handle</code> 。代码如下：</p>
<blockquote>
<p>关于 <code>handle</code> 怎么翻译和解释好呢？笔者暂时没想好，官方的定义是 <code>"Returns the bitmap index of the subpage allocation."</code> 。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">long</span> <span class="title">allocate</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 防御性编程，不存在这种情况。</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (elemSize == <span class="number">0</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span> toHandle(<span class="number">0</span>);</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 可用数量为 0 ，或者已销毁，返回 -1 ，即不可分配。</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (numAvail == <span class="number">0</span> || !doNotDestroy) {</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="number">10</span>:     }</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 获得下一个可用的 Subpage 在 bitmap 中的总体位置</span></span><br><span class="line"><span class="number">13</span>:     <span class="keyword">final</span> <span class="keyword">int</span> bitmapIdx = getNextAvail();</span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 获得下一个可用的 Subpage 在 bitmap 中数组的位置</span></span><br><span class="line"><span class="number">15</span>:     <span class="keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line"><span class="number">16</span>:     <span class="comment">// 获得下一个可用的 Subpage 在 bitmap 中数组的位置的第几 bits</span></span><br><span class="line"><span class="number">17</span>:     <span class="keyword">int</span> r = bitmapIdx &amp; <span class="number">63</span>;</span><br><span class="line"><span class="number">18</span>:     <span class="keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span>:     <span class="comment">// 修改 Subpage 在 bitmap 中不可分配。</span></span><br><span class="line"><span class="number">20</span>:     bitmap[q] |= <span class="number">1L</span> &lt;&lt; r;</span><br><span class="line"><span class="number">21</span>: </span><br><span class="line"><span class="number">22</span>:     <span class="comment">// 可用 Subpage 内存块的计数减一</span></span><br><span class="line"><span class="number">23</span>:     <span class="keyword">if</span> (-- numAvail == <span class="number">0</span>) { <span class="comment">// 无可用 Subpage 内存块</span></span><br><span class="line"><span class="number">24</span>:         <span class="comment">// 从双向链表中移除</span></span><br><span class="line"><span class="number">25</span>:         removeFromPool();</span><br><span class="line"><span class="number">26</span>:     }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:     <span class="comment">// 计算 handle</span></span><br><span class="line"><span class="number">29</span>:     <span class="keyword">return</span> toHandle(bitmapIdx);</span><br><span class="line"><span class="number">30</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 5 行：防御性编程，不存在这种情况。</li>
<li>第 7 至 10 行：可用数量为 0 ，或者已销毁，返回 -1 ，即<strong>不可分配</strong>。</li>
<li>第 12 至 20 行：分配一个 Subpage 内存块。<ul>
<li>第 13 行：调用 <code>#getNextAvail()</code> 方法，获得下一个可用的 Subpage 在 bitmap 中的<strong>总体</strong>位置。详细解析，见 <a href="#">「2.6 getNextAvail」</a> 。</li>
<li>第 15 行：<code>bitmapIdx &gt;&gt;&gt; 6 = bitmapIdx / 64</code> 操作，获得下一个可用的 Subpage 在 bitmap 中<strong>数组的位置</strong>。</li>
<li>第 17 行：<code>bitmapIdx &amp; 63 = bitmapIdx % 64</code> 操作， 获得下一个可用的 Subpage 在 bitmap 中数组的位置的<strong>第几 bit</strong> 。</li>
<li>第 20 行：<code>| (1L &lt;&lt; r)</code> 操作，修改 Subpage 在 bitmap 中不可分配。</li>
</ul>
</li>
<li>第 23 行：可用 Subpage 内存块的计数减一。<ul>
<li>第 25 行：当 <code>numAvail == 0</code> 时，表示无可用 Subpage 内存块。所以，调用 <code>#removeFromPool()</code> 方法，从双向链表中移除。详细解析，见 <a href="#">「2.3.2 removeFromPool」</a> 。</li>
</ul>
</li>
<li><p>第 29 行：调用 <code>#toHandle(bitmapIdx)</code> 方法，计算 <code>handle</code> 值。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">toHandle</span><span class="params">(<span class="keyword">int</span> bitmapIdx)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x4000000000000000L</span> | (<span class="keyword">long</span>) bitmapIdx &lt;&lt; <span class="number">32</span> | memoryMapIdx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>低 32 bits ：<code>memoryMapIdx</code> ，可以判断所属 Chunk 的哪个 Page 节点，即 <code>memoryMap[memoryMapIdx]</code> 。</li>
<li>高 32 bits ：<code>bitmapIdx</code> ，可以判断 Page 节点中的哪个 Subpage 的内存块，即 <code>bitmap[bitmapIdx]</code> 。<ul>
<li>那么为什么会有 <code>0x4000000000000000L</code> 呢？因为在 <code>PoolChunk#allocate(int normCapacity)</code> 中：<ul>
<li>如果分配的是 Page 内存块，返回的是 <code>memoryMapIdx</code> 。</li>
<li>如果分配的是 Subpage 内存块，返回的是 <code>handle</code> 。<strong>但但但是</strong>，如果说 <code>bitmapIdx = 0</code> ，那么没有 <code>0x4000000000000000L</code> 情况下，就会和【分配 Page 内存块】冲突。因此，需要有 <code>0x4000000000000000L</code> 。</li>
</ul>
</li>
<li>因为有了 <code>0x4000000000000000L</code>(最高两位为 <code>01</code> ，其它位为 <code>0</code> )，所以获取 <code>bitmapIdx</code> 时，通过 <code>handle &gt;&gt;&gt; 32 &amp; 0x3FFFFFFF</code> 操作。使用 <code>0x3FFFFFFF</code>( 最高两位为 <code>00</code> ，其它位为 <code>1</code> ) 进行消除 <code>0x4000000000000000L</code> 带来的影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-5-free"><a href="#2-5-free" class="headerlink" title="2.5 free"></a>2.5 free</h2><p><code>#free(PoolSubpage&lt;T&gt; head, int bitmapIdx)</code> 方法，释放指定位置的 Subpage 内存块，并返回当前 Page <strong>是否正在使用中</strong>( <code>true</code> )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">boolean</span> <span class="title">free</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> bitmapIdx)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 防御性编程，不存在这种情况。</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (elemSize == <span class="number">0</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 获得 Subpage 在 bitmap 中数组的位置</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// 获得 Subpage 在 bitmap 中数组的位置的第几 bits</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">int</span> r = bitmapIdx &amp; <span class="number">63</span>;</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 修改 Subpage 在 bitmap 中可分配。</span></span><br><span class="line"><span class="number">12</span>:     bitmap[q] ^= <span class="number">1L</span> &lt;&lt; r;</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 设置下一个可用为当前 Subpage</span></span><br><span class="line"><span class="number">15</span>:     setNextAvail(bitmapIdx);</span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:     <span class="comment">// 可用 Subpage 内存块的计数加一</span></span><br><span class="line"><span class="number">18</span>:     <span class="keyword">if</span> (numAvail ++ == <span class="number">0</span>) {</span><br><span class="line"><span class="number">19</span>:         <span class="comment">// 添加到 Arena 的双向链表中。</span></span><br><span class="line"><span class="number">20</span>:         addToPool(head);</span><br><span class="line"><span class="number">21</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">22</span>:     }</span><br><span class="line"><span class="number">23</span>: </span><br><span class="line"><span class="number">24</span>:     <span class="comment">// 还有 Subpage 在使用</span></span><br><span class="line"><span class="number">25</span>:     <span class="keyword">if</span> (numAvail != maxNumElems) {</span><br><span class="line"><span class="number">26</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">27</span>:     <span class="comment">// 没有 Subpage 在使用</span></span><br><span class="line"><span class="number">28</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">29</span>:         <span class="comment">// 双向链表中，只有该节点，不进行移除</span></span><br><span class="line"><span class="number">30</span>:         <span class="comment">// Subpage not in use (numAvail == maxNumElems)</span></span><br><span class="line"><span class="number">31</span>:         <span class="keyword">if</span> (prev == next) {</span><br><span class="line"><span class="number">32</span>:             <span class="comment">// Do not remove if this subpage is the only one left in the pool.</span></span><br><span class="line"><span class="number">33</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">34</span>:         }</span><br><span class="line"><span class="number">35</span>: </span><br><span class="line"><span class="number">36</span>:         <span class="comment">// 标记为已销毁</span></span><br><span class="line"><span class="number">37</span>:         <span class="comment">// Remove this subpage from the pool if there are other subpages left in the pool.</span></span><br><span class="line"><span class="number">38</span>:         doNotDestroy = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">39</span>:         <span class="comment">// 从双向链表中移除</span></span><br><span class="line"><span class="number">40</span>:         removeFromPool();</span><br><span class="line"><span class="number">41</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">42</span>:     }</span><br><span class="line"><span class="number">43</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 5 行：防御性编程，不存在这种情况。</li>
<li>第 6 至 12 行：释放指定位置的 Subpage 内存块。<ul>
<li>第 7 行：<code>bitmapIdx &gt;&gt;&gt; 6 = bitmapIdx / 64</code> 操作，获得下一个可用的 Subpage 在 bitmap 中<strong>数组的位置</strong>。</li>
<li>第 9 行：<code>bitmapIdx &amp; 63 = bitmapIdx % 64</code> 操作， 获得下一个可用的 Subpage 在 bitmap 中数组的位置的<strong>第几 bit</strong> 。</li>
<li>第 12 行：<code>^ (1L &lt;&lt; r)</code> 操作，修改 Subpage 在 bitmap 中可分配。</li>
</ul>
</li>
<li><p>第 15 行：调用 <code>#setNextAvail(int bitmapIdx)</code> 方法，设置下一个可用为当前 Subpage 的位置。这样，就能避免下次分配 Subpage 时，再去找位置。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextAvail</span><span class="params">(<span class="keyword">int</span> bitmapIdx)</span> </span>{</span><br><span class="line">    nextAvail = bitmapIdx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 18 行：可用 Subpage 内存块的计数加一。</p>
<ul>
<li>第 20 行：当之前 <code>numAvail == 0</code> 时，表示<strong>又有</strong>可用 Subpage 内存块。所以，调用 <code>#addToPool(PoolSubpage&lt;T&gt; head)</code> 方法，添加到 Arena 的双向链表中。详细解析，见 <a href="#">「2.3.1 addToPool」</a> 。</li>
<li>第 21 行：返回 <code>true</code> ，正在使用中。</li>
</ul>
</li>
<li>第 24 至 26 行：返回 <code>true</code> ，因为还有其它在使用的 Subpage 内存块。</li>
<li>第 27 至 42 行：没有 Subpage 在使用。<ul>
<li>第 29 至 34 行：返回 <code>true</code> ，因为通过 <code>prev == next</code> 可判断，当前节点为双向链表中的唯一节点，不进行移除。也就说，该节点后续，继续使用。</li>
<li>第 36 至 41 行：返回 <code>false</code> ，不在使用中。<ul>
<li>第 38 行：标记为已销毁。 </li>
<li>第 40 行：调用 <code>#removeFromPool()</code> 方法，从双向链表中移除。因为此时双向链表中，还有其它节点可使用，<strong>没必要保持多个相同规格的节点</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>关于为什么 <code>#free(PoolSubpage&lt;T&gt; head, int bitmapIdx)</code> 方法，需要返回 <code>true</code> 或 <code>false</code> 呢？胖友再看看 <code>PoolChunk#free(long handle)</code> 方法，就能明白。答案是，如果不再使用，可以将该节点( Page )从 Chunk 中释放，标记为可用。😈😈😈</p>
<h2 id="2-6-getNextAvail"><a href="#2-6-getNextAvail" class="headerlink" title="2.6 getNextAvail"></a>2.6 getNextAvail</h2><p><code>#getNextAvail()</code> 方法，获得下一个可用的 Subpage 在 bitmap 中的<strong>总体</strong>位置。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextAvail</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> nextAvail = <span class="keyword">this</span>.nextAvail;</span><br><span class="line">    <span class="comment">// &lt;1&gt; nextAvail 大于 0 ，意味着已经“缓存”好下一个可用的位置，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (nextAvail &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">this</span>.nextAvail = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nextAvail;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;2&gt; 寻找下一个 nextAvail</span></span><br><span class="line">    <span class="keyword">return</span> findNextAvail();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，如果 <code>nextAvail</code> 大于 0 ，意味着已经“缓存”好下一个可用的位置，直接返回即可。<ul>
<li>获取好后，会将 <code>nextAvail</code> 置为 -1 。意味着，下次需要寻找下一个 <code>nextAvail</code> 。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#findNextAvail()</code> 方法，寻找下一个 <code>nextAvail</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextAvail</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] bitmap = <span class="keyword">this</span>.bitmap;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bitmapLength = <span class="keyword">this</span>.bitmapLength;</span><br><span class="line">    <span class="comment">// 循环 bitmap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) {</span><br><span class="line">        <span class="keyword">long</span> bits = bitmap[i];</span><br><span class="line">        <span class="comment">// ~ 操作，如果不等于 0 ，说明有可用的 Subpage</span></span><br><span class="line">        <span class="keyword">if</span> (~bits != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 在这 bits 寻找可用 nextAvail</span></span><br><span class="line">            <span class="keyword">return</span> findNextAvail0(i, bits);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友直接看注释。</li>
<li><p>调用 <code>#findNextAvail0(int i, long bits)</code> 方法，在这 bits 寻找可用 <code>nextAvail</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextAvail0</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> bits)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">final</span> <span class="keyword">int</span> maxNumElems = <span class="keyword">this</span>.maxNumElems;</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 计算基础值，表示在 bitmap 的数组下标</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">final</span> <span class="keyword">int</span> baseVal = i &lt;&lt; <span class="number">6</span>; <span class="comment">// 相当于 * 64</span></span><br><span class="line"> <span class="number">5</span>: </span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 遍历 64 bits</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j ++) {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 计算当前 bit 是否未分配</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> ((bits &amp; <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line"><span class="number">10</span>:             <span class="comment">// 可能 bitmap 最后一个元素，并没有 64 位，通过 baseVal | j &lt; maxNumElems 来保证不超过上限。</span></span><br><span class="line"><span class="number">11</span>:             <span class="keyword">int</span> val = baseVal | j;</span><br><span class="line"><span class="number">12</span>:             <span class="keyword">if</span> (val &lt; maxNumElems) {</span><br><span class="line"><span class="number">13</span>:                 <span class="keyword">return</span> val;</span><br><span class="line"><span class="number">14</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">15</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">16</span>:             }</span><br><span class="line"><span class="number">17</span>:         }</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 去掉当前 bit</span></span><br><span class="line"><span class="number">19</span>:         bits &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="number">20</span>:     }</span><br><span class="line"><span class="number">21</span>: </span><br><span class="line"><span class="number">22</span>:     <span class="comment">// 未找到</span></span><br><span class="line"><span class="number">23</span>:     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="number">24</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：计算基础值，表示在 <code>bitmap</code> 的数组<strong>下标</strong>。通过 <code>i &lt;&lt; 6 = i * 64</code> 的计算，我们可以通过 <code>i &gt;&gt;&gt; 6 = i / 64</code> 的方式，知道是 <code>bitmap</code> 数组的第几个元素。</li>
<li>第 7 行：循环 64 bits 。<ul>
<li>第 9 行：<code>(bits &amp; 1) == 0</code> 操作，计算当前 bit 是否<strong>未分配</strong>。<ul>
<li>第 11 行：<code>baseVal | j</code> 操作，使用<strong>低 64 bits</strong> ，表示分配 <code>bitmap</code> 数组的元素的<strong>第几 bit</strong> 。</li>
<li>第 12 行：可能 <code>bitmap</code> 数组的最后一个元素，并没有 64 位，通过 <code>baseVal | j &lt; maxNumElems</code> 来保证不超过上限。如果<ul>
<li>第 13 行：未超过，返回 <code>val</code> 。</li>
<li>第 15 行：超过，结束循环，最终返回 <code>-1</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>第 19 行：去掉当前 bit 。这样，下次循环就可以判断下一个 bit 是否<strong>未分配</strong>。</li>
</ul>
</li>
<li>第 23 行：返回 <code>-1</code> ，表示未找到。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-6-destroy"><a href="#2-6-destroy" class="headerlink" title="2.6 destroy"></a>2.6 destroy</h2><p><code>#destroy()</code> 方法，销毁。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="keyword">null</span>) {</span><br><span class="line">        chunk.destroy();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-7-PoolSubpageMetric"><a href="#2-7-PoolSubpageMetric" class="headerlink" title="2.7 PoolSubpageMetric"></a>2.7 PoolSubpageMetric</h2><p><code>io.netty.buffer.PoolSubpageMetric</code> ，PoolSubpage Metric 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PoolSubpageMetric</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of maximal elements that can be allocated out of the sub-page.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumElements</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of available elements to be allocated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numAvailable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the size (in bytes) of the elements that will be allocated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">elementSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the size (in bytes) of this page.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>PoolChunk 对 PoolChunkMetric 接口的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumElements</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (chunk.arena) {</span><br><span class="line">        <span class="keyword">return</span> maxNumElems;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numAvailable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (chunk.arena) {</span><br><span class="line">        <span class="keyword">return</span> numAvail;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">elementSize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (chunk.arena) {</span><br><span class="line">        <span class="keyword">return</span> elemSize;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> pageSize;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>PoolSubpage 相比 PoolChunk 来说，简单好多。嘿嘿。</p>
<p>参考如下文章：</p>
<ul>
<li>占小狼 <a href="https://www.jianshu.com/p/d91060311437" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolSubpage》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/7afd3a801b15" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–PoolSubpage》</a></li>
</ul>


</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-3-3-Jemalloc-subpage/" data-id="ck4pl3fp600e5fgcf7ybsopht" class="article-share-link">分享</a>



</footer>
-->
</div>