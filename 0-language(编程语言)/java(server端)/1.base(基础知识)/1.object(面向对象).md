### 1.什么是面向对象

    1.1 面向过程定义
        面向过程：POP(procedure oriented programming)
        面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。
    
    1.2 面向对象定义
        面向对象：OOP(object oriented programming)
        面向对象是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所
        发生的行为。
    
    1.3 面向对象的三大基本特征
        面向对象具备封装、继承、多态三大特征
        
        1.3.1 封装
            封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过
        任何形式修改对象内部实现，正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象
        实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。
        
        1.3.2 继承
        　　 继承来源于现实世界，一个最简单的例子就是孩子会具有父母的一些特征，即每个孩子都会继承父亲或者母亲的某些特征，当然这只是最基本
        的继承关系，现实世界中还存在着更复杂的继承，面向对象之所以使用继承机制主要是用于实现代码的复用多个类所公用的代码部分可以只在一个
        类中提供，而其他类只需要继承即可。
        
        1.3.3 多态
        　　 多态与继承纤细紧密，是面向对象编程中另一个突出的特征，所谓的多态是指在继承体系中，所有派生类都从基类继承接口，但由于每个派生类
        都是独立的实体，因此在接收同一消息的时候，可能会生成不同的响应。多态的作用作为隐藏代码实现细节， 使得代码能够模块化;扩展代码模块，
        实现接口重用。简单来说：一种行为产生多种效果。
       
    1.4 面向对象的五大基本原则
        1.4.1 单一职责原则(SRP)：
            SRP(Single Responsibilities Principle)的定义：就一个类而言，应该仅有一个引起它变化的原因。简而言之，就是功能要单一。
            如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，
            当变化发生时，设计会遭受到意想不到的破坏。(敏捷软件开发)
            软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。(敏捷软件开发)
            
            总结：单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
            职责过多，可能引起它变化的原因就越多，这样导致职责依赖，相互之间就会产生原因，大大损伤其内聚性和耦合度。
    
        1.4.2 开-闭原则(OCP)：
            OCP(Open-Close Principle)的定义：就是说软件实体(类，方法等等)应该可以扩展，但是不能修改。它是软件设计中也是最重要的一种设计原则。
            OCP的两个特征：对于扩展是开放的,对于修改是封闭的。
            
            什么时候应用OCP原则呢？在我们最初编写代码时，假设变化不会发生，当变化发生时，我们就创建抽象(比如抽象类，接口等等)来隔离以后发生的同类变化。
            开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。
            开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意
            。拒绝不成熟的抽象和抽象本身一样重要。OCP的UML图如下
            ![](1.object(面向对象)/1.4.2-ocp.jpg)
            
            总结：开放封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处：可维护、可扩展、可复用、灵活性好。
            开发人员应该仅对程序中呈现频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样也不是一个好主意。
            拒绝不成熟的抽象和抽象本身一样重要。“需求总是变化”没有不变的软件，所以需要用开放封闭原则来封闭变化满足需求，
            同时还能保持软件内部的封装体系稳定，不被需求的变化影响。
    
        1.4.3 依赖倒转原则(DIP)：
            DIP(Dependence Inversion Principle)的定义：抽象不应该依赖细节，细节应该依赖于抽象。简单说就是，我们要针对接口编程，而不要针对实现编程。
            高层模块不应该依赖低层模块。两个都应该依赖抽象。抽象不应该依赖具体（细节）。具体（细节）应该依赖抽象。
            反面例子：
                高层模块-->引用-->底层模块（比如db中间件依赖一个商城系统，商城系统改变，将会影响db中间件）
        　　 缺点：高层模块太依赖低层模块，耦合太紧密。低层模块发生变化会影响到高层模块。
        　　 解决方法：利用依赖倒置原则使高层模块和低层模块都依赖于抽象(接口或抽象类)。
        　　
            修改后如下：
                定义抽象层（高层模块--->引用--->抽象层;底层模块---->引用----->抽象层）
            优点：这样的话修改低层模块不会影响到高层模块，减小了它们之间的耦合度，增强系统的稳定性。
            
            总结：依赖倒置原则其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对
            细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。
    
        1.4.4 接口隔离原则：
    
            使用多个专门的接口比使用单一的总接口要好。
            一个类对另外一个类的依赖性应当是建立在最小的接口上的。
            一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。
            “不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，
            不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。
            
            总结:接口隔离的方法有两种（分享客户就是分离接口）：
            (1)使用委托（此委托非.net委托[delegate]）分离接口
            使用委托即，创建一个委托类，用此类去实现分离后的其它接口中的方法。
            (2)使用多重继承分离接口、
            此方法，即将现有“胖”接口分成供不同客户程序调用的两个或多个接口，而需要实现多个接口的客户程序，则使用多重继承来实现。
        
         1.4.5 Liskov（里氏）替换原则(LSP)
            LSP(Liskov Substitution Principle)的定义：子类型必须能够替换掉它们的父类型
            简单地说，这是因为子类型继承了父类，所以子类可以以父类的身份出现。
            interface Animal{
                void run();
            }
            class Dog implements Animal{
                void run(){
                    System.out.println("dog run")
                }
            }
            class Cat implements Animal{
                void run(){
                    System.out.println("cat run")
                }
            }
            总结：任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，
            基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。
            实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
    
        1.4.5 迪米特法则(LoD)
            自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量
            的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。迪米特法则又叫最少
            知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。
            也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。
            迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，
            只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、
            方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在
            类的内部。
            (1)LoD(Law of Demeter)的定义：如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用。如果其中一个类需要调用另一个类的
            某一个方法的话，可以通过第三者转发这个调用。
            (2)在类的结构设计上，每一个类都应当尽量降低成员的访问权限，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行
            为(方法)就尽量不要公开。
            定义：一个对象应该对其他对象保持最少的了解。
            问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 
            解决方案：尽量降低类与类之间的耦合。
            举例：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。
            现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接
            朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加
            了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。
            
            class SubCompanyManager{
                public List<SubEmployee> getAllEmployee(){
                    List<SubEmployee> list = new ArrayList<SubEmployee>();
                    for(int i=0; i<100; i++){
                        SubEmployee emp = new SubEmployee();
                        //为分公司人员按顺序分配一个ID
                        emp.setId("分公司"+i);
                        list.add(emp);
                    }
                    return list;
                }
                public void printEmployee(){
                    List<SubEmployee> list = this.getAllEmployee();
                    for(SubEmployee e:list){
                        System.out.println(e.getId());
                    }
                }
            }
            
            class CompanyManager{
                public List<Employee> getAllEmployee(){
                    List<Employee> list = new ArrayList<Employee>();
                    for(int i=0; i<30; i++){
                        Employee emp = new Employee();
                        //为总公司人员按顺序分配一个ID
                        emp.setId("总公司"+i);
                        list.add(emp);
                    }
                    return list;
                }
                
                public void printAllEmployee(SubCompanyManager sub){
                    sub.printEmployee();
                    List<Employee> list2 = this.getAllEmployee();
                    for(Employee e:list2){
                        System.out.println(e.getId());
                    }
                }
            }
            修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。
            迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，
            虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，
            例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，
            导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。

### 2.平台无关性
    2.1 Java如何实现平台无关性
        java源文件(.java)通过编译器生成字节码文件（.class），字节码文件（.class）通过JVM（Java虚拟机）中的解释器再翻译成特定机器上的机器码
        ，然后在特定的机器上运行。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。
        ①编写JAVA源文件（.JAVA）
        ②JAVA源文件经过编译器后，被编译成字节码文件（.class）
        C/C++是编译型语言，因为他们可以直接编译成操作系统可以识别的可执行文件。但JAVA编译后只能形成被JAVA自己识别的class文件，然后
        解释class文件才能翻译成各个操作系统可以直接认识的可运行文件，所以JAVA是解释型语言
        JAVA编译过程同C/C++ 的 编译有些不同。当C编译器编译生成一个对象的代码时，该代码是为在某一特定硬件平台运行而产生的。
        因此，在编译过程中，编译程序通过查表将所有对符号的引 用转换为特定的内存偏移量，以保证程序运行。Java编译器却不将对变量和方法的引用
        编译为数值引用，也不确定程序执行过程中的内存布局，而是将这些符号 引用信息保留在字节码中，由解释器在运行过程中创立内存布局，然后再
        通过查表来确定一个方法所在的地址。这样就有效的保证了Java的可移植性和安全 性。
        ③装入：装入代码的工作由"类装载器"（class loader）完成。类装载器负责装入运行一个程序需要的所有代码，这也包括程序代码中的类所继承
        的类和被其调用的类，例如上图中的类库。当类装载器装入一个类时，该类被放 在自己的名字空间中。除了通过符号引用自己名字空间以外的类，
        类之间没有其他办法可以影响其他类。在本台计算机上的所有类都在同一地址空间内，而所有从外 部引进的类，都有一个自己独立的名字空间。
        这使得本地类通过共享相同的名字空间获得较高的运行效率，同时又保证它们与从外部引进的类不会相互影响。当装入 了运行程序需要的所有类后，
        解释器便可确定整个可执行程序的内存布局。解释器为符号引用同特定的地址空间建立对应关系及查询表。通过在这一阶段确定代码的 内存布局，
        Java很好地解决了由超类改变而使子类崩溃的问题，同时也防止了代码对地址的非法访问。
        ④字节码校验：被装入的代码由字节码校验器进行检查。校验器可发现操作数栈溢出，非法数据类型转化等多种错误。
        ⑤通过校验后，代码便开始执行了。
            Java字节码的执行有两种方式：
        　　1.即时编译方式：解释器先将字节码编译成机器码，然后再执行该机器码。
        　　2.解释执行方式：解释器通过每次解释并执行一小段代码来完成Java字节码程 序的所有操作。
        需要说明的是：解释字节码比全速运行机器码指令慢很多。早期的JAVA是解释性的，现在除了像手机这样的“微型”平台之外，JAVA虚拟机使用了
        及时编译器，可以把使用最频繁的字节码翻译成机器码，这个过程被称作即时编译。
        
    2.2 JVM支持那些语言
        Java、Kotlin、Grovy、JRuby、Jython、Scala


### 3. 值传递
    形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行
    完成后，a就会被销毁释放空间，也就是不存在了
    实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。
    
    3.1 值传递
    在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，
    都仅仅是对这个副本的操作，不影响原始值的内容。
    
    3.2 引用传递
    引用传递：
    ”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，
    对形参的操作会影响的真实内容。
    
    3.3 为什么Java只有值传递
    在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。
    只是在传递过程中：
    如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。
    如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。
    一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。
    实例：
    第一个例子：基本类型
    void foo(int value) {
        value = 100;
    }
    foo(num); // num 没有被改变
    
    第二个例子：没有提供改变自身方法的引用类型
    void foo(String text) {
        text = "windows";
    }
    foo(str); // str 也没有被改变
    
    第三个例子：提供了改变自身方法的引用类型
    StringBuilder sb = new StringBuilder("iphone");
    void foo(StringBuilder builder) {
        builder.append("4");
    }
    foo(sb); // sb 被改变了，变成了"iphone4"。
    
    第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
    StringBuilder sb = new StringBuilder("iphone");
    void foo(StringBuilder builder) {
        builder = new StringBuilder("ipad");
    }
    foo(sb); // sb 没有被改变，还是 "iphone"。
    
    由此可见Java为值传递，基本类型为副本（值），对象为对象引用的副本，修改对象成员对象修改，修改对象指向原对象不变
### 4 继承多态封装
    4.1 什么是多态
        指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）
        实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
        多态的作用：消除类型之间的耦合关系。
    4.2 方法的重写与重载
        重写子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖。
        
        重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。
        所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。
        方法的重载在实际应用中也会经常用到。不仅是一般的方法，构造方法也可以重载。
    4.3 Java的继承与实现
        extends:继承，单继承，类可以被子类继承
        implements：实现，可以多实现，接口被类实现
        
        Java中普通类只支持单继承，不支持多重继承，也就是说在java中一个类只能有一个父类。可是在实际应用中，我们又往往需要使用多重继承来解决
        问题。那这不是前后矛盾了么？又说不能多重继承，又说要使用多重继承来解决问题。其实这是有原因的的，下面我们就来具体说说。首先，我们来
        说说为什么Java不支持多重继承。先假设Java支持多重继承，注意是假设，事实并不支持的。举个例子，类C继承类B和类A，A、B都有一个返回值、
        方法名、参数都完全相同的而内部实现不同的方法，那么类C就不知道该继承哪个类里的方法，从而出现问题。所以为了避免此类问题Java不支持多
        重继承。既然Java不支持多重继承，那我们遇到需要使用多重继承来解决的问题，我们又该怎么办呢？为此，Java提出了接口的思想，接口本质上
        也是一个类，只不过它所有的方法都是抽象的，也就是说所有的方法都只是做了声明而没有具体的实现内容。为了与普通的类做出区别， 这种特殊
        的类我们不称为类，而命名为接口。类可以继承多个接口，因为对于前面举的例子，由于方法都是抽象没有实现的，类继承哪个接口的方法都无所谓
        了，都 只是个声明而已。不过为了避免与Java不支持多重继承混淆，我们把类继承接口不称作继承而称作实现，也就是说一个类可以实现多个接口。
        同时当类实现接口 时，是要对接口声明的抽象方法具体实现的，所以类实现接口的称呼也显得更加贴切。同理，接口也可以继承接口的，而且一个
        接口可以继承多个接口，因为方法都是抽象的，所以不会引起‘不知道该继承哪个方法’的问题。综述，普通类和接口本质上是一样的，原则是不能出
        现继承方法混乱。
       
    4.4 构造函数
        java构造函数，也叫构造方法，是java中一种特殊的函数。函数名与相同，无返回值。
        作用：一般用来初始化成员属性和成员方法的，即new对象产生后，就调用了对象了属性和方法。
        未定义构造函数采用默认构造函数
        (1)函数名与类名相同
        (2)不用定义返回值类型。（不同于void类型返回值，void是没有具体返回值类型；构造函数是连类型都没有）
        (3)不可以写return语句。（返回值类型都没有，也就不需要return语句了）
        子类构造函数：super语句必须要定义在子类构造函数的第一行。因为父类的初始化动作要先完成。即先初始化父类
    4.5 变量
        类变量、成员变量（实例变量）、局部变量
        局部变量：
            就是本地变量，在方法、构造器或者块中使用，在方法、构造器或者块进入时被创建，一旦退出该变量就会被销毁
            局部变量没有默认值，因此本地变量必须被声明并且在第一次使用前要给它赋值
        实例变量：
            在类中声明，但是它在方法、构造器或者块外，当堆中的对象被分配了一个空间时，每个实例变量的位置就被创建了。
            当对象采用关键字“new”创建时实例变量就被创建了，当对象被销毁时它也就被销毁了。实例变量的值必须被一个以上的方法、构造器或者块，
            或者类中必须出现的对象的状态的重要部分所引用，实例变量可以用访问描述符，实例变量有默认值。数字的默认为0，boolean的默认为false，
            对象引用默认值为NULL，实例变量可以直接采用在类中叫名字方式访问。然而在静态方法和不同的类中应当使用完全限定名称。
            ObjectReference.VariableName，实例变量是归属于类的实例的变量，又称为成员变量，没有经过static修饰。实例变量只能通过类名的实例，
            +点操作符+变量来操作。
        类变量：也叫静态变量，在类中用static关键字声明，但是它在方法、构造器或者块之外。
               每个类只有一个类变量，不管这个类有多少个对象。
        　　　　除了作为常量被声明之外，类变量很少被应用。常量是被作为public、private、final和static被声明的变量。例变量的初始值不会被改变
        　　　　静态变量存储在静态内存中，很少采用静态变量而不是声明结束或者用常量public或private之一。
        　　　　静态变量随着程序的开始和结束而开始和结束。
        　　　　可见性和实例变量类似。然而大多数静态变量被声明为public由于他们必须为类的使用者所用。
        　　　　默认值和实例变量类似，除此之外，可以在特殊的静态初始化区赋值
        　　　　静态变量可以用类的名称访问ClassName.VariableName，静态变量被作为public static final声明时，变量（常量）名称都要用大写字母。如果静态变量不是public和final，它的命名方法和实例变量和本地变量相同。
    4.6 作用域
        静态域：
            初始化执行
        成员变量域：
            对象分为private、protect、public 默认包访问权限
        方法域：
            方法域：成员变量
    


参考:
面向对象：https://www.cnblogs.com/yuan-jun/p/6628497.html

Java平台无关性：https://www.cnblogs.com/beyourself/p/3279503.html

值传递:https://www.colabug.com/2351590.html
      https://www.zhihu.com/question/31203609/answer/50992895
