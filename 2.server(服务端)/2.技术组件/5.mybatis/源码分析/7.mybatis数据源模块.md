<div class="article-inner">

<header class="article-header">


<h1 class="article-title" itemprop="name">
精尽 MyBatis 源码分析 —— 数据源模块
</h1>



<a href="/MyBatis/datasource-package/" class="archive-article-date">
<time style="display: none;" datetime="2020-01-15T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-01-16</time>
</a>

</header>

<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来分享 MyBatis 的数据源模块，对应 <code>datasource</code> 包。如下图所示：<img src="http://static2.iocoder.cn/images/MyBatis/2020_01_16/01.png" alt="`datasource` 包"></p>
<p>在 <a href="http://svip.iocoder.cn/MyBatis/intro">《精尽 MyBatis 源码解析 —— 项目结构一览》</a> 中，简单介绍了这个模块如下：</p>
<blockquote>
<p>数据源是实际开发中常用的组件之一。现在开源的数据源都提供了比较丰富的功能，例如，连接池功能、检测连接状态等，选择性能优秀的数据源组件对于提升 ORM 框架乃至整个应用的性能都是非常重要的。</p>
<p>MyBatis <strong>自身提供了相应的数据源实现，当然 MyBatis 也提供了与第三方数据源集成的接口，这些功能都位于数据源模块之中</strong>。</p>
</blockquote>
<p>本文涉及的类如下图所示：<img src="http://static2.iocoder.cn/images/MyBatis/2020_01_16/02.png" alt="类图"></p>
<p>下面，我们就一起来看看具体的源码实现。</p>
<h1 id="2-DataSourceFactory"><a href="#2-DataSourceFactory" class="headerlink" title="2. DataSourceFactory"></a>2. DataSourceFactory</h1><p><code>org.apache.ibatis.datasource.DataSourceFactory</code> ，<code>javax.sql.DataSource</code> 工厂接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 DataSource 对象的属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> props 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 DataSource 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DataSource 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-1-UnpooledDataSourceFactory"><a href="#2-1-UnpooledDataSourceFactory" class="headerlink" title="2.1 UnpooledDataSourceFactory"></a>2.1 UnpooledDataSourceFactory</h2><p><code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> ，实现 DataSourceFactory 接口，非池化的 DataSourceFactory 实现类。</p>
<blockquote>
<p>FROM <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 文档 —— XML 映射配置文件》</a></p>
<p><strong>UNPOOLED</strong>– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。 不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p>
<ul>
<li><code>driver</code> – 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的数据源类）。</li>
<li><code>url</code> – 这是数据库的 JDBC URL 地址。</li>
<li><code>username</code> – 登录数据库的用户名。</li>
<li><code>password</code> – 登录数据库的密码。</li>
<li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li>
</ul>
<p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为“driver.”，例如：</p>
<ul>
<li><code>driver.encoding=UTF8</code></li>
</ul>
<p>这将通过 <code>DriverManager.getConnection(url,driverProperties)</code> 方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。</p>
</blockquote>
<h3 id="2-1-1-构造方法"><a href="#2-1-1-构造方法" class="headerlink" title="2.1.1 构造方法"></a>2.1.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DataSource 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 UnpooledDataSource 对象</span></span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认创建了 UnpooledDataSource 对象。</li>
</ul>
<h3 id="2-1-2-getDataSource"><a href="#2-1-2-getDataSource" class="headerlink" title="2.1.2 getDataSource"></a>2.1.2 getDataSource</h3><p><code>#getDataSource()</code> 方法，返回 DataSource 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-1-3-setProperties"><a href="#2-1-3-setProperties" class="headerlink" title="2.1.3 setProperties"></a>2.1.3 setProperties</h3><p><code>#setProperties(Properties properties)</code> 方法，将 <code>properties</code> 的属性，初始化到 <code>dataSource</code> 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line">    Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 创建 dataSource 对应的 MetaObject 对象</span></span><br><span class="line">    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">    <span class="comment">// 遍历 properties 属性，初始化到 driverProperties 和 MetaObject 中</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : properties.keySet()) {</span><br><span class="line">        String propertyName = (String) key;</span><br><span class="line">        <span class="comment">// 初始化到 driverProperties 中</span></span><br><span class="line">        <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) { <span class="comment">// 以 "driver." 开头的配置</span></span><br><span class="line">            String value = properties.getProperty(propertyName);</span><br><span class="line">            driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">        <span class="comment">// 初始化到 MetaObject 中</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) {</span><br><span class="line">            String value = (String) properties.get(propertyName);</span><br><span class="line">            Object convertedValue = convertValue(metaDataSource, propertyName, value); <span class="comment">// &lt;1&gt; 转化属性</span></span><br><span class="line">            metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">"Unknown DataSource property: "</span> + propertyName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置 driverProperties 到 MetaObject 中</span></span><br><span class="line">    <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) {</span><br><span class="line">        metaDataSource.setValue(<span class="string">"driverProperties"</span>, driverProperties);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友直接看下代码。</li>
<li><code>&lt;1&gt;</code> 处，调用 <code>#convertValue(MetaObject metaDataSource, String propertyName, String value)</code> 方法，将字符串转化成对应属性的类型。代码如下：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">convertValue</span><span class="params">(MetaObject metaDataSource, String propertyName, String value)</span> </span>{</span><br><span class="line">    Object convertedValue = value;</span><br><span class="line">    <span class="comment">// 获得该属性的 setting 方法的参数类型</span></span><br><span class="line">    Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName);</span><br><span class="line">    <span class="comment">// 转化</span></span><br><span class="line">    <span class="keyword">if</span> (targetType == Integer.class || targetType == <span class="keyword">int</span>.class) {</span><br><span class="line">        convertedValue = Integer.valueOf(value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Long.class || targetType == <span class="keyword">long</span>.class) {</span><br><span class="line">        convertedValue = Long.valueOf(value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Boolean.class || targetType == <span class="keyword">boolean</span>.class) {</span><br><span class="line">        convertedValue = Boolean.valueOf(value);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> convertedValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-2-PooledDataSourceFactory"><a href="#2-2-PooledDataSourceFactory" class="headerlink" title="2.2 PooledDataSourceFactory"></a>2.2 PooledDataSourceFactory</h2><p><code>org.apache.ibatis.datasource.pooled.PooledDataSourceFactory</code> ，继承 UnpooledDataSourceFactory 类，池化的 DataSourceFactory 实现类。</p>
<blockquote>
<p>FROM <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 文档 —— XML 映射配置文件》</a></p>
<p><strong>POOLED</strong>– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
<p>除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code> – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10</li>
<li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li>
<li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li>
<li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。</li>
<li><code>poolMaximumLocalBadConnectionTolerance</code> – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程. 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 <code>poolMaximumIdleConnections</code> 与 <code>poolMaximumLocalBadConnectionTolerance</code> 之和。 默认值：3 (新增于 3.4.5)</li>
<li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。</li>
<li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，需要设置 <code>poolPingQuery</code> 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。</li>
<li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li>
</ul>
</blockquote>
<ul>
<li>PooledDataSource 比 UnpooledDataSource 的配置项<strong>多很多</strong>。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceFactory</span> <span class="keyword">extends</span> <span class="title">UnpooledDataSourceFactory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认创建了 PooledDataSource 对象。</li>
</ul>
<p>其它方法，在父类中 UnpooledDataSourceFactory 中已经实现。所以，真正的<strong>池化</strong>逻辑，在 PooledDataSource 对象中。</p>
<h2 id="2-3-JndiDataSourceFactory"><a href="#2-3-JndiDataSourceFactory" class="headerlink" title="2.3 JndiDataSourceFactory"></a>2.3 JndiDataSourceFactory</h2><p><code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code> ，实现 DataSourceFactory 接口，基于 JNDI 的 DataSourceFactory 实现类。</p>
<blockquote>
<p>FROM <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 文档 —— XML 映射配置文件》</a></p>
<p><strong>JNDI</strong> – 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p>
<ul>
<li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。</li>
<li><code>data_source</code> – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</li>
</ul>
<p>和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文。比如：</p>
<ul>
<li><code>env.encoding=UTF8</code></li>
</ul>
<p>这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性。</p>
</blockquote>
<h3 id="2-3-1-构造方法"><a href="#2-3-1-构造方法" class="headerlink" title="2.3.1 构造方法"></a>2.3.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JndiDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不同于 UnpooledDataSourceFactory 和 PooledDataSourceFactory ，<code>dataSource</code> 不在构造方法中创建，而是在 <code>#setProperties(Properties properties)</code> 中。</li>
</ul>
<h3 id="2-3-2-getDataSource"><a href="#2-3-2-getDataSource" class="headerlink" title="2.3.2 getDataSource"></a>2.3.2 getDataSource</h3><p><code>#getDataSource()</code> 方法，返回 DataSource 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JndiDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-3-setProperties"><a href="#2-3-3-setProperties" class="headerlink" title="2.3.3 setProperties"></a>2.3.3 setProperties</h3><p><code>#setProperties(Properties properties)</code> 方法，从上下文中，获得 DataSource 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JndiDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INITIAL_CONTEXT = <span class="string">"initial_context"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_SOURCE = <span class="string">"data_source"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENV_PREFIX = <span class="string">"env."</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        InitialContext initCtx;</span><br><span class="line">        <span class="comment">// &lt;1&gt; 获得系统 Properties 对象</span></span><br><span class="line">        Properties env = getEnvProperties(properties);</span><br><span class="line">        <span class="comment">// 创建 InitialContext 对象</span></span><br><span class="line">        <span class="keyword">if</span> (env == <span class="keyword">null</span>) {</span><br><span class="line">            initCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            initCtx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 InitialContext 上下文中，获取 DataSource 对象</span></span><br><span class="line">        <span class="keyword">if</span> (properties.containsKey(INITIAL_CONTEXT)</span><br><span class="line">                &amp;&amp; properties.containsKey(DATA_SOURCE)) {</span><br><span class="line">            Context ctx = (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));</span><br><span class="line">            dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(DATA_SOURCE)) {</span><br><span class="line">            dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (NamingException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">"There was an error configuring JndiDataSourceTransactionPool. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>目前已经很少使用 JNDI 功能了，所以胖友简单了解下就好。</li>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#getEnvProperties(Properties allProps)</code> 方法，获得系统 Properties 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JndiDataSourceFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Properties <span class="title">getEnvProperties</span><span class="params">(Properties allProps)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String PREFIX = ENV_PREFIX;</span><br><span class="line">    Properties contextProperties = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Object, Object&gt; entry : allProps.entrySet()) {</span><br><span class="line">        String key = (String) entry.getKey();</span><br><span class="line">        String value = (String) entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (key.startsWith(PREFIX)) {</span><br><span class="line">            <span class="keyword">if</span> (contextProperties == <span class="keyword">null</span>) {</span><br><span class="line">                contextProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">            }</span><br><span class="line">            contextProperties.put(key.substring(PREFIX.length()), value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> contextProperties;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h1 id="3-DataSource"><a href="#3-DataSource" class="headerlink" title="3. DataSource"></a>3. DataSource</h1><p><code>javax.sql.DataSource</code> 是个<strong>神奇</strong>的接口，在其上可以衍生出数据连接池、分库分表、读写分离等等功能。</p>
<p>如果你对 DataSource 如何实现分库分表的功能，可以看看 <a href="http://www.iocoder.cn/Sharding-JDBC/jdbc-implement-and-read-write-splitting/?svip" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 源码分析 —— JDBC实现与读写分离》</a> 。</p>
<h2 id="3-1-UnpooledDataSource"><a href="#3-1-UnpooledDataSource" class="headerlink" title="3.1 UnpooledDataSource"></a>3.1 UnpooledDataSource</h2><p><code>org.apache.ibatis.datasource.unpooled.UnpooledDataSource</code> ，实现 DataSource 接口，非池化的 DataSource 对象。</p>
<h3 id="3-1-1-构造方法"><a href="#3-1-1-构造方法" class="headerlink" title="3.1.1 构造方法"></a>3.1.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已注册的 Driver 映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * KEY：Driver 类名</span></span><br><span class="line"><span class="comment"> * VALUE：Driver 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Driver 类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Driver 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Properties driverProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Driver 类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否自动提交事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认事务隔离级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="comment">// 初始化 registeredDrivers</span></span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) {</span><br><span class="line">        Driver driver = drivers.nextElement();</span><br><span class="line">        registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, Properties driverProperties)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.driverProperties = driverProperties;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(ClassLoader driverClassLoader, String driver, String url, String username, String password)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.driverClassLoader = driverClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(ClassLoader driverClassLoader, String driver, String url, Properties driverProperties)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.driverClassLoader = driverClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.driverProperties = driverProperties;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较简单，就是属性的赋值。</li>
</ul>
<h3 id="3-1-2-getConnection"><a href="#3-1-2-getConnection" class="headerlink" title="3.1.2 getConnection"></a>3.1.2 getConnection</h3><p><code>#getConnection(...)</code> 方法，获得 Connection 连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>都是调用 <code>#doGetConnection(String username, String password)</code> 方法，获取 Connection 连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 创建 Properties 对象</span></span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 设置 driverProperties 到 props 中</span></span><br><span class="line">    <span class="keyword">if</span> (driverProperties != <span class="keyword">null</span>) {</span><br><span class="line">        props.putAll(driverProperties);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置 user 和 password 到 props 中</span></span><br><span class="line">    <span class="keyword">if</span> (username != <span class="keyword">null</span>) {</span><br><span class="line">        props.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span>) {</span><br><span class="line">        props.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 执行获得 Connection 连接</span></span><br><span class="line">    <span class="keyword">return</span> doGetConnection(props);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 初始化 Driver</span></span><br><span class="line">    initializeDriver();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 获得 Connection 对象</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 配置 Connection 对象</span></span><br><span class="line">    configureConnection(connection);</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>#initializeDriver()</code> 方法，初始化 Driver 。详细解析，见 <a href="#">「3.1.2.1 initializeDriver」</a> 。 </li>
<li><code>&lt;2&gt;</code> 处，调用 <code>java.sql.DriverManager#getConnection(String url, Properties info)</code> 方法，获得 Connection 对象。</li>
<li><code>&lt;3&gt;</code> 处，调用 <code>#configureConnection(Connection conn)</code> 方法，配置 Connection 对象。详细解析，见 <a href="#">「3.1.2.2 configureConnection」</a> 。 </li>
</ul>
</li>
</ul>
<h4 id="3-1-2-1-initializeDriver"><a href="#3-1-2-1-initializeDriver" class="headerlink" title="3.1.2.1 initializeDriver"></a>3.1.2.1 initializeDriver</h4><p><code>#initializeDriver()</code> 方法，初始化 Driver 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{ <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    <span class="comment">// 判断 registeredDrivers 是否已经存在该 driver ，若不存在，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) {</span><br><span class="line">        Class&lt;?&gt; driverType;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// &lt;2&gt; 获得 driver 类</span></span><br><span class="line">            <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) {</span><br><span class="line">                driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                driverType = Resources.classForName(driver);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// &lt;3&gt; 创建 Driver 对象</span></span><br><span class="line">            <span class="comment">// DriverManager requires the driver to be loaded via the system ClassLoader.</span></span><br><span class="line">            <span class="comment">// http://www.kfu.com/~nsayer/Java/dyn-jdbc.html</span></span><br><span class="line">            Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">            <span class="comment">// 创建 DriverProxy 对象，并注册到 DriverManager 中</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">            <span class="comment">// 添加到 registeredDrivers 中</span></span><br><span class="line">            registeredDrivers.put(driver, driverInstance);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error setting driver on UnpooledDataSource. Cause: "</span> + e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>总体逻辑比较简单，判断 <code>registeredDrivers</code> 是否已经存在该 <code>driver</code> ？若不存在，进行初始化。</li>
<li><code>&lt;1&gt;</code> 处，<code>synchronized</code> 锁的粒度太大，可以减小到基于 <code>registeredDrivers</code> 来同步，并且很多时候，不需要加锁。</li>
<li><code>&lt;2&gt;</code> 处，获得 <code>driver</code> 类，实际上，就是我们常见的 <code>"Class.forName("com.mysql.jdbc.Driver")"</code> 。</li>
<li><p><code>&lt;3&gt;</code> 处，创建 Driver 对象，并注册到 DriverManager 中，以及添加到 <code>registeredDrivers</code> 中。为什么此处会有使用 DriverProxy 呢？DriverProxy 的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSource.java 的内部私有静态类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverProxy</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    DriverProxy(Driver d) {</span><br><span class="line">        <span class="keyword">this</span>.driver = d;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptsURL</span><span class="params">(String u)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.driver.acceptsURL(u);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">connect</span><span class="params">(String u, Properties p)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.driver.connect(u, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMajorVersion</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.driver.getMajorVersion();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinorVersion</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.driver.getMinorVersion();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DriverPropertyInfo[] getPropertyInfo(String u, Properties p) <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.driver.getPropertyInfo(u, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jdbcCompliant</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.driver.jdbcCompliant();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override only valid jdk7+</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">getParentLogger</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Logger.getLogger(Logger.GLOBAL_LOGGER_NAME); <span class="comment">// &lt;4&gt;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 <code>&lt;4&gt;</code> 处，使用 MyBatis 自定义的 Logger 对象。</li>
<li>其他方法，实际就是直接调用 <code>driver</code> 对应的方法。</li>
</ul>
</li>
</ul>
<h4 id="3-1-2-2-configureConnection"><a href="#3-1-2-2-configureConnection" class="headerlink" title="3.1.2.2 configureConnection"></a>3.1.2.2 configureConnection</h4><p><code>#configureConnection(Connection conn)</code> 方法，配置 Connection 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 设置自动提交</span></span><br><span class="line">    <span class="keyword">if</span> (autoCommit != <span class="keyword">null</span> &amp;&amp; autoCommit != conn.getAutoCommit()) {</span><br><span class="line">        conn.setAutoCommit(autoCommit);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置事务隔离级别</span></span><br><span class="line">    <span class="keyword">if</span> (defaultTransactionIsolationLevel != <span class="keyword">null</span>) {</span><br><span class="line">        conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-1-3-其它方法"><a href="#3-1-3-其它方法" class="headerlink" title="3.1.3 其它方法"></a>3.1.3 其它方法</h3><p>UnpooledDataSource 还实现了 DataSource 的其它方法，感兴趣的胖友，可以自己看。实际上，不看也行。哈哈哈哈。</p>
<h2 id="3-2-PooledDataSource"><a href="#3-2-PooledDataSource" class="headerlink" title="3.2 PooledDataSource"></a>3.2 PooledDataSource</h2><p><code>org.apache.ibatis.datasource.pooled.PooledDataSource</code> ，实现 DataSource 接口，池化的 DataSource 实现类。</p>
<blockquote>
<p>FROM PooledDataSource 类上的注释</p>
<p>This is a simple, synchronous, thread-safe database connection pool.</p>
</blockquote>
<ul>
<li>实际场景下，我们基本不用 MyBatis 自带的数据库连接池的实现。所以，本文更多的目的，是让胖友们对数据库连接池的实现，有个大体的理解。</li>
</ul>
<h3 id="3-2-1-构造方法"><a href="#3-2-1-构造方法" class="headerlink" title="3.2.1 构造方法"></a>3.2.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolState 对象，记录池化的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSource 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTIONAL CONFIGURATION FIELDS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在任意时间可以存在的活动（也就是正在使用）连接数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任意时间可能存在的空闲连接数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在被强制返回之前，池中连接被检出（checked out）时间。单位：毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败）。单位：毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个关于坏连接容忍度的底层设置，作用于每一个尝试从缓存池获取连接的线程. 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String poolPingQuery = <span class="string">"NO PING QUERY SET"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 期望 Connection 的类型编码，通过 {<span class="doctag">@link</span> #assembleConnectionTypeCode(String, String, String)} 计算。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(UnpooledDataSource dataSource)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>{</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource(driver, url, username, password);</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(String driver, String url, Properties driverProperties)</span> </span>{</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource(driver, url, driverProperties);</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(ClassLoader driverClassLoader, String driver, String url, String username, String password)</span> </span>{</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource(driverClassLoader, driver, url, username, password);</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(ClassLoader driverClassLoader, String driver, String url, Properties driverProperties)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 UnpooledDataSource 对象</span></span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource(driverClassLoader, driver, url, driverProperties);</span><br><span class="line">    <span class="comment">// 计算  expectedConnectionTypeCode 的值</span></span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>属性都比较简单，看起来虽然多，主要是可选的<strong>配置</strong>属性。我们就看几个重点的。</li>
<li><code>dataSource</code> 属性，UnpooledDataSource 对象。这样，就能重用 UnpooledDataSource 的代码了。说白了，获取真正连接的逻辑，还是在 UnpooledDataSource 中实现。</li>
<li><p><code>expectedConnectionTypeCode</code> 属性，调用 <code>#assembleConnectionTypeCode(ClassLoader driverClassLoader, String driver, String url, Properties driverProperties)</code> 方法，计算 <code>expectedConnectionTypeCode</code> 的值。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span> + url + username + password).hashCode();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><code>state</code> 属性，PoolState 对象，记录池化的状态。这是一个非常重要的类，下文也会花一定的篇幅，详细解析。</li>
</ul>
<h3 id="3-2-2-getConnection"><a href="#3-2-2-getConnection" class="headerlink" title="3.2.2 getConnection"></a>3.2.2 getConnection</h3><p><code>#getConnection(...)</code> 方法，获得 Connection 连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">return</span> popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">return</span> popConnection(username, password).getProxyConnection();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#popConnection(String username, String password)</code> 方法，获取 <code>org.apache.ibatis.datasource.pooled.PooledConnection</code> 对象，这是一个<strong>池化</strong>的连接。非常关键的一个方法，详细解析，见 <a href="#">「3.2.2.1 popConnection」</a> 。</li>
<li>调用 <code>PooledConnection#getProxyConnection()</code> 方法，返回代理的 Connection 对象。这样，每次对数据库的操作，才能被 PooledConnection 的 <a href="#">「5.2 invoke」</a> <strong>代理拦截</strong>。</li>
</ul>
<h4 id="3-2-2-1-popConnection"><a href="#3-2-2-1-popConnection" class="headerlink" title="3.2.2.1 popConnection"></a>3.2.2.1 popConnection</h4><p><code>#popConnection(String username, String password)</code> 方法，获取 PooledConnection 对象。</p>
<p>整体流程如下图：</p>
<blockquote>
<p>FROM <a href="https://item.jd.com/12125531.html" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 技术内幕》</a></p>
<p><img src="http://static2.iocoder.cn/images/MyBatis/2020_01_16/03.png" alt="整体流程"></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>; <span class="comment">// 标记，获取连接时，是否进行了等待</span></span><br><span class="line">  <span class="number">3</span>:     PooledConnection conn = <span class="keyword">null</span>; <span class="comment">// 最终获取到的链接对象</span></span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">long</span> t = System.currentTimeMillis(); <span class="comment">// 记录当前时间</span></span><br><span class="line">  <span class="number">5</span>:     <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>; <span class="comment">// 记录当前方法，获取到坏连接的次数</span></span><br><span class="line">  <span class="number">6</span>: </span><br><span class="line">  <span class="number">7</span>:     <span class="comment">// 循环，获取可用的 Connection 连接</span></span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">while</span> (conn == <span class="keyword">null</span>) {</span><br><span class="line">  <span class="number">9</span>:         <span class="keyword">synchronized</span> (state) {</span><br><span class="line"> <span class="number">10</span>:             <span class="comment">// 空闲连接非空</span></span><br><span class="line"> <span class="number">11</span>:             <span class="keyword">if</span> (!state.idleConnections.isEmpty()) {</span><br><span class="line"> <span class="number">12</span>:                 <span class="comment">// Pool has available connection</span></span><br><span class="line"> <span class="number">13</span>:                 <span class="comment">// 通过移除的方式，获得首个空闲的连接</span></span><br><span class="line"> <span class="number">14</span>:                 conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line"> <span class="number">15</span>:                 <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"> <span class="number">16</span>:                     log.debug(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span><br><span class="line"> <span class="number">17</span>:                 }</span><br><span class="line"> <span class="number">18</span>:             <span class="comment">// 无空闲空闲连接</span></span><br><span class="line"> <span class="number">19</span>:             } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">20</span>:                 <span class="comment">// Pool does not have available connection</span></span><br><span class="line"> <span class="number">21</span>:                 <span class="comment">// 激活的连接数小于 poolMaximumActiveConnections</span></span><br><span class="line"> <span class="number">22</span>:                 <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) {</span><br><span class="line"> <span class="number">23</span>:                     <span class="comment">// Can create new connection</span></span><br><span class="line"> <span class="number">24</span>:                     <span class="comment">// 创建新的 PooledConnection 连接对象</span></span><br><span class="line"> <span class="number">25</span>:                     conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line"> <span class="number">26</span>:                     <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"> <span class="number">27</span>:                         log.debug(<span class="string">"Created connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line"> <span class="number">28</span>:                     }</span><br><span class="line"> <span class="number">29</span>:                 } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">30</span>:                     <span class="comment">// Cannot create new connection</span></span><br><span class="line"> <span class="number">31</span>:                     <span class="comment">// 获得首个激活的 PooledConnection 对象</span></span><br><span class="line"> <span class="number">32</span>:                     PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line"> <span class="number">33</span>:                     <span class="comment">// 检查该连接是否超时</span></span><br><span class="line"> <span class="number">34</span>:                     <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line"> <span class="number">35</span>:                     <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) { <span class="comment">// 检查到超时</span></span><br><span class="line"> <span class="number">36</span>:                         <span class="comment">// Can claim overdue connection</span></span><br><span class="line"> <span class="number">37</span>:                         <span class="comment">// 对连接超时的时间的统计</span></span><br><span class="line"> <span class="number">38</span>:                         state.claimedOverdueConnectionCount++;</span><br><span class="line"> <span class="number">39</span>:                         state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line"> <span class="number">40</span>:                         state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line"> <span class="number">41</span>:                         <span class="comment">// 从活跃的连接集合中移除</span></span><br><span class="line"> <span class="number">42</span>:                         state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line"> <span class="number">43</span>:                         <span class="comment">// 如果非自动提交的，需要进行回滚。即将原有执行中的事务，全部回滚。</span></span><br><span class="line"> <span class="number">44</span>:                         <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) {</span><br><span class="line"> <span class="number">45</span>:                             <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">46</span>:                                 oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line"> <span class="number">47</span>:                             } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line"> <span class="number">48</span>:                                 <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 49:                                    Just log a message for debug and continue to execute the following</span></span><br><span class="line"><span class="comment"> 50:                                    statement like nothing happened.</span></span><br><span class="line"><span class="comment"> 51:                                    Wrap the bad connection with a new PooledConnection, this will help</span></span><br><span class="line"><span class="comment"> 52:                                    to not interrupt current executing thread and give current thread a</span></span><br><span class="line"><span class="comment"> 53:                                    chance to join the next competition for another valid/good database</span></span><br><span class="line"><span class="comment"> 54:                                    connection. At the end of this loop, bad {@link @conn} will be set as null.</span></span><br><span class="line"><span class="comment"> 55:                                 */</span></span><br><span class="line"> <span class="number">56</span>:                                 log.debug(<span class="string">"Bad connection. Could not roll back"</span>);</span><br><span class="line"> <span class="number">57</span>:                             }</span><br><span class="line"> <span class="number">58</span>:                         }</span><br><span class="line"> <span class="number">59</span>:                         <span class="comment">// 创建新的 PooledConnection 连接对象</span></span><br><span class="line"> <span class="number">60</span>:                         conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line"> <span class="number">61</span>:                         conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line"> <span class="number">62</span>:                         conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line"> <span class="number">63</span>:                         <span class="comment">// 设置 oldestActiveConnection 为无效</span></span><br><span class="line"> <span class="number">64</span>:                         oldestActiveConnection.invalidate();</span><br><span class="line"> <span class="number">65</span>:                         <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"> <span class="number">66</span>:                             log.debug(<span class="string">"Claimed overdue connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line"> <span class="number">67</span>:                         }</span><br><span class="line"> <span class="number">68</span>:                     } <span class="keyword">else</span> { <span class="comment">// 检查到未超时</span></span><br><span class="line"> <span class="number">69</span>:                         <span class="comment">// Must wait</span></span><br><span class="line"> <span class="number">70</span>:                         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">71</span>:                             <span class="comment">// 对等待连接进行统计。通过 countedWait 标识，在这个循环中，只记录一次。</span></span><br><span class="line"> <span class="number">72</span>:                             <span class="keyword">if</span> (!countedWait) {</span><br><span class="line"> <span class="number">73</span>:                                 state.hadToWaitCount++;</span><br><span class="line"> <span class="number">74</span>:                                 countedWait = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">75</span>:                             }</span><br><span class="line"> <span class="number">76</span>:                             <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"> <span class="number">77</span>:                                 log.debug(<span class="string">"Waiting as long as "</span> + poolTimeToWait + <span class="string">" milliseconds for connection."</span>);</span><br><span class="line"> <span class="number">78</span>:                             }</span><br><span class="line"> <span class="number">79</span>:                             <span class="comment">// 记录当前时间</span></span><br><span class="line"> <span class="number">80</span>:                             <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line"> <span class="number">81</span>:                             <span class="comment">// 等待，直到超时，或 pingConnection 方法中归还连接时的唤醒</span></span><br><span class="line"> <span class="number">82</span>:                             state.wait(poolTimeToWait);</span><br><span class="line"> <span class="number">83</span>:                             <span class="comment">// 统计等待连接的时间</span></span><br><span class="line"> <span class="number">84</span>:                             state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line"> <span class="number">85</span>:                         } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line"> <span class="number">86</span>:                             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">87</span>:                         }</span><br><span class="line"> <span class="number">88</span>:                     }</span><br><span class="line"> <span class="number">89</span>:                 }</span><br><span class="line"> <span class="number">90</span>:             }</span><br><span class="line"> <span class="number">91</span>:             <span class="comment">// 获取到连接</span></span><br><span class="line"> <span class="number">92</span>:             <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">93</span>:                 <span class="comment">// ping to server and check the connection is valid or not</span></span><br><span class="line"> <span class="number">94</span>:                 <span class="comment">// 通过 ping 来测试连接是否有效</span></span><br><span class="line"> <span class="number">95</span>:                 <span class="keyword">if</span> (conn.isValid()) {</span><br><span class="line"> <span class="number">96</span>:                     <span class="comment">// 如果非自动提交的，需要进行回滚。即将原有执行中的事务，全部回滚。</span></span><br><span class="line"> <span class="number">97</span>:                     <span class="comment">// 这里又执行了一次，有点奇怪。目前猜测，是不是担心上一次适用方忘记提交或回滚事务 TODO 1001 芋艿</span></span><br><span class="line"> <span class="number">98</span>:                     <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) {</span><br><span class="line"> <span class="number">99</span>:                         conn.getRealConnection().rollback();</span><br><span class="line"><span class="number">100</span>:                     }</span><br><span class="line"><span class="number">101</span>:                     <span class="comment">// 设置获取连接的属性</span></span><br><span class="line"><span class="number">102</span>:                     conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line"><span class="number">103</span>:                     conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line"><span class="number">104</span>:                     conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line"><span class="number">105</span>:                     <span class="comment">// 添加到活跃的连接集合</span></span><br><span class="line"><span class="number">106</span>:                     state.activeConnections.add(conn);</span><br><span class="line"><span class="number">107</span>:                     <span class="comment">// 对获取成功连接的统计</span></span><br><span class="line"><span class="number">108</span>:                     state.requestCount++;</span><br><span class="line"><span class="number">109</span>:                     state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line"><span class="number">110</span>:                 } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">111</span>:                     <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"><span class="number">112</span>:                         log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") was returned from the pool, getting another connection."</span>);</span><br><span class="line"><span class="number">113</span>:                     }</span><br><span class="line"><span class="number">114</span>:                     <span class="comment">// 统计获取到坏的连接的次数</span></span><br><span class="line"><span class="number">115</span>:                     state.badConnectionCount++;</span><br><span class="line"><span class="number">116</span>:                     <span class="comment">// 记录获取到坏的连接的次数【本方法】</span></span><br><span class="line"><span class="number">117</span>:                     localBadConnectionCount++;</span><br><span class="line"><span class="number">118</span>:                     <span class="comment">// 将 conn 置空，那么可以继续获取</span></span><br><span class="line"><span class="number">119</span>:                     conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">120</span>:                     <span class="comment">// 如果超过最大次数，抛出 SQLException 异常</span></span><br><span class="line"><span class="number">121</span>:                     <span class="comment">// 为什么次数要包含 poolMaximumIdleConnections 呢？相当于把激活的连接，全部遍历一次。</span></span><br><span class="line"><span class="number">122</span>:                     <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {</span><br><span class="line"><span class="number">123</span>:                         <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"><span class="number">124</span>:                             log.debug(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line"><span class="number">125</span>:                         }</span><br><span class="line"><span class="number">126</span>:                         <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line"><span class="number">127</span>:                     }</span><br><span class="line"><span class="number">128</span>:                 }</span><br><span class="line"><span class="number">129</span>:             }</span><br><span class="line"><span class="number">130</span>:         }</span><br><span class="line"><span class="number">131</span>:     }</span><br><span class="line"><span class="number">132</span>: </span><br><span class="line"><span class="number">133</span>:     <span class="comment">// 获取不到连接，抛出 SQLException 异常</span></span><br><span class="line"><span class="number">134</span>:     <span class="keyword">if</span> (conn == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">135</span>:         <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line"><span class="number">136</span>:             log.debug(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line"><span class="number">137</span>:         }</span><br><span class="line"><span class="number">138</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line"><span class="number">139</span>:     }</span><br><span class="line"><span class="number">140</span>: </span><br><span class="line"><span class="number">141</span>:     <span class="keyword">return</span> conn;</span><br><span class="line"><span class="number">142</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 5 行：声明四个变量，具体用途，看看注释。</li>
<li>第 8 行：<code>while</code> 循环，获取可用的 Connection 连接，或超过获取次数上限( <code>poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance</code> )。</li>
<li>第 9 行：基于 <code>state</code> 变量做同步，避免并发问题。从这个锁的粒度来说，颗粒度还是比较大的，所以 MyBatis 自带的数据池连接池性能应该一般。从 <a href="https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98" rel="external nofollow noopener noreferrer" target="_blank">《Druid 锁的公平模式问题》</a> 文章来看，Druid 在锁的处理上，肯定是<strong>相对</strong>精细的。</li>
<li>============== 获取连接，分成四种 ==============</li>
<li>第 10 至 17 行：<strong>第一种</strong>，空闲连接<strong>非空</strong>，此处就使用到了 <code>PoolState.idleConnections</code> 属性。<ul>
<li>第 14 行：通过移除 <code>PoolState.idleConnections</code> 的方式，获得首个空闲的连接。</li>
</ul>
</li>
<li>第 20 至 28 行：<strong>第二种</strong>，空闲连接<strong>为空</strong>，激活的连接数小于 <code>poolMaximumActiveConnections</code> 。<ul>
<li>第 25 行：创建新的 PooledConnection 连接对象。此处，<strong>真正</strong>的数据库连接，是通过 <code>UnpooledConnection#getConnection()</code> 方法获取到的。</li>
</ul>
</li>
<li>第 32 行：获取首个激活的 PooledConnection 对象，从 <code>PoolState.activeConnections</code> 中。</li>
<li>第 36 至 67 行：<strong>第三种</strong>，获取的连接<strong>已超时</strong>，那么就可以<strong>重新</strong>使用该连接的<strong>真实数据库连接</strong>了。所以，我们可以发现，连接的超时发现，并不是由一个定时任务后台执行，而是有点类似<strong>懒加载</strong>的方式，在连接不够的时候，再去进行处理。实际上，很多“东西”的过期，都是基于这样的思路，例如 Redis 的键过期。<ul>
<li>第 36 至 40 行：对连接超时的时间的统计。</li>
<li>第 42 行：从活跃的连接集合 <code>PoolState.activeConnections</code> 中移除。</li>
<li>第 43 至 58 行：如果非自动提交的，需要进行回滚。即将原有执行中的事务，全部回滚。</li>
<li>第 59 至 62 行：创建新的 PooledConnection 连接对象。此处，使用的是 <code>oldestActiveConnection.realConnection</code> 。</li>
<li>第 64 行：调用 <code>PooledConnection#invalidate()</code> 方法，设置 <code>oldestActiveConnection</code> 为无效。这样，如果目前正在使用该连接的调用方，如果在发起数据库操作，将可以抛出异常。具体原因，可见 <a href="#">「5.2 invoke」</a> 。</li>
</ul>
</li>
<li><p>第 68 至 87 行：<strong>第四种</strong>，获取的连接<strong>未超时</strong>，那么就只能<strong>等待</strong>。</p>
<ul>
<li>第 71 至 75 行：对等待连接进行统计。通过 <code>countedWait</code> 标识，在这个循环中，只记录一次。</li>
<li>【重要】第 82 行：<strong>等待</strong>，直到<strong>超时</strong>，或 <code>pingConnection</code> 方法中归还连接时的<strong>唤醒</strong>。</li>
<li>第 80 &amp;&amp; 84 行：统计等待连接的时间。</li>
</ul>
</li>
<li><p>============== 校验连接 ==============</p>
</li>
<li>第 95 行：调用 <code>PooledConnection#isValid()</code> 方法，校验获得的连接是否可用。详细解析，见 <a href="#">「5.3 isValid」</a> 。</li>
<li>第 95 至 109 行：连接<strong>可用</strong>。<ul>
<li>第 96 至 100 行：如果非自动提交的，需要进行回滚。即将原有执行中的事务，全部回滚。这里又执行了一次，有点奇怪。目前猜测，是不是担心上一次适用方忘记提交或回滚事务 TODO 1002 芋艿</li>
<li>第 101 至 104 行：设置获取连接的属性。</li>
<li>第 106 行：添加到活跃的连接集合 <code>PoolState.activeConnections</code> 中。</li>
<li>第 107 至 109 行：对获取成功连接的统计。</li>
</ul>
</li>
<li><p>第 110 至 128 行：连接<strong>不可用</strong>。</p>
<ul>
<li>第 115 行：统计获取到坏的连接的次数。</li>
<li>第 117 行：记录获取到坏的连接的次数【本方法】<code>localBadConnectionCount</code> 。</li>
<li>第 119 行：将 <code>conn</code> 置空，那么可以继续获取，即回到【第 8 行】代码。</li>
<li>第 120 至 127 行：如果超过最大次数，抛出 SQLException 异常。为什么次数要包含 <code>poolMaximumIdleConnections</code> 呢？相当于把激活的连接，全部遍历一次。</li>
</ul>
</li>
<li><p>============== 循环结束 ==============</p>
</li>
<li>第 133 至 139 行：获取不到连接，抛出 SQLException 异常。实际上，这块逻辑是不会执行到的，无论是从上面的逻辑推导，还是从官方在抛出的 SQLException 异常的描述。</li>
</ul>
<p>嘿嘿，代码有点长。胖友好好品味下。</p>
<h3 id="3-2-3-pushConnection"><a href="#3-2-3-pushConnection" class="headerlink" title="3.2.3 pushConnection"></a>3.2.3 pushConnection</h3><p><code>#pushConnection(PooledConnection conn)</code> 方法，将使用完的连接，添加回连接池中。</p>
<p>整体流程如下图：</p>
<blockquote>
<p>FROM <a href="https://item.jd.com/12125531.html" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 技术内幕》</a></p>
<p><img src="http://static2.iocoder.cn/images/MyBatis/2020_01_16/04.png" alt="整体流程"></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (state) {</span><br><span class="line">        <span class="comment">// 从激活的连接集合中移除该连接</span></span><br><span class="line">        state.activeConnections.remove(conn);</span><br><span class="line">        <span class="comment">// 通过 ping 来测试连接是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (conn.isValid()) { <span class="comment">// 有效</span></span><br><span class="line">            <span class="comment">// 判断是否超过空闲连接上限，并且和当前连接池的标识匹配</span></span><br><span class="line">            <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) {</span><br><span class="line">                <span class="comment">// 统计连接使用时长</span></span><br><span class="line">                state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">                <span class="comment">// 回滚事务，避免适用房未提交或者回滚事务</span></span><br><span class="line">                <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) {</span><br><span class="line">                    conn.getRealConnection().rollback();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 创建 PooledConnection 对象，并添加到空闲的链接集合中</span></span><br><span class="line">                PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">                state.idleConnections.add(newConn);</span><br><span class="line">                newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">                newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">                <span class="comment">// 设置原连接失效</span></span><br><span class="line">                <span class="comment">// 为什么这里要创建新的 PooledConnection 对象呢？避免使用方还在使用 conn ，通过将它设置为失效，万一再次调用，会抛出异常</span></span><br><span class="line">                conn.invalidate();</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                    log.debug(<span class="string">"Returned connection "</span> + newConn.getRealHashCode() + <span class="string">" to pool."</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 唤醒正在等待连接的线程</span></span><br><span class="line">                state.notifyAll();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 统计连接使用时长</span></span><br><span class="line">                state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">                <span class="comment">// 回滚事务，避免适用房未提交或者回滚事务</span></span><br><span class="line">                <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) {</span><br><span class="line">                    conn.getRealConnection().rollback();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 关闭真正的数据库连接</span></span><br><span class="line">                conn.getRealConnection().close();</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                    log.debug(<span class="string">"Closed connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 设置原连接失效</span></span><br><span class="line">                conn.invalidate();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 失效</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") attempted to return to the pool, discarding connection."</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 统计获取到坏的连接的次数</span></span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码虽长，胖友耐心跟着代码注释读读。还是蛮简单的。</li>
<li>该方法会被 PooledConnection 的 <a href="#">「5.2 invoke」</a> 在 <code>methodName = close</code> 方法的情况下时被调用。 </li>
</ul>
<h3 id="3-2-4-pingConnection"><a href="#3-2-4-pingConnection" class="headerlink" title="3.2.4 pingConnection"></a>3.2.4 pingConnection</h3><p><code>#pingConnection(PooledConnection conn)</code> 方法，通过向数据库发起 <code>poolPingQuery</code> 语句来发起“ping”操作，以判断数据库连接是否有效。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to check to see if a connection is still usable</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn - the connection to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the connection is still usable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">pingConnection</span><span class="params">(PooledConnection conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 记录是否 ping 成功</span></span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断真实的连接是否已经关闭。若已关闭，就意味着 ping 肯定是失败的。</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        result = !conn.getRealConnection().isClosed();</span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">        }</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// 是否启用侦测查询</span></span><br><span class="line">        <span class="keyword">if</span> (poolPingEnabled) {</span><br><span class="line">            <span class="comment">// 判断是否长时间未使用。若是，才需要发起 ping</span></span><br><span class="line">            <span class="keyword">if</span> (poolPingConnectionsNotUsedFor &gt;= <span class="number">0</span> &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                        log.debug(<span class="string">"Testing connection "</span> + conn.getRealHashCode() + <span class="string">" ..."</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 通过执行 poolPingQuery 语句来发起 ping</span></span><br><span class="line">                    Connection realConn = conn.getRealConnection();</span><br><span class="line">                    <span class="keyword">try</span> (Statement statement = realConn.createStatement()) {</span><br><span class="line">                        statement.executeQuery(poolPingQuery).close();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (!realConn.getAutoCommit()) {</span><br><span class="line">                        realConn.rollback();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 标记执行成功</span></span><br><span class="line">                    result = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                        log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is GOOD!"</span>);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    <span class="comment">// 关闭数据库真实的连接</span></span><br><span class="line">                    log.warn(<span class="string">"Execution of ping query '"</span> + poolPingQuery + <span class="string">"' failed: "</span> + e.getMessage());</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        conn.getRealConnection().close();</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e2) {</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 标记执行失败</span></span><br><span class="line">                    result = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                        log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码虽长，胖友耐心跟着代码注释读读。还是蛮简单的。</li>
<li>该方法会被 PooledConnection 的 <a href="#">「5.2 invoke」</a> 在 <code>methodName != close</code> 方法的情况下时被调用，校验连接是否可用。</li>
</ul>
<h3 id="3-2-5-forceCloseAll"><a href="#3-2-5-forceCloseAll" class="headerlink" title="3.2.5 forceCloseAll"></a>3.2.5 forceCloseAll</h3><p><code>#forceCloseAll()</code> 方法，关闭所有的 <code>activeConnections</code> 和 <code>idleConnections</code> 的连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledDataSource.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Closes all active and idle connections in the pool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (state) {</span><br><span class="line">        <span class="comment">// 计算 expectedConnectionTypeCode</span></span><br><span class="line">        expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">        <span class="comment">// 遍历 activeConnections ，进行关闭</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 设置为失效</span></span><br><span class="line">                PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">                conn.invalidate();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回滚事务，如果有事务未提交或回滚</span></span><br><span class="line">                Connection realConn = conn.getRealConnection();</span><br><span class="line">                <span class="keyword">if</span> (!realConn.getAutoCommit()) {</span><br><span class="line">                    realConn.rollback();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 关闭真实的连接</span></span><br><span class="line">                realConn.close();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历 idleConnections ，进行关闭</span></span><br><span class="line">        <span class="comment">//【实现代码上，和上面是一样的】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 设置为失效</span></span><br><span class="line">                PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">                conn.invalidate();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回滚事务，如果有事务未提交或回滚</span></span><br><span class="line">                Connection realConn = conn.getRealConnection();</span><br><span class="line">                <span class="keyword">if</span> (!realConn.getAutoCommit()) {</span><br><span class="line">                    realConn.rollback();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 关闭真实的连接</span></span><br><span class="line">                realConn.close();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">        log.debug(<span class="string">"PooledDataSource forcefully closed/removed all connections."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码虽长，胖友耐心跟着代码注释读读。还是蛮简单的。</li>
<li><p>该方法会被 <code>#finalize()</code> 方法所调用，即当前 PooledDataSource 对象被释放时。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PoolState.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="comment">// 关闭所有连接</span></span><br><span class="line">    forceCloseAll();</span><br><span class="line">    <span class="comment">// 执行对象销毁</span></span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="3-2-6-unwrapConnection"><a href="#3-2-6-unwrapConnection" class="headerlink" title="3.2.6 unwrapConnection"></a>3.2.6 unwrapConnection</h3><p><code>#unwrapConnection(Connection conn)</code> 方法，获取真实的数据库连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PoolState.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unwraps a pooled connection to get to the 'real' connection</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn - the pooled connection to unwrap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The 'real' connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">unwrapConnection</span><span class="params">(Connection conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果传入的是被代理的连接</span></span><br><span class="line">    <span class="keyword">if</span> (Proxy.isProxyClass(conn.getClass())) {</span><br><span class="line">        <span class="comment">// 获取 InvocationHandler 对象</span></span><br><span class="line">        InvocationHandler handler = Proxy.getInvocationHandler(conn);</span><br><span class="line">        <span class="comment">// 如果是 PooledConnection 对象，则获取真实的连接</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> PooledConnection) {</span><br><span class="line">            <span class="keyword">return</span> ((PooledConnection) handler).getRealConnection();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-7-其它方法"><a href="#3-2-7-其它方法" class="headerlink" title="3.2.7 其它方法"></a>3.2.7 其它方法</h3><p>PooledDataSource 还有其它简单方法，胖友自己瞅瞅，都简单。</p>
<h1 id="4-PoolState"><a href="#4-PoolState" class="headerlink" title="4. PoolState"></a>4. PoolState</h1><p> <code>org.apache.ibatis.datasource.pooled.PoolState</code> ，连接池状态，记录空闲和激活的 PooledConnection 集合，以及相关的数据统计。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">// PoolState.java</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属的 PooledDataSource 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲的 PooledConnection 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 激活的的 PooledConnection 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 获取连接的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 获取连接的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 获取到连接非超时 + 超时的占用时长</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以，包括 {<span class="doctag">@link</span> #accumulatedCheckoutTimeOfOverdueConnections} 部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 获取到连接超时的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 获取到连接超时的占用时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 等待连接的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 等待连接的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统计 - 获取到坏的连接的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>dataSource</code> 属性，所属的 PooledDataSource 对象。</li>
<li><code>idleConnections</code> 属性，空闲的 PooledConnection 集合，即该连接<strong>未</strong>被使用，还在连接池中。</li>
<li><code>activeConnections</code> 属性，激活的 PooledConnection 集合，即该连接<strong>正在</strong>被使用，不在连接池中。</li>
<li>其它全局<strong>统计</strong>属性，指的是和当前 <code>dataSource</code> 获得连接相关的统计。</li>
</ul>
<p>PoolState 还有一些其它方法，比较简单，感兴趣的胖友，可以自己去看。</p>
<h1 id="5-PooledConnection"><a href="#5-PooledConnection" class="headerlink" title="5. PooledConnection"></a>5. PooledConnection</h1><p><code>org.apache.ibatis.datasource.pooled.PooledConnection</code> ，实现 InvocationHandler 接口，池化的 Connection 对象。</p>
<h2 id="5-1-构造方法"><a href="#5-1-构造方法" class="headerlink" title="5.1 构造方法"></a>5.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭 Connection 方法名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOSE = <span class="string">"close"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK Proxy 的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="keyword">new</span> Class&lt;?&gt;[]{Connection.class};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象的标识，基于 {<span class="doctag">@link</span> #realConnection} 求 hashCode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属的 PooledDataSource 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实的 Connection 连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理的 Connection 连接，即 {<span class="doctag">@link</span> PooledConnection} 这个动态代理的 Connection 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从连接池中，获取走的时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象创建时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后更新时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接的标识，即 {<span class="doctag">@link</span> PooledDataSource#expectedConnectionTypeCode}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connection - the connection that is to be presented as a pooled connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataSource - the dataSource that the connection is from</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.hashCode = connection.hashCode();</span><br><span class="line">    <span class="keyword">this</span>.realConnection = connection;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 创建代理的 Connection 对象</span></span><br><span class="line">    <span class="keyword">this</span>.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>属性比较简单，胖友直接看代码注释。</li>
<li><code>dataSource</code> 属性，所属的 PooledDataSource 对象。</li>
<li><code>realConnection</code> 属性，<strong>真实</strong>的 Connection 连接。</li>
<li><code>proxyConnection</code> 属性，<strong>代理</strong>的 Connection 连接，在 <code>&lt;1&gt;</code> 处，基于 JDK Proxy 创建 Connection 对象，并且 <code>handler</code> 对象就是 <code>this</code> ，也就是自己。那意味着什么？后续对 <code>proxyConnection</code> 的所有方法调用，都会委托给 <code>PooledConnection#invoke(Object proxy, Method method, Object[] args)</code> 方法。更多“秘密”，见 <a href="#">「5.2 invoke」</a> 。</li>
</ul>
<h2 id="5-2-invoke"><a href="#5-2-invoke" class="headerlink" title="5.2 invoke"></a>5.2 invoke</h2><p><code>#invoke(Object proxy, Method method, Object[] args)</code> 方法，代理调用方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 判断是否为 CLOSE 方法，则将连接放回到连接池中，避免连接被关闭</span></span><br><span class="line">    <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) {</span><br><span class="line">        dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// &lt;2.1&gt; 判断非 Object 的方法，则先检查连接是否可用</span></span><br><span class="line">            <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) {</span><br><span class="line">                <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">                <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">                checkConnection();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// &lt;2.2&gt; 反射调用对应的方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，判断调用的方法是不是 <code>Connection#close()</code> 方法，如果是，则调用 <code>PooledDataSource#pushConnection(PooledConnection conn)</code> 方法，将该连接放回到连接池中，从而避免连接被关闭。</li>
<li><p><code>&lt;2.1&gt;</code> 处，判断非 Object 的方法，则<strong>额外</strong>调用 <code>#checkConnection()</code> 方法，则先检查连接是否可用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">if</span> (!valid) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error accessing PooledConnection. Connection is invalid."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当 <code>valid</code> 为 <code>false</code> 时，意味着连接无效，所以抛出 SQLException 异常。</li>
</ul>
</li>
<li><code>&lt;2.2&gt;</code> 处，反射调用对应的方法。</li>
</ul>
<h2 id="5-3-isValid"><a href="#5-3-isValid" class="headerlink" title="5.3 isValid"></a>5.3 isValid</h2><p><code>#isValid()</code> 方法，校验连接是否可用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当连接有效时，调用 <code>PooledDataSource#pingConnection(PooledConnection conn)</code> 方法，向数据库发起 “ping” 请求，判断连接是否真正有效。</li>
</ul>
<h2 id="5-4-invalidate"><a href="#5-4-invalidate" class="headerlink" title="5.4 invalidate"></a>5.4 invalidate</h2><p><code>#invalidate()</code> 方法，设置连接无效。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PooledConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-5-其它方法"><a href="#5-5-其它方法" class="headerlink" title="5.5 其它方法"></a>5.5 其它方法</h2><p>PooledConnection 还有其它简单方法，胖友自己瞅瞅，都简单。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，又对数据库连接池又加深了认识，有机会看看 Druid 或者 HikariCP 的源码实现。如果胖友对 HikariCP 感兴趣，可以看看 <a href="http://www.iocoder.cn/HikariCP/good-collection/?svip" rel="external nofollow noopener noreferrer" target="_blank">《HikariCP 实现原理与源码解析系统 —— 精品合集》</a> 。</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>田小波 <a href="https://www.tianxiaobo.com/2018/08/19/MyBatis-源码分析-内置数据源/" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 源码分析 - 内置数据源》</a></li>
<li>徐郡明 <a href="https://item.jd.com/12125531.html" rel="external nofollow noopener noreferrer" target="_blank">《MyBatis 技术内幕》</a> 的 <a href="#">「2.6 DataSource」</a> 小节</li>
</ul>




</div>
<div class="article-info article-info-index">



<div class="article-category tagcloud">
<i class="icon-book icon"></i>
<ul class="article-tag-list">

<li class="article-tag-list-item">
<a href="/categories/MyBatis//" class="article-tag-list-link color3">MyBatis</a>
</li>

</ul>
</div>





<div class="clearfix"></div>
</div>
</div>