原

# Netty ByteBuf 与 NIO ByteBuffer

2019 年 03 月 20 日 21:54:29 [duanduan_l](https://me.csdn.net/duanduan_l) 阅读数 53 更多

个人分类： [Java 网络编程](https://blog.csdn.net/duanduan_l/article/category/8701117)

Netty 中引入了 ByteBuf，相较于 NIO 中的 ByteBuffer 有了一下改进，使得网络编程更加简便。

### []()ByteBuffer 的缺点

在 NIO 的 Buffer 中，我们已经知道 Buffer 有七种，最常用的是 ByteBuffer，而 ByteBuffer 也有一些局限性：

1.

ByteBuffer 的长度是固定的，一旦分配完成就不能进行扩容和收缩，当需要操作的对象大于 Buffer 的容量时，会发生异常；

1.

在进行读写状态切换时，需要调用 flip()或 rewind()方法改变指针 position 的位置，稍有不慎，就不能完成任务；

基于 ByteBuffer 的这些局限性，Netty 的 ByteBuf 改进了这些问题。

### []()ByteBuf 的工作原理

由于 ByteBuf 是改进了 ByteBuffer 的缺点， 这一部分内容主要从两个方面介绍：

### []()**扩容**

ByteBuffer

在对 ByteBuffer 进行 put()操作时，若缓冲区可写入空间不足，会发生 BufferOverFlowException 异常，因此，ByteBuffer 中每次在进行 put()操作时，都会对可用空间进行校验，空间不足时，会创建一个新的 ByteBuffer，将旧 ByteBuffer 复制到新的中去，最后释放旧的 ByteBuffer，代码如下：

```
1. if(this.buffer.remaining() < needSize) {    1. int toBeExtSize = needSize < 128 ? needSize : 128;    1. ByteBuffer tmpBuffer = ByteBuffer.allocate(this.buffer.capacity() + toBeExtSize);    1. this.buffer.flip();    1. tmpBuffer.put(this.buffer);    1. this.buffer = tmpBuffer;    1. }
```

ByteBuf

问题在于，每次进行 put()操作都要进行可写空间校验，会导致代码冗余，不小心操作就可能出现别的问题。基于此，ByteBuf 对 ByteBuffer 进行了封装，利用 write 操作进行可用空间的校验，当可用空间不足时，ByteBuf 会进行自动扩容，对于使用者而言，不需要关心底层实现，操作更简便。

```
1. AbstractByteBuf    1. @Override    1. public ByteBuf writeByte(int value){    1. ensureWritable(1);    1. setByte(writerIndex++, value);    1. return this;    1. }    1. @Override    1. public ByteBuf ensureWritable(int minWritableBytes){    1. if (minWritableBytes < 0) {    1. throw new IllegalArgumentException(String.format(    1. "minWritableBytes: %d (expected: >= 0)", minWritableBytes));    1. }    1. if (minWritableBytes <= writableBytes()) {    1. return this;    1. }    1. if (minWritableBytes > maxCapacity - writerIndex) {    1. throw new IndexOutOfBoundsException(String.format(    1. "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s",    1. writerIndex, minWritableBytes, maxCapacity, this));    1. }    1. //扩容    1. int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);    1. capacity(newCapacity);    1. return this;    1. }
```

可以看到具体的容量计算在 calcculateNewCapacity()方法中：

```
1. private int calculateNewCapacity(int minNewCapacity){    1. int maxCapacity = this.maxCapacity;    1. int threshold = 4194304; //4mb阀值    1. if(minNewCapacity == 4194304) {//如果新容量为阀值，直接返回    1. return 4194304;    1. } else {    1. int newCapacity;    1. if(minNewCapacity > 4194304) {//如果传入的新容量大于阀值，进行计算    1. newCapacity = minNewCapacity / 4194304 /* 4194304;    1. if(newCapacity > maxCapacity - 4194304) {//如果大于最大容量，新容量为最大容量    1. newCapacity = maxCapacity;    1. } else {//否则新容量 + 阀值 4mb，按照阀值扩容    1. newCapacity += 4194304;    1. }    1. return newCapacity;    1. } else {//如果小于阀值，则以64为计数倍增，知道倍增的结果>=需要的容量值    1. for(newCapacity = 64; newCapacity < minNewCapacity; newCapacity <<= 1) {    1. ;    1. }    1. return Math.min(newCapacity, maxCapacity);    1. }    1. }    1. }
```

注意：

1. 当申请的新空间大于阀值时，采用每次步进 4MB 的方式进行扩张内存，而不是倍增，因为这会造成内存膨胀和浪费

2. 而但申请的新空间小于阀值时，则以 64 为基数进行倍增而不是步进，因为当内存比较小的时候，倍增是可以接受的（64 -> 128 和 10Mb -> 20Mb 相比）

### []()**位置指针**

ByteBuffer

ByteBuffer 只有一个位置指针，当我们需要将读写状态切换时，需要手动调用 flip()方法或 rewind()方法改变 position 的值，使用不慎就会造成问题。

```
1. //创建缓冲区    1. ByteBuffer buffer = ByteBuffer.allocate(1024);    1. //存入数据    1. buffer.put((byte)'A');    1. buffer.put((byte)'B');    1. //翻转    1. buffer.flip();    1. //读取二次数据    1. System.out.println((char)buffer.get());    1. System.out.println((char)buffer.get());
```

ByteBuf

ByteBuf 通过两个位置指针来协助缓冲区的读写操作，读操作使用 readerIndex，写操作使用 writerIndex。

readerIndex 和 writerIndex 的取值一开始都是 0，随着数据的写入 writerIndex 会增加，读取数据会使 readerIndex 增加，但是它不会超过 writerIndex。在读取之后，0 ～ readerIndex 的就被视为 discard 的，调用 discardReadBytes 方法，可以释放这部分空间，它的作用类似 ByteBuffer 的 compact 方法。readerIndex 和 writerIndex 之间的数据是可读取的，等价于 ByteBuffer position 和 limit 之间的数据。writerIndex 和 capacity 之间的空间是可写的，等价于 ByteBuffer limit 和 capacity 之间的可用空间。

由于写操作不修改 readerIndex 指针，读操作不修改 writerIndex 指针，因此读写之间不再需要调整位置指针，这极大地简化了缓冲区的读写操作，避免了由于遗漏或者不熟悉 flip()操作导致的功能异常。

初始分配的 ByteBuf 如图:

![](https://img-blog.csdnimg.cn/20190320214459136.png)

写入 N 个字节之后的 ByteBuf 如图:

![](https://img-blog.csdnimg.cn/20190320214459156.png)

读取 M（＜ N）个字节之后的 ByteBuf 如图:

![](https://img-blog.csdnimg.cn/20190320214459175.png)

调用 discardReadBytes 操作之后的 ByteBuf 如图:

![](https://img-blog.csdnimg.cn/20190320214459179.png)

调用 clear 操作之后的 ByteBuf 如图:

![](https://img-blog.csdnimg.cn/20190320214459183.png)

## []()**ByteBuf 源码思路**

由于 NIO 的 Channel 读写的参数都是 ByteBuffer，因此，Netty 的 ByteBuf 接口必须提供 API 方便的将 ByteBuf 转换成 ByteBuffer，或者将 ByteBuffer 包装成 ByteBuf。考虑到性能，应该尽量避免缓冲区的复制，内部实现的时候可以考虑聚合一个 ByteBuffer 的私有指针用来代表 ByteBuffer。

从内存分配的角度看，ByteBuf 可以分为两类。

（1）**堆内存**（HeapByteBuf）字节缓冲区：特点是内存的分配和回收速度快，可以被 JVM 自动回收；缺点就是如果进行 Socket 的 I/O 读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核 Channel 中，性能会有一定程度的下降。

（2）**直接内存**（DirectByteBuf）字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收速度会慢一些，但是将它写入或者从 Socket Channel 中读取时，由于少了一次内存复制，速度比堆内存快。

正是因为各有利弊，所以 Netty 提供了多种 ByteBuf 供开发者使用，经验表明，ByteBuf 的最佳实践是在 I/O 通信线程的读写缓冲区使用 DirectByteBuf，后端业务消息的编解码模块使用 HeapByteBuf，这样组合可以达到性能最优。

从内存回收角度看，ByteBuf 也分为两类：基于对象池的 ByteBuf 和普通 ByteBuf。

两者的主要区别就是基于对象池的 ByteBuf 可以重用 ByteBuf 对象，它自己维护了一个内存池，可以循环利用创建的 ByteBuf，提升内存的使用效率，降低由于高负载导致的频繁 GC。测试表明使用内存池后的 Netty 在高负载、大并发的冲击下内存和 GC 更加平稳。尽管推荐使用基于内存池的 ByteBuf，但是内存池的管理和维护更加复杂，使用起来也需要更加谨慎，因此，Netty 提供了灵活的策略供使用者来做选择。

### []()**内存池原理分析**

Arena 本身是指一块区域，在内存管理中，Memory Arena 是指内存中的一大块连续的区域，PoolArena 就是 Netty 的内存池实现类。

为了集中管理内存的分配和释放，同时提高分配和释放内存时候的性能，很多框架和应用都会通过预先申请一大块内存，然后通过提供相应的分配和释放接口来使用内存。这样一来，对内存的管理就被集中到几个类或者函数中，由于不再频繁使用系统调用来申请和释放内存，应用或者系统的性能也会大大提高。在这种设计思路下，预先申请的那一大块内存就被称为 Memory Arena。

不同的框架，Memory Arena 的实现不同，Netty 的 PoolArena 是由多个 Chunk 组成的大块内存区域，而每个 Chunk 则由一个或者多个 Page 组成，因此，对内存的组织和管理也就主要集中在如何管理和组织 Chunk 和 Page 了。

**PoolChunk**

Chunk 主要用来组织和管理多个 Page 的内存分配和释放，在 Netty 中，Chunk 中的 Page 被构建成一棵二叉树。假设一个 Chunk 由 16 个 Page 组成，那么这些 Page 将会被按照下图所示的形式组织起来。

![](https://img-blog.csdnimg.cn/20190320214459235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5kdWFuX2w=,size_16,color_FFFFFF,t_70)

Page 的大小是 4 个字节，Chunk 的大小是 64 个字节(4×16)。整棵树有 5 层，第 1 层（也就是叶子节点所在的层）用来分配所有 Page 的内存，第 4 层用来分配 2 个 Page 的内存，依次类推。

每个节点都记录了自己在整个 Memory Arena 中的偏移地址，当一个节点代表的内存区域被分配出去之后，这个节点就会被标记为已分配，自这个节点以下的所有节点在后面的内存分配请求中都会被忽略。举例来说，当我们请求一个 16 字节的存储区域时，上面这个树中的第 3 层中的 4 个节点中的一个就会被标记为已分配，这就表示整个 Memroy Arena 中有 16 个字节被分配出去了，新的分配请求只能从剩下的 3 个节点及其子树中寻找合适的节点。

对树的遍历采用深度优先的算法，但是在选择哪个子节点继续遍历时则是随机的，并不像通常的深度优先算法中那样总是访问左边的子节点。

**PoolSubpage**

对于小于一个 Page 的内存，Netty 在 Page 中完成分配。每个 Page 会被切分成大小相等的多个存储块，存储块的大小由第一次申请的内存块大小决定。假如一个 Page 是 8 个字节，如果第一次申请的块大小是 4 个字节，那么这个 Page 就包含 2 个存储块；如果第一次申请的是 8 个字节，那么这个 Page 就被分成 1 个存储块。

一个 Page 只能用于分配与第一次申请时大小相同的内存，比如，一个 4 字节的 Page，如果第一次分配了 1 字节的内存，那么后面这个 Page 只能继续分配 1 字节的内存，如果有一个申请 2 字节内存的请求，就需要在一个新的 Page 中进行分配。

Page 中存储区域的使用状态通过一个 long 数组来维护，数组中每个 long 的每一位表示一个块存储区域的占用情况：0 表示未占用，1 表示以占用。对于一个 4 字节的 Page 来说，如果这个 Page 用来分配 1 个字节的存储区域，那么 long 数组中就只有一个 long 类型的元素，这个数值的低 4 位用来指示各个存储区域的占用情况。对于一个 128 字节的 Page 来说，如果这个 Page 也是用来分配 1 个字节的存储区域，那么 long 数组中就会包含 2 个元素，总共 128 位，每一位代表一个区域的占用情况。

**内存回收策略**

无论是 Chunk 还是 Page，都通过状态位来标识内存是否可用，不同之处是 Chunk 通过在二叉树上对节点进行标识实现，Page 是通过维护块的使用状态标识来实现。

对于使用者来说，不需要关心内存池的实现细节，也不需要与这些类库打交道，只需要按照 API 说明正常使用即可。

## []()**辅助类功能介绍**

### []()**ByteBufHolder**

ByteBufHolder 是 ByteBuf 的容器，在 Netty 中，它非常有用，例如 HTTP 协议的请求消息和应答消息都可以携带消息体，这个消息体在 NIO ByteBuffer 中就是个 ByteBuffer 对象，在 Netty 中就是 ByteBuf 对象。由于不同的协议消息体可以包含不同的协议字段和功能，因此，需要对 ByteBuf 进行包装和抽象，不同的子类可以有不同的实现。为了满足这些定制化的需求，Netty 抽象出了 ByteBufHolder 对象，它包含了一个 ByteBuf，另外还提供了一些其他实用的方法，使用者继承 ByteBufHolder 接口后可以按需封装自己的实现。

### []()**ByteBufAllocator**

ByteBufAllocator 是字节缓冲区分配器，按照 Netty 的缓冲区实现不同，共有两种不同的分配器：基于内存池的字节缓冲区分配器和普通的字节缓冲区分配器。

### []()**CompositeByteBuf**

CompositeByteBuf 允许将多个 ByteBuf 的实例组装到一起，形成一个统一的视图，有点类似于数据库将多个表的字段组装到一起统一用视图展示。

CompositeByteBuf 在一些场景下非常有用，例如某个协议 POJO 对象包含两部分：消息头和消息体，它们都是 ByteBuf 对象。当需要对消息进行编码的时候需要进行整合，如果使用 JDK 的默认能力，有以下两种方式：

（1）将某个 ByteBuffer 复制到另一个 ByteBuffer 中，或者创建一个新的 ByteBuffer，将两者复制到新建的 ByteBuffer 中；

（2）通过 List 或数组等容器，将消息头和消息体放到容器中进行统一维护和处理。

上面的做法非常别扭，实际上我们遇到的问题跟数据库中视图解决的问题一致——缓冲区有多个，但是需要统一展示和处理，必须有存放它们的统一容器。为了解决这个问题，Netty 提供了 CompositeByteBuf。

它定义了一个 Component 类型的集合，实际上 Component 就是 ByteBuf 的包装实现类，它聚合了 ByteBuf 对象，维护了在集合中的位置偏移量信息等。

关于使用复合缓冲区实现零拷贝会在下篇博文介绍。

### []()**ByteBufUtil**

ByteBufUtil 是一个非常有用的工具类，它提供了一系列静态方法用于操作 ByteBuf 对象。其中最有用的方法就是对字符串的编码和解码，具体如下。

（1）encodeString(ByteBufAllocator alloc, CharBuffer src, Charset charset)：对需要编码的字符串 src 按照指定的字符集 charset 进行编码，利用指定的 ByteBufAllocator 生成一个新的 ByteBuf；

（2）decodeString(ByteBuffer src, Charset charset)：使用指定的 ByteBuffer 和 charset 进行对 ByteBuffer 进行解码，获取解码后的字符串。

还有一个非常有用的方法就是 hexDump，它能够将参数 ByteBuf 的内容以十六进制字符串的方式打印出来，用于输出日志或者打印码流，方便问题定位，提升系统的可维护性。hexDump 包含了一系列的方法，参数不同，输出的结果也不同。

### []()Unpooled （非池化）缓存

当未引用 ByteBufAllocator 时，上面的方法无法访问到 ByteBuf。对于这个用例 Netty 提供一个实用工具类称为 Unpooled,，它提供了静态辅助方法来创建非池化的 ByteBuf 实例。表列出了最重要的方法

![](https://img-blog.csdnimg.cn/20190320215301287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5kdWFuX2w=,size_16,color_FFFFFF,t_70)

在 非联网项目，该 Unpooled 类也使得它更容易使用的 ByteBuf API，获得一个高性能的可扩展缓冲 API，而不需要 Netty 的其他部分的。

参考自：[https://www.cnblogs.com/wade-luffy/p/6196481.html](https://www.cnblogs.com/wade-luffy/p/6196481.html)
