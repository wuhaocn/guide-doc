Java 并发编程：Synchronized 底层优化（偏向锁、轻量级锁）

<div id="main" class="">

<div class="h-entry" style="display:none">
<a href="https://prophesy.iteye.com" class="p-author" target="_blank">Prophesy</a>
</div>

<div class="blog_main">
<script type="application/ld+json">
{
"@context": "https://zhanzhang.baidu.com/contexts/cambrian.jsonld",
"@id": "http://prophesy.iteye.com/blog/2409178",
"title": "Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）",
"images": [],
"description": "",
"pubDate": "2018-01-26T15:51:39"
}
</script>
<div class="blog_title">
<h3>
<a href="/blog/2409178">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a>
<em class="actions">      </em>
</h3>
<ul class="blog_categories"><strong>博客分类：</strong> <li><a href="/category/378152">并发编程</a></li> </ul>
<div class="news_tag"><a href="http://www.iteye.com/blogs/tag/java">java</a><a href="http://www.iteye.com/blogs/tag/Synchronized">Synchronized</a>&nbsp;</div>
</div>

<div id="blog_content" class="hide-main-content">
<div class="hide-article-box text-center" style="display: none;">
<a class="btn" id="btn-readmore">阅读更多</a>
</div>
<div style="font-size: 14px;" class="iteye-blog-content-contain">
<h1 style="margin-bottom: 20px; font-size: 28px; font-weight: 400; line-height: 1.8; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;" class="postTitle"><a style="margin: 0px; padding: 0px; color: #333333;" href="http://www.cnblogs.com/paddix/p/5405678.html" class="postTitle2">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></h1>
<div style="color: #7d8b8d; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;" class="clear">&nbsp;</div>
<div style="margin: 0px; padding: 0px; color: #7d8b8d; font-family: Verdana, Arial, Helvetica, sans-serif;" class="postBody">
<div style="margin: 0px 0px 20px; padding: 0px; color: #333333; line-height: 1.8;" class="blogpost-body">
<div style="margin: 0px; padding: 0px;" title="Page 551" class="page">
<div style="margin: 0px; padding: 0px;" class="layoutArea">
<div style="margin: 0px; padding: 0px;" class="column">
<p style="margin: 10px auto;">Java并发编程系列：</p>
<ul style="margin-bottom: 1em; margin-left: 40px;">
<li style="margin-bottom: 0px; margin-left: 0px;">
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix/p/5374810.html" class="postTitle2">Java 并发编程：核心理论</a>&nbsp;</p>
</li>
<li style="margin-bottom: 0px; margin-left: 0px;">
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix/p/5367116.html">Java并发编程：Synchronized及其实现原理</a></p>
</li>
<li style="margin-bottom: 0px; margin-left: 0px;">
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix/p/5405678.html">Java并发编程：Synchronized底层优化（轻量级锁、偏向锁）</a></p>
</li>
<li style="margin-bottom: 0px; margin-left: 0px;">
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix/p/5381958.html">Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)</a></p>
</li>
<li style="margin-bottom: 0px; margin-left: 0px;">
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix/p/5428507.html">Java 并发编程：volatile的使用及其原理</a></p>
</li>
</ul>
<p style="margin: 10px auto;"><span style="margin: 0px; padding: 0px; font-size: 14pt;">一、重量级锁</span></p>
<p style="margin: 10px auto;">　　上篇文章中向大家介绍了Synchronized的用法及其实现的原理。现在我们应该知道，Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px; font-size: 14pt;">二、轻量级锁&nbsp;</span></strong></p>
<p style="margin: 10px auto;">　　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。锁的状态保存在对象的头文件中，以32位的JDK为例：</p>
<table cellpadding="0" border="1" style="margin: 0px; padding: 0px; border-collapse: collapse; border-spacing: 0px; max-width: 850px; border: 1px solid silver; width: 800px;" cellspacing="0">
<tbody><tr style="margin: 0px; padding: 0px;">
<td width="76" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">锁状态</strong></p>
</td>
<td width="160" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">25 bit</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">4bit</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">1bit</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">2bit</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="70" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">23bit</p>
</td>
<td width="80" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">2bit</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">是否是偏向锁</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">锁标志位</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="105" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">轻量级锁</p>
</td>
<td width="390" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">指向栈中锁记录的指针</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">00</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="105" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">重量级锁</p>
</td>
<td width="390" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">指向互斥量（重量级锁）的指针</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">10</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="105" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">GC标记</p>
</td>
<td width="390" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">空</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">11</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="105" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">偏向锁</p>
</td>
<td width="70" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">线程ID</p>
</td>
<td width="80" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">Epoch</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">对象分代年龄</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">1</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">01</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="105" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">无锁</p>
</td>
<td width="150" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">对象的hashCode</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">对象分代年龄</p>
</td>
<td width="120" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">0</p>
</td>
<td width="110" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">01</p>
</td>
</tr>
</tbody></table>
<p style="margin: 10px auto;">　　“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p style="margin: 10px auto;">1、<strong style="margin: 0px; padding: 0px;">轻量级锁的加锁过程</strong></p>
<p style="margin: 10px auto;">　　（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图2.1所示。</p>
<p style="margin: 10px auto;">　　（2）拷贝对象头中的Mark Word复制到锁记录中。</p>
<p style="margin: 10px auto;">　　（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。</p>
<p style="margin: 10px auto;">　　（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。</p>
<p style="margin: 10px auto;">　　（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p>
<p style="margin: 10px auto;">&nbsp;<img src="https://images2015.cnblogs.com/blog/820406/201604/820406-20160424105442866-2111954866.png" style="margin: 0px; padding: 0px; border-style: none; max-width: 800px; width: 520px; height: 245px;" alt=""></p>
<p style="margin: 10px auto;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;图2.1&nbsp;轻量级锁CAS操作之前堆栈与对象的状态</p>
<p style="margin: 10px auto;"><img src="https://images2015.cnblogs.com/blog/820406/201604/820406-20160424105540163-1019388398.png" style="margin: 0px; padding: 0px; border-style: none; max-width: 800px; width: 520px; height: 330px;" alt="">　　&nbsp;</p>
<p style="margin: 10px auto;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;图2.2&nbsp;轻量级锁CAS操作之后堆栈与对象的状态</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">2、轻量级锁的解锁过程：</strong></p>
<p style="margin: 10px auto;">　　（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</p>
<p style="margin: 10px auto;">　　（2）如果替换成功，整个同步过程就完成了。</p>
<p style="margin: 10px auto;">　　（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</p>
</div>
</div>
</div>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px; font-size: 14pt;">三、偏向锁</span></strong></p>
<p style="margin: 10px auto;">　　引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">1、偏向锁获取过程：</strong></p>
<p style="margin: 10px auto;">　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</p>
<p style="margin: 10px auto;">　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</p>
<p style="margin: 10px auto;">　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</p>
<p style="margin: 10px auto;">　　（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</p>
<p style="margin: 10px auto;">　　（5）执行同步代码。</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">2、偏向锁的释放：</strong></p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">　　</strong>偏向锁的撤销在上述第四步骤中有提到<strong style="margin: 0px; padding: 0px;">。</strong>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">3、重量级锁、轻量级锁和偏向锁之间转换</strong></p>
<p style="margin: 10px auto;">&nbsp;<img src="https://images2015.cnblogs.com/blog/820406/201604/820406-20160424163618101-624122079.png" style="margin: 0px; padding: 0px; border-style: none; max-width: 800px; width: 700px; height: 340px;" alt=""></p>
<p style="margin: 10px auto;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图 2.3三者的转换图</p>
<p style="margin: 10px auto;">　　该图主要是对上述内容的总结，如果对上述内容有较好的了解的话，该图应该很容易看懂。</p>
<p style="margin: 10px auto;"><span style="margin: 0px; padding: 0px; font-size: 14pt;"><strong style="margin: 0px; padding: 0px;">四、其他优化&nbsp;</strong></span></p>
<p style="margin: 10px auto;">1、<strong style="margin: 0px; padding: 0px;">适应性自旋（Adaptive Spinning）：</strong>从轻量级锁获取的流程中我们知道<strong style="margin: 0px; padding: 0px;">，</strong>当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">2、锁粗化（Lock Coarsening）：</strong>锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子：</p>
<div style="margin: 5px 0px; padding: 5px; background-color: #f5f5f5; border: 1px solid #cccccc; overflow: auto; color: #000000; font-family: 'Courier New' !important; font-size: 12px !important;" class="cnblogs_code">
<div style="margin: 5px 0px 0px; padding: 0px;" class="cnblogs_code_toolbar"><span style="margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;" class="cnblogs_code_copy"><a style="margin: 0px; padding: 0px; color: #000000; border: none !important;" title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" style="margin: 0px; padding: 0px; max-width: 800px; border-style: none !important;" alt="复制代码"></a></span></div>
<pre><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 1</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">package</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> com.paddx.test.string;
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 2</span> 
<span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 3</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">public</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">class</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> StringBufferTest {
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 4</span>     StringBuffer stringBuffer = <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">new</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> StringBuffer();
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 5</span> 
<span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 6</span>     <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">public</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">void</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> append(){
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 7</span>         stringBuffer.append("a"<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">);
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 8</span>         stringBuffer.append("b"<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">);
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 9</span>         stringBuffer.append("c"<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">);
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">10</span> <span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">    }
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">11</span> }</pre>
<div style="margin: 5px 0px 0px; padding: 0px;" class="cnblogs_code_toolbar"><span style="margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;" class="cnblogs_code_copy"><a style="margin: 0px; padding: 0px; color: #000000; border: none !important;" title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" style="margin: 0px; padding: 0px; max-width: 800px; border-style: none !important;" alt="复制代码"></a></span></div>
</div>
<p style="margin: 10px auto;">　　这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">3、锁消除（Lock Elimination）：</strong>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。看下面这段程序：</p>
<div style="margin: 5px 0px; padding: 5px; background-color: #f5f5f5; border: 1px solid #cccccc; overflow: auto; color: #000000; font-family: 'Courier New' !important; font-size: 12px !important;" class="cnblogs_code">
<div style="margin: 5px 0px 0px; padding: 0px;" class="cnblogs_code_toolbar"><span style="margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;" class="cnblogs_code_copy"><a style="margin: 0px; padding: 0px; color: #000000; border: none !important;" title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" style="margin: 0px; padding: 0px; max-width: 800px; border-style: none !important;" alt="复制代码"></a></span></div>
<pre><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 1</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">package</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> com.paddx.test.concurrent;
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 2</span> 
<span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 3</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">public</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">class</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> SynchronizedTest02 {
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 4</span> 
<span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 5</span>     <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">public</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">static</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">void</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> main(String[] args) {
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 6</span>         SynchronizedTest02 test02 = <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">new</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> SynchronizedTest02();
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 7</span>         <span style="margin: 0px; padding: 0px; color: #008000; line-height: 1.5 !important;">//</span><span style="margin: 0px; padding: 0px; color: #008000; line-height: 1.5 !important;">启动预热</span>
<span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 8</span>         <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">for</span> (<span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">int</span> i = 0; i &lt; 10000; i++<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">) {
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;"> 9</span>             i++<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">;
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">10</span> <span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">        }
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">11</span>         <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">long</span> start =<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> System.currentTimeMillis();
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">12</span>         <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">for</span> (<span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">int</span> i = 0; i &lt; 100000000; i++<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">) {
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">13</span>             test02.append("abc", "def"<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">);
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">14</span> <span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">        }
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">15</span>         System.out.println("Time=" + (System.currentTimeMillis() -<span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> start));
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">16</span> <span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">    }
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">17</span> 
<span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">18</span>     <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">public</span> <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">void</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> append(String str1, String str2) {
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">19</span>         StringBuffer sb = <span style="margin: 0px; padding: 0px; color: #0000ff; line-height: 1.5 !important;">new</span><span style="margin: 0px; padding: 0px; line-height: 1.5 !important;"> StringBuffer();
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">20</span> <span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">        sb.append(str1).append(str2);
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">21</span> <span style="margin: 0px; padding: 0px; line-height: 1.5 !important;">    }
</span><span style="margin: 0px; padding: 0px; color: #008080; line-height: 1.5 !important;">22</span> }</pre>
<div style="margin: 5px 0px 0px; padding: 0px;" class="cnblogs_code_toolbar"><span style="margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;" class="cnblogs_code_copy"><a style="margin: 0px; padding: 0px; color: #000000; border: none !important;" title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" style="margin: 0px; padding: 0px; max-width: 800px; border-style: none !important;" alt="复制代码"></a></span></div>
</div>
<p style="margin: 10px auto;">虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，可以将锁消除。下面是我本地执行的结果：</p>
<p style="margin: 10px auto;"><img src="https://images2015.cnblogs.com/blog/820406/201604/820406-20160424211554570-376308694.png" style="margin: 0px; padding: 0px; border-style: none; max-width: 800px; width: 800px; height: 370px;" alt=""></p>
<p style="margin: 10px auto;">　　为了尽量减少其他因素的影响，这里禁用了偏向锁（-XX:-UseBiasedLocking）。通过上面程序，可以看出消除锁以后性能还是有比较大提升的。</p>
<p style="margin: 10px auto;">　　注：可能JDK各个版本之间执行的结果不尽相同，我这里采用的JDK版本为1.6。</p>
<p style="margin: 10px auto;"><span style="margin: 0px; padding: 0px; font-size: 14pt;"><strong style="margin: 0px; padding: 0px;">五、总结&nbsp;</strong></span></p>
<p style="margin: 10px auto;"><span style="margin: 0px; padding: 0px; line-height: 1.5;">　　本文重点介绍了JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。下面是这几种锁的对比：</span></p>
<table cellpadding="0" border="1" style="margin: 0px; padding: 0px; border-collapse: collapse; border-spacing: 0px; max-width: 850px; border: 1px solid silver;" cellspacing="0">
<tbody><tr style="margin: 0px; padding: 0px;">
<td width="64" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">锁</p>
</td>
<td width="113" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">优点</p>
</td>
<td width="137" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">缺点</p>
</td>
<td width="106" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">适用场景</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="64" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">偏向锁</p>
</td>
<td width="113" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</p>
</td>
<td width="137" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</p>
</td>
<td width="106" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">适用于只有一个线程访问同步块场景。</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="64" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">轻量级锁</p>
</td>
<td width="113" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">竞争的线程不会阻塞，提高了程序的响应速度。</p>
</td>
<td width="137" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">如果始终得不到锁竞争的线程使用自旋会消耗CPU。</p>
</td>
<td width="106" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">追求响应时间。</p>
<p style="margin: 10px auto;">同步块执行速度非常快。</p>
</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td width="64" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">重量级锁</p>
</td>
<td width="113" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">线程竞争不使用自旋，不会消耗CPU。</p>
</td>
<td width="137" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">线程阻塞，响应时间缓慢。</p>
</td>
<td width="106" style="margin: 0px; padding: 3px; border: 1px solid silver; border-collapse: collapse;">
<p style="margin: 10px auto;">追求吞吐量。</p>
<p style="margin: 10px auto;">同步块执行速度较长。</p>
</td>
</tr>
</tbody></table>
<p style="margin: 10px auto;">&nbsp;</p>
<p style="margin: 10px auto;"><strong style="margin: 0px; padding: 0px;">&nbsp;参考文献：</strong></p>
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" target="_blank" href="http://www.iteye.com/topic/1018932">http://www.iteye.com/topic/1018932</a></p>
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" target="_blank" href="http://www.infoq.com/cn/articles/java-se-16-synchronized">http://www.infoq.com/cn/articles/java-se-16-synchronized</a></p>
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" target="_blank" href="http://frank1234.iteye.com/blog/2163142">http://frank1234.iteye.com/blog/2163142</a></p>
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" target="_blank" href="https://www.artima.com/insidejvm/ed2/threadsynch3.html">https://www.artima.com/insidejvm/ed2/threadsynch3.html</a></p>
<p style="margin: 10px auto;"><a style="margin: 0px; padding: 0px; color: #000000;" target="_blank" href="http://www.tuicool.com/articles/2aeAZn">http://www.tuicool.com/articles/2aeAZn</a></p>
</div>
<div style="margin: 0px; padding: 0px;">
<div style="margin: 0px; padding: 15px 10px; background: #fbfeff; border: 1px dashed #886d0d; font-family: 微软雅黑;">
<p style="padding-bottom: 5px;">&nbsp;作者：<a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix">liuxiaopeng</a></p>
<p style="padding-bottom: 5px;">&nbsp;博客地址：<a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/paddix">http://www.cnblogs.com/paddix/</a></p>
<p style="padding-bottom: 5px;">&nbsp;声明：转载请在文章页面明显位置给出原文连接。&nbsp;</p>
</div>
</div>
</div>
</div>

<div>
<!-- 广告位：PC端-iteye博客详情页底部banner2-728*90 -->
<script>
(function() {
var s = "_" + Math.random().toString(36).slice(2);
document.write('<div id="' + s + '"></div>');
(window.slotbydup=window.slotbydup || []).push({
id: '4774193',
container: s,
size: '728,90',
display: 'inlay-fix'
});
})();
jQuery(function(){
window.csdn.recommendSide({
contentBox: "recommend",
postBox: jQuery(".news-right-side"),
query:'Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）',
popu:'725'
})
});
</script><div id="_rkvr54x0ibm"></div><script charset="utf-8" src="https://pos.baidu.com/ncjm?psi=cdd3645400bf2a690446b97bb25954a3&amp;di=4774193&amp;dri=0&amp;dis=0&amp;dai=0&amp;ps=5310x571&amp;enu=encoding&amp;dcb=___adblockplus&amp;dtm=SSP_JSONP&amp;dvi=0.0&amp;dci=-1&amp;dpt=none&amp;tsr=0&amp;tpr=1564411287032&amp;ti=Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9ASynchronized%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%EF%BC%88%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89%20-%20%E5%B0%9A%E5%B8%9D%20-%20ITeye%E5%8D%9A%E5%AE%A2&amp;ari=2&amp;dbv=2&amp;drs=1&amp;pcs=1886x919&amp;pss=1886x5358&amp;cfv=0&amp;cpl=3&amp;chi=1&amp;cce=true&amp;cec=UTF-8&amp;tlm=1564411287&amp;prot=2&amp;rw=919&amp;ltu=https%3A%2F%2Fprophesy.iteye.com%2Fblog%2F2409178&amp;ltr=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3Dc8cvhCpW7JobFXKGVP6zWW6caMsfFVcrls7WA7ow-gh1FADVY6BfdgAXvyL93cdYpmInQM1FimtGfKVf2zhfpq%26wd%3D%26eqid%3Dc644c3bf00069cd3000000035d3f0529&amp;lcr=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3Dc8cvhCpW7JobFXKGVP6zWW6caMsfFVcrls7WA7ow-gh1FADVY6BfdgAXvyL93cdYpmInQM1FimtGfKVf2zhfpq%26wd%3D%26eqid%3Dc644c3bf00069cd3000000035d3f0529&amp;ecd=1&amp;uc=1920x1040&amp;pis=-1x-1&amp;sr=1920x1080&amp;tcn=1564411288&amp;exps=110011"></script><a href="http://www.baidu.com/cb.php?c=IgF_pyfqnHmkPjbvrHT0IZ0qnfK9ujYzrH6YrjTk0Aw-5Hnsn16YnjT0TAq15HfLP1fkrHn0T1YvPHRLnyDsrAnvrj0zujN-0AwY5HDdPWfYnHDzrjT0IgF_5y9YIZK1rBtEuywdQhP1uA38UhNYQLwETA-WQvG9IhDk5LNYUNq1ULNzmvRqmhkEuv-Yug--0ZFb5HD0mhYqnfKsTWYs0ZNGujYkPHTYn1mk0AqGujYknWb3rjDY0APGujYLn1bdn1n0ULI85H00TZbqnW0v0APzm1Ykrjbzn6" target="_blank" style="text-decoration:none;">

<div style="font-size:17px;color:#f13d3d;font-family: SF Pro Display,Roboto,Noto,Arial,PingFang SC,Hiragino Sans GB,Microsoft YaHei,sans-serif;width:728px;height:25px;font-weight:bold;">Java你会用，但这10点实战经验你一定不知道！</div>

<div style="font-size:13px;color:#666;font-family: SF Pro Display,Roboto,Noto,Arial,PingFang SC,Hiragino Sans GB,Microsoft YaHei,sans-serif;height:35px;margin-top:10px;">8大企业级实战项目提炼，总200+课时，限时助学2折特惠，立省4688元！</div>

</a>
</div>

<div id="bottoms" class="clearfix">

<div id="share_weibo">分享到：
<a data-type="sina" href="javascript:;" title="分享到新浪微博"><img src="/images/sina.jpg"></a>
<a data-type="qq" href="javascript:;" title="分享到腾讯微博"><img src="/images/tec.jpg"></a>
</div>
</div>

<div class="blog_nav">
<div class="pre_next">
<a href="/blog/2409180" class="next" title="Java 并发编程：volatile的使用及其原理">Java 并发编程：volatile的使用及其原理</a>
|
<a href="/blog/2409177" class="pre" title="Java并发编程：Synchronized及其实现原理">Java并发编程：Synchronized及其实现原理</a>
</div>
</div>
<div class="blog_bottom">
<ul>
<li>2018-01-26 15:51</li>
<li>浏览 906</li>
<li><a href="#comments">评论(0)</a></li>

<li>分类:<a href="https://www.iteye.com/blogs/category/language">编程语言</a></li>      
<li class="last"><a href="https://www.iteye.com/wiki/blog/2409178" target="_blank" class="more">查看更多</a></li>
</ul>    
</div>

<div class="blog_comment">
<h5>评论</h5>
<a id="comments" name="comments"></a>

</div>

<div class="blog_comment">
<h5>发表评论</h5>
<p style="text-align:center; margin-top:30px;margin-bottom:0px;"><a href="/login" style="background-color:white;"> <img src="/images/login_icon.png" style="vertical-align:middle; margin-right: 10px;"></a><a href="/login">  您还没有登录,请您登录后再发表评论 </a></p>
</div>
</div>

<div class="boutique-curr-box blog_comment">
<div class="boutique-curr clearfix" id="album_detail_wrap">
<h5 class="h3titles">相关资源推荐</h5>
<ul style="margin-top: 8px" class="clearfix">

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/qq_37001674/article/details/87916598" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_37001674/article/details/87916598&quot;}" target="_blank" title="synchronized原理分析及自旋锁、偏向锁、轻量级锁和重量级锁的概念和优化"><em class="related_suggestion_highlight">synchronized</em>原理分析及自旋锁、<em class="related_suggestion_highlight">偏向</em>锁、<em class="related_suggestion_highlight">轻量级</em>锁和重量级锁的概念和<em class="related_suggestion_highlight">优化</em></a>

<p>
诚然，我们一提到<em class="related_suggestion_highlight">并发编程</em>，首先想到的可能应该就是<em class="related_suggestion_highlight">synchronized</em>，无可厚非其作用。大多数人都会称呼其为重量级锁，但是随着<em class="related_suggestion_highlight">JAVA</em>1.6对<em class="related_suggestion_highlight">synchronized</em>的<em class="related_suggestion_highlight">优化</em>，其变得不再那么重了。1.6中为了减少获得锁和释放锁带来的性能消耗而引入的<em class="related_suggestion_highlight">偏向</em>锁和<em class="related_suggestion_highlight">轻量级</em>锁，以及锁的存储结构和升级过程。下面我们一起来探究<em class="related_suggestion_highlight">synchronized</em>的实现机制以及<em class="related_suggestion_highlight">Java</em>是如何对其进行<em class="related_suggestion_highlight">优化</em>的。nn从宏观上分析，锁...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/Kirito_j/article/details/79201213" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/Kirito_j/article/details/79201213&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/Kirito_j/article/details/79201213&quot;}" target="_blank" title="Synchronized的原理及自旋锁，偏向锁，轻量级锁，重量级锁的区别"><em class="related_suggestion_highlight">Synchronized</em>的原理及自旋锁，<em class="related_suggestion_highlight">偏向</em>锁，<em class="related_suggestion_highlight">轻量级</em>锁，重量级锁的区别</a>

<p>
在多线程<em class="related_suggestion_highlight">并发编程</em>中<em class="related_suggestion_highlight">Synchronized</em>一直是元老级角色，很多人都会称呼它为重量级锁，但是随着<em class="related_suggestion_highlight">Java</em> SE1.6对<em class="related_suggestion_highlight">Synchronized</em>进行了各种<em class="related_suggestion_highlight">优化</em>之后，有些情况下它并不那么重了，<em class="related_suggestion_highlight">Java</em> SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的<em class="related_suggestion_highlight">偏向</em>锁和<em class="related_suggestion_highlight">轻量级</em>锁，以及锁的存储结构和升级过程。nn&nbsp;nn锁从宏观上分类，分为悲观锁与乐观锁。nn乐观锁nn乐观锁是一种乐观思想，即认为读多写少，遇...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/love905661433/article/details/82871531" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/love905661433/article/details/82871531&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/love905661433/article/details/82871531&quot;}" target="_blank" title="Java并发-synchronized, 偏向锁, 轻量级锁详解"><em class="related_suggestion_highlight">Java</em>并发-<em class="related_suggestion_highlight">synchronized</em>, <em class="related_suggestion_highlight">偏向</em>锁, <em class="related_suggestion_highlight">轻量级</em>锁详解</a>

<p>
<em class="related_suggestion_highlight">synchronized</em>概述nn<em class="related_suggestion_highlight">synchronized</em>就是所谓的重量级锁, 但是自从jdk1.6引入了<em class="related_suggestion_highlight">偏向</em>锁, <em class="related_suggestion_highlight">轻量级</em>锁之后, <em class="related_suggestion_highlight">synchronized</em>就没有那么重了。nn<em class="related_suggestion_highlight">synchronized</em>用法nn对于普通同步方法，锁是当前实例对象n对于静态同步方法，锁是当前类的Class对象n对于同步方法块，锁是Synchonized括号里配置的对象nn<em class="related_suggestion_highlight">synchronized</em>实现原理nn任何对象都有一...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/xyh930929/article/details/84571805" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/xyh930929/article/details/84571805&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/xyh930929/article/details/84571805&quot;}" target="_blank" title="Java并发偏向锁、轻量级锁、重量级锁、synchronized和volatile的实现原理"><em class="related_suggestion_highlight">Java</em>并发<em class="related_suggestion_highlight">偏向</em>锁、<em class="related_suggestion_highlight">轻量级</em>锁、重量级锁、<em class="related_suggestion_highlight">synchronized</em>和 volatile 的实现原理</a>

<p>
读<em class="related_suggestion_highlight">Java</em><em class="related_suggestion_highlight">并发编程</em>的艺术学习整理。rn1. 上下文切换rnCPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间,因为时间片非常短,所以CPU通过不停地切换线程执行,让我们感觉多个线程是同时执行的,时间片一般是几十毫秒(ms)。rnCPU通过时间片分配算法来循环执行任务,当前任务执行一个时间片后会切换到下一个任务。但是,在切换前会保存上一个任务的状态,以便下次切换回这个任...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/ailaojie/article/details/88712519" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/ailaojie/article/details/88712519&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/ailaojie/article/details/88712519&quot;}" target="_blank" title="JVM针对synchronized的锁优化:自旋锁,锁消除,锁粗化,轻量级锁,锁消除">JVM 针对<em class="related_suggestion_highlight">synchronized</em>的锁<em class="related_suggestion_highlight">优化</em>:自旋锁,锁消除,锁粗化,<em class="related_suggestion_highlight">轻量级</em>锁,锁消除</a>

<p>

</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/lkforce/article/details/81128358" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/lkforce/article/details/81128358&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/lkforce/article/details/81128358&quot;}" target="_blank" title="java同步锁优化方案学习笔记（偏向锁，轻量级锁，自旋锁，重量级锁）"><em class="related_suggestion_highlight">java</em>同步锁<em class="related_suggestion_highlight">优化</em>方案学习笔记（<em class="related_suggestion_highlight">偏向</em>锁，<em class="related_suggestion_highlight">轻量级</em>锁，自旋锁，重量级锁）</a>

<p>
目录nn一，概述nn二，CAS算法nn三，<em class="related_suggestion_highlight">Java</em>对象的对象头，以及Mark Wordnn四，<em class="related_suggestion_highlight">偏向</em>锁 Baised Locknn五，<em class="related_suggestion_highlight">轻量级</em>锁nn六，自旋锁 SpinLocknn七，重量级锁nn八，在应用层提高锁效率的方案nn一，概述nnn什么是<em class="related_suggestion_highlight">java</em>的锁？nn为什么<em class="related_suggestion_highlight">java</em>要有锁？nn<em class="related_suggestion_highlight">java</em>的锁为什么需要<em class="related_suggestion_highlight">优化</em>？nn怎么<em class="related_suggestion_highlight">优化</em>的？nnn1，<em class="related_suggestion_highlight">java</em>中使用<em class="related_suggestion_highlight">synchronized</em>关键字来实现同步功能...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/lengxiao1993/article/details/81568130" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/lengxiao1993/article/details/81568130&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/lengxiao1993/article/details/81568130&quot;}" target="_blank" title="Java中的偏向锁，轻量级锁， 重量级锁解析"><em class="related_suggestion_highlight">Java</em>中的<em class="related_suggestion_highlight">偏向</em>锁，<em class="related_suggestion_highlight">轻量级</em>锁， 重量级锁解析</a>

<p>
参考文章nnn聊聊并发（二）<em class="related_suggestion_highlight">Java</em> SE1.6中的<em class="related_suggestion_highlight">Synchronized</em>nLock Lock Lock: Enter!n5 Things You Didn’t Know About Synchronization in <em class="related_suggestion_highlight">Java</em> and ScalanSynchronization and Object Lockingnnn<em class="related_suggestion_highlight">Java</em> 中的锁nn在 <em class="related_suggestion_highlight">Java</em> 中主要2种加锁机制:nnnsynchr...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/qq_32924343/article/details/79680681" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_32924343/article/details/79680681&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_32924343/article/details/79680681&quot;}" target="_blank" title="Java--偏向锁/轻量级锁/重量级锁"><em class="related_suggestion_highlight">Java</em>--<em class="related_suggestion_highlight">偏向</em>锁/<em class="related_suggestion_highlight">轻量级</em>锁/重量级锁</a>

<p>
首先要解释清楚这几种锁的特征和区别，以及运行时候的变化，需要了解<em class="related_suggestion_highlight">Java</em>对象头的一些知识，在<em class="related_suggestion_highlight">Java</em>对象头的Mark Word内就记录着这些不同锁的状态位。另外<em class="related_suggestion_highlight">偏向</em>锁---<em class="related_suggestion_highlight">轻量级</em>锁---重量级锁本文都需要依托synchronize进行理解和分析。另外也要参照网络上很多的资料。1.对象头：关于对象头的具体记录，可以参考这边：对象头2.同步的原理：关于JVM规范对于同步的解释，可以参考这边：monit...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/ZISHAN0072009/article/details/76285995" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/ZISHAN0072009/article/details/76285995&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/ZISHAN0072009/article/details/76285995&quot;}" target="_blank" title="Synchronized下的三种锁升级场景解读"><em class="related_suggestion_highlight">Synchronized</em>下的三种锁升级场景解读</a>

<p>
http://www.infoq.com/cn/articles/<em class="related_suggestion_highlight">java</em>-se-16-<em class="related_suggestion_highlight">synchronized</em>rnrn读后解读<em class="related_suggestion_highlight">Synchronized</em>下的三种锁rn<em class="related_suggestion_highlight">偏向</em>锁rn轻量锁rn重量锁rnrnrnrnrn共享场景骑单车007号车rnrnrn# 获取<em class="related_suggestion_highlight">偏向</em>锁rn1、 张飞要骑rn有人吗rn没人rn写上张飞的名字rn成功获取<em class="related_suggestion_highlight">偏向</em>锁rn骑走rn# 成功<em class="related_suggestion_highlight">偏向</em>锁 rn1.1、张飞要骑车rn有我的名字r
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/noble510520/article/details/78834224" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/noble510520/article/details/78834224&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/noble510520/article/details/78834224&quot;}" target="_blank" title="锁原理：偏向锁、轻量锁、重量锁">锁原理：<em class="related_suggestion_highlight">偏向</em>锁、轻量锁、重量锁</a>

<p>
<em class="related_suggestion_highlight">java</em>中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁、<em class="related_suggestion_highlight">偏向</em>锁、<em class="related_suggestion_highlight">轻量级</em>锁、重量级锁。每个对象一开始都是无锁的，随着线程间争夺锁，越激烈，锁的级别越高，并且锁只能升级不能降级。
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/nalanmingdian/article/details/77513209" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/nalanmingdian/article/details/77513209&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/nalanmingdian/article/details/77513209&quot;}" target="_blank" title="深入理解JVM——轻量级锁和偏向锁">深入理解 JVM——<em class="related_suggestion_highlight">轻量级</em>锁和<em class="related_suggestion_highlight">偏向</em>锁</a>

<p>
<em class="related_suggestion_highlight">轻量级</em>锁JDK1.6出现的。并不能代替重量级锁，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。HotSpot虚拟机对象头对象自身的运行时数据如：哈希吗（HashCode）、GC分代年龄(Generational GC Age)等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，简称“Mark Word”，如果对象是数组类型，则虚拟机用3个
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/qq_34337272/article/details/83409990" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_34337272/article/details/83409990&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_34337272/article/details/83409990&quot;}" target="_blank" title="Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比"><em class="related_suggestion_highlight">Synchronized</em> 关键字使用、<em class="related_suggestion_highlight">底层</em>原理、JDK1.6 之后的<em class="related_suggestion_highlight">底层</em><em class="related_suggestion_highlight">优化</em>以及 和 ReenTrantLock 的对比</a>

<p>
以下内容摘自我的 Gitchat ：<em class="related_suggestion_highlight">Java</em> 程序员必备：并发知识系统总结，欢迎订阅！nGithub 地址：https://github.com/Snailclimb/<em class="related_suggestion_highlight">Java</em>Guide/edit/master/<em class="related_suggestion_highlight">Java</em>相关/<em class="related_suggestion_highlight">synchronized</em>.mdnn<em class="related_suggestion_highlight">synchronized</em>关键字最主要的三种使用方式的总结nn修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁n修饰...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/lmx125254/article/details/88558535" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/lmx125254/article/details/88558535&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/lmx125254/article/details/88558535&quot;}" target="_blank" title="Synchronized下的自旋锁、偏向锁、轻量级锁以及重量级锁（这是一篇有味道的博客）"><em class="related_suggestion_highlight">Synchronized</em>下的自旋锁、<em class="related_suggestion_highlight">偏向</em>锁、<em class="related_suggestion_highlight">轻量级</em>锁以及重量级锁（这是一篇有味道的博客）</a>

<p>
在理解<em class="related_suggestion_highlight">Synchronized</em>中的锁时，需要先了解一下CAS，CAS在应用中有很多的用途。nn什么是CAS？nnCAS的全名叫做Compare andSwap,翻译过来就是先比较再交换，在<em class="related_suggestion_highlight">JAVA</em>的并发包中很多的类用到了这个技术，也和数据库的乐观锁机制是一样的。nn举个栗子说明下nn   1。第一步拿到需要修改的对象nn   2。第二步修改当前对象的值nn   3。将当前的对象...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/zhttly/article/details/84030393" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/zhttly/article/details/84030393&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/zhttly/article/details/84030393&quot;}" target="_blank" title="synchronized的实现原理以及锁的升级降级"><em class="related_suggestion_highlight">synchronized</em>的实现原理以及锁的升级降级</a>

<p>
n<em class="related_suggestion_highlight">java</em>中锁的表现形式nnn对于普通的方法,锁是当前的实例对象n对于静态同步方法,锁是当前类的class对象n对于同步代码块,锁是代码块中的对象nnn<em class="related_suggestion_highlight">java</em>对象头nn<em class="related_suggestion_highlight">synchronized</em>所使用的锁是存放在<em class="related_suggestion_highlight">java</em>的对象头中的,如果对象是数组类型,虚拟机使用3个字宽存储对象头,如果对象是非数组类型,则使用2字宽来存储对象头nn锁的升级nn首先要了解<em class="related_suggestion_highlight">偏向</em>锁和<em class="related_suggestion_highlight">轻量级</em>锁,<em class="related_suggestion_highlight">偏向</em>锁就是在不存在大量线程...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/u012722531/article/details/78244786" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/u012722531/article/details/78244786&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/u012722531/article/details/78244786&quot;}" target="_blank" title="浅谈Java里的三种锁：偏向锁、轻量级锁和重量级锁">浅谈<em class="related_suggestion_highlight">Java</em>里的三种锁：<em class="related_suggestion_highlight">偏向</em>锁、<em class="related_suggestion_highlight">轻量级</em>锁和重量级锁</a>

<p>
在学习sychronized关键字及其实现细节的时候，发现<em class="related_suggestion_highlight">java</em>中的三种锁，<em class="related_suggestion_highlight">偏向</em>锁，<em class="related_suggestion_highlight">轻量级</em>锁，重量级锁其实也有很多值得探究的地方，引入<em class="related_suggestion_highlight">偏向</em>锁是为了在无多线程竞争的情况下尽量减少不必要的<em class="related_suggestion_highlight">轻量级</em>锁执行路径，因为<em class="related_suggestion_highlight">轻量级</em>锁的获取及释放依赖多次CAS原子指令，而<em class="related_suggestion_highlight">偏向</em>锁只需要在置换ThreadID的时候依赖一次CAS原子指令，代价就是一旦出现多线程竞争的情况就必须撤销<em class="related_suggestion_highlight">偏向</em>锁。nn<em class="related_suggestion_highlight">Java</em>对象头的长度
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/a15929748502/article/details/84351074" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/a15929748502/article/details/84351074&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/a15929748502/article/details/84351074&quot;}" target="_blank" title="从Java的对象头到Java内建锁synchronized的底层实现（一）">从<em class="related_suggestion_highlight">Java</em>的对象头到<em class="related_suggestion_highlight">Java</em>内建锁<em class="related_suggestion_highlight">synchronized</em>的<em class="related_suggestion_highlight">底层</em>实现（一）</a>

<p>
就如标题，今天我们的话题会从对象说起。我们知道对象在JVM的内存结构中，是存放在堆内存中的（new 一个类之后JVM会在堆上为new出的对象申请一块空间）。在内存中，一个<em class="related_suggestion_highlight">Java</em>对象包含三部分：对象头、实例数据和对齐填充。而对象头内存有的信息就有markwork，这是实现<em class="related_suggestion_highlight">synchronized</em>锁机制的核心。对象头到底是什么呢？是怎样通过对象头来实现<em class="related_suggestion_highlight">synchronized</em>锁机...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/weixin_34152820/article/details/88268458" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_34152820/article/details/88268458&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_34152820/article/details/88268458&quot;}" target="_blank" title="锁优化:偏向锁,轻量级锁,重量级锁">锁<em class="related_suggestion_highlight">优化</em>:<em class="related_suggestion_highlight">偏向</em>锁,<em class="related_suggestion_highlight">轻量级</em>锁,重量级锁</a>

<p>
一个想休息的线程：JVM到底是怎么处理锁的？怎么不让我阻塞呢？n《深入理解<em class="related_suggestion_highlight">java</em>虚拟机》nn代码中有些特殊的地方，叫做临界区，比如<em class="related_suggestion_highlight">synchronized</em>修饰的方法或者代码块，只允许一个线程进入执行。n线程1要进入一个Account对象的临界区为例:n<em class="related_suggestion_highlight">偏向</em>锁n提高  有同步,但无竞争  的程序的性能n线程1 是第一个 准备进入此代码块的线程,JVM把A...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/qq_25484147/article/details/87732180" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_25484147/article/details/87732180&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_25484147/article/details/87732180&quot;}" target="_blank" title="Java并发之彻底搞懂偏向锁升级为轻量级锁"><em class="related_suggestion_highlight">Java</em>并发之彻底搞懂<em class="related_suggestion_highlight">偏向</em>锁升级为<em class="related_suggestion_highlight">轻量级</em>锁</a>

<p>
转载:https://www.cnblogs.com/tiancai/p/9382542.htmln<em class="related_suggestion_highlight">Java</em>并发之彻底搞懂<em class="related_suggestion_highlight">偏向</em>锁升级为<em class="related_suggestion_highlight">轻量级</em>锁nn网上有许多讲<em class="related_suggestion_highlight">偏向</em>锁，<em class="related_suggestion_highlight">轻量级</em>锁的文章，但对<em class="related_suggestion_highlight">偏向</em>锁如何升级讲的不够明白,有些文章还相互矛盾,经过对jvm源码(biasedLocking.cpp)的仔细分析和追踪,基本升级过程有了一个清晰的过程,现将升级流程阐述如下:nnn因为<em class="related_suggestion_highlight">偏向</em>锁，锁住对象时，会写入对象...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/A__17/article/details/78187386" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/A__17/article/details/78187386&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/A__17/article/details/78187386&quot;}" target="_blank" title="java中锁的优化 -- JVM对synchronized的优化"><em class="related_suggestion_highlight">java</em>中锁的<em class="related_suggestion_highlight">优化</em> -- JVM 对<em class="related_suggestion_highlight">synchronized</em>的<em class="related_suggestion_highlight">优化</em></a>

<p>
n<em class="related_suggestion_highlight">java</em>中锁的<em class="related_suggestion_highlight">优化</em> -- JVM对<em class="related_suggestion_highlight">synchronized</em>的<em class="related_suggestion_highlight">优化</em>nn	n1）锁消除n	概念：JVM在JIT编译(即时编译)时，通过对运行上下文的扫描，去除掉那些不可能发生共享资源竞争的锁，从而节省了线程请求这些锁的时间。nn	举例：n		StringBuffer的append方法是一个同步方法，如果StringBuffer类型的变量是一个局部变量，则该变量就不会被其它线程所使用，即对局部变量的操...
</p>
</li>

<li class="news-recommends-ajax">

<a href="https://blog.csdn.net/a314773862/article/details/54095819" data-report-click="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/a314773862/article/details/54095819&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_712&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/a314773862/article/details/54095819&quot;}" target="_blank" title="自旋锁、阻塞锁、可重入锁、悲观锁、乐观锁、读写锁、偏向所、轻量级锁、重量级锁、锁膨胀、对象锁和类锁">自旋锁、阻塞锁、可重入锁、悲观锁、乐观锁、读写锁、<em class="related_suggestion_highlight">偏向</em>所、<em class="related_suggestion_highlight">轻量级</em>锁、重量级锁、锁膨胀、对象锁和类锁</a>

<p>

</p>
</li>

</ul>
</div>
</div>

</div>

<script type="text/javascript">
dp.SyntaxHighlighter.HighlightAll('code', true, true);

$$('#main .blog_content pre[name=code]').each(function(pre, index){ // blog content
var post_id = 2409178;
var location = window.location;
source_url = location.protocol + "//" + location.host + location.pathname + location.search;
pre.writeAttribute('codeable_id', post_id);
pre.writeAttribute('codeable_type', "Blog");
pre.writeAttribute('source_url', source_url);
pre.writeAttribute('pre_index', index);
pre.writeAttribute('title', 'Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）');
});

fix_image_size($$('div.blog_content img'), 700);

function processComment() {
$$('#main .blog_comment > div').each(function(comment){// comment
var post_id = comment.id.substr(2);
$$("#"+comment.id+" pre[name=code]").each(function(pre, index){
var location = window.location;
source_url = location.protocol + "//" + location.host + location.pathname + location.search;
source_url += "#" + comment.id;
pre.writeAttribute('codeable_id', post_id);
pre.writeAttribute('codeable_type', "BlogComment");
pre.writeAttribute('source_url', source_url);
pre.writeAttribute('pre_index', index);
pre.writeAttribute('title', 'Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）');
});
});
}

function quote_comment(id) {
new Ajax.Request('/editor/quote', {
parameters: {'id':id, 'type':'BlogComment'},
onSuccess:function(response){editor.bbcode_editor.textarea.insertAfterSelection(response.responseText);
Element.scrollTo(editor.bbcode_editor.textarea.element);}
});
}

code_favorites_init();
processComment();
new WeiboShare({share_buttons: $('share_weibo'), img_scope: $('blog_content')});
</script>

</div>
