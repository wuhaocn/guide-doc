# Java 内存模型

## 地址空间划分

- 内核空间
- 用户空间(java 实际运用)

## 内存模型(JDK ８）

### 线程角度

私有

- 程序计数器
- 虚拟机栈
- 本地方法栈

共享:

- MetaSpace(类加载信息,元空间)
- 常量词,Java 堆

### 程序计数器(PC)

- 当前线程所执行字节码的行号指示器(**逻辑**)
- 改变 PC 的值来选取下一条需要执行的字节码指令
- **和线程是一对一的**
- **对 Java 方法计数**,如果是**Native 方法**则计数器值为**Undefined**
- 不会发生内存泄漏

Java 虚拟机栈(Stack)

- Java 方法执行的内存模型
- 包含多个栈帧
  - 局部变量表
    - 包含方法执行过程中的所有变量
  - 操作栈
    - 入栈,出栈,复制,交换,产生消费变量
  - 动态链接
  - 返回地址

递归为什么会引发 java.lang.StackOverFlowError 异常

虚拟机栈过多会引发 Java.lang.OutOfMemoryErrot 异常

### 本地方法栈

用于 native 方法

### 元空间(MetaSpace)与永久代(PermGen)

- jdk7 以前元空间是永久代
- 元空间使用本地内存,永久代使用 jvm 内存
- 类和方法的信息大小难以确定,给永久代指定大小带来困难
- 永久代会为 GC 带来不必要的复杂性
- 方便 HotSpot 与其他 JVM 如 Jrockit 的集成

### 三大性能调优参数

- -Xms(规定每个线程虚拟机栈(堆栈)的大小
- -Xmx(堆的初始值)
- -Xss(堆能达到的最大值)

### 堆和栈的区别 - 内存分配策略

- 静态存储:编译时确定每个数据目标再运行时的存储的空间需求
- 栈式存储:数据区需求再编译时未知,运行时模块入口前确定
- 堆式存储:编译时或运行时入口都无法确定,动态分配

区别:

- 联系:引用对象,数组时,栈里定义变量保存堆中目标的首地址
- 管理方式:栈自动释放,堆需要 GC
- 空间大小:栈比堆小
- 碎片相关:栈产生的碎片远小于堆
- 分配方式:栈支持静态,动态分配,而堆仅支持动态分配
- 效率:栈效率比堆高

### 元空间,堆,线程独占部分间的联系

![1551835957454](C:\Users\95150\AppData\Roaming\Typora\typora-user-images\1551835957454.png)

### intern( ) JDK6 VS JDK6+

- JDK6:当调用 intern()方法时,如果字符串常量池已经创建出该字符串对象,则返回到池中该字符串的引用.否则,则先将此字符串对象添加到字符串常量词中,并返回该字符串对象的引用(永久代里)
- JDK6+:调用 intern()方法时.如果字符串常量池先前已创建出该字符串对象,则返回该字符串的引用,否则,若字符串对象已经存在于 Java 堆中,则将堆中对此对象的引用添加到字符串常量池中,并且返回该引用.若 Java 堆中不存在,则在池中创建该字符串并返回引用.
