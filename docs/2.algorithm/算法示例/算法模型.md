### 数组

- 下标访问时间复杂度为 o(1)
- 存在容量限制
- 修改操作成本较高
- java 实现：ArrayList

### 链表

- 访问时间复杂度 o(n)
- 无容量限制
- 修改操作成本较低
- java 实现： LinkedList

### 栈

- 先进后出
- java 实现： Stack<T>

### 队列

- 先进先出
- java 实现： Queue<T>,LinkedBlockingQueue, ArrayBlockingQueue, PriorityQueue,PriorityBlockingQueue

### 树

- 访问时间复杂度为 log(n）
- 具备排序属性
- 修改操作成本较高
- java 实现：TreeMap（红黑树）
- mysql 实现：B+树

### 区间树

-

### 字典树

-

### 树状数组

-

### 线段树

- 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。
- 时间复杂度 log（n）（建树为 O(n)）
- [线段树](https://www.cnblogs.com/xenny/p/9801703.html)
- [线段树](https://zhuanlan.zhihu.com/p/48760172)

### 跳表

- 访问时间复杂度为 log（n）
- 具备排序属性
- 修改成本较低
- java 实现： SkipList
- Redis 实现： 有序集合

### 哈希

- 基于数组实现，访问时间复杂度为 o(1)
- 不具备排序属性
- 特定容量情况下修改操作耗时成本较低
- java 实现：HashMap，LinkedHashMap
  [哈希表实例](哈希表.md)

### 字符串

- 不可变
-

### 位运算

- 提高运算效率
- 替代加减乘除

### 暴力算法

- 有效时间复杂度较高的算法
- 得到的结果肯定是正确的；
- 可能做了很多的无用功，浪费了宝贵的时间，效率低下。
- 通常会涉及到求极值（如最大，最小，最重等）。
- 数据量大的话，可能会造成时间崩溃。
  [暴力法案例](暴力法.md)

### 双指针

- 优化暴力解法算法复杂度 O(n2)到 O(n)
- 对于一个序列，用两个指针维护一段区间，减少重复次数
- 对于两个序列，维护某种次序，比如归并合并两个有序的序列
- https://www.acwing.com/blog/content/631/
  [双指针案例](双指针.md)

### 分治算法

- 该问题的规模缩小到一定的程度就可以容易地解决
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。
- 利用该问题分解出的子问题的解可以合并为该问题的解；
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。
  [分治算法案例](分治算法.md)

### 动态规划

- 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
- 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
- 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
  [动态规划案例](动态规划.md)

### 贪心算法

- 建立数学模型来描述问题。
- 把求解的问题分成若干个子问题。
- 对每一子问题求解，得到子问题的局部最优解。
- 把子问题的解局部最优解合成原来解问题的一个解。

### 回溯算法

- 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。
- 确定结点的扩展搜索规则
- 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

### 深度优先搜索算法

- 深度优先搜索（DFS）
-
- [深度优先算法示例](深度优先搜索.md)

### 广度优先搜索

- 广度优先搜索（BFS）
  _（1）从队列头取出一个结点，检查它按照扩展规则是否能够扩展，如果能则产生一个新结点。
  _（2）检查新生成的结点，看它是否已在队列中存在，如果新结点已经在队列中出现过，就放弃这个结点，然后回到第（1）步。否则，如果新结点未曾在队列中出现过，则将它加入到队列尾。 \*（3）检查新结点是否目标结点。如果新结点是目标结点，则搜索成功，程序结束；若新结点不是目标结点，则回到第（1）步，再从队列头取出结点进行扩展。
- [广度优先算法示例](广度优先搜索.md)

### 递归

- 栈的变形
- 分治算法实现策略
-

### 二分查找

## -

### 二叉搜索树

### 字典树

- 单词查找树，Trie 树，是一种树形结构，是一种哈希树的变种。
- 典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
- 优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。
  [字典树示例](字典树.md)

### 排序

- [选择排序.md](排序/0.选择排序.md)
- [冒泡排序.md](排序/1.冒泡排序.md)
- [插入排序.md](排序/2.插入排序.md)
- [快速排序.md](排序/3-快速排序.md)
- [归并排序.md](排序/4-归并排序.md)
- [希尔排序.md](排序/5-希尔排序.md)
- [堆排序.md](排序/6-堆排序.md)
- [计数排序.md](排序/7.计数排序.md)
- [桶排序.md](排序/8-桶排序.md)
- [基数排序.md](排序/9-基数排序.md)
