【Zookeeper】源码分析之 Watcher 机制（一） 一、前言 前面已经分析了 Zookeeper 持久话相关的类，下面接着分析 Zookeeper 中的 Watcher 机制所涉及到的类。 二、总体框图 对于 Watcher 机制而言，主要涉及的类主要如下。 ![](https://images2015.cnblogs.com/blog/616953/201701/616953-20170115160511635-533910072.png) 说明： Watcher，接口类型，其定义了 process 方法，需子类实现。 Event，接口类型，Watcher 的内部类，无任何方法。 KeeperState，枚举类型，Event 的内部类，表示 Zookeeper 所处的状态。 EventType，枚举类型，Event 的内部类，表示 Zookeeper 中发生的事件类型。 WatchedEvent，表示对 ZooKeeper 上发生变化后的反馈，包含了 KeeperState 和 EventType。 ClientWatchManager，接口类型，表示客户端的 Watcher 管理者，其定义了 materialized 方法，需子类实现。 ZKWatchManager，Zookeeper 的内部类，继承 ClientWatchManager。 MyWatcher，ZooKeeperMain 的内部类，继承 Watcher。 ServerCnxn，接口类型，继承 Watcher，表示客户端与服务端的一个连接。 WatchManager，管理 Watcher。 三、Watcher 源码分析 3.1 内部类 Event，接口类型，表示事件代表的状态，除去其内部类，其源码结构如下 public interface Event {} 　　说明：可以看到，Event 接口并没有定义任何属性和方法，但是其包含了 KeeperState 和 EventType 两个内部枚举类。 3.2 接口方法 abstract public void process(WatchedEvent event); 　　说明：其代表了实现 Watcher 接口时必须实现的的方法，即定义进行处理，WatchedEvent 表示观察的事件。 四、Event 源码分析 3.1 内部类 1. KeeperState `public enum KeeperState { // 事件发生时Zookeeper的状态 //*/* Unused, this state is never generated by the server /*/ @Deprecated // 未知状态，不再使用，服务器不会产生此状态 Unknown (-1), //*/* The client is in the disconnected state - it is not connected /* to any server in the ensemble. /*/ // 断开 Disconnected (0), //*/* Unused, this state is never generated by the server /*/ @Deprecated // 未同步连接，不再使用，服务器不会产生此状态 NoSyncConnected (1), //*/* The client is in the connected state - it is connected /* to a server in the ensemble (one of the servers specified /* in the host connection parameter during ZooKeeper client /* creation). /*/ // 同步连接状态 SyncConnected (3), //*/* /* Auth failed state /*/ // 认证失败状态 AuthFailed (4), //*/* /* The client is connected to a read-only server, that is the /* server which is not currently connected to the majority. /* The only operations allowed after receiving this state is /* read operations. /* This state is generated for read-only clients only since /* read/write clients aren't allowed to connect to r/o servers. /*/ // 只读连接状态 ConnectedReadOnly (5), //*/* /* SaslAuthenticated: used to notify clients that they are SASL-authenticated, /* so that they can perform Zookeeper actions with their SASL-authorized permissions. /*/ // SASL认证通过状态 SaslAuthenticated(6), //*/* The serving cluster has expired this session. The ZooKeeper /* client connection (the session) is no longer valid. You must /* create a new client connection (instantiate a new ZooKeeper /* instance) if you with to access the ensemble. /*/ // 过期状态 Expired (-112); // 代表状态的整形值 private final int intValue; // Integer representation of value // for sending over wire // 构造函数 KeeperState(int intValue) { this.intValue = intValue; } // 返回整形值 public int getIntValue() { return intValue; } // 从整形值构造相应的状态 public static KeeperState fromInt(int intValue) { switch(intValue) { case -1: return KeeperState.Unknown; case 0: return KeeperState.Disconnected; case 1: return KeeperState.NoSyncConnected; case 3: return KeeperState.SyncConnected; case 4: return KeeperState.AuthFailed; case 5: return KeeperState.ConnectedReadOnly; case 6: return KeeperState.SaslAuthenticated; case -112: return KeeperState.Expired; default: throw new RuntimeException("Invalid integer value for conversion to KeeperState"); } } }` 说明：KeeperState 是一个枚举类，其定义了在事件发生时 Zookeeper 所处的各种状态，其还定义了一个从整形值返回对应状态的方法 fromInt。 2. EventType `public enum EventType { // 事件类型 // 无 None (-1), // 结点创建 NodeCreated (1), // 结点删除 NodeDeleted (2), // 结点数据变化 NodeDataChanged (3), // 结点子节点变化 NodeChildrenChanged (4); // 代表事件类型的整形 private final int intValue; // Integer representation of value // for sending over wire // 构造函数 EventType(int intValue) { this.intValue = intValue; } // 返回整形 public int getIntValue() { return intValue; } // 从整形构造相应的事件 public static EventType fromInt(int intValue) { switch(intValue) { case -1: return EventType.None; case 1: return EventType.NodeCreated; case 2: return EventType.NodeDeleted; case 3: return EventType.NodeDataChanged; case 4: return EventType.NodeChildrenChanged; default: throw new RuntimeException("Invalid integer value for conversion to EventType"); } } } }` 说明：EventType 是一个枚举类，其定义了事件的类型（如创建节点、删除节点等事件），同时，其还定义了一个从整形值返回对应事件类型的方法 fromInt。 五、WatchedEvent 5.1 类的属性 `public class WatchedEvent { // Zookeeper的状态 final private KeeperState keeperState; // 事件类型 final private EventType eventType; // 事件所涉及节点的路径 private String path; }` 说明：WatchedEvent 类包含了三个属性，分别代表事件发生时 Zookeeper 的状态、事件类型和发生事件所涉及的节点路径。 5.2 构造函数 1. public WatchedEvent(EventType eventType, KeeperState keeperState, String path)型构造函数 `public WatchedEvent(EventType eventType, KeeperState keeperState, String path) { // 初始化属性 this.keeperState = keeperState; this.eventType = eventType; this.path = path; }` 说明：构造函数传入了三个参数，然后分别对属性进行赋值操作。 2. public WatchedEvent(WatcherEvent eventMessage)型构造函数 `public WatchedEvent(WatcherEvent eventMessage) { // 从eventMessage中取出相应属性进行赋值 keeperState = KeeperState.fromInt(eventMessage.getState()); eventType = EventType.fromInt(eventMessage.getType()); path = eventMessage.getPath(); }` 说明：构造函数传入了 WatcherEvent 参数，之后直接从该参数中取出相应属性进行赋值操作。 对于 WatchedEvent 类的方法而言，相对简单，包含了几个 getXXX 方法，用于获取相应的属性值。 六、ClientWatchManager 6.1 接口方法 public Set materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String path); 　　说明：该方法表示事件发生时，返回需要被通知的 Watcher 集合，可能为空集合。 七、ZKWatchManager 7.1 类的属性 `private static class ZKWatchManager implements ClientWatchManager { // 数据变化的Watchers private final Map> dataWatches = new HashMap>(); // 节点存在与否的Watchers private final Map> existWatches = new HashMap>(); // 子节点变化的Watchers private final Map> childWatches = new HashMap>(); }` 说明：ZKWatchManager 实现了 ClientWatchManager，并定义了三个 Map 键值对，键为节点路径，值为 Watcher。分别对应数据变化的 Watcher、节点是否存在的 Watcher、子节点变化的 Watcher。 7.2 核心方法分析 1. materialize 方法 `public Set materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath) { // 新生成结果Watcher集合 Set result = new HashSet(); switch (type) { // 确定事件类型 case None: // 无类型 // 添加默认Watcher result.add(defaultWatcher); // 是否需要清空(提取对zookeeper.disableAutoWatchReset字段进行配置的值、Zookeeper的状态是否为同步连接) boolean clear = ClientCnxn.getDisableAutoResetWatch() && state != Watcher.Event.KeeperState.SyncConnected; synchronized(dataWatches) { // 同步块 for(Set ws: dataWatches.values()) { // 添加至结果集合 result.addAll(ws); } if (clear) { // 是否需要清空 dataWatches.clear(); } } synchronized(existWatches) { // 同步块 for(Set ws: existWatches.values()) { // 添加至结果集合 result.addAll(ws); } if (clear) { // 是否需要清空 existWatches.clear(); } } synchronized(childWatches) { // 同步块 for(Set ws: childWatches.values()) { // 添加至结果集合 result.addAll(ws); } if (clear) { // 是否需要清空 childWatches.clear(); } } // 返回结果 return result; case NodeDataChanged: // 节点数据变化 case NodeCreated: // 创建节点 synchronized (dataWatches) { // 同步块 // 移除clientPath对应的Watcher后全部添加至结果集合 addTo(dataWatches.remove(clientPath), result); } synchronized (existWatches) { // 移除clientPath对应的Watcher后全部添加至结果集合 addTo(existWatches.remove(clientPath), result); } break; case NodeChildrenChanged: // 节点子节点变化 synchronized (childWatches) { // 移除clientPath对应的Watcher后全部添加至结果集合 addTo(childWatches.remove(clientPath), result); } break; case NodeDeleted: // 删除节点 synchronized (dataWatches) { // 移除clientPath对应的Watcher后全部添加至结果集合 addTo(dataWatches.remove(clientPath), result); } // XXX This shouldn't be needed, but just in case synchronized (existWatches) { // 移除clientPath对应的Watcher Set list = existWatches.remove(clientPath); if (list != null) { // 移除clientPath对应的Watcher后全部添加至结果集合 addTo(existWatches.remove(clientPath), result); LOG.warn("We are triggering an exists watch for delete! Shouldn't happen!"); } } synchronized (childWatches) { // 移除clientPath对应的Watcher后全部添加至结果集合 addTo(childWatches.remove(clientPath), result); } break; default: // 缺省处理 String msg = "Unhandled watch event type " + type + " with state " + state + " on path " + clientPath; LOG.error(msg); throw new RuntimeException(msg); } // 返回结果集合 return result; } }` 说明：该方法在事件发生后，返回需要被通知的 Watcher 集合。在该方法中，首先会根据 EventType 类型确定相应的事件类型，然后根据事件类型的不同做出相应的操作，如针对 None 类型，即无任何事件，则首先会从三个键值对中删除 clientPath 对应的 Watcher，然后将剩余的 Watcher 集合添加至结果集合；针对 NodeDataChanged 和 NodeCreated 事件而言，其会从 dataWatches 和 existWatches 中删除 clientPath 对应的 Watcher，然后将剩余的 Watcher 集合添加至结果集合。 八、总结 针对 Watcher 机制的第一部分的源码分析就已经完成，可以看到此部分的源码相对简单，之后会分析 org.apache.zookeeper.server 下的 WatchManager 和 ClientWatchManager 所在外部类 ZooKeeper，也谢谢各位园友的观看~
