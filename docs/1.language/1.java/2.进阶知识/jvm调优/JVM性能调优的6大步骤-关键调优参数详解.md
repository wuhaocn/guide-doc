## 一、JVM 内存调优

对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数。
![](https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg)

### 1.Full GC

会对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少 Full GC 的次数。

### 2.导致 Full GC 的原因

1)年老代（Tenured）被写满

调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。

2)持久代 Pemanet Generation 空间不足

增大 Perm Gen 空间，避免太多静态对象 ， 控制好新生代和旧生代的比例

3)System.gc()被显示调用

垃圾回收不要手动触发，尽量依靠 JVM 自身的机制

在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节，下面详细介绍对应 JVM 调优的方法和步骤。

## 二、JVM 性能调优方法和步骤

![](https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg)

### 1.监控 GC 的状态

使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 gc 日志，根据实际的各区域内存划分和 GC 执行时间，觉得是否进行优化。

举一个例子： 系统崩溃前的一些现象：

每次垃圾回收的时间越来越长，由之前的 10ms 延长到 50ms 左右，FullGC 的时间也有之前的 0.5s 延长到 4、5s FullGC 的次数越来越多，最频繁时隔不到 1 分钟就进行一次 FullGC
年老代的内存越来越大并且每次 FullGC 后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达 OutOfMemoryError 的临界值，这个时候就需要分析 JVM 内存快照 dump。

### 2.生成堆的 dump 文件

通过 JMX 的 MBean 生成当前的 Heap 信息，大小为一个 3G（整个堆的大小）的 hprof 文件，如果没有启动 JMX 可以通过 Java 的 jmap 命令来生成该文件。

### 3.分析 dump 文件

打开这个 3G 的堆信息文件，显然一般的 Window 系统没有这么大的内存，必须借助高配置的 Linux，几种工具打开该文件：

Visual VM IBM HeapAnalyzer JDK 自带的 Hprof 工具 Mat(Eclipse 专门的静态内存分析工具)推荐使用 备注：文件太大，建议使用 Eclipse 专门的静态内存分析工具 Mat 打开分析。

### 4.分析结果，判断是否需要优化

如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化，如果 GC 时间超过 1-3 秒，或者频繁 GC，则必须优化。

注：如果满足下面的指标，则一般不需要进行 GC：

Minor GC 执行时间不到 50ms； Minor GC 执行不频繁，约 10 秒一次； Full GC 执行时间不到 1s； Full GC 执行频率不算频繁，不低于 10 分钟 1 次；

### 5.调整 GC 类型和内存分配

如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找 1 台或几台机器进行 beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。

### 6.不断的分析和调整

通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。

cms 参数优化步流程
![](https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg)
下面我再继续介绍下 JVM 的关键参数配置(仅用于参考)。

## JVM 调优参数参考

### 1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;

### 2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。

比如年轻代，通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize 设置为同样大小。

### 3.年轻代和年老代设置多大才算合理

1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC
2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率 如何选择应该依赖应用程序对象生命周期的分布情况：
如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性。 在抉择时应该根 据以下两点：

- （1）本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的默认比例 1：2 也是这个道理 。

- （2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响 Full GC 的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。 但应该给年老代至少预留 1/3 的增长空间。

### 4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。

### 5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。

理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

觉得不错请点赞支持下。

----end----

JVM 相关技术干货推荐：

- 深入详解 JVM 内存模型与 JVM 参数详细配置
- 7 种 JVM 垃圾收集器特点，优劣势、及使用场景
- JVM 的 4 种垃圾回收算法、垃圾回收机制与总结
- 深入剖析 JVM：G1 收集器+回收流程+推荐用例

## 参考：

https://zhuanlan.zhihu.com/p/58897189
