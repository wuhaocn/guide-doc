<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelHandler（一）之简介
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/intro-2/?self">《精尽 Netty 源码分析 —— Netty 简介（二）之核心组件》</a> 中，对 ChannelHandler 做了定义，我们再来回顾下：</p>
<blockquote>
<p>ChannelHandler ，连接通道处理器，我们使用 Netty 中<strong>最常用</strong>的组件。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>
</blockquote>
<p>实际上，我们已经在前面的文章看了一遍又一遍 ChannelHandler 的身影，已经是熟悉的老朋友了。当然，我们还是会在这个<strong>专属</strong>于 ChannelHandler 章节里，再更加深入的认识 ChannelHandler 。</p>
<p><code>io.netty.channel.ChannelHandler</code> ，Channel 处理器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called after the {<span class="doctag">@link</span> ChannelHandler} was added to the actual context and it's ready to handle events.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ChannelHandler 已经成功被添加到 ChannelPipeline 中，可以进行处理事件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该方法，一般用于 ChannelHandler 的初始化的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called after the {<span class="doctag">@link</span> ChannelHandler} was removed from the actual context and it doesn't handle events</span></span><br><span class="line"><span class="comment">     * anymore.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ChannelHandler 已经成功从 ChannelPipeline 中被移除，不再进行处理事件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该方法，一般用于 ChannelHandler 的销毁的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called if a {<span class="doctag">@link</span> Throwable} was thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 抓取到异常。目前被废弃，移到 ChannelInboundHandler 接口中，作为对 Exception Inbound 事件的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> is part of {<span class="doctag">@link</span> ChannelInboundHandler}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates that the same instance of the annotated {<span class="doctag">@link</span> ChannelHandler}</span></span><br><span class="line"><span class="comment">     * can be added to one or more {<span class="doctag">@link</span> ChannelPipeline}s multiple times</span></span><br><span class="line"><span class="comment">     * without a race condition.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If this annotation is not specified, you have to create a new handler</span></span><br><span class="line"><span class="comment">     * instance every time you add it to a pipeline because it has unshared</span></span><br><span class="line"><span class="comment">     * state such as member variables.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This annotation is provided for documentation purpose, just like</span></span><br><span class="line"><span class="comment">     * &lt;a href="http://www.javaconcurrencyinpractice.com/annotations/doc/"&gt;the JCIP annotations&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@interface</span> Sharable {</span><br><span class="line">        <span class="comment">// no value</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关于 <code>#handlerAdded(...)</code>、<code>#handlerRemoved(...)</code>、<code>#exceptionCaught(...)</code> 方法，胖友看方法上的注释。</li>
<li><code>@Sharable</code> 注解，ChannelHandler 是否可共享，即是否可以被<strong>多次</strong>添加。在 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler?self">《精尽 Netty 源码解析 —— ChannelPipeline（二）之添加 ChannelHandler》</a> 的 <a href="#">「3. checkMultiplicity」</a> 小节，已经有详细解析。</li>
</ul>
<h1 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2. 核心类"></a>2. 核心类</h1><p>ChannelHandler 的<strong>核心类</strong>的类图如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_10_01/01.png" title="核心类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_10_01/01.png" alt="核心类图"></a><span class="caption">核心类图</span></p>
<ul>
<li>ChannelInboundHandler ，在 <a href="http://svip.iocoder.cn/Netty/Pipeline-5-inbound">《精尽 Netty 源码解析 —— ChannelPipeline（五）之 Inbound 事件的传播》</a> 有详细解析。</li>
<li>ChannelOutboundHandler ，在 <a href="http://svip.iocoder.cn/Netty/Pipeline-6-outbound">《精尽 Netty 源码解析 —— ChannelPipeline（六）之 Outbound 事件的传播》</a> 有详细解析。</li>
<li><strong>红框</strong>部分，ChannelHandler Adaptive 实现类，提供默认的骨架( Skeleton )实现。</li>
<li><strong>绿框</strong>部分，用于编解码消息的 ChannelHandler 实现类。关于这部分，我们会在 《Codec》专属的章节，而不是在《ChannelHandler》章节。</li>
<li><strong>黄框</strong>部分<ul>
<li>SimpleChannelInboundHandler ，抽象类，处理<strong>指定类型</strong>的消息。应用程序中，我们可以实现 SimpleChannelInboundHandler 后，实现对<strong>指定类型</strong>的消息的自定义处理。</li>
<li>Simple<strong>UserEvent</strong>ChannelHandler ，和 SimpleChannelInboundHandler 基本一致，差别在于将指定类型的消息，改成了制定类型的事件。</li>
<li>详细解析，见 <a href="http://svip.iocoder.cn/Netty/ChannelHandler-3-SimpleChannelInboundHandler">《精尽 Netty 源码解析 —— ChannelHandler（三）之 SimpleChannelInboundHandler》</a> 。</li>
</ul>
</li>
<li>ChannelInitializer ，一个<strong>特殊</strong>的 ChannelHandler ，用于 Channel 注册到 EventLoop 后，<strong>执行自定义的初始化操作</strong>。一般情况下，初始化自定义的 ChannelHandler 到 Channel 中。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ChannelHandler-2-ChannelInitializer">《精尽 Netty 源码解析 —— ChannelHandler（二）之 ChannelInitializer》</a> 。</li>
</ul>
<h1 id="3-ChannelHandlerAdaptive"><a href="#3-ChannelHandlerAdaptive" class="headerlink" title="3. ChannelHandlerAdaptive"></a>3. ChannelHandlerAdaptive</h1><p>在看看 ChannelHandlerAdaptive 的具体代码实现之前，我们先一起了解 ChannelHandlerAdaptive 的设计思想。在《Netty 权威指南》如是说：</p>
<blockquote>
<p>对于大多数的 ChannelHandler 会选择性地拦截和处理某个或者某些事件，其他的事件会忽略，由下一个 ChannelHandler 进行拦截和处理。这就会导致一个问题：用户 ChannelHandler 必须要实现 ChannelHandler 的所有接口，包括它不关心的那些事件处理接口，这会导致用户代码的冗余和臃肿，代码的可维护性也会变差。</p>
<p>为了解决这个问题，Netty提供了ChannelHandlerAdapter基类，它的所有接口实现都是事件透传，如果用户ChannelHandler关心某个事件，只需要覆盖ChannelHandlerAdapter对应的方法即可，对于不关心的，可以直接继承使用父类的方法，这样子类的代码就会非常简洁和清晰。</p>
</blockquote>
<p>😈 下面，我们看到的其它 Adaptive 实现类，也是这样的设计思想。</p>
<hr>
<p><code>io.netty.channel.ChannelHandlerAdapter</code> ，实现 ChannelHandler 接口，ChannelHandler Adapter 抽象类。</p>
<h2 id="3-1-isSharable"><a href="#3-1-isSharable" class="headerlink" title="3.1 isSharable"></a>3.1 isSharable</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Not using volatile because it's used only for a sanity check.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否已经初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">boolean</span> added;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Throws {<span class="doctag">@link</span> IllegalStateException} if {<span class="doctag">@link</span> ChannelHandlerAdapter#isSharable()} returns {<span class="doctag">@code</span> true}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ensureNotSharable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (isSharable()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ChannelHandler "</span> + getClass().getName() + <span class="string">" is not allowed to be shared"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return {<span class="doctag">@code</span> true} if the implementation is {<span class="doctag">@link</span> Sharable} and so can be added</span></span><br><span class="line"><span class="comment"> * to different {<span class="doctag">@link</span> ChannelPipeline}s.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSharable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache the result of {<span class="doctag">@link</span> Sharable} annotation detection to workaround a condition. We use a</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> ThreadLocal} and {<span class="doctag">@link</span> WeakHashMap} to eliminate the volatile write/reads. Using different</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> WeakHashMap} instances per {<span class="doctag">@link</span> Thread} is good enough for us and the number of</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> Thread}s are quite limited anyway.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * See &lt;a href="https://github.com/netty/netty/issues/2289"&gt;#2289&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; clazz = getClass();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; cache = InternalThreadLocalMap.get().handlerSharableCache();</span><br><span class="line">    Boolean sharable = cache.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (sharable == <span class="keyword">null</span>) {</span><br><span class="line">        sharable = clazz.isAnnotationPresent(Sharable.class);</span><br><span class="line">        cache.put(clazz, sharable);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sharable;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这块内容，和 <code>@Sharable</code> 注解相关。在 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler?self">《精尽 Netty 源码解析 —— ChannelPipeline（二）之添加 ChannelHandler》</a> 的 <a href="#">「3. checkMultiplicity」</a> 小节，已经有详细解析。</li>
</ul>
<h2 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do nothing by default, sub-classes may override this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// NOOP</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do nothing by default, sub-classes may override this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// NOOP</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireExceptionCaught(Throwable)} to forward</span></span><br><span class="line"><span class="comment"> * to the next {<span class="doctag">@link</span> ChannelHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 <code>#handlerAdded(ChannelHandlerContext ctx)</code> 和 <code>#handlerRemoved(ChannelHandlerContext ctx)</code> 方法，默认无任何逻辑。子类如果有自定义的逻辑，可以进行覆写对应的方法。</li>
<li><code>#exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code> 方法，直接转发到下一个节点，<strong>实际上</strong>也是默认无任何逻辑。子类如果有自定义的逻辑，可以进行覆写对应的方法。</li>
</ul>
<h1 id="4-ChannelOutboundHandlerAdapter"><a href="#4-ChannelOutboundHandlerAdapter" class="headerlink" title="4. ChannelOutboundHandlerAdapter"></a>4. ChannelOutboundHandlerAdapter</h1><p><code>io.netty.channel.ChannelOutboundHandlerAdapter</code> ，实现 ChannelOutboundHandler 接口，继承 ChannelHandlerAdapter 抽象类，ChannelOutboundHandler Adapter 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelOutboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#bind(SocketAddress, ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.bind(localAddress, promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#disconnect(ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.disconnect(promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#close(ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#deregister(ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.deregister(promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#read()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.read();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#write(Object, ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#flush()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.flush();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个实现方法，直接转发到下一个节点，<strong>实际上</strong>也是默认无任何逻辑。子类如果有自定义的逻辑，可以进行覆写对应的方法。</li>
</ul>
<h1 id="5-ChannelInboundHandlerAdapter"><a href="#5-ChannelInboundHandlerAdapter" class="headerlink" title="5. ChannelInboundHandlerAdapter"></a>5. ChannelInboundHandlerAdapter</h1><p><code>io.netty.channel.ChannelInboundHandlerAdapter</code> ，实现 ChannelInboundHandler 接口，继承 ChannelHandlerAdapter 抽象类，ChannelInboundHandler Adapter 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelRegistered()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelUnregistered()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelActive()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelInactive()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelRead(Object)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelReadComplete()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireChannelWritabilityChanged()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelInboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#fireExceptionCaught(Throwable)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个实现方法，直接转发到下一个节点，<strong>实际上</strong>也是默认无任何逻辑。子类如果有自定义的逻辑，可以进行覆写对应的方法。</li>
</ul>
<h1 id="6-ChannelDuplexHandler"><a href="#6-ChannelDuplexHandler" class="headerlink" title="6. ChannelDuplexHandler"></a>6. ChannelDuplexHandler</h1><p><code>io.netty.channel.ChannelDuplexHandler</code> ，实现 ChannelOutboundHandler 接口，继承 ChannelInboundHandlerAdapter 抽象类，Channel Duplex Handler 实现类，支持对 Inbound 和 Outbound 事件的 Adaptive 处理，所以命名上带有“<strong>Duplex</strong>”( 双重 )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDuplexHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#bind(SocketAddress, ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.bind(localAddress, promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#disconnect(ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.disconnect(promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#close(ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#close(ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.deregister(promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#read()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.read();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#write(Object, ChannelPromise)} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls {<span class="doctag">@link</span> ChannelHandlerContext#flush()} to forward</span></span><br><span class="line"><span class="comment">     * to the next {<span class="doctag">@link</span> ChannelOutboundHandler} in the {<span class="doctag">@link</span> ChannelPipeline}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.flush();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>实现代码上，和 <a href="#">「4. ChannelOutboundHandlerAdapter」</a> 是一致的。因为 Java 不支持<strong>多继承</strong>的特性，所以不得又重新实现一遍。</li>
</ul>
<p>😈 大多数情况下，我们会实现 ChannelDuplexHandler 类，覆写部分方法，处理对应的事件。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>小小水文一篇，主要帮胖友梳理下，对 ChannelHandler 有整体的认识。在后续的文章中，我们会看具体的一个一个 ChannelHandler 的带有“业务”的实现类。</p>
<p>推荐阅读如下文章：</p>
<ul>
<li>Hypercube <a href="https://www.jianshu.com/p/a9bcd89553f5" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（八）–ChannelHandler》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ChannelHandler-1-intro/" data-id="ck4pl3fp700e8fgcfgzlsuuif" class="article-share-link">分享</a>

</footer>
-->
</div>
