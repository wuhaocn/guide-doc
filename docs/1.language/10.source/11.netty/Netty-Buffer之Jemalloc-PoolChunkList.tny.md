<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 Jemalloc（四）PoolChunkList
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》</a> ，我们看到 PoolChunk 有如下三个属性：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 PoolChunkList 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolChunkList&lt;T&gt; parent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上一个 Chunk 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolChunk&lt;T&gt; prev;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个 Chunk 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolChunk&lt;T&gt; next;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>prev</code> 和 <code>next</code> 两个属性，形成一个<strong>双向</strong> Chunk 链表 <code>parent</code>( PoolChunkList )。</li>
</ul>
<p>那么为什么需要有 PoolChunkList 这样一个链表呢？直接开始撸代码。</p>
<h1 id="2-PoolChunkList"><a href="#2-PoolChunkList" class="headerlink" title="2. PoolChunkList"></a>2. PoolChunkList</h1><p><code>io.netty.buffer.PoolChunkList</code> ，实现 PoolChunkListMetric 接口，负责管理多个 Chunk 的生命周期，<strong>在此基础上对内存分配进行进一步的优化</strong>。</p>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 PoolArena 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolArena&lt;T&gt; arena;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个 PoolChunkList 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; nextList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 最小内存使用率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minUsage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 最大内存使用率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUsage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个 Chunk 最大可分配的容量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #calculateMaxCapacity(int, int) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolChunk 头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> PoolChunk&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前一个 PoolChunkList 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// This is only update once when create the linked like list of PoolChunkList in PoolArena constructor.</span></span><br><span class="line"><span class="keyword">private</span> PoolChunkList&lt;T&gt; prevList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Test if adding padding helps under contention</span></span><br><span class="line"><span class="comment">//private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;</span></span><br><span class="line"></span><br><span class="line">PoolChunkList(PoolArena&lt;T&gt; arena, PoolChunkList&lt;T&gt; nextList, <span class="keyword">int</span> minUsage, <span class="keyword">int</span> maxUsage, <span class="keyword">int</span> chunkSize) {</span><br><span class="line">    <span class="keyword">assert</span> minUsage &lt;= maxUsage;</span><br><span class="line">    <span class="keyword">this</span>.arena = arena;</span><br><span class="line">    <span class="keyword">this</span>.nextList = nextList;</span><br><span class="line">    <span class="keyword">this</span>.minUsage = minUsage;</span><br><span class="line">    <span class="keyword">this</span>.maxUsage = maxUsage;</span><br><span class="line">    <span class="comment">// 计算 maxUsage 属性</span></span><br><span class="line">    maxCapacity = calculateMaxCapacity(minUsage, chunkSize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>arena</code> 属性，所属 PoolArena 对象。</li>
<li><p><code>prevList</code> + <code>nextList</code> 属性，上一个和下一个 PoolChunkList 对象。也就是说，PoolChunkList 除了<strong>自身</strong>有一条双向链表外，PoolChunkList 和 PoolChunkList <strong>之间</strong>也形成了一条双向链表。如下图所示：</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/a1debfe4ff02" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolChunkList》</a></p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_09_10/01.png" title="双向链表" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_10/01.png" alt="双向链表"></a><span class="caption">双向链表</span></p>
</blockquote>
</li>
<li><p><code>head</code> 属性，PoolChunkList <strong>自身</strong>的双向链表的<strong>头节点</strong>。</p>
</li>
<li><code>minUsage</code> + <code>maxUsage</code> 属性，PoolChunkList 管理的 Chunk 们的内存使用率。<ul>
<li>当 Chunk 分配的内存率超过 <code>maxUsage</code> 时，从当前 PoolChunkList 节点移除，添加到下一个 PoolChunkList 节点( <code>nextList</code> )。TODO 详细解析。</li>
<li>当 Chunk 分配的内存率小于 <code>minUsage</code> 时，从当前 PoolChunkList 节点移除，添加到上一个 PoolChunkList 节点( <code>prevList</code> )。TODO 详细解析。</li>
</ul>
</li>
<li><p><code>maxCapacity</code> 属性，每个 Chunk 最大可分配的容量。通过 <code>#calculateMaxCapacity(int minUsage, int chunkSize)</code> 方法，来计算。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calculates the maximum capacity of a buffer that will ever be possible to allocate out of the {<span class="doctag">@link</span> PoolChunk}s</span></span><br><span class="line"><span class="comment"> * that belong to the {<span class="doctag">@link</span> PoolChunkList} with the given {<span class="doctag">@code</span> minUsage} and {<span class="doctag">@code</span> maxUsage} settings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateMaxCapacity</span><span class="params">(<span class="keyword">int</span> minUsage, <span class="keyword">int</span> chunkSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 计算 minUsage 值</span></span><br><span class="line">    minUsage = minUsage0(minUsage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minUsage == <span class="number">100</span>) {</span><br><span class="line">        <span class="comment">// If the minUsage is 100 we can not allocate anything out of this list.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the maximum amount of bytes that can be allocated from a PoolChunk in this PoolChunkList.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// As an example:</span></span><br><span class="line">    <span class="comment">// - If a PoolChunkList has minUsage == 25 we are allowed to allocate at most 75% of the chunkSize because</span></span><br><span class="line">    <span class="comment">//   this is the maximum amount available in any PoolChunk in this PoolChunkList.</span></span><br><span class="line">    <span class="keyword">return</span>  (<span class="keyword">int</span>) (chunkSize * (<span class="number">100L</span> - minUsage) / <span class="number">100L</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证最小 &gt;= 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minUsage0</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">1</span>, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>为什么使用 <code>(int) (chunkSize * (100L - minUsage) / 100L)</code> 来计算呢？因为 Chunk 进入当前 PoolChunkList 节点，意味着 Chunk 内存已经分配了 <code>minUsage</code> 比率，所以 Chunk 剩余的容量是 <code>chunkSize * (100L - minUsage) / 100L</code> 。😈 是不是豁然开朗噢？！</li>
</ul>
</li>
</ul>
<h2 id="2-2-allocate"><a href="#2-2-allocate" class="headerlink" title="2.2 allocate"></a>2.2 allocate</h2><blockquote>
<p>随着 Chunk 中 Page 的不断分配和释放，会导致很多碎片内存段，大大增加了之后分配一段连续内存的失败率。针对这种情况，可以把内存使用率较大的 Chunk 放到PoolChunkList 链表更后面。</p>
</blockquote>
<p><code>#allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity)</code> 方法，给 PooledByteBuf 对象分配内存块，并返回是否分配内存块成功。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 双向链表中无 Chunk</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 申请分配的内存超过 ChunkList 的每个 Chunk 最大可分配的容量</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (head == <span class="keyword">null</span> || normCapacity &gt; maxCapacity) {</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</span></span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// be handled by the PoolChunks that are contained in this PoolChunkList.</span></span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">8</span>:     }</span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 遍历双向链表。注意，遍历的是 ChunkList 的内部双向链表。</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">for</span> (PoolChunk&lt;T&gt; cur = head;;) {</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 分配内存块</span></span><br><span class="line"><span class="number">13</span>:         <span class="keyword">long</span> handle = cur.allocate(normCapacity);</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 分配失败</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">16</span>:             <span class="comment">// 进入下一节点</span></span><br><span class="line"><span class="number">17</span>:             cur = cur.next;</span><br><span class="line"><span class="number">18</span>:             <span class="comment">// 若下一个节点不存在，返回 false ，结束循环</span></span><br><span class="line"><span class="number">19</span>:             <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">20</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 分配失败</span></span><br><span class="line"><span class="number">21</span>:             }</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 分配成功</span></span><br><span class="line"><span class="number">23</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">24</span>:             <span class="comment">// 初始化内存块到 PooledByteBuf 对象中</span></span><br><span class="line"><span class="number">25</span>:             cur.initBuf(buf, handle, reqCapacity);</span><br><span class="line"><span class="number">26</span>:             <span class="comment">// 超过当前 ChunkList 管理的 Chunk 的内存使用率上限</span></span><br><span class="line"><span class="number">27</span>:             <span class="keyword">if</span> (cur.usage() &gt;= maxUsage) {</span><br><span class="line"><span class="number">28</span>:                 <span class="comment">// 从当前 ChunkList 节点移除</span></span><br><span class="line"><span class="number">29</span>:                 remove(cur);</span><br><span class="line"><span class="number">30</span>:                 <span class="comment">// 添加到下一个 ChunkList 节点</span></span><br><span class="line"><span class="number">31</span>:                 nextList.add(cur); </span><br><span class="line"><span class="number">32</span>:             }</span><br><span class="line"><span class="number">33</span>:             <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 分配成功</span></span><br><span class="line"><span class="number">34</span>:         }</span><br><span class="line"><span class="number">35</span>:     }</span><br><span class="line"><span class="number">36</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 8 行：双向链表中无 Chunk，或者申请分配的内存超过 ChunkList 的每个 Chunk 最大可分配的容量，返回 <code>false</code> ，分配失败。</li>
<li>第 11 行：遍历双向链表。<strong>注意，遍历的是 ChunkList 的内部双向链表</strong>。</li>
<li>第 13 行：调用 <code>PoolChunk#allocate(normCapacity)</code> 方法，分配内存块。这块，可以结合 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》「2.2 allocate」</a> 在复习下。</li>
<li>第 15 至 17 行：分配失败，进入下一个节点。<ul>
<li>第 18 至 21 行：若下一个节点不存在，返回 <code>false</code> ，分配失败。</li>
</ul>
</li>
<li>第 22 至 25 行：分配成功，调用 <code>PooledByteBuf##initBuf(PooledByteBuf&lt;T&gt; buf, long handle, int reqCapacity)</code> 方法，初始化分配的内存块到 PooledByteBuf 中。这块，可以结合 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》「2.5 initBuf」</a> 在复习下。<ul>
<li>第 26 至 32 行：超过当前 ChunkList 管理的 Chunk 的内存使用率上限，从当前 ChunkList 节点移除，并添加到“<strong>下</strong>”一个 ChunkList 节点。<ul>
<li>第 29 行：调用 <code>#remove(PoolChunk&lt;T&gt; cur)</code> 方法，解析见 <a href="#">「2.4.2 remove」</a> 。</li>
<li>第 31 行：调用 <code>#remove(PoolChunk&lt;T&gt; cur)</code> 方法，解析见 <a href="#">「2.4.1 add」</a> 。</li>
</ul>
</li>
<li>第 33 行：返回 <code>true</code> ，分配成功。</li>
</ul>
</li>
</ul>
<h2 id="2-3-free"><a href="#2-3-free" class="headerlink" title="2.3 free"></a>2.3 free</h2><p><code>#free(PoolChunk&lt;T&gt; chunk, long handle)</code> 方法，释放 PoolChunk 的指定位置( <code>handle</code> )的内存块。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">boolean</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 释放 PoolChunk 的指定位置( handle )的内存块</span></span><br><span class="line"> <span class="number">3</span>:     chunk.free(handle);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 小于当前 ChunkList 管理的 Chunk 的内存使用率下限</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (chunk.usage() &lt; minUsage) {</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// 从当前 ChunkList 节点移除</span></span><br><span class="line"> <span class="number">7</span>:         remove(chunk);</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 添加到上一个 ChunkList 节点</span></span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// Move the PoolChunk down the PoolChunkList linked-list.</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">return</span> move0(chunk);</span><br><span class="line"><span class="number">11</span>:     }</span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 释放成功</span></span><br><span class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">14</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：调用 <code>PoolChunk#free(long handle)</code> 方法，释放指定位置的内存块。这块，可以结合 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》「2.3 free」</a> 在复习下。</li>
<li>第 5 行：小于当前 ChunkList 管理的 Chunk 的内存使用率下限：<ul>
<li>第 7 行：调用 <code>#remove(PoolChunk&lt;T&gt; cur)</code> 方法，从当前 ChunkList 节点移除。</li>
<li>第 10 行：调用 <code>#move(PoolChunk&lt;T&gt; chunk)</code> 方法， 添加到“上”一个 ChunkList 节点。详细解析，见 <a href="#">「2.4.3 move」</a> 。</li>
</ul>
</li>
<li>第 13 行：返回 <code>true</code> ，释放成功。</li>
</ul>
<h2 id="2-4-双向链表操作"><a href="#2-4-双向链表操作" class="headerlink" title="2.4 双向链表操作"></a>2.4 双向链表操作</h2><h3 id="2-4-1-add"><a href="#2-4-1-add" class="headerlink" title="2.4.1 add"></a>2.4.1 add</h3><p><code>#add(PoolChunk&lt;T&gt; chunk)</code> 方法，将 PoolChunk 添加到 ChunkList 节点中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span> </span>{</span><br><span class="line"><span class="number">2</span>:     <span class="comment">// 超过当前 ChunkList 管理的 Chunk 的内存使用率上限，继续递归到下一个 ChunkList 节点进行添加。</span></span><br><span class="line"><span class="number">3</span>:     <span class="keyword">if</span> (chunk.usage() &gt;= maxUsage) {</span><br><span class="line"><span class="number">4</span>:         nextList.add(chunk);</span><br><span class="line"><span class="number">5</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">6</span>:     }</span><br><span class="line"><span class="number">7</span>:     <span class="comment">// 执行真正的添加</span></span><br><span class="line"><span class="number">8</span>:     add0(chunk);</span><br><span class="line"><span class="number">9</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 6 行：超过当前 ChunkList 管理的 Chunk 的内存使用率上限，调用 <code>nextList</code> 的 <code>#add(PoolChunk&lt;T&gt; chunk)</code> 方法，继续递归到下一个 ChunkList 节点进行添加。</li>
<li><p>第 8 行：调用 <code>#add0(PoolChunk&lt;T&gt; chunk)</code> 方法，执行真正的添加。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the {<span class="doctag">@link</span> PoolChunk} to this {<span class="doctag">@link</span> PoolChunkList}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add0</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span> </span>{</span><br><span class="line">    chunk.parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 无头节点，自己成为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        head = chunk;</span><br><span class="line">        chunk.prev = <span class="keyword">null</span>;</span><br><span class="line">        chunk.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// &lt;2&gt; 有头节点，自己成为头节点，原头节点成为自己的下一个节点</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        chunk.prev = <span class="keyword">null</span>;</span><br><span class="line">        chunk.next = head;</span><br><span class="line">        head.prev = chunk;</span><br><span class="line">        head = chunk;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，比较好理解，胖友自己看。</li>
<li><code>&lt;2&gt;</code> 处，因为 <code>chunk</code> <strong>新</strong>进入下一个 ChunkList 节点，一般来说，内存使用率相对较低，分配内存块成功率相对较高，所以变成新的首节点。</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-remove"><a href="#2-4-2-remove" class="headerlink" title="2.4.2 remove"></a>2.4.2 remove</h3><p><code>#remove(PoolChunk&lt;T&gt; chunk)</code> 方法，从当前 ChunkList 节点移除。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(PoolChunk&lt;T&gt; cur)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前节点为首节点，将下一个节点设置为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (cur == head) {</span><br><span class="line">        head = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">            head.prev = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">// 当前节点非首节点，将节点的上一个节点指向节点的下一个节点</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        PoolChunk&lt;T&gt; next = cur.next;</span><br><span class="line">        cur.prev.next = next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) {</span><br><span class="line">            next.prev = cur.prev;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己研究。</li>
</ul>
<h3 id="2-4-3-move"><a href="#2-4-3-move" class="headerlink" title="2.4.3 move"></a>2.4.3 move</h3><p><code>#move(PoolChunk&lt;T&gt; chunk)</code> 方法， 添加到“上”一个 ChunkList 节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Moves the {<span class="doctag">@link</span> PoolChunk} down the {<span class="doctag">@link</span> PoolChunkList} linked-list so it will end up in the right</span></span><br><span class="line"><span class="comment">    * {<span class="doctag">@link</span> PoolChunkList} that has the correct minUsage / maxUsage in respect to {<span class="doctag">@link</span> PoolChunk#usage()}.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">assert</span> chunk.usage() &lt; maxUsage;</span><br><span class="line"> <span class="number">3</span>: </span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 小于当前 ChunkList 管理的 Chunk 的内存使用率下限，继续递归到上一个 ChunkList 节点进行添加。</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (chunk.usage() &lt; minUsage) {</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// Move the PoolChunk down the PoolChunkList linked-list.</span></span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span> move0(chunk);</span><br><span class="line"> <span class="number">8</span>:     }</span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 执行真正的添加</span></span><br><span class="line"><span class="number">11</span>:     <span class="comment">// PoolChunk fits into this PoolChunkList, adding it here.</span></span><br><span class="line"><span class="number">12</span>:     add0(chunk);</span><br><span class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">14</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 4 至 8 行：小于当前 ChunkList 管理的 Chunk 的内存使用率下限，调用 <code>#move0(PoolChunk&lt;T&gt; chunk)</code> 方法，继续递归到上一个 ChunkList 节点进行添加。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> chunk.usage() &lt; maxUsage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于当前 ChunkList 管理的 Chunk 的内存使用率下限，继续递归到上一个 ChunkList 节点进行添加。</span></span><br><span class="line">    <span class="keyword">if</span> (chunk.usage() &lt; minUsage) {</span><br><span class="line">        <span class="comment">// Move the PoolChunk down the PoolChunkList linked-list.</span></span><br><span class="line">        <span class="keyword">return</span> move0(chunk);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行真正的添加</span></span><br><span class="line">    <span class="comment">// PoolChunk fits into this PoolChunkList, adding it here.</span></span><br><span class="line">    add0(chunk);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li>第 12 行：调用 <code>#add0(PoolChunk&lt;T&gt; chunk)</code> 方法，执行真正的添加。</li>
<li>第 13 行：返回 <code>true</code> ，移动成功。   </li>
</ul>
<h2 id="2-5-iterator"><a href="#2-5-iterator" class="headerlink" title="2.5 iterator"></a>2.5 iterator</h2><p><code>#iterator()</code> 方法，创建 Iterator 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Iterator&lt;PoolChunkMetric&gt; EMPTY_METRICS = Collections.&lt;PoolChunkMetric&gt;emptyList().iterator();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;PoolChunkMetric&gt; <span class="title">iterator</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (arena) {</span><br><span class="line">        <span class="comment">// 空，返回 EMPTY_METRICS</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> EMPTY_METRICS;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 生成数组，后生成 Iterator</span></span><br><span class="line">        List&lt;PoolChunkMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolChunkMetric&gt;();</span><br><span class="line">        <span class="keyword">for</span> (PoolChunk&lt;T&gt; cur = head;;) {</span><br><span class="line">            metrics.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> metrics.iterator();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-6-destroy"><a href="#2-6-destroy" class="headerlink" title="2.6 destroy"></a>2.6 destroy</h2><p><code>#destroy()</code> 方法，销毁。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(PoolArena&lt;T&gt; arena)</span> </span>{</span><br><span class="line">    <span class="comment">// 循环，销毁 ChunkList 管理的所有 Chunk</span></span><br><span class="line">    PoolChunk&lt;T&gt; chunk = head;</span><br><span class="line">    <span class="keyword">while</span> (chunk != <span class="keyword">null</span>) {</span><br><span class="line">        arena.destroyChunk(chunk);</span><br><span class="line">        chunk = chunk.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 置空</span></span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-7-PoolChunkListMetric"><a href="#2-7-PoolChunkListMetric" class="headerlink" title="2.7 PoolChunkListMetric"></a>2.7 PoolChunkListMetric</h2><p><code>io.netty.buffer.PoolChunkListMetric</code> ，继承 Iterable 接口，PoolChunkList Metric 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PoolChunkListMetric</span> <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">PoolChunkMetric</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the maximum usage of the chunk list after which chunks are promoted to the next list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUsage</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>PoolChunkList 对 PoolChunkMetric 接口的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minUsage</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> minUsage0(minUsage);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUsage</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> min(maxUsage, <span class="number">100</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-PoolChunkList-初始化"><a href="#3-PoolChunkList-初始化" class="headerlink" title="3. PoolChunkList 初始化"></a>3. PoolChunkList 初始化</h1><p>在 PoolChunkArena 中，初始化 PoolChunkList 代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PoolChunkList 之间的双向链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q050;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q025;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q000;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; qInit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q075;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolChunkList&lt;T&gt; q100;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolChunkListMetric 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;PoolChunkListMetric&gt; chunkListMetrics;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="title">PoolArena</span><span class="params">(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">2</span>:       <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> cacheAlignment)</span> </span>{</span><br><span class="line">  <span class="number">3</span>:       </span><br><span class="line">  <span class="number">4</span>:     <span class="comment">// ... 省略其它无关代码</span></span><br><span class="line">  <span class="number">5</span>:       </span><br><span class="line">  <span class="number">6</span>:     <span class="comment">// PoolChunkList 之间的双向链表，初始化</span></span><br><span class="line">  <span class="number">7</span>: </span><br><span class="line">  <span class="number">8</span>:     q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line">  <span class="number">9</span>:     q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line"> <span class="number">10</span>:     q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line"> <span class="number">11</span>:     q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line"> <span class="number">12</span>:     q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line"> <span class="number">13</span>:     qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br><span class="line"> <span class="number">14</span>:     </span><br><span class="line"> <span class="number">15</span>:     q100.prevList(q075);</span><br><span class="line"> <span class="number">16</span>:     q075.prevList(q050);</span><br><span class="line"> <span class="number">17</span>:     q050.prevList(q025);</span><br><span class="line"> <span class="number">18</span>:     q025.prevList(q000);</span><br><span class="line"> <span class="number">19</span>:     q000.prevList(<span class="keyword">null</span>); <span class="comment">// 无前置节点</span></span><br><span class="line"> <span class="number">20</span>:     qInit.prevList(qInit); <span class="comment">// 前置节点为自己</span></span><br><span class="line"> <span class="number">21</span>:     </span><br><span class="line"> <span class="number">22</span>:     <span class="comment">// 创建 PoolChunkListMetric 数组</span></span><br><span class="line"> <span class="number">23</span>:     List&lt;PoolChunkListMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolChunkListMetric&gt;(<span class="number">6</span>);</span><br><span class="line"> <span class="number">24</span>:     metrics.add(qInit);</span><br><span class="line"> <span class="number">25</span>:     metrics.add(q000);</span><br><span class="line"> <span class="number">26</span>:     metrics.add(q025);</span><br><span class="line"> <span class="number">27</span>:     metrics.add(q050);</span><br><span class="line"> <span class="number">28</span>:     metrics.add(q075);</span><br><span class="line"> <span class="number">29</span>:     metrics.add(q100);</span><br><span class="line"> <span class="number">30</span>:     chunkListMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line"> <span class="number">31</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>PoolChunkList 之间的双向链表有 <code>qInit</code>、<code>q000</code>、<code>q025</code>、<code>q050</code>、<code>q075</code>、<code>q100</code> 有 6 个节点，在【第 6 至 20 行】的代码，进行<strong>初始化</strong>。链表如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 正向</span></span><br><span class="line">qInit -&gt; q000 -&gt; q025 -&gt; q050 -&gt; q075 -&gt; q100 -&gt; <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆向</span></span><br><span class="line"><span class="keyword">null</span> &lt;- q000 &lt;- q025 &lt;- q050 &lt;- q075 &lt;- q100</span><br><span class="line">qInit &lt;- qInit</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较神奇的是，<code>qInit</code> 指向自己？！<code>qInit</code> 用途是，新创建的 Chunk 内存块 <code>chunk_new</code>( 这只是个代号，方便描述 ) ，添加到 <code>qInit</code> 后，不会被释放掉。<ul>
<li>为什么不会被释放掉？<code>qInit.minUsage = Integer.MIN_VALUE</code> ，所以在 <code>PoolChunkList#move(PoolChunk chunk)</code> 方法中，<code>chunk_new</code> 的内存使用率最小值为 0 ，所以肯定不会被释放。</li>
<li>那岂不是 <code>chunk_new</code> 无法被释放？随着 <code>chunk_new</code> 逐渐分配内存，内存使用率到达 25 ( <code>qInit.maxUsage</code> )后，会移动到 <code>q000</code> 。再随着 <code>chunk_new</code> 逐渐释放内存，内存使用率降到 0 (<code>q000.minUsage</code>) 后，就可以被释放。</li>
</ul>
</li>
<li>当然，如果新创建的 Chunk 内存块 <code>chunk_new</code> <strong>第一次</strong>分配的内存使用率超过 25 ( <code>qInit.maxUsage</code> )，不会进入 <code>qInit</code> 中，而是进入后面的 PoolChunkList 节点。</li>
</ul>
</li>
<li><code>chunkListMetrics</code> 属性，PoolChunkListMetric 数组。在【第 22 至 30 行】的代码，进行<strong>初始化</strong>。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>PoolChunList 相比 PoolSubpage 来说，又又又更加简单啦。</p>
<p>老艿艿整理了下 Arena、ChunkList、Chunk、Page、Subpage 的“操纵”关系如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_09_10/02.png" title="PoolSubpage" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_10/02.png" alt="PoolSubpage"></a><span class="caption">PoolSubpage</span></p>
<ul>
<li>当然，这不是一幅严谨的图，仅仅表达“操纵”的关系。</li>
</ul>
<p>参考如下文章：</p>
<ul>
<li>Hypercube <a href="https://www.jianshu.com/p/2b8375df2d1a" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–PoolChunkList》</a></li>
<li>占小狼 <a href="https://www.jianshu.com/p/4856bd30dd56" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolChunkList》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-3-4-Jemalloc-chunkList/" data-id="ck4pl3fp600e6fgcf7qikzp5l" class="article-share-link">分享</a>

</footer>
-->
</div>
