<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 ByteBufAllocator（二）UnpooledByteBufAllocator
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来分享 UnpooledByteBufAllocator ，<strong>普通</strong>的 ByteBuf 的分配器，<strong>不基于内存池</strong>。</p>
<h1 id="2-ByteBufAllocatorMetricProvider"><a href="#2-ByteBufAllocatorMetricProvider" class="headerlink" title="2. ByteBufAllocatorMetricProvider"></a>2. ByteBufAllocatorMetricProvider</h1><p><code>io.netty.buffer.ByteBufAllocatorMetricProvider</code> ，ByteBufAllocator Metric 提供者接口，<strong>用于监控 ByteBuf 的 Heap 和 Direct 占用内存的情况</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteBufAllocatorMetricProvider</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a {<span class="doctag">@link</span> ByteBufAllocatorMetric} for a {<span class="doctag">@link</span> ByteBufAllocator}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ByteBufAllocatorMetric <span class="title">metric</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ByteBufAllocatorMetricProvider 有两个子类：UnpooledByteBufAllocator 和 PooledByteBufAllocator 。</p>
<h1 id="3-ByteBufAllocatorMetric"><a href="#3-ByteBufAllocatorMetric" class="headerlink" title="3. ByteBufAllocatorMetric"></a>3. ByteBufAllocatorMetric</h1><p><code>io.netty.buffer.ByteBufAllocatorMetric</code> ，ByteBufAllocator Metric 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteBufAllocatorMetric</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of bytes of heap memory used by a {<span class="doctag">@link</span> ByteBufAllocator} or {<span class="doctag">@code</span> -1} if unknown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 已使用 Heap 占用内存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">usedHeapMemory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of bytes of direct memory used by a {<span class="doctag">@link</span> ByteBufAllocator} or {<span class="doctag">@code</span> -1} if unknown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 已使用 Direct 占用内存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">usedDirectMemory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ByteBufAllocatorMetric 有两个子类：UnpooledByteBufAllocatorMetric 和 PooledByteBufAllocatorMetric 。</p>
<h2 id="3-1-UnpooledByteBufAllocatorMetric"><a href="#3-1-UnpooledByteBufAllocatorMetric" class="headerlink" title="3.1 UnpooledByteBufAllocatorMetric"></a>3.1 UnpooledByteBufAllocatorMetric</h2><p>UnpooledByteBufAllocatorMetric ，在 UnpooledByteBufAllocator 的<strong>内部静态类</strong>，实现 ByteBufAllocatorMetric 接口，UnpooledByteBufAllocator Metric 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Direct ByteBuf 占用内存大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> LongCounter directCounter = PlatformDependent.newLongCounter();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heap ByteBuf 占用内存大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> LongCounter heapCounter = PlatformDependent.newLongCounter();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">usedHeapMemory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> heapCounter.value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">usedDirectMemory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> directCounter.value();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较简单，两个计数器。</li>
<li><p><code>PlatformDependent#newLongCounter()</code> 方法，获得 LongCounter 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new fastest {<span class="doctag">@link</span> LongCounter} implementation for the current platform.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LongCounter <span class="title">newLongCounter</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (javaVersion() &gt;= <span class="number">8</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongAdderCounter();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicLongCounter();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>也就是说，JDK <code>&gt;=8</code> 使用 <code>java.util.concurrent.atomic.LongAdder</code> ，JDK <code>&lt;7</code> 使用 <code>java.util.concurrent.atomic.AtomicLong</code> 。相比来说，Metric 写多读少，所以 LongAdder 比 AtomicLong 更合适。对比的解析，可以看看 <a href="https://www.cnkirito.moe/java-concurrent-counter/" rel="external nofollow noopener noreferrer" target="_blank">《Java并发计数器探秘》</a> 。</li>
</ul>
</li>
</ul>
<h1 id="4-UnpooledByteBufAllocator"><a href="#4-UnpooledByteBufAllocator" class="headerlink" title="4. UnpooledByteBufAllocator"></a>4. UnpooledByteBufAllocator</h1><p><code>io.netty.buffer.UnpooledByteBufAllocator</code> ，实现 ByteBufAllocatorMetricProvider 接口，继承 AbstractByteBufAllocator 抽象类，<strong>普通</strong>的 ByteBuf 的分配器，<strong>不基于内存池</strong>。</p>
<h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Metric</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnpooledByteBufAllocatorMetric metric = <span class="keyword">new</span> UnpooledByteBufAllocatorMetric();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否禁用内存泄露检测功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> disableLeakDetector;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不使用 `io.netty.util.internal.Cleaner` 释放 Direct ByteBuf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> UnpooledUnsafeNoCleanerDirectByteBuf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> noCleaner;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, disableLeakDetector, PlatformDependent.useDirectBufferNoCleaner() <span class="comment">/** 返回 true **/</span> );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> preferDirect {<span class="doctag">@code</span> true} if {<span class="doctag">@link</span> #buffer(int)} should try to allocate a direct buffer rather than</span></span><br><span class="line"><span class="comment"> *                     a heap buffer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> disableLeakDetector {<span class="doctag">@code</span> true} if the leak-detection should be disabled completely for this</span></span><br><span class="line"><span class="comment"> *                            allocator. This can be useful if the user just want to depend on the GC to handle</span></span><br><span class="line"><span class="comment"> *                            direct buffers when not explicit released.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tryNoCleaner {<span class="doctag">@code</span> true} if we should try to use {<span class="doctag">@link</span> PlatformDependent#allocateDirectNoCleaner(int)}</span></span><br><span class="line"><span class="comment"> *                            to allocate direct memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector, <span class="keyword">boolean</span> tryNoCleaner)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);</span><br><span class="line">    <span class="keyword">this</span>.disableLeakDetector = disableLeakDetector;</span><br><span class="line">    noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe() <span class="comment">/** 返回 true **/</span></span><br><span class="line">            &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor() <span class="comment">/** 返回 true **/</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>metric</code> 属性，UnpooledByteBufAllocatorMetric 对象。</li>
<li><code>disableLeakDetector</code> 属性，是否禁用内存泄露检测功能。<ul>
<li>默认为 <code>false</code> 。</li>
</ul>
</li>
<li><code>noCleaner</code> 属性，是否不使用 <code>io.netty.util.internal.Cleaner</code> 来释放 Direct ByteBuf 。<ul>
<li>默认为 <code>true</code> 。</li>
<li>详细解析，见 <a href="#">「5.5 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf」</a> 。</li>
</ul>
</li>
</ul>
<h2 id="4-2-newHeapBuffer"><a href="#4-2-newHeapBuffer" class="headerlink" title="4.2 newHeapBuffer"></a>4.2 newHeapBuffer</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.hasUnsafe() ?</span><br><span class="line">            <span class="keyword">new</span> InstrumentedUnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">            <span class="keyword">new</span> InstrumentedUnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的是以 <code>"Instrumented"</code> 的 Heap ByteBuf 对象，因为要结合 Metric 。详细解析，见 <a href="#">「5. Instrumented ByteBuf」</a> 。</li>
</ul>
<h2 id="4-3-newDirectBuffer"><a href="#4-3-newDirectBuffer" class="headerlink" title="4.3 newDirectBuffer"></a>4.3 newDirectBuffer</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) {</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的是以 <code>"Instrumented"</code> 的 Heap ByteBuf 对象，因为要结合 Metric 。详细解析，见 <a href="#">「5. Instrumented ByteBuf」</a> 。</li>
<li>结合了 <code>disableLeakDetector</code> 属性。</li>
</ul>
<h2 id="4-4-compositeHeapBuffer"><a href="#4-4-compositeHeapBuffer" class="headerlink" title="4.4 compositeHeapBuffer"></a>4.4 compositeHeapBuffer</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>{</span><br><span class="line">    CompositeByteBuf buf = <span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">false</span>, maxNumComponents);</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>结合了 <code>disableLeakDetector</code> 属性。</li>
</ul>
<h2 id="4-5-compositeDirectBuffer"><a href="#4-5-compositeDirectBuffer" class="headerlink" title="4.5 compositeDirectBuffer"></a>4.5 compositeDirectBuffer</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeDirectBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>{</span><br><span class="line">    CompositeByteBuf buf = <span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">true</span>, maxNumComponents);</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>结合了 <code>disableLeakDetector</code> 属性。</li>
</ul>
<h2 id="4-6-isDirectBufferPooled"><a href="#4-6-isDirectBufferPooled" class="headerlink" title="4.6 isDirectBufferPooled"></a>4.6 isDirectBufferPooled</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectBufferPooled</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-7-Metric-相关操作方法"><a href="#4-7-Metric-相关操作方法" class="headerlink" title="4.7 Metric 相关操作方法"></a>4.7 Metric 相关操作方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBufAllocatorMetric <span class="title">metric</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> metric;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementDirect</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>{ <span class="comment">// 增加 Direct</span></span><br><span class="line">    metric.directCounter.add(amount);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrementDirect</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>{ <span class="comment">// 减少 Direct</span></span><br><span class="line">    metric.directCounter.add(-amount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementHeap</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>{ <span class="comment">// 增加 Heap</span></span><br><span class="line">    metric.heapCounter.add(amount);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrementHeap</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>{ <span class="comment">// 减少 Heap</span></span><br><span class="line">    metric.heapCounter.add(-amount);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="5-Instrumented-ByteBuf"><a href="#5-Instrumented-ByteBuf" class="headerlink" title="5. Instrumented ByteBuf"></a>5. Instrumented ByteBuf</h1><p>因为要和 Metric 结合，所以通过<strong>继承</strong>的方式，进行增强。</p>
<h2 id="5-1-InstrumentedUnpooledUnsafeHeapByteBuf"><a href="#5-1-InstrumentedUnpooledUnsafeHeapByteBuf" class="headerlink" title="5.1 InstrumentedUnpooledUnsafeHeapByteBuf"></a>5.1 InstrumentedUnpooledUnsafeHeapByteBuf</h2><p><strong>Instrumented</strong>UnpooledUnsafeHeapByteBuf ，在 UnpooledByteBufAllocator 的<strong>内部静态类</strong>，继承 UnpooledUnsafeHeapByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeHeapByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) {</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">super</span>.allocateArray(initialCapacity);</span><br><span class="line">        <span class="comment">// Metric ++</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementHeap(bytes.length);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeArray</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">super</span>.freeArray(array);</span><br><span class="line">        <span class="comment">// Metric --</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementHeap(length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在原先的基础上，调用 Metric 相应的增减操作方法，得以记录 Heap 占用内存的大小。</li>
</ul>
<h2 id="5-2-InstrumentedUnpooledHeapByteBuf"><a href="#5-2-InstrumentedUnpooledHeapByteBuf" class="headerlink" title="5.2 InstrumentedUnpooledHeapByteBuf"></a>5.2 InstrumentedUnpooledHeapByteBuf</h2><p><strong>Instrumented</strong>UnpooledHeapByteBuf ，在 UnpooledByteBufAllocator 的<strong>内部静态类</strong>，继承 UnpooledHeapByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledHeapByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    InstrumentedUnpooledHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) {</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">super</span>.allocateArray(initialCapacity);</span><br><span class="line">        <span class="comment">// Metric ++</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementHeap(bytes.length);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeArray</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">super</span>.freeArray(array);</span><br><span class="line">        <span class="comment">// Metric --</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementHeap(length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在原先的基础上，调用 Metric 相应的增减操作方法，得以记录 Heap 占用内存的大小。</li>
</ul>
<h2 id="5-3-InstrumentedUnpooledUnsafeDirectByteBuf"><a href="#5-3-InstrumentedUnpooledUnsafeDirectByteBuf" class="headerlink" title="5.3 InstrumentedUnpooledUnsafeDirectByteBuf"></a>5.3 InstrumentedUnpooledUnsafeDirectByteBuf</h2><p><strong>Instrumented</strong>UnpooledUnsafeDirectByteBuf ，在 UnpooledByteBufAllocator 的<strong>内部静态类</strong>，继承 UnpooledUnsafeDirectByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>{</span><br><span class="line">    InstrumentedUnpooledUnsafeDirectByteBuf(</span><br><span class="line">            UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        <span class="comment">// Metric ++</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        <span class="comment">// Metric --</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在原先的基础上，调用 Metric 相应的增减操作方法，得以记录 Direct 占用内存的大小。</li>
</ul>
<h2 id="5-4-InstrumentedUnpooledDirectByteBuf"><a href="#5-4-InstrumentedUnpooledDirectByteBuf" class="headerlink" title="5.4 InstrumentedUnpooledDirectByteBuf"></a>5.4 InstrumentedUnpooledDirectByteBuf</h2><p><strong>Instrumented</strong>UnpooledDirectByteBuf 的<strong>内部静态类</strong>，继承 UnpooledDirectByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledDirectByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    InstrumentedUnpooledDirectByteBuf(</span><br><span class="line">            UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        <span class="comment">// Metric ++</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        <span class="comment">// Metric --</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在原先的基础上，调用 Metric 相应的增减操作方法，得以记录 Direct 占用内存的大小。</li>
</ul>
<h2 id="5-5-InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"><a href="#5-5-InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf" class="headerlink" title="5.5 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"></a>5.5 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</h2><p><strong>Instrumented</strong>UnpooledDirectByteBuf 的<strong>内部静态类</strong>，继承 UnpooledUnsafeNoCleanerDirectByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">UnpooledUnsafeNoCleanerDirectByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(</span><br><span class="line">            UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.allocateDirect(initialCapacity);</span><br><span class="line">        <span class="comment">// Metric ++</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity());</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ByteBuffer <span class="title">reallocateDirect</span><span class="params">(ByteBuffer oldBuffer, <span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> capacity = oldBuffer.capacity();</span><br><span class="line">        ByteBuffer buffer = <span class="keyword">super</span>.reallocateDirect(oldBuffer, initialCapacity);</span><br><span class="line">        <span class="comment">// Metric ++</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).incrementDirect(buffer.capacity() - capacity);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">        <span class="keyword">super</span>.freeDirect(buffer);</span><br><span class="line">        <span class="comment">// Metric --</span></span><br><span class="line">        ((UnpooledByteBufAllocator) alloc()).decrementDirect(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在原先的基础上，调用 Metric 相应的增减操作方法，得以记录 Heap 占用内存的大小。</li>
</ul>
<h3 id="5-5-1-UnpooledUnsafeNoCleanerDirectByteBuf"><a href="#5-5-1-UnpooledUnsafeNoCleanerDirectByteBuf" class="headerlink" title="5.5.1 UnpooledUnsafeNoCleanerDirectByteBuf"></a>5.5.1 UnpooledUnsafeNoCleanerDirectByteBuf</h3><p><code>io.netty.buffer.UnpooledUnsafeNoCleanerDirectByteBuf</code> ，继承 UnpooledUnsafeDirectByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnpooledUnsafeNoCleanerDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    UnpooledUnsafeNoCleanerDirectByteBuf(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="comment">// 反射，直接创建 ByteBuffer 对象。并且该对象不带 Cleaner 对象</span></span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.allocateDirectNoCleaner(initialCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ByteBuffer <span class="title">reallocateDirect</span><span class="params">(ByteBuffer oldBuffer, <span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.reallocateDirectNoCleaner(oldBuffer, initialCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">        <span class="comment">// 直接释放 ByteBuffer 对象</span></span><br><span class="line">        PlatformDependent.freeDirectNoCleaner(buffer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line">        checkNewCapacity(newCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = capacity();</span><br><span class="line">        <span class="keyword">if</span> (newCapacity == oldCapacity) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配 ByteBuf 对象</span></span><br><span class="line">        ByteBuffer newBuffer = reallocateDirect(buffer, newCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; oldCapacity) {</span><br><span class="line">            <span class="keyword">if</span> (readerIndex() &lt; newCapacity) {</span><br><span class="line">                <span class="comment">// 重置 writerIndex 为 newCapacity ，避免越界</span></span><br><span class="line">                <span class="keyword">if</span> (writerIndex() &gt; newCapacity) {</span><br><span class="line">                    writerIndex(newCapacity);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 重置 writerIndex 和 readerIndex 为 newCapacity ，避免越界</span></span><br><span class="line">                setIndex(newCapacity, newCapacity);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 ByteBuf 对象</span></span><br><span class="line">        setByteBuffer(newBuffer, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/b833254908f7" rel="external nofollow noopener noreferrer" target="_blank">《Netty源码分析（一） ByteBuf》</a></p>
<p>和 UnpooledUnsafeDirectByteBuf 最大区别在于 UnpooledUnsafeNoCleanerDirectByteBuf 在 allocate的时候通过反射构造函数的方式创建DirectByteBuffer，这样在DirectByteBuffer中没有对应的Cleaner函数(通过ByteBuffer.allocateDirect的方式会自动生成Cleaner函数，Cleaner用于内存回收，具体可以看源码)，内存回收时，UnpooledUnsafeDirectByteBuf通过调用DirectByteBuffer中的Cleaner函数回收，而UnpooledUnsafeNoCleanerDirectByteBuf直接使用UNSAFE.freeMemory(address)释放内存地址。</p>
</blockquote>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 小水文一篇。铺垫铺垫，你懂的。</p>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-2-2-ByteBufAllocator-unpooled/" data-id="ck4pl3fp500e3fgcf5q3frs4k" class="article-share-link">分享</a>

</footer>
-->
</div>
