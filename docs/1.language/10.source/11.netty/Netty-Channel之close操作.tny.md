<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Channel（七）之 close 操作
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 Netty NIO Channel 关闭( <strong>close</strong> )操作的过程，分成客户端和服务端 Channel <strong>两种</strong>关闭：</p>
<ul>
<li>客户端 NioSocketChannel <ul>
<li>客户端关闭 NioSocketChannel ，断开和服务端的连接。</li>
<li>服务端关闭 NioSocketChannel ，断开和客户端的连接。</li>
</ul>
</li>
<li>服务端 NioServerSocketChannel<ul>
<li>服务端关闭 NioServerSocketChannel ，取消端口绑定，关闭服务。</li>
</ul>
</li>
</ul>
<p>上面的关闭，可能是客户端/服务端主动关闭，也可能是异常关闭。</p>
<ul>
<li>关于 NioSocketChannel 的关闭，在 <a href="#">「2. NioSocketChannel」</a> 详细解析。  </li>
<li>关于 NioServerSocketChannel 的关闭，在 <a href="#">「3. NioSocketChannel」</a> 详细解析。</li>
</ul>
<h1 id="2-NioSocketChannel"><a href="#2-NioSocketChannel" class="headerlink" title="2. NioSocketChannel"></a>2. NioSocketChannel</h1><p>通过 <code>NioSocketChannel#close()</code> 方法，应用程序里可以主动关闭 NioSocketChannel 通道。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> pipeline.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>NioSocketChannel 继承 AbstractChannel 抽象类，所以 <code>#close()</code> 方法实际是 AbstractChannel 实现的。</li>
<li><p>在方法内部，会调用对应的 <code>ChannelPipeline#close()</code> 方法，将 close 事件在 pipeline 上传播。而 close 事件属于 Outbound 事件，所以会从 <code>tail</code> 节点开始，最终传播到 <code>head</code> 节点，使用 Unsafe 进行关闭。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tail.close();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// TailContext.java</span></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// FROM AbstractChannelHandlerContext.java 。因为 TailContext 继承 AbstractChannelHandlerContext 抽象类，该方法是它实现的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> close(newPromise());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeadContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.close(promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="2-1-AbstractUnsafe-close"><a href="#2-1-AbstractUnsafe-close" class="headerlink" title="2.1 AbstractUnsafe#close"></a>2.1 AbstractUnsafe#close</h2><p><code>AbstractUnsafe#close()</code> 方法，关闭 Channel 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(promise, CLOSE_CLOSED_CHANNEL_EXCEPTION, CLOSE_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise, <span class="keyword">final</span> Throwable cause, <span class="keyword">final</span> ClosedChannelException closeCause, <span class="keyword">final</span> <span class="keyword">boolean</span> notify)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// 设置 Promise 不可取消</span></span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">if</span> (!promise.setUncancellable()) {</span><br><span class="line">  <span class="number">4</span>:         <span class="keyword">return</span>;</span><br><span class="line">  <span class="number">5</span>:     }</span><br><span class="line">  <span class="number">6</span>: </span><br><span class="line">  <span class="number">7</span>:     <span class="comment">// 若关闭已经标记初始化</span></span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">if</span> (closeInitiated) {</span><br><span class="line">  <span class="number">9</span>:         <span class="comment">// 关闭已经完成，直接通知 Promise 对象</span></span><br><span class="line"> <span class="number">10</span>:         <span class="keyword">if</span> (closeFuture.isDone()) {</span><br><span class="line"> <span class="number">11</span>:             <span class="comment">// Closed already.</span></span><br><span class="line"> <span class="number">12</span>:             safeSetSuccess(promise);</span><br><span class="line"> <span class="number">13</span>:         <span class="comment">// 关闭未完成，通过监听器通知 Promise 对象</span></span><br><span class="line"> <span class="number">14</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise)) { <span class="comment">// Only needed if no VoidChannelPromise.</span></span><br><span class="line"> <span class="number">15</span>:             <span class="comment">// This means close() was called before so we just register a listener and return</span></span><br><span class="line"> <span class="number">16</span>:             closeFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line"> <span class="number">17</span>:                 <span class="meta">@Override</span></span><br><span class="line"> <span class="number">18</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">19</span>:                     promise.setSuccess();</span><br><span class="line"> <span class="number">20</span>:                 }</span><br><span class="line"> <span class="number">21</span>:             });</span><br><span class="line"> <span class="number">22</span>:         }</span><br><span class="line"> <span class="number">23</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">24</span>:     }</span><br><span class="line"> <span class="number">25</span>: </span><br><span class="line"> <span class="number">26</span>:     <span class="comment">// 标记关闭已经初始化</span></span><br><span class="line"> <span class="number">27</span>:     closeInitiated = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">28</span>: </span><br><span class="line"> <span class="number">29</span>:     <span class="comment">// 获得 Channel 是否激活</span></span><br><span class="line"> <span class="number">30</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line"> <span class="number">31</span>:     <span class="comment">// 标记 outboundBuffer 为空</span></span><br><span class="line"> <span class="number">32</span>:     <span class="keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line"> <span class="number">33</span>:     <span class="keyword">this</span>.outboundBuffer = <span class="keyword">null</span>; <span class="comment">// Disallow adding any messages and flushes to outboundBuffer.</span></span><br><span class="line"> <span class="number">34</span>:     <span class="comment">// 执行准备关闭</span></span><br><span class="line"> <span class="number">35</span>:     Executor closeExecutor = prepareToClose();</span><br><span class="line"> <span class="number">36</span>:     <span class="comment">// 若 closeExecutor 非空</span></span><br><span class="line"> <span class="number">37</span>:     <span class="keyword">if</span> (closeExecutor != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">38</span>:         closeExecutor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line"> <span class="number">39</span>:             <span class="meta">@Override</span></span><br><span class="line"> <span class="number">40</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">41</span>:                 <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">42</span>:                     <span class="comment">// 在 closeExecutor 中，执行关闭</span></span><br><span class="line"> <span class="number">43</span>:                     <span class="comment">// Execute the close.</span></span><br><span class="line"> <span class="number">44</span>:                     doClose0(promise);</span><br><span class="line"> <span class="number">45</span>:                 } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">46</span>:                     <span class="comment">// 在 EventLoop 中，执行</span></span><br><span class="line"> <span class="number">47</span>:                     <span class="comment">// Call invokeLater so closeAndDeregister is executed in the EventLoop again!</span></span><br><span class="line"> <span class="number">48</span>:                     invokeLater(<span class="keyword">new</span> Runnable() {</span><br><span class="line"> <span class="number">49</span>:                         <span class="meta">@Override</span></span><br><span class="line"> <span class="number">50</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">51</span>:                             <span class="keyword">if</span> (outboundBuffer != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">52</span>:                                 <span class="comment">// 写入数据( 消息 )到对端失败，通知相应数据对应的 Promise 失败。</span></span><br><span class="line"> <span class="number">53</span>:                                 <span class="comment">// Fail all the queued messages</span></span><br><span class="line"> <span class="number">54</span>:                                 outboundBuffer.failFlushed(cause, notify);</span><br><span class="line"> <span class="number">55</span>:                                 <span class="comment">// 关闭内存队列</span></span><br><span class="line"> <span class="number">56</span>:                                 outboundBuffer.close(closeCause);</span><br><span class="line"> <span class="number">57</span>:                             }</span><br><span class="line"> <span class="number">58</span>:                             <span class="comment">// 执行取消注册，并触发 Channel Inactive 事件到 pipeline 中</span></span><br><span class="line"> <span class="number">59</span>:                             fireChannelInactiveAndDeregister(wasActive);</span><br><span class="line"> <span class="number">60</span>:                         }</span><br><span class="line"> <span class="number">61</span>:                     });</span><br><span class="line"> <span class="number">62</span>:                 }</span><br><span class="line"> <span class="number">63</span>:             }</span><br><span class="line"> <span class="number">64</span>:         });</span><br><span class="line"> <span class="number">65</span>:     <span class="comment">// 若 closeExecutor 为空</span></span><br><span class="line"> <span class="number">66</span>:     } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">67</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">68</span>:             <span class="comment">// 执行关闭</span></span><br><span class="line"> <span class="number">69</span>:             <span class="comment">// Close the channel and fail the queued messages in all cases.</span></span><br><span class="line"> <span class="number">70</span>:             doClose0(promise);</span><br><span class="line"> <span class="number">71</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">72</span>:             <span class="keyword">if</span> (outboundBuffer != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">73</span>:                 <span class="comment">// 写入数据( 消息 )到对端失败，通知相应数据对应的 Promise 失败。</span></span><br><span class="line"> <span class="number">74</span>:                 <span class="comment">// Fail all the queued messages.</span></span><br><span class="line"> <span class="number">75</span>:                 outboundBuffer.failFlushed(cause, notify);</span><br><span class="line"> <span class="number">76</span>:                 <span class="comment">// 关闭内存队列</span></span><br><span class="line"> <span class="number">77</span>:                 outboundBuffer.close(closeCause);</span><br><span class="line"> <span class="number">78</span>:             }</span><br><span class="line"> <span class="number">79</span>:         }</span><br><span class="line"> <span class="number">80</span>:         <span class="comment">// 正在 flush 中，在 EventLoop 中执行执行取消注册，并触发 Channel Inactive 事件到 pipeline 中</span></span><br><span class="line"> <span class="number">81</span>:         <span class="keyword">if</span> (inFlush0) {</span><br><span class="line"> <span class="number">82</span>:             invokeLater(<span class="keyword">new</span> Runnable() {</span><br><span class="line"> <span class="number">83</span>:                 <span class="meta">@Override</span></span><br><span class="line"> <span class="number">84</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">85</span>:                     fireChannelInactiveAndDeregister(wasActive);</span><br><span class="line"> <span class="number">86</span>:                 }</span><br><span class="line"> <span class="number">87</span>:             });</span><br><span class="line"> <span class="number">88</span>:         <span class="comment">// 不在 flush 中，直接执行执行取消注册，并触发 Channel Inactive 事件到 pipeline 中</span></span><br><span class="line"> <span class="number">89</span>:         } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">90</span>:             fireChannelInactiveAndDeregister(wasActive);</span><br><span class="line"> <span class="number">91</span>:         }</span><br><span class="line"> <span class="number">92</span>:     }</span><br><span class="line"> <span class="number">93</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>方法参数 <code>cause</code>、<code>closeCause</code> ，关闭的“原因”。对于 <strong>close</strong> 操作来说，无论是正常关闭，还是异常关闭，通过使用 <strong>Exception</strong> 来表示<strong>来源</strong>。在 AbstractChannel 类中，枚举了所有来源：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException FLUSH0_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">        <span class="keyword">new</span> ClosedChannelException(), AbstractUnsafe.class, <span class="string">"flush0()"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException ENSURE_OPEN_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">        <span class="keyword">new</span> ClosedChannelException(), AbstractUnsafe.class, <span class="string">"ensureOpen(...)"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException CLOSE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">        <span class="keyword">new</span> ClosedChannelException(), AbstractUnsafe.class, <span class="string">"close(...)"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException WRITE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">        <span class="keyword">new</span> ClosedChannelException(), AbstractUnsafe.class, <span class="string">"write(...)"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NotYetConnectedException FLUSH0_NOT_YET_CONNECTED_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">        <span class="keyword">new</span> NotYetConnectedException(), AbstractUnsafe.class, <span class="string">"flush0()"</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 2 至 5 行：调用 <code>ChannelPromise#setUncancellable()</code> 方法，设置 Promise 不可取消。</p>
</li>
<li>第 8 行：若 <code>AbstractChannel.closeInitiated</code> 为 <code>true</code> 时，表示关闭已经标记初始化，此时<strong>可能</strong>已经关闭完成。<ul>
<li>第 10 至 12 行：关闭<strong>已经</strong>完成，直接通知 Promise 对象。</li>
<li>第 13 至 22 行：关闭<strong>并未</strong>完成，通过监听器回调通知 Promise 对象。</li>
<li>第 23 行：<code>return</code> 结束。</li>
<li>第 27 行：标记关闭已经初始化。</li>
</ul>
</li>
<li>第 30 行：调用 <code>#isActive()</code> 方法， 获得 Channel 是否激活。</li>
<li>第 31 至 33 行：标记内存队列 <code>outboundBuffer</code> 为空。</li>
<li>第 35 行：调用 <code>#prepareToClose()</code> 方法，执行准备关闭。详细解析，胖友先跳到 <a href="#">「2.2 NioSocketChannelUnsafe#prepareToClose」</a> 中。</li>
<li>第 37 行：若 <code>closeExecutor</code> 非空，在 <a href="#">「2.2 NioSocketChannelUnsafe#prepareToClose」</a> 中，我们已经看到如果开启 <code>SO_LINGER</code> 功能，会返回 <code>GlobalEventExecutor.INSTANCE</code> 对象。<ul>
<li>第 38 至 44 行：提交任务到 <code>closeExecutor</code> 中，<strong>在它的线程中</strong>，执行 <code>#doClose0(promise)</code> 方法，执行关闭。为什么要在“在它的线程中”中？回答不出来的胖友，再好好重新看下 <a href="#">「2.2 NioSocketChannelUnsafe#prepareToClose」</a> 小节。</li>
<li>第 46 至 61 行：提交任务到 Channel 所在的 EventLoop 中，执行后续的任务。</li>
<li>整体的逻辑和代码，和【第 66 至 91 行】的代码是<strong>基本</strong>一致。</li>
</ul>
</li>
<li>第 66 行：若 <code>closeExecutor</code> 为空。<ul>
<li>第 70 行：调用 <code>#doClose0(promise)</code> 方法，执行<strong>真正的</strong>关闭。详细解析，胖友先跳到 <a href="#">「2.4 doClose0」</a> 中。</li>
<li>第 75 行：调用 <code>ChannelOutboundBuffer#failFlushed(Throwable cause, boolean notify)</code> 方法，写入数据( 消息 )到对端失败，通知相应数据对应的 Promise 失败。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Channel-5-flush/">《精尽 Netty 源码解析 —— Channel（五）之 flush 操作》</a> 。</li>
<li>第 77 行：调用 <code>ChannelOutboundBuffer#close(Throwable cause)</code> 方法，关闭内存队列。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Channel-5-flush/">《精尽 Netty 源码解析 —— Channel（五）之 flush 操作》</a> 。</li>
<li>第 81 行：若 <code>inFlush0</code> 为 <code>true</code> ，<strong>正在</strong> flush 中，<strong>在 EventLoop 中的线程中</strong>，调用 <code>#fireChannelInactiveAndDeregister(boolean wasActive)</code> 方法，执行取消注册，并触发 Channel Inactive 事件到 pipeline 中。详细解析，见 <a href="#">「2.5 AbstractUnsafe#fireChannelInactiveAndDeregister」</a> 中。<ul>
<li>第 90 行：若 <code>inFlush0</code> 为 <code>false</code> ，<strong>不在</strong> flush 中，<strong>直接</strong>调用 <code>#fireChannelInactiveAndDeregister(boolean wasActive)</code> 方法，执行取消注册，并触发 Channel Inactive 事件到 pipeline 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-NioSocketChannelUnsafe-prepareToClose"><a href="#2-2-NioSocketChannelUnsafe-prepareToClose" class="headerlink" title="2.2 NioSocketChannelUnsafe#prepareToClose"></a>2.2 NioSocketChannelUnsafe#prepareToClose</h2><p><code>NioSocketChannelUnsafe#prepareToClose()</code> 方法，执行准备关闭。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> Executor <span class="title">prepareToClose</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">if</span> (javaChannel().isOpen() &amp;&amp; config().getSoLinger() &gt; <span class="number">0</span>) {</span><br><span class="line"> <span class="number">5</span>:             <span class="comment">// We need to cancel this key of the channel so we may not end up in a eventloop spin</span></span><br><span class="line"> <span class="number">6</span>:             <span class="comment">// because we try to read or write until the actual close happens which may be later due</span></span><br><span class="line"> <span class="number">7</span>:             <span class="comment">// SO_LINGER handling.</span></span><br><span class="line"> <span class="number">8</span>:             <span class="comment">// See https://github.com/netty/netty/issues/4449</span></span><br><span class="line"> <span class="number">9</span>:             doDeregister();</span><br><span class="line"><span class="number">10</span>:             <span class="comment">// 返回 GlobalEventExecutor 对象</span></span><br><span class="line"><span class="number">11</span>:             <span class="keyword">return</span> GlobalEventExecutor.INSTANCE;</span><br><span class="line"><span class="number">12</span>:         }</span><br><span class="line"><span class="number">13</span>:     } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// Ignore the error as the underlying channel may be closed in the meantime and so</span></span><br><span class="line"><span class="number">15</span>:         <span class="comment">// getSoLinger() may produce an exception. In this case we just return null.</span></span><br><span class="line"><span class="number">16</span>:         <span class="comment">// See https://github.com/netty/netty/issues/4449</span></span><br><span class="line"><span class="number">17</span>:     }</span><br><span class="line"><span class="number">18</span>:     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">19</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 4 行：如果配置 <code>StandardSocketOptions.SO_LINGER</code> 大于 0 。让我们先来看下它的定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Socket 参数，关闭 Socket 的延迟时间，Netty 默认值为 -<span class="number">1</span> ，表示禁用该功能。</span><br><span class="line"></span><br><span class="line">* -<span class="number">1</span> 表示 socket.close() 方法立即返回，但 OS 底层会将发送缓冲区全部发送到对端。</span><br><span class="line">* <span class="number">0</span> 表示 socket.close() 方法立即返回，OS 放弃发送缓冲区的数据直接向对端发送RST包，对端收到复位错误。</span><br><span class="line">* 非 <span class="number">0</span> 整数值表示调用 socket.close() 方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>按照这个定义，如果<strong>大于 0</strong>，如果在<strong>真正关闭</strong> Channel ，需要<strong>阻塞</strong>直到延迟时间到或发送缓冲区中的数据发送完毕。</li>
<li>如果在 EventLoop 中执行<strong>真正关闭</strong> Channel 的操作，那么势必会阻塞 EventLoop 的线程。所以，在【第 11 行】的代码，返回 <code>GlobalEventExecutor.INSTANCE</code> 对象，作为执行<strong>真正关闭</strong> Channel 的操作的<strong>执行器</strong>( 它也有一个自己的线程哟 )。</li>
</ul>
</li>
<li>第 9 行：调用 <code>#doDeregister()</code> 方法，执行取消注册。详细解析，胖友先跳到 <a href="#">「2.2 AbstractUnsafe#doDeregister」</a> 中。</li>
<li>【来自我表弟普架的牛逼解答，我表示点赞支持】第 9 行的：为什么要调用 <code>#doDeregister()</code> 方法呢？因为 <code>SO_LINGER</code> 大于 0 时，<strong>真正关闭</strong> Channel ，需要<strong>阻塞</strong>直到延迟时间到或发送缓冲区中的数据发送完毕。如果不取消该 Channel 的 <code>SelectionKey.OP_READ</code> 事件的感兴趣，就会不断触发读事件，导致 CPU 空轮询。为什么呢?在 Channel 关闭时，会<strong>自动</strong>触发 <code>SelectionKey.OP_READ</code> 事件。而且，会不断不断不断的触发，如果不进行取消 <code>SelectionKey.OP_READ</code> 事件的感兴趣。<ul>
<li>😈 感叹一句，细思极恐啊，厉害了，Netty 。 </li>
</ul>
</li>
<li>第 11 行：如果开启 <code>SO_LINGER</code> 功能，返回 <code>GlobalEventExecutor.INSTANCE</code> 对象。</li>
<li>第 18 行：若果关闭 <code>SO_LINGER</code> 功能，返回 <code>null</code> 对象。</li>
<li>😈 胖友，调回 <a href="#">「2.1 AbstractUnsafe#close」</a> 继续把。</li>
</ul>
<h2 id="2-3-AbstractUnsafe-doDeregister"><a href="#2-3-AbstractUnsafe-doDeregister" class="headerlink" title="2.3 AbstractUnsafe#doDeregister"></a>2.3 AbstractUnsafe#doDeregister</h2><p><code>AbstractUnsafe#doDeregister()</code> 方法，执行取消注册。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDeregister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    eventLoop().cancel(selectionKey());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>EventLoop#cancel(SelectionKey key)</code> 方法，取消 SelectionKey ，即相当于调用 <code>SelectionKey#cancel()</code> 方法。如此，对通道的读写等等 IO 就绪事件不再感兴趣，也不会做出相应的处理。</li>
</ul>
<h2 id="2-4-AbstractUnsafe-doClose0"><a href="#2-4-AbstractUnsafe-doClose0" class="headerlink" title="2.4 AbstractUnsafe#doClose0"></a>2.4 AbstractUnsafe#doClose0</h2><p><code>AbstractUnsafe#doClose0(ChannelPromise promise)</code> 方法，执行<strong>真正的</strong>关闭。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose0</span><span class="params">(ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// 执行关闭</span></span><br><span class="line"> <span class="number">4</span>:         doClose();</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 通知 closeFuture 关闭完成</span></span><br><span class="line"> <span class="number">6</span>:         closeFuture.setClosed();</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 通知 Promise 关闭成功</span></span><br><span class="line"> <span class="number">8</span>:         safeSetSuccess(promise);</span><br><span class="line"> <span class="number">9</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 通知 closeFuture 关闭完成</span></span><br><span class="line"><span class="number">11</span>:         closeFuture.setClosed();</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 通知 Promise 关闭异常</span></span><br><span class="line"><span class="number">13</span>:         safeSetFailure(promise, t);</span><br><span class="line"><span class="number">14</span>:     }</span><br><span class="line"><span class="number">15</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：调用 <code>#doClose()</code> 方法，执行关闭。这是一个<strong>抽象</strong>方法，NioSocketChannel 对它的实现，胖友先跳到 <a href="#">「2.4.1 NioSocketChannel#doClose」 </a> 中。</li>
<li><p>第 6 行：调用 <code>CloseFuture#setClosed()</code> 方法，通知 <code>closeFuture</code> 关闭完成。此处就会结束我们在 EchoClient 的阻塞监听客户端关闭。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Wait until the connection is closed.</span></span><br><span class="line"><span class="comment">// 监听客户端关闭，并阻塞等待</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>哟哟哟，就要结束阻塞等待了。</li>
</ul>
</li>
<li><p>第 8 行：调用 <code>#safeSetSuccess(promise)</code> 方法，通知 通知 Promise 关闭<strong>成功</strong>。此处就会回调我们对 <code>Channel#close()</code> 方法的返回的 ChannelFuture 的监听。示例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ctx.channel().close().addListener(<span class="keyword">new</span> ChannelFutureListener() { <span class="comment">// 我是一个萌萌哒监听器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"我会被唤醒"</span>);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>哟哟哟，要被回调了。</li>
</ul>
</li>
<li>若发生异常：<ul>
<li>第 11 行：调用 <code>CloseFuture#setClosed()</code> 方法，通知 <code>closeFuture</code> 关闭完成。</li>
<li>第 13 行: 调用 <code>#safeSetFailure(promise, t)</code> 方法，通知 通知 Promise 关闭<strong>异常</strong>。</li>
</ul>
</li>
</ul>
<h3 id="2-4-1-NioSocketChannel-doClose"><a href="#2-4-1-NioSocketChannel-doClose" class="headerlink" title="2.4.1  NioSocketChannel#doClose"></a>2.4.1  NioSocketChannel#doClose</h3><p><code>NioSocketChannel#doClose()</code> 方法，执行 Java 原生 NIO SocketChannel 关闭。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"><span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="number">3</span>:     <span class="comment">// 执行父类关闭方法</span></span><br><span class="line"><span class="number">4</span>:     <span class="keyword">super</span>.doClose();</span><br><span class="line"><span class="number">5</span>:     <span class="comment">// 执行 Java 原生 NIO SocketChannel 关闭</span></span><br><span class="line"><span class="number">6</span>:     javaChannel().close();</span><br><span class="line"><span class="number">7</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 4 行：调用 <code>AbstractNioChannel#doClose()</code> 方法，执行<strong>父类</strong>关闭方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 通知 connectPromise 异常失败</span></span><br><span class="line">    ChannelPromise promise = connectPromise;</span><br><span class="line">    <span class="keyword">if</span> (promise != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// Use tryFailure() instead of setFailure() to avoid the race against cancel().</span></span><br><span class="line">        promise.tryFailure(DO_CLOSE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">        connectPromise = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消 connectTimeoutFuture 等待</span></span><br><span class="line">    ScheduledFuture&lt;?&gt; future = connectTimeoutFuture;</span><br><span class="line">    <span class="keyword">if</span> (future != <span class="keyword">null</span>) {</span><br><span class="line">        future.cancel(<span class="keyword">false</span>);</span><br><span class="line">        connectTimeoutFuture = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>适用于客户端<strong>正在</strong>发起对服务端的连接的阶段。</li>
</ul>
</li>
<li>【重要】第 6 行：调用 <code>SocketChannel#close()</code> 方法，执行 Java 原生 NIO SocketChannel 关闭。</li>
</ul>
<h2 id="2-5-AbstractUnsafe-fireChannelInactiveAndDeregister"><a href="#2-5-AbstractUnsafe-fireChannelInactiveAndDeregister" class="headerlink" title="2.5 AbstractUnsafe#fireChannelInactiveAndDeregister"></a>2.5 AbstractUnsafe#fireChannelInactiveAndDeregister</h2><p><code>AbstractUnsafe#fireChannelInactiveAndDeregister(boolean wasActive)</code> 方法，执行取消注册，并触发 Channel Inactive 事件到 pipeline 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireChannelInactiveAndDeregister</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> wasActive)</span> </span>{</span><br><span class="line">    deregister(voidPromise() <span class="comment">/** &lt;1&gt; **/</span>, wasActive &amp;&amp; !isActive() <span class="comment">/** &lt;2&gt; **/</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise, <span class="keyword">final</span> <span class="keyword">boolean</span> fireChannelInactive)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// 设置 Promise 不可取消</span></span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">if</span> (!promise.setUncancellable()) {</span><br><span class="line">  <span class="number">4</span>:         <span class="keyword">return</span>;</span><br><span class="line">  <span class="number">5</span>:     }</span><br><span class="line">  <span class="number">6</span>: </span><br><span class="line">  <span class="number">7</span>:     <span class="comment">// 不处于已经注册状态，直接通知 Promise 取消注册成功。</span></span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">if</span> (!registered) {</span><br><span class="line">  <span class="number">9</span>:         safeSetSuccess(promise);</span><br><span class="line"> <span class="number">10</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">11</span>:     }</span><br><span class="line"> <span class="number">12</span>: </span><br><span class="line"> <span class="number">13</span>:     <span class="comment">// As a user may call deregister() from within any method while doing processing in the ChannelPipeline,</span></span><br><span class="line"> <span class="number">14</span>:     <span class="comment">// we need to ensure we do the actual deregister operation later. This is needed as for example,</span></span><br><span class="line"> <span class="number">15</span>:     <span class="comment">// we may be in the ByteToMessageDecoder.callDecode(...) method and so still try to do processing in</span></span><br><span class="line"> <span class="number">16</span>:     <span class="comment">// the old EventLoop while the user already registered the Channel to a new EventLoop. Without delay,</span></span><br><span class="line"> <span class="number">17</span>:     <span class="comment">// the deregister operation this could lead to have a handler invoked by different EventLoop and so</span></span><br><span class="line"> <span class="number">18</span>:     <span class="comment">// threads.</span></span><br><span class="line"> <span class="number">19</span>:     <span class="comment">//</span></span><br><span class="line"> <span class="number">20</span>:     <span class="comment">// See:</span></span><br><span class="line"> <span class="number">21</span>:     <span class="comment">// https://github.com/netty/netty/issues/4435</span></span><br><span class="line"> <span class="number">22</span>:     invokeLater(<span class="keyword">new</span> Runnable() {</span><br><span class="line"> <span class="number">23</span>:         <span class="meta">@Override</span></span><br><span class="line"> <span class="number">24</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">25</span>:             <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">26</span>:                 <span class="comment">// 执行取消注册</span></span><br><span class="line"> <span class="number">27</span>:                 doDeregister();</span><br><span class="line"> <span class="number">28</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"> <span class="number">29</span>:                 logger.warn(<span class="string">"Unexpected exception occurred while deregistering a channel."</span>, t);</span><br><span class="line"> <span class="number">30</span>:             } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">31</span>:                 <span class="comment">// 触发 Channel Inactive 事件到 pipeline 中</span></span><br><span class="line"> <span class="number">32</span>:                 <span class="keyword">if</span> (fireChannelInactive) {</span><br><span class="line"> <span class="number">33</span>:                     pipeline.fireChannelInactive();</span><br><span class="line"> <span class="number">34</span>:                 }</span><br><span class="line"> <span class="number">35</span>: </span><br><span class="line"> <span class="number">36</span>:                 <span class="comment">// Some transports like local and AIO does not allow the deregistration of</span></span><br><span class="line"> <span class="number">37</span>:                 <span class="comment">// an open channel.  Their doDeregister() calls close(). Consequently,</span></span><br><span class="line"> <span class="number">38</span>:                 <span class="comment">// close() calls deregister() again - no need to fire channelUnregistered, so check</span></span><br><span class="line"> <span class="number">39</span>:                 <span class="comment">// if it was registered.</span></span><br><span class="line"> <span class="number">40</span>:                 <span class="keyword">if</span> (registered) {</span><br><span class="line"> <span class="number">41</span>:                     <span class="comment">// 标记为未注册</span></span><br><span class="line"> <span class="number">42</span>:                     registered = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">43</span>:                     <span class="comment">// 触发 Channel Unregistered 事件到 pipeline 中</span></span><br><span class="line"> <span class="number">44</span>:                     pipeline.fireChannelUnregistered();</span><br><span class="line"> <span class="number">45</span>:                 }</span><br><span class="line"> <span class="number">46</span>: </span><br><span class="line"> <span class="number">47</span>:                 <span class="comment">// 通知 Promise 取消注册成功。</span></span><br><span class="line"> <span class="number">48</span>:                 safeSetSuccess(promise);</span><br><span class="line"> <span class="number">49</span>:             }</span><br><span class="line"> <span class="number">50</span>:         }</span><br><span class="line"> <span class="number">51</span>:     });</span><br><span class="line"> <span class="number">52</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，传入 <code>#deregister(...)</code> 方法的第一个参数为 <code>unsafeVoidPromise</code> ，类型为 VoidChannelPromise <strong>类</strong>，表示需要通知 Promise 。为什么这么说呢？在 <code>#safeSetSuccess(promise)</code> 方法中，可以看到：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">safeSetSuccess</span><span class="params">(ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.trySuccess()) {</span><br><span class="line">        logger.warn(<span class="string">"Failed to mark a promise as success because it is done already: {}"</span>, promise);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>!(promise instanceof VoidChannelPromise)</code> 代码块，表示排除 VoidChannelPromise 类型的 <code>promise</code> 。</li>
</ul>
</li>
<li><code>&lt;2&gt;</code> 处，通过对比新老的 <code>active</code> 的值，判断是否 Channel 的状态是否从 Active 变成 Inactive 。</li>
<li>第 2 至 5 行：调用 <code>ChannelPromise#setUncancellable()</code> 方法，设置 Promise 不可取消。</li>
<li>第 7 至 11 行：不处于已经注册状态，直接通知 Promise 取消注册成功，并 <code>return</code> 返回。<ul>
<li>😈 在当前情况下，<code>registered = true</code> ，所以不符合条件。 </li>
</ul>
</li>
<li>第 22 行：调用 <code>#invokeLater(Runnable)</code> 方法，提交任务到 EventLoop 的线程中执行，以避免<strong>一个</strong> Channel 的 ChannelHandler 在<strong>不同</strong>的 EventLoop 或者线程中执行。详细的说明，可以看下【第 13 至 21 行】的英文说明。<ul>
<li>😈 实际从目前该方法的调用看下来，有可能不是从 EventLoop 的线程中调用。</li>
</ul>
</li>
<li>第 27 行：调用 <code>AbstractUnsafe#doDeregister()</code> 方法，执行取消注册。在 <a href="#">「2.3 AbstractUnsafe#doDeregister」</a> 中，已经详细解析。</li>
<li>第 31 至 34 行：如果 <code>fireChannelInactive = true</code> ，调用 <code>ChannelPipeline#fireChannelInactive()</code> 方法，触发 Channel Inactive 事件到 pipeline 中。而 Channel Inactive 事件属于 Inbound 事件，所以会从 <code>head</code> 节点开始，最终传播到 <code>tail</code> 节点，目前并未执行什么逻辑，感兴趣的胖友，可以自己去看看。如果胖友业务上有需要，可以自己添加 ChannelHandler 进行处理。</li>
<li>第 40 至 42 行：标记为未注册。</li>
<li>第 44 行：调用 <code>ChannelPipeline#fireChannelUnregistered()</code> 方法，触发 Channel Unregistered 事件到 pipeline 中。而 Channel Unregistered 事件属于 Inbound 事件，所以会从 <code>head</code> 节点开始，最终传播到 <code>tail</code> 节点，目前并未执行什么逻辑，感兴趣的胖友，可以自己去看看。如果胖友业务上有需要，可以自己添加 ChannelHandler 进行处理。<ul>
<li>😈 又啰嗦了一遍，【第 31 至 34 行】的代码的逻辑。</li>
</ul>
</li>
<li>第 48 行：调用 <code>#safeSetSuccess(promise)</code> 方法，通知 Promise 取消注册成功。</li>
</ul>
<h1 id="3-NioServerSocketChannel"><a href="#3-NioServerSocketChannel" class="headerlink" title="3. NioServerSocketChannel"></a>3. NioServerSocketChannel</h1><p>通过 <code>NioServerSocketChannel#close()</code> 方法，应用程序里可以主动关闭 NioServerSocketChannel 通道。在具体的代码实现上，唯一的差别就是对 <code>AbstractNioChannel#doClose()</code> 方法的实现不同( 对应 <a href="#">「2.4.1 NioSocketChannel#doClose」</a> )。代码如下：</p>
<p><code>NioSocketChannel#doClose()</code> 方法，执行 Java 原生 NIO SocketServerChannel 关闭。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    javaChannel().close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>SocketServerChannel#close()</code> 方法，执行 Java 原生 NIO SocketServerChannel 关闭。</li>
</ul>
<hr>
<p>那么可能会有胖友有疑惑了，<code>#close()</code> 方法的实现，99.99% 都相似，那么 NioSocketChannel 和 NioServerSocketChannel 差异的关闭逻辑怎么实现呢？答案其实很简单，通过给它们配置不同的 ChannelHandler 实现类即可。</p>
<h1 id="4-Unsafe-closeForcibly"><a href="#4-Unsafe-closeForcibly" class="headerlink" title="4. Unsafe#closeForcibly"></a>4. Unsafe#closeForcibly</h1><p>实际上，在 Unsafe 接口上定义了 <code>#closeForcibly()</code> 方法，英文注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes the {<span class="doctag">@link</span> Channel} immediately without firing any events.  Probably only useful</span></span><br><span class="line"><span class="comment"> * when registration attempt failed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeForcibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>立即关闭 Channel ，并且不触发 pipeline 上的任何事件。</li>
<li>仅仅用于 Channel 注册到 EventLoop 上失败的情况下。😈 这也就是为什么 <code>without firing any events</code> 的原因啦。</li>
</ul>
<p>AbstractUnsafe 对该接口方法，实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeForcibly</span><span class="params">()</span> </span>{</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        doClose();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        logger.warn(<span class="string">"Failed to close a channel."</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，调用 <code>AbstractNioChannel#doClose()</code> 方法，执行 Java 原生 NIO SocketServerChannel 或 SocketChannel 关闭。</li>
<li>并且，从代码实现上，我们可以看到，确实并未触发任何 pipeline 上的事件。</li>
</ul>
<h1 id="5-服务端处理客户端主动关闭连接"><a href="#5-服务端处理客户端主动关闭连接" class="headerlink" title="5. 服务端处理客户端主动关闭连接"></a>5. 服务端处理客户端主动关闭连接</h1><p>在客户端主动关闭时，服务端会收到一个 <code>SelectionKey.OP_READ</code> 事件的就绪，在调用客户端对应在服务端的 SocketChannel 的 <code>#read()</code> 方法会返回 <strong>-1</strong> ，从而实现在服务端关闭客户端的逻辑。在 Netty 的实现，在 <code>NioByteUnsafe#read()</code> 方法中，简化代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 设置最后读取字节数</span></span><br><span class="line">allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line"><span class="comment">// 如果最后读取的字节为小于 0 ，说明对端已经关闭</span></span><br><span class="line">close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭客户端的连接</span></span><br><span class="line"><span class="keyword">if</span> (close) {</span><br><span class="line">    closeOnRead(pipeline);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，读取客户端的 SocketChannel 返回 <strong>-1</strong> ，说明客户端已经关闭。</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#closeOnRead(ChannelPipeline pipeline)</code> 方法，关闭客户端的连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOnRead</span><span class="params">(ChannelPipeline pipeline)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (!isInputShutdown0()) {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// 开启连接半关闭</span></span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">if</span> (isAllowHalfClosure(config())) {</span><br><span class="line"> <span class="number">5</span>:             <span class="comment">// 关闭 Channel 数据的读取</span></span><br><span class="line"> <span class="number">6</span>:             shutdownInput();</span><br><span class="line"> <span class="number">7</span>:             <span class="comment">// 触发 ChannelInputShutdownEvent.INSTANCE 事件到 pipeline 中</span></span><br><span class="line"> <span class="number">8</span>:             pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);</span><br><span class="line"> <span class="number">9</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">10</span>:             close(voidPromise());</span><br><span class="line"><span class="number">11</span>:         }</span><br><span class="line"><span class="number">12</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 标记 inputClosedSeenErrorOnRead 为 true</span></span><br><span class="line"><span class="number">14</span>:         inputClosedSeenErrorOnRead = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">15</span>:         <span class="comment">// 触发 ChannelInputShutdownEvent.INSTANCE 事件到 pipeline 中</span></span><br><span class="line"><span class="number">16</span>:         pipeline.fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);</span><br><span class="line"><span class="number">17</span>:     }</span><br><span class="line"><span class="number">18</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 2 行：调用 <code>NioSocketChannel#isInputShutdown0()</code> 方法，判断是否关闭 Channel 数据的读取。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// NioSocketChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInputShutdown0</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isInputShutdown();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInputShutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> javaChannel().socket().isInputShutdown() || !isActive();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.net.Socket.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> shutIn = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the read-half of the socket connection is closed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the input of the socket has been shutdown</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #shutdownInput</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInputShutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> shutIn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 注意看下英文注释。</li>
</ul>
</li>
<li><p><code>&lt;1&gt;</code> 第 4 行：调用 <code>AbstractNioByteChannel#isAllowHalfClosure()</code> 方法，判断是否开启连接<strong>半关闭</strong>的功能。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractNioByteChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAllowHalfClosure</span><span class="params">(ChannelConfig config)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> config <span class="keyword">instanceof</span> SocketChannelConfig &amp;&amp;</span><br><span class="line">            ((SocketChannelConfig) config).isAllowHalfClosure();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可通过 <code>ALLOW_HALF_CLOSURE</code> 配置项开启。<ul>
<li>Netty 参数，一个连接的远端关闭时本地端是否关闭，默认值为 <code>false</code> 。</li>
<li>值为 <code>false</code>时，连接自动关闭。</li>
<li>值为 <code>true</code> 时，触发 ChannelInboundHandler 的<code>#userEventTriggered()</code> 方法，事件 ChannelInputShutdownEvent 。</li>
</ul>
</li>
<li><p><code>&lt;1.1&gt;</code> 第 6 行：调用 <code>NioSocketChannel#shutdownInput()</code> 方法，关闭 Channel 数据的读取。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">shutdownInput</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> shutdownInput(newPromise());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">shutdownInput</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    EventLoop loop = eventLoop();</span><br><span class="line">    <span class="keyword">if</span> (loop.inEventLoop()) {</span><br><span class="line">        shutdownInput0(promise);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        loop.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                shutdownInput0(promise);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutdownInput0</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 关闭 Channel 数据的读取</span></span><br><span class="line">        shutdownInput0();</span><br><span class="line">        <span class="comment">// 通知 Promise 成功</span></span><br><span class="line">        promise.setSuccess();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 通知 Promise 失败</span></span><br><span class="line">        promise.setFailure(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutdownInput0</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 调用 Java NIO Channel 的 shutdownInput 方法</span></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) {</span><br><span class="line">        javaChannel().shutdownInput();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        javaChannel().socket().shutdownInput();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>核心是，调用 Java NIO Channel 的 shutdownInput 方法。</li>
</ul>
</li>
<li><code>&lt;1.1&gt;</code> 第 8 行：调用 <code>ChannelPipeline#fireUserEventTriggered(Object event)</code> 方法，触发 <code>ChannelInputShutdownEvent.INSTANCE</code> 事件到 pipeline 中。关于这个事件，胖友可以看看 <a href="https://my.oschina.net/chenleijava/blog/484667" rel="external nofollow noopener noreferrer" target="_blank">《netty 处理远程主机强制关闭一个连接》</a> 。</li>
<li><code>&lt;1.2&gt;</code> 第 9 至 11 行：调用 <code>#close(Promise)</code> 方法，关闭客户端的 Channel 。后续的，就是 <a href="#">「2. NioSocketChannel」</a> 中。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 12 至 17 行：</p>
<ul>
<li><p>第 14 行：标记 <code>inputClosedSeenErrorOnRead</code> 为 <code>true</code> 。原因如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道关闭读取，又错误读取的错误的标识</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 详细见 https://github.com/netty/netty/commit/ed0668384b393c3502c2136e3cc412a5c8c9056e 提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> inputClosedSeenErrorOnRead;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>如下是提交的说明：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">AbstractNioByteChannel will detect that the remote end of the socket has</span><br><span class="line">been closed and propagate a user event through the pipeline. However <span class="keyword">if</span></span><br><span class="line">the user has auto read on, or calls read again, we may propagate the</span><br><span class="line">same user events again. If the underlying transport continuously</span><br><span class="line">notifies us that there is read activity <span class="keyword">this</span> will happen in a spin loop</span><br><span class="line">which consumes unnecessary CPU.</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>胖友认真看下英文注释。结合 <a href="https://github.com/netty/netty/pull/7801" rel="external nofollow noopener noreferrer" target="_blank">《NIO read spin event loop spin when half closed #7801》</a> 提供的示例。</li>
<li><p>在标记 <code>inputClosedSeenErrorOnRead = true</code> 后，在 <code>NioByteUnsafe#read()</code> 方法中，会主动对 <code>SelectionKey.OP_READ</code> 的感兴趣，避免空轮询。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractNioByteUnsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="comment">// 若 inputClosedSeenErrorOnRead = true ，移除对 SelectionKey.OP_READ 事件的感兴趣。</span></span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) {</span><br><span class="line">        clearReadPending(); <span class="comment">// 移除对 SelectionKey.OP_READ 事件的感兴趣</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略其他代码。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioByteChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">shouldBreakReadReady</span><span class="params">(ChannelConfig config)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isInputShutdown0() &amp;&amp; (inputClosedSeenErrorOnRead || !isAllowHalfClosure(config));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第 16 行：调用 <code>ChannelPipeline#fireUserEventTriggered(Object event)</code> 方法，触发 <code>ChannelInputShutdownEvent.INSTANCE</code> 事件到 pipeline 中。</li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>比想象中简单的文章。但是，卡了比较久的时间。主要是针对 <a href="https://github.com/netty/netty/issues/4449" rel="external nofollow noopener noreferrer" target="_blank">《High CPU usage with SO_LINGER and sudden connection close (4.0.26.Final+) #4449》</a> 的讨论，中间请教了基友闪电侠和表弟普架。</p>
<p>痛并快乐的过程。如果英文好一点，相信解决的过程，可能更加愉快一些把。</p>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Channel-7-close/" data-id="ck4pl3fp300dxfgcf9x6fgwps" class="article-share-link">分享</a>

</footer>
-->
</div>
