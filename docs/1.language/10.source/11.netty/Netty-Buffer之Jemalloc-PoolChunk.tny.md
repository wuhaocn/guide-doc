<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote>
<p>老艿艿：如下阐释的内容，参考 Hypercube <a href="https://www.jianshu.com/p/15304cd63175" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–JEMalloc分配算法》</a> 。</p>
</blockquote>
<p>为了提高内存<strong>分配效率</strong>并减少<strong>内存碎片</strong>，Jemalloc 算法将每个 Arena 切分成多个<strong>小块</strong> Chunk 。但是实际上，每个 Chunk 依然是<strong>相当大</strong>的内存块。因为在 Jemalloc 建议为 4MB ，Netty 默认使用为 16MB 。</p>
<p>为了进一步提供提高内存<strong>分配效率</strong>并减少<strong>内存碎片</strong>，Jemalloc 算法将每个 Chunk 切分成多个<strong>小块</strong> Page 。一个典型的切分是将 Chunk 切分为 2048 块 Page ，Netty 也是如此，因此 Page 的大小为：<code>16MB / 2048 = 8KB</code> 。</p>
<p>一个好的内存分配算法，应使得已分配内存块尽可能保持连续，这将大大减少内部碎片，由此 Jemalloc 使用<a href="#">伙伴分配算法</a>尽可能提高连续性。<strong>伙伴分配算法</strong>的示意图如下：</p>
<blockquote>
<p>可能很多胖友不了解【伙伴分配算法】，感兴趣的话，可以看看 <a href="https://coolshell.cn/articles/10427.html" rel="external nofollow noopener noreferrer" target="_blank">《伙伴分配器的一个极简实现》</a> 了解了解。</p>
<p>当然，Netty PoolChunk 也是基于【伙伴分配算法】实现。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_09_04/01.png" title="满二叉树" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_04/01.png" alt="满二叉树"></a><span class="caption">满二叉树</span></p>
<p>图中<strong>最底层</strong>表示一个被切分为 2048 个 Page 的 Chunk 块。自底向上，每一层节点作为上一层的子节点构造出一棵<a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="external nofollow noopener noreferrer" target="_blank">满二叉树</a>，然后按层分配满足要求的内存块。以待分配序列 8KB、16KB、8KB 为例分析分配过程( 假设每个 Page 大小 8KB )：</p>
<ol>
<li>8KB —— 需要一个 Page ，第 11 层满足要求，故分配 <em>2048</em> 节点即 <strong>Page0</strong> 。</li>
<li>16KB —— 需要两个Page ，故需要在第 10 层进行分配，而 <em>1024</em> 的子节点 <em>2048</em> 已分配，从左到右找到满足要求的 <em>1025</em> 节点，故分配节点 <em>1025</em> 即<strong>Page2</strong> 和 <strong>Page3</strong> 。</li>
<li>8KB —— 需要一个 Page ，第 11 层满足要求，但是 <em>2048</em> 已分配，从左到右找到 <em>2049</em> 节点即 <strong>Page1</strong> 进行分配。</li>
</ol>
<p>总结来说：</p>
<ul>
<li>分配结束后，已分配连续的 <strong>Page0 - Page3</strong> 。这样的连续内存块，大大减少内部碎片并提高<strong>内存使用率</strong>。</li>
<li>通过使用<strong>满二叉树</strong>这样的树结构，提升检索到可用 Page 的速度，从而提高内存<strong>分配效率</strong>。</li>
</ul>
<h1 id="2-PoolChunk"><a href="#2-PoolChunk" class="headerlink" title="2. PoolChunk"></a>2. PoolChunk</h1><p><code>io.netty.buffer.PoolChunk</code> ，实现 PoolChunkMetric 接口，Netty 对 Jemalloc Chunk 的实现类。</p>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 Arena 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> PoolArena&lt;T&gt; arena;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> PooledByteBuf#memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> T memory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否非池化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #PoolChunk(PoolArena, Object, int, int) 非池化。当申请的内存大小为 Huge 类型时，创建一整块 Chunk ，并且不拆分成若干 Page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #PoolChunk(PoolArena, Object, int, int, int, int, int) 池化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> unpooled;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 芋艿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配信息满二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * index 为节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] memoryMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高度信息满二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * index 为节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] depthMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolSubpage 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断分配请求内存是否为 Tiny/Small ，即分配 Subpage 内存块。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Used to determine if the requested capacity is equal to or greater than pageSize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> subpageOverflowMask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Page 大小，默认 8KB = 8192B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 1 开始左移到 {<span class="doctag">@link</span> #pageSize} 的位数。默认 13 ，1 &lt;&lt; 13 = 8192 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 具体用途，见 {<span class="doctag">@link</span> #allocateRun(int)} 方法，计算指定容量所在满二叉树的层级。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pageShifts;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 满二叉树的高度。默认为 11 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxOrder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 内存块占用大小。默认为 16M = 16 * 1024  。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * log2 {<span class="doctag">@link</span> #chunkSize} 的结果。默认为 log2( 16M ) = 24 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> log2ChunkSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可分配 {<span class="doctag">@link</span> #subpages} 的数量，即数组大小。默认为 1 &lt;&lt; maxOrder = 1 &lt;&lt; 11 = 2048 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSubpageAllocs;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记节点不可用。默认为 maxOrder + 1 = 12 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Used to mark memory as unusable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> unusable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剩余可用字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> freeBytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 PoolChunkList 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolChunkList&lt;T&gt; parent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上一个 Chunk 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolChunk&lt;T&gt; prev;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个 Chunk 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolChunk&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法一：</span></span><br><span class="line">  <span class="number">1</span>: PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> offset) {</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// 池化</span></span><br><span class="line">  <span class="number">3</span>:     unpooled = <span class="keyword">false</span>;</span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">this</span>.arena = arena;</span><br><span class="line">  <span class="number">5</span>:     <span class="keyword">this</span>.memory = memory;</span><br><span class="line">  <span class="number">6</span>:     <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">  <span class="number">7</span>:     <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">  <span class="number">9</span>:     <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line"> <span class="number">10</span>:     <span class="keyword">this</span>.offset = offset;</span><br><span class="line"> <span class="number">11</span>:     unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);</span><br><span class="line"> <span class="number">12</span>:     log2ChunkSize = log2(chunkSize);</span><br><span class="line"> <span class="number">13</span>:     subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line"> <span class="number">14</span>:     freeBytes = chunkSize;</span><br><span class="line"> <span class="number">15</span>: </span><br><span class="line"> <span class="number">16</span>:     <span class="keyword">assert</span> maxOrder &lt; <span class="number">30</span> : <span class="string">"maxOrder should be &lt; 30, but is: "</span> + maxOrder;</span><br><span class="line"> <span class="number">17</span>:     maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;</span><br><span class="line"> <span class="number">18</span>: </span><br><span class="line"> <span class="number">19</span>:     <span class="comment">// 初始化 memoryMap 和 depthMap</span></span><br><span class="line"> <span class="number">20</span>:     <span class="comment">// Generate the memory map.</span></span><br><span class="line"> <span class="number">21</span>:     memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> <span class="number">22</span>:     depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line"> <span class="number">23</span>:     <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line"> <span class="number">24</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) { <span class="comment">// move down the tree one level at a time</span></span><br><span class="line"> <span class="number">25</span>:         <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line"> <span class="number">26</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) {</span><br><span class="line"> <span class="number">27</span>:             <span class="comment">// in each level traverse left to right and set value to the depth of subtree</span></span><br><span class="line"> <span class="number">28</span>:             memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line"> <span class="number">29</span>:             depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line"> <span class="number">30</span>:             memoryMapIndex ++;</span><br><span class="line"> <span class="number">31</span>:         }</span><br><span class="line"> <span class="number">32</span>:     }</span><br><span class="line"> <span class="number">33</span>: </span><br><span class="line"> <span class="number">34</span>:     <span class="comment">// 初始化 subpages</span></span><br><span class="line"> <span class="number">35</span>:     subpages = newSubpageArray(maxSubpageAllocs);</span><br><span class="line"> <span class="number">36</span>: }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法二： </span></span><br><span class="line"> <span class="number">38</span>: <span class="comment">/** Creates a special chunk that is not pooled. */</span></span><br><span class="line"> <span class="number">39</span>: PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> size, <span class="keyword">int</span> offset) {</span><br><span class="line"> <span class="number">40</span>:     <span class="comment">// 非池化</span></span><br><span class="line"> <span class="number">41</span>:     unpooled = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">42</span>:     <span class="keyword">this</span>.arena = arena;</span><br><span class="line"> <span class="number">43</span>:     <span class="keyword">this</span>.memory = memory;</span><br><span class="line"> <span class="number">44</span>:     <span class="keyword">this</span>.offset = offset;</span><br><span class="line"> <span class="number">45</span>:     memoryMap = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">46</span>:     depthMap = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">47</span>:     subpages = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">48</span>:     subpageOverflowMask = <span class="number">0</span>;</span><br><span class="line"> <span class="number">49</span>:     pageSize = <span class="number">0</span>;</span><br><span class="line"> <span class="number">50</span>:     pageShifts = <span class="number">0</span>;</span><br><span class="line"> <span class="number">51</span>:     maxOrder = <span class="number">0</span>;</span><br><span class="line"> <span class="number">52</span>:     unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);</span><br><span class="line"> <span class="number">53</span>:     chunkSize = size;</span><br><span class="line"> <span class="number">54</span>:     log2ChunkSize = log2(chunkSize);</span><br><span class="line"> <span class="number">55</span>:     maxSubpageAllocs = <span class="number">0</span>;</span><br><span class="line"> <span class="number">56</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>arena</code> 属性，所属 Arena 对象。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena》</a> 。 <ul>
<li><code>memory</code> 属性，内存空间。即<strong>用于</strong> <code>PooledByteBuf.memory</code> 属性，有 Direct ByteBuffer 和 <code>byte[]</code> 字节数组。</li>
<li><code>unpooled</code> 属性，是否非池化。<ul>
<li><code>unpooled = false</code> ，池化，对应构造方法<strong>一</strong>。默认情况下，对于 分配 16M <strong>以内</strong>的内存空间时，Netty 会分配一个 Normal 类型的 Chunk 块。并且，该 Chunk 块在使用完后，进行池化缓存，重复使用。</li>
<li><code>unpooled = true</code> ，非池化，对应构造方法<strong>二</strong>。默认情况下，对于分配 16M <strong>以上</strong>的内存空间时，Netty 会分配一个 Huge 类型的<strong>特殊</strong>的 Chunk 块。并且，由于 Huge 类型的 Chunk 占用内存空间较大，比较特殊，所以该 Chunk 块在使用完后，立即释放，不进行重复使用。</li>
<li>笔者对 Netty 对 Jemalloc 不同类型的内存块的整理，如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_04/02.png" title="内存块分类" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_04/02.png" alt="内存块分类"></a><span class="caption">内存块分类</span></li>
</ul>
</li>
</ul>
</li>
<li><p>Jemalloc 基于【伙伴分配算法】分配 Chunk 中的 Page 节点。Netty 实现的伙伴分配算法中，构造了<strong>两颗</strong>满二叉树。因为满二叉树非常适合数组存储，Netty 使用两个字节数组 <code>memoryMap</code> 和 <code>depthMap</code> 来分别表示<strong>分配信息</strong>满二叉树、<strong>高度信息</strong>满二叉树。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_04/03.png" title="满二叉树" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_04/03.png" alt="满二叉树"></a><span class="caption">满二叉树</span></p>
<ul>
<li><code>maxOrder</code> 属性，满二叉树的高度。默认为 11 。注意，层高是从 0 开始。</li>
<li><code>maxSubpageAllocs</code> 属性，可分配的 Page 的数量。默认为 2048 ，在【第 17 行】的代码进行初始化。在第 11 层，可以看到 Page0 - Page2047 这 2048 个节点，也也符合 <code>1 &lt;&lt; maxOrder = 11 &lt;&lt; 11 = 2048</code> 的计算。</li>
<li><p>在【第 19 至 32 行】的代码，<code>memoryMap</code> 和 <code>depthMap</code> 进行满二叉树的初始化。</p>
<ul>
<li>数组大小为 <code>maxSubpageAllocs &lt;&lt; 1 = 2048 &lt;&lt; 1 = 4096</code> 。</li>
<li>数组下标为<strong>左图</strong>对应的节点编号。在【第 23 行】的代码，从 <code>memoryMapIndex = 1</code> 代码可以看出，满二叉树的节点编号是<strong>从 1 开始</strong>。省略 0 是因为这样更容易计算父子关系：子节点加倍，父节点减半，例如：512 的子节点为 1024( <code>512 * 2</code> )和 1025( <code>512 * 2 + 1</code> )。</li>
<li><p>初始时，<code>memoryMap</code> 和 <code>depthMap</code> 相等，值为<strong>节点高度</strong>。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">memoryMap[<span class="number">1024</span>] = depthMap[<span class="number">1024</span>] = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对应<strong>右图</strong>。</li>
</ul>
</li>
<li>分配节点时，<code>depthMap</code> 的值保持<strong>不变</strong>( 因为，节点的高度没发生变化 )，<code>memoryMap</code> 的值发生<strong>变化</strong>( 因为，节点的分配信息发生变化 )。当一个节点被分配后，该节点的值设为 <code>unusable</code>( 标记节点不可用。默认为 <code>maxOrder + 1 = 12</code> ) 。<strong>并且，会更新祖先节点的值为其子节点较小的值</strong>( 因为，祖先节点共用该节点的 Page 内存；同时，一个父节点有两个子节点，一个节点不可用后，另一个子节点可能可用，所以更新为其子节点<strong>较小</strong>的值。 )。举个例子，下图表示随着节点 4 分配而更新祖先节点的过程，其中每个节点的第一个数字表示<strong>节点编号</strong>，第二个数字表示<strong>节点高度</strong>：<a href="http://static2.iocoder.cn/images/Netty/2018_09_04/04.png" title="例子" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_04/04.png" alt="例子"></a><span class="caption">例子</span><ul>
<li>节点 4 被<strong>完全</strong>分配，将高度值设置为 12 表示不可用。</li>
<li>节点 4 的父节点 2，将高度值更新为两个子节点的较小值。其他祖先节点亦然，直到高度值更新至根节点。</li>
</ul>
</li>
<li><code>memoryMap</code> 数组的值，总结为 3 种情况：<ul>
<li>1、<code>memoryMap[id] = depthMap[id]</code> ，该节点没有被分配。 </li>
<li>2、<code>最大高度 &gt;= memoryMap[id] &gt; depthMap[id]</code> ，至少有一个子节点被分配，不能再分配该高度满足的内存，但可以根据实际分配较小一些的内存。比如，上图中父节点 2 分配了子节点 4，值从 1 更新为 2，表示该节点不能再分配 8MB 的只能最大分配 4MB 内存，即只剩下节点 5 可用。</li>
<li>3、<code>memoryMap[id] = 最大高度 + 1</code> ，该节点及其子节点已被<strong>完全</strong>分配，没有剩余空间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Chunk 相关字段</p>
<ul>
<li><code>chunkSize</code> 属性，Chunk 内存块占用大小。默认为 <code>16M = 16 * 1024KB</code>  。</li>
<li><p><code>log2ChunkSize</code> 属性，<code>log2(chunkSize)</code> 的结果。默认为 <code>log2( 16M ) = 24</code> 。 代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTEGER_SIZE_MINUS_ONE = Integer.SIZE - <span class="number">1</span>; <span class="comment">// 32 - 1 = 31</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="comment">// compute the (0-based, with lsb = 0) position of highest set bit i.e, log2</span></span><br><span class="line">    <span class="keyword">return</span> INTEGER_SIZE_MINUS_ONE - Integer.numberOfLeadingZeros(val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>x</li>
</ul>
</li>
<li><code>freeBytes</code> 属性，剩余可用字节数。</li>
</ul>
</li>
<li>Page 相关字段<ul>
<li><code>pageSize</code> 属性，每个 Page 的大小。默认为 <code>8KB = 8192B</code> 。</li>
<li><code>pageShifts</code> 属性，从 1 开始左移到 <code>pageSize</code> 的位数。默认 13 ，<code>1 &lt;&lt; 13 = 8192</code> 。具体用于计算指定容量所在满二叉树的层级，详细解析，见 <a href="#">「2.2.1 allocateRun」</a> 。</li>
</ul>
</li>
<li><p>SubPage 相关字段</p>
<ul>
<li>详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-3-Jemalloc-subpage">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（三）PoolSubpage》</a> 。</li>
<li><p><code>subpages</code> 属性，PoolSubpage 数组。每个节点对应一个 PoolSubpage 对象。因为实际上，每个 Page 还是<strong>比较大</strong>的内存块，可以进一步切分成小块 SubPage 。在【第 35 行】的代码，调用 <code>#newSubpageArray(int size)</code> 方法，进行初始化。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PoolSubpage&lt;T&gt;[] newSubpageArray(<span class="keyword">int</span> size) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolSubpage[size];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认情况下，数组大小为 <code>maxSubpageAllocs = 2048</code> 。</li>
</ul>
</li>
<li><p><code>subpageOverflowMask</code> 属性，判断分配请求内存是否为 <strong>Tiny/Small</strong> ，即分配 Subpage 内存块。默认，-8192 。在【13 行】的代码进行初始化。对于 -8192 的二进制，除了首 bits 为 1 ，其它都为 0 。这样，对于小于 8K 字节的申请，求 <code>subpageOverflowMask &amp; length</code> 都等于 0 ；对于大于 8K 字节的申请，求 <code>subpageOverflowMask &amp; length</code> 都<strong>不</strong>等于 0 。相当于说，做了 <code>if ( length &lt; pageSize )</code> 的计算优化。</p>
</li>
</ul>
</li>
<li>ChunkList 相关字段<ul>
<li>详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-4-Jemalloc-chunkList">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（四）PoolChunkList》</a> 。</li>
<li><code>parent</code> 属性，所属 PoolChunkList 对象。</li>
<li><code>prev</code> 属性，上一个 Chunk 对象。</li>
<li><code>next</code> 属性，下一个 Chunk 对象。</li>
</ul>
</li>
</ul>
<p>内容比较“厚实”( 😈 字比较多 )，建议胖友再读一遍，再看下面的代码具体实现。</p>
<h2 id="2-2-allocate"><a href="#2-2-allocate" class="headerlink" title="2.2 allocate"></a>2.2 allocate</h2><p><code>#allocate(int normCapacity)</code> 方法，分配内存空间。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="function"><span class="keyword">long</span> <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line"><span class="number">2</span>:     <span class="comment">// 大于等于 Page 大小，分配 Page 内存块</span></span><br><span class="line"><span class="number">3</span>:     <span class="keyword">if</span> ((normCapacity &amp; subpageOverflowMask) != <span class="number">0</span>) { <span class="comment">// &gt;= pageSize</span></span><br><span class="line"><span class="number">4</span>:         <span class="keyword">return</span> allocateRun(normCapacity);</span><br><span class="line"><span class="number">5</span>:     <span class="comment">// 小于 Page 大小，分配 Subpage 内存块</span></span><br><span class="line"><span class="number">6</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">7</span>:         <span class="keyword">return</span> allocateSubpage(normCapacity);</span><br><span class="line"><span class="number">8</span>:     }</span><br><span class="line"><span class="number">9</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 4 行：当申请的 <code>normCapacity</code> 大于等于 Page 大小时，调用 <code>#allocateRun(int normCapacity)</code> 方法，分配 Page 内存块。详细解析，见 <a href="#">「2.2.1 allocateRun」</a> 中。</li>
<li>第 5 至 8 行：调用 <code>#allocateSubpage(int normCapacity)</code> 方法，分配 Subpage 内存块。详细解析，见 <a href="#">「2.2.1 allocateSubpage」</a> 中。</li>
</ul>
<h3 id="2-2-1-allocateRun"><a href="#2-2-1-allocateRun" class="headerlink" title="2.2.1 allocateRun"></a>2.2.1 allocateRun</h3><p><code>#allocateRun(int normCapacity)</code> 方法，分配 Page 内存块。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Allocate a run of pages (&gt;=1)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> normCapacity normalized capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> index in memoryMap</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateRun</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 获得层级</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">int</span> d = maxOrder - (log2(normCapacity) - pageShifts);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得节点</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 未获得到节点，直接返回</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (id &lt; <span class="number">0</span>) {</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">return</span> id;</span><br><span class="line"> <span class="number">9</span>:     }</span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 减少剩余可用字节数</span></span><br><span class="line"><span class="number">11</span>:     freeBytes -= runLength(id);</span><br><span class="line"><span class="number">12</span>:     <span class="keyword">return</span> id;</span><br><span class="line"><span class="number">13</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：获得层级。</li>
<li>第 5 行：调用 <code>#allocateNode(int normCapacity)</code> 方法，分配节点。详细解析，见 <a href="#">「2.2.3 allocateNode」</a> 中。<ul>
<li>第 7 至 9 行：未获得到节点，直接返回。</li>
</ul>
</li>
<li><p>第 11 行：调用 <code>#runLength(int id)</code> 方法，计算使用节点的字节数，并减少剩余可用字节数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runLength</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="comment">// represents the size in #bytes supported by node 'id' in the tree</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; log2ChunkSize - depth(id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">depth</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> depthMap[id];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="2-2-2-allocateSubpage"><a href="#2-2-2-allocateSubpage" class="headerlink" title="2.2.2 allocateSubpage"></a>2.2.2 allocateSubpage</h3><blockquote>
<p>老艿艿：本小节，胖友先看完 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-3-Jemalloc-subpage">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（三）PoolSubpage》</a> 。</p>
</blockquote>
<p><code>#allocateSubpage(int normCapacity)</code> 方法，分配 Subpage 内存块。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create/ initialize a new PoolSubpage of normCapacity</span></span><br><span class="line"><span class="comment">    * Any PoolSubpage created/ initialized here is added to subpage pool in the PoolArena that owns this PoolChunk</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> normCapacity normalized capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> index in memoryMap</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 获得对应内存规格的 Subpage 双向链表的 head 节点</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line"> <span class="number">5</span>:     PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 加锁，分配过程会修改双向链表的结构，会存在多线程的情况。</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">synchronized</span> (head) {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 获得最底层的一个节点。Subpage 只能使用二叉树的最底层的节点。</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">int</span> d = maxOrder; <span class="comment">// subpages are only be allocated from pages i.e., leaves</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 获取失败，直接返回</span></span><br><span class="line"><span class="number">12</span>:         <span class="keyword">if</span> (id &lt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">13</span>:             <span class="keyword">return</span> id;</span><br><span class="line"><span class="number">14</span>:         }</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:         <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line"><span class="number">17</span>:         <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line"><span class="number">18</span>: </span><br><span class="line"><span class="number">19</span>:         <span class="comment">// 减少剩余可用字节数</span></span><br><span class="line"><span class="number">20</span>:         freeBytes -= pageSize;</span><br><span class="line"><span class="number">21</span>: </span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 获得节点对应的 subpages 数组的编号</span></span><br><span class="line"><span class="number">23</span>:         <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line"><span class="number">24</span>:         <span class="comment">// 获得节点对应的 subpages 数组的 PoolSubpage 对象</span></span><br><span class="line"><span class="number">25</span>:         PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line"><span class="number">26</span>:         <span class="comment">// 初始化 PoolSubpage 对象</span></span><br><span class="line"><span class="number">27</span>:         <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) { <span class="comment">// 不存在，则进行创建 PoolSubpage 对象</span></span><br><span class="line"><span class="number">28</span>:             subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line"><span class="number">29</span>:             subpages[subpageIdx] = subpage;</span><br><span class="line"><span class="number">30</span>:         } <span class="keyword">else</span> { <span class="comment">// 存在，则重新初始化 PoolSubpage 对象</span></span><br><span class="line"><span class="number">31</span>:             subpage.init(head, normCapacity);</span><br><span class="line"><span class="number">32</span>:         }</span><br><span class="line"><span class="number">33</span>:         <span class="comment">// 分配 PoolSubpage 内存块</span></span><br><span class="line"><span class="number">34</span>:         <span class="keyword">return</span> subpage.allocate();</span><br><span class="line"><span class="number">35</span>:     }</span><br><span class="line"><span class="number">36</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 行：调用 <code>PoolArena#findSubpagePoolHead(int normCapacity)</code> 方法，获得对应内存规格的 Subpage 双向链表的 <code>head</code> 节点。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena》</a> 。</li>
<li>第 7 行：<code>synchronized</code> 加锁，分配过程会修改双向链表的结构，会存在<strong>多线程</strong>的情况。</li>
<li>第 8 至 10 行：调用 <code>#allocateNode(int d)</code> 方法，获得最底层的一个节点。<strong>Subpage 只能使用二叉树的最底层的节点</strong>。<ul>
<li>第 11 至 14 行：获取失败，直接返回。</li>
<li>第 20 行：减少剩余可用字节数。</li>
</ul>
</li>
<li><p>第 23 至 34 行：分配 PoolSubpage 内存块。</p>
<ul>
<li><p>第 23 行：调用 <code>#subpageIdx(int id)</code> 方法，获得节点对应的 <code>subpages</code> 数组的编号。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subpageIdx</span><span class="params">(<span class="keyword">int</span> memoryMapIdx)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> memoryMapIdx ^ maxSubpageAllocs; <span class="comment">// remove highest set bit, to get offset</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>去掉最高位( bit )。例如节点 2048 计算后的结果为 0 。</li>
</ul>
</li>
<li>第 25 行：获得节点对应的 <code>subpages</code> 数组的 PoolSubpage 对象。</li>
<li>第 26 至 32 行：初始化 PoolSubpage 对象。</li>
<li>第 34 行：调用 <code>PoolSubpage#allocate()</code> 方法，分配 PoolSubpage 内存块。</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-allocateNode"><a href="#2-2-3-allocateNode" class="headerlink" title="2.2.3 allocateNode"></a>2.2.3 allocateNode</h3><p><code>#allocateNode(int normCapacity)</code> 方法，分配节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Algorithm to allocate an index in memoryMap when we query for a free node</span></span><br><span class="line"><span class="comment">    * at depth d</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> d depth</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> index in memoryMap</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">allocateNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">int</span> initial = - (<span class="number">1</span> &lt;&lt; d); <span class="comment">// has last d bits = 0 and rest all = 1</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得根节点的指值。</span></span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 如果根节点的值，大于 d ，说明，第 d 层没有符合的节点，也就是说 [0, d-1] 层也没有符合的节点。即，当前 Chunk 没有符合的节点。</span></span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">byte</span> val = value(id);</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (val &gt; d) { <span class="comment">// unusable</span></span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="number">9</span>:     }</span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 获得第 d 层，匹配的节点。</span></span><br><span class="line"><span class="number">11</span>:     <span class="comment">// id &amp; initial 来保证，高度小于 d 会继续循环</span></span><br><span class="line"><span class="number">12</span>:     <span class="keyword">while</span> (val &lt; d || (id &amp; initial) == <span class="number">0</span>) { <span class="comment">// id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</span></span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 进入下一层</span></span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 获得左节点的编号</span></span><br><span class="line"><span class="number">15</span>:         id &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="number">16</span>:         <span class="comment">// 获得左节点的值</span></span><br><span class="line"><span class="number">17</span>:         val = value(id);</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 如果值大于 d ，说明，以左节点作为根节点形成虚拟的虚拟满二叉树，没有符合的节点。</span></span><br><span class="line"><span class="number">19</span>:         <span class="keyword">if</span> (val &gt; d) {</span><br><span class="line"><span class="number">20</span>:             <span class="comment">// 获得右节点的编号</span></span><br><span class="line"><span class="number">21</span>:             id ^= <span class="number">1</span>;</span><br><span class="line"><span class="number">22</span>:             <span class="comment">// 获得右节点的值</span></span><br><span class="line"><span class="number">23</span>:             val = value(id);</span><br><span class="line"><span class="number">24</span>:         }</span><br><span class="line"><span class="number">25</span>:     }</span><br><span class="line"><span class="number">26</span>: </span><br><span class="line"><span class="number">27</span>:     <span class="comment">// 校验获得的节点值合理</span></span><br><span class="line"><span class="number">28</span>:     <span class="keyword">byte</span> value = value(id);</span><br><span class="line"><span class="number">29</span>:     <span class="keyword">assert</span> value == d &amp;&amp; (id &amp; initial) == <span class="number">1</span> &lt;&lt; d : String.format(<span class="string">"val = %d, id &amp; initial = %d, d = %d"</span>,</span><br><span class="line"><span class="number">30</span>:             value, id &amp; initial, d);</span><br><span class="line"><span class="number">31</span>: </span><br><span class="line"><span class="number">32</span>:     <span class="comment">// 更新获得的节点不可用</span></span><br><span class="line"><span class="number">33</span>:     setValue(id, unusable); <span class="comment">// mark as unusable</span></span><br><span class="line"><span class="number">34</span>:     <span class="comment">// 更新获得的节点的祖先都不可用</span></span><br><span class="line"><span class="number">35</span>:     updateParentsAlloc(id);</span><br><span class="line"><span class="number">36</span>: </span><br><span class="line"><span class="number">37</span>:     <span class="comment">// 返回节点编号</span></span><br><span class="line"><span class="number">38</span>:     <span class="keyword">return</span> id;</span><br><span class="line"><span class="number">39</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：通过 <code>- (1 &lt;&lt; d)</code> 计算，获得 <code>initial</code> 。用于【第 12 行】的代码，<code>id &amp; initial</code> ，来保证，高度小于 <code>d</code> 会继续<strong>循环</strong>。</li>
<li><p>第 6 行：获得根节点( <code>id = 1</code> )的指值。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> memoryMap[id];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 7 至 9 行：如果根节点的值，大于 <code>d</code> ，说明，第 <code>d</code> 层没有符合的节点，也就是说 <code>[1, d-1]</code> 层也没有符合的节点。即，当前 Chunk 没有符合的节点。</li>
</ul>
</li>
<li>第 10 至 25 行：获得第 <code>d</code> 层，匹配的节点。因为 <code>val &lt; d</code> 难以保证是第 <code>d</code> 层，<code>[0, d-1]</code> 层也可以满足 <code>val &lt; d</code> ，所以才有 <code>id &amp; initial</code> 来保证，高度小于 <code>d</code> 会继续循环。<ul>
<li>← 第 15 行：<code>&lt;&lt; 1</code> 操作，进入下一层。获得<strong>左节点</strong>的编号。</li>
<li>← 第 17 行：获得左节点的值。</li>
<li>→ 第 19 行：如果值大于 <code>d</code> ，说明，以左节点作为根节点形成虚拟的虚拟满二叉树，没有符合的节点。此时，需要跳到<strong>右节点</strong>。</li>
<li>→ 第 21 行：<code>^ 1</code> 操作，获得<strong>右节点</strong>的编号。</li>
<li>→ 第 23 行：获得右节点的值。</li>
<li>【第 17 行】或者【第 23 行】的代码，会通过【第 12 行】的代码，结束循环。也就说，获得第 <code>d</code> 层，匹配的节点。</li>
</ul>
</li>
<li><p>第 33 行：调用 <code>#setValue(int id, byte val)</code> 方法，设置获得的节点的值为 <code>unusable</code> ，表示不可用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">byte</span> val)</span> </span>{</span><br><span class="line">    memoryMap[id] = val;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 35 行：调用 <code>#updateParentsAlloc(int id)</code> 方法，更新获得的节点的祖先都不可用。详细解析，见 <a href="#">「2.4.1 updateParentsAlloc」</a> 。</p>
</li>
<li>第 38 行：返回节点编号。</li>
</ul>
<h2 id="2-3-free"><a href="#2-3-free" class="headerlink" title="2.3 free"></a>2.3 free</h2><blockquote>
<p>老艿艿：本小节，胖友先看完 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-3-Jemalloc-subpage">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（三）PoolSubpage》</a> 。</p>
</blockquote>
<p><code>#free(long handle)</code> 方法，释放指定位置的内存块。根据情况，内存块可能是 SubPage ，也可能是 Page ，也可能是释放 SubPage 并且释放对应的 Page 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Free a subpage or a run of pages</span></span><br><span class="line"><span class="comment">    * When a subpage is freed from PoolSubpage, it might be added back to subpage pool of the owning PoolArena</span></span><br><span class="line"><span class="comment">    * If the subpage pool in PoolArena has at least one other PoolSubpage of given elemSize, we can</span></span><br><span class="line"><span class="comment">    * completely free the owning Page so it is available for subsequent allocations</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handle handle to free</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 获得 memoryMap 数组的编号( 下标 )</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得 bitmap 数组的编号( 下标 )。注意，此时获得的还不是真正的 bitmapIdx 值，需要经过 `bitmapIdx &amp; 0x3FFFFFFF` 运算。</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 释放 Subpage begin ~</span></span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">if</span> (bitmapIdx != <span class="number">0</span>) { <span class="comment">// free a subpage bitmapIdx 非空，说明释放的是 Subpage</span></span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 获得 PoolSubpage 对象</span></span><br><span class="line"><span class="number">11</span>:         PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line"><span class="number">12</span>:         <span class="keyword">assert</span> subpage != <span class="keyword">null</span> &amp;&amp; subpage.doNotDestroy;</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 获得对应内存规格的 Subpage 双向链表的 head 节点</span></span><br><span class="line"><span class="number">15</span>:         <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line"><span class="number">16</span>:         <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line"><span class="number">17</span>:         PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 加锁，分配过程会修改双向链表的结构，会存在多线程的情况。</span></span><br><span class="line"><span class="number">19</span>:         <span class="keyword">synchronized</span> (head) {</span><br><span class="line"><span class="number">20</span>:             <span class="comment">// 释放 Subpage 。</span></span><br><span class="line"><span class="number">21</span>:             <span class="keyword">if</span> (subpage.free(head, bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>)) {</span><br><span class="line"><span class="number">22</span>:                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">23</span>:             }</span><br><span class="line"><span class="number">24</span>:             <span class="comment">// ↑↑↑ 返回 false ，说明 Page 中无切分正在使用的 Subpage 内存块，所以可以继续向下执行，释放 Page</span></span><br><span class="line"><span class="number">25</span>:         }</span><br><span class="line"><span class="number">26</span>:     }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:     <span class="comment">// 释放 Page begin ~</span></span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:     <span class="comment">// 增加剩余可用字节数</span></span><br><span class="line"><span class="number">31</span>:     freeBytes += runLength(memoryMapIdx);</span><br><span class="line"><span class="number">32</span>:     <span class="comment">// 设置 Page 对应的节点可用</span></span><br><span class="line"><span class="number">33</span>:     setValue(memoryMapIdx, depth(memoryMapIdx));</span><br><span class="line"><span class="number">34</span>:     <span class="comment">// 更新 Page 对应的节点的祖先可用</span></span><br><span class="line"><span class="number">35</span>:     updateParentsFree(memoryMapIdx);</span><br><span class="line"><span class="number">36</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 3 行：调用 <code>#memoryMapIdx(handle)</code> 方法，获得 <code>memoryMap</code> 数组的编号( 下标 )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memoryMapIdx</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) handle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 5 行：调用 <code>#bitmapIdx(handle)</code> 方法，获得 <code>bitmap</code> 数组的编号( 下标 )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitmapIdx</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (handle &gt;&gt;&gt; Integer.SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>注意，此时获得的还不是真正的 bitmapIdx 值，需要经过 <code>bitmapIdx &amp; 0x3FFFFFFF</code> 运算，即【第 21 行】的代码。</li>
</ul>
</li>
<li>第 9 至 26 行：释放 Subpage 内存块。<ul>
<li>第 9 行：通过 <code>bitmapIdx !=0</code> 判断，说明释放的是 Subpage 内存块。</li>
<li>第 11 行：获得 PoolSubpage 对象。</li>
<li>第 17 行：调用 <code>PoolArena#findSubpagePoolHead(int normCapacity)</code> 方法，获得对应内存规格的 Subpage 双向链表的 <code>head</code> 节点。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena》</a> 。</li>
<li>第 19 行：<code>synchronized</code> 加锁，分配过程会修改双向链表的结构，会存在多线程的情况。</li>
<li>第 21 行：调用 <code>SubPage#free(PoolSubpage&lt;T&gt; head, int bitmapIdx)</code> 方法，释放 Subpage 内存块。<ul>
<li>如果返回 <code>false</code> ，说明 Page 中<strong>无切分正在使用</strong>的 Subpage 内存块，所以可以继续向下执行，释放 Page 内存块。</li>
</ul>
</li>
</ul>
</li>
<li>第 30 至 35 行：释放 Page 内存块。<ul>
<li>第 31 行：增加剩余可用字节数。</li>
<li>第 33 行：调用 <code>#setValue(int id, byte val)</code> 方法，设置 Page 对应的节点<strong>可用</strong>。</li>
<li>第 35 行：调用 <code>#updateParentsAlloc(int id)</code> 方法，更新获得的节点的祖先<strong>可用</strong>。</li>
</ul>
</li>
</ul>
<h2 id="2-4-updateParents"><a href="#2-4-updateParents" class="headerlink" title="2.4 updateParents"></a>2.4 updateParents</h2><h3 id="2-4-1-updateParentsAlloc"><a href="#2-4-1-updateParentsAlloc" class="headerlink" title="2.4.1 updateParentsAlloc"></a>2.4.1 updateParentsAlloc</h3><p><code>#updateParentsAlloc(int id)</code> 方法，更新获得的节点的祖先都不可用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Update method used by allocate</span></span><br><span class="line"><span class="comment">    * This is triggered only when a successor is allocated and all its predecessors</span></span><br><span class="line"><span class="comment">    * need to update their state</span></span><br><span class="line"><span class="comment">    * The minimal depth at which subtree rooted at id has some free space</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsAlloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">while</span> (id &gt; <span class="number">1</span>) {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// 获得父节点的编号</span></span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 获得子节点的值</span></span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 获得另外一个子节点的</span></span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 获得子节点较小值，并设置到父节点</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line"><span class="number">11</span>:         setValue(parentId, val);</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 跳到父节点</span></span><br><span class="line"><span class="number">13</span>:         id = parentId;</span><br><span class="line"><span class="number">14</span>:     }</span><br><span class="line"><span class="number">15</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 注意，调用此方法时，节点 <code>id</code> 已经更新为<strong>不可用</strong>。</li>
<li>第 2 行：循环，直到<strong>根</strong>节点。</li>
<li>第 4 行：<code>&gt;&gt;&gt; 1</code> 操作，获得父节点的编号。</li>
<li>第 5 至 11 行：获得子节点较小值，并调用 <code>#setValue(int id, int value)</code> 方法，设置到父节点。</li>
<li>第 13 行：跳到父节点。</li>
</ul>
<h3 id="2-4-2-updateParentsFree"><a href="#2-4-2-updateParentsFree" class="headerlink" title="2.4.2 updateParentsFree"></a>2.4.2 updateParentsFree</h3><p><code>#updateParentsAlloc(int id)</code> 方法，更新获得的节点的祖先可用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Update method used by free</span></span><br><span class="line"><span class="comment">    * This needs to handle the special case when both children are completely free</span></span><br><span class="line"><span class="comment">    * in which case parent be directly allocated on request of size = child-size * 2</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsFree</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 获得当前节点的子节点的层级</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">int</span> logChild = depth(id) + <span class="number">1</span>;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">while</span> (id &gt; <span class="number">1</span>) {</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 获得父节点的编号</span></span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 获得子节点的值</span></span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 获得另外一个子节点的值</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 获得当前节点的层级</span></span><br><span class="line"><span class="number">12</span>:         logChild -= <span class="number">1</span>; <span class="comment">// in first iteration equals log, subsequently reduce 1 from logChild as we traverse up</span></span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 两个子节点都可用，则直接设置父节点的层级</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">if</span> (val1 == logChild &amp;&amp; val2 == logChild) {</span><br><span class="line"><span class="number">16</span>:             setValue(parentId, (<span class="keyword">byte</span>) (logChild - <span class="number">1</span>));</span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 两个子节点任一不可用，则取子节点较小值，并设置到父节点</span></span><br><span class="line"><span class="number">18</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">19</span>:             <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line"><span class="number">20</span>:             setValue(parentId, val);</span><br><span class="line"><span class="number">21</span>:         }</span><br><span class="line"><span class="number">22</span>: </span><br><span class="line"><span class="number">23</span>:         <span class="comment">// 跳到父节点</span></span><br><span class="line"><span class="number">24</span>:         id = parentId;</span><br><span class="line"><span class="number">25</span>:     }</span><br><span class="line"><span class="number">26</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 注意，调用此方法时，节点 <code>id</code> 已经更新为可用。</li>
<li>第 3 行：获得当前节点的子节点的层级。</li>
<li>第 4 行：循环，直到<strong>根</strong>节点。</li>
<li>第 6 行：<code>&gt;&gt;&gt; 1</code> 操作，获得<strong>父</strong>节点的编号。</li>
<li>第 7 至 10 行：获得两个<strong>子</strong>节点的值。</li>
<li>第 12 行：获得当前节点的层级。</li>
<li>第 14 至 16 行：两个子节点都可用，则调用 <code>#setValue(id, value)</code> 方法，直接设置父节点的层级( 注意，是 <code>logChild - 1</code> )。</li>
<li>第 17 至 21 行：两个子节点任一不可用，则<code>#setValue(id, value)</code> 方法，取子节点较小值，并设置到父节点。</li>
<li>第 24 行：跳到父节点。</li>
</ul>
<h2 id="2-5-initBuf"><a href="#2-5-initBuf" class="headerlink" title="2.5 initBuf"></a>2.5 initBuf</h2><p><code>#initBuf(PooledByteBuf&lt;T&gt; buf, long handle, int reqCapacity)</code> 方法，初始化分配的内存块到 PooledByteBuf 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 获得 memoryMap 数组的编号( 下标 )</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得 bitmap 数组的编号( 下标 )。注意，此时获得的还不是真正的 bitmapIdx 值，需要经过 `bitmapIdx &amp; 0x3FFFFFFF` 运算。</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 内存块为 Page</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (bitmapIdx == <span class="number">0</span>) {</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">byte</span> val = value(memoryMapIdx);</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">assert</span> val == unusable : String.valueOf(val);</span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 初始化 Page 内存块到 PooledByteBuf 中</span></span><br><span class="line"><span class="number">11</span>:         buf.init(<span class="keyword">this</span>, handle, runOffset(memoryMapIdx) + offset, reqCapacity, runLength(memoryMapIdx), arena.parent.threadCache());</span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 内存块为 SubPage</span></span><br><span class="line"><span class="number">13</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 初始化 SubPage 内存块到 PooledByteBuf 中</span></span><br><span class="line"><span class="number">15</span>:         initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);</span><br><span class="line"><span class="number">16</span>:     }</span><br><span class="line"><span class="number">17</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：调用 <code>#memoryMapIdx(handle)</code> 方法，获得 <code>memoryMap</code> 数组的编号( 下标 )。</li>
<li>第 5 行：调用 <code>#bitmapIdx(handle)</code> 方法，获得 <code>bitmap</code> 数组的编号( 下标 )。</li>
<li><p>第 6 至 11 行：通过 <code>bitmapIdx == 0</code> 判断出，内存块是 Page 。所以，调用 <code>PooledByteBuf#init(PoolChunk&lt;T&gt; chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache)</code> 方法，初始化 Page 内存块到 PooledByteBuf 中。其中，<code>runOffset(memoryMapIdx) + offset</code> 代码块，计算 Page 内存块在 <code>memory</code> 中的开始位置。<code>runOffset(int id)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runOffset</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="comment">// represents the 0-based offset in #bytes from start of the byte-array chunk</span></span><br><span class="line">    <span class="keyword">int</span> shift = id ^ <span class="number">1</span> &lt;&lt; depth(id);</span><br><span class="line">    <span class="keyword">return</span> shift * runLength(id);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runLength</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">    <span class="comment">// represents the size in #bytes supported by node 'id' in the tree</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; log2ChunkSize - depth(id);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第12 至 16 行：通过 <code>bitmapIdx != 0</code> 判断出，内存块是 SubPage 。所以，调用 <code>#initBufWithSubpage(PooledByteBuf&lt;T&gt; buf, long handle, int reqCapacity)</code> 方法，初始化 SubPage 内存块到 PooledByteBuf 中。详细解析，见 <a href="#">「2.5.1 initBufWithSubpage」</a> 。</p>
</li>
</ul>
<h3 id="2-5-1-initBufWithSubpage"><a href="#2-5-1-initBufWithSubpage" class="headerlink" title="2.5.1 initBufWithSubpage"></a>2.5.1 initBufWithSubpage</h3><p><code>#initBufWithSubpage(PooledByteBuf&lt;T&gt; buf, long handle, int reqCapacity)</code> 方法，初始化 SubPage 内存块到 PooledByteBuf 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line">       initBufWithSubpage(buf, handle, bitmapIdx(handle), reqCapacity);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> bitmapIdx, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">assert</span> bitmapIdx != <span class="number">0</span>;</span><br><span class="line"> <span class="number">3</span>: </span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得 memoryMap 数组的编号( 下标 )</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 获得 SubPage 对象</span></span><br><span class="line"> <span class="number">7</span>:     PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">assert</span> subpage.doNotDestroy;</span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">assert</span> reqCapacity &lt;= subpage.elemSize;</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 初始化 SubPage 内存块到 PooledByteBuf 中</span></span><br><span class="line"><span class="number">12</span>:     buf.init(</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">this</span>, handle,</span><br><span class="line"><span class="number">14</span>:         runOffset(memoryMapIdx) + (bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>) * subpage.elemSize + offset,</span><br><span class="line"><span class="number">15</span>:             reqCapacity, subpage.elemSize, arena.parent.threadCache());</span><br><span class="line"><span class="number">16</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 7 行：获得 SubPage 对象。</li>
<li>第 11 至于 15 行：调用 <code>PooledByteBuf#init(PoolChunk&lt;T&gt; chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache)</code> 方法，初始化 SubPage 内存块到 PooledByteBuf 中。其中，<code>runOffset(memoryMapIdx) + (bitmapIdx &amp; 0x3FFFFFFF) * subpage.elemSize + offset</code> 代码块，计算 SubPage 内存块在 <code>memory</code> 中的开始位置。</li>
</ul>
<h2 id="2-6-destroy"><a href="#2-6-destroy" class="headerlink" title="2.6 destroy"></a>2.6 destroy</h2><p><code>#destroy()</code> 方法，从 Arena 中销毁当前 Chunk 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">    arena.destroyChunk(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena》</a> 。</li>
</ul>
<h2 id="2-7-PoolChunkMetric"><a href="#2-7-PoolChunkMetric" class="headerlink" title="2.7 PoolChunkMetric"></a>2.7 PoolChunkMetric</h2><p><code>io.netty.buffer.PoolChunkMetric</code> ，PoolChunk Metric 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PoolChunkMetric</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the percentage of the current usage of the chunk.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">usage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the size of the chunk in bytes, this is the maximum of bytes that can be served out of the chunk.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chunkSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of free bytes in the chunk.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">freeBytes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>PoolChunk 对 PoolChunkMetric 接口的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">usage</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> freeBytes;</span><br><span class="line">    <span class="keyword">synchronized</span> (arena) {</span><br><span class="line">        freeBytes = <span class="keyword">this</span>.freeBytes;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> usage(freeBytes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">usage</span><span class="params">(<span class="keyword">int</span> freeBytes)</span> </span>{</span><br><span class="line">    <span class="comment">// 全部使用，100%</span></span><br><span class="line">    <span class="keyword">if</span> (freeBytes == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分使用，最高 99%</span></span><br><span class="line">    <span class="keyword">int</span> freePercentage = (<span class="keyword">int</span>) (freeBytes * <span class="number">100L</span> / chunkSize);</span><br><span class="line">    <span class="keyword">if</span> (freePercentage == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> - freePercentage;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chunkSize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> chunkSize;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">freeBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (arena) {</span><br><span class="line">        <span class="keyword">return</span> freeBytes;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>synchronized</code> 的原因是，保证 <code>freeBytes</code> 对其它线程的可见性。对应 Github 提交为 <a href="https://github.com/netty/netty/commit/a7fe6c01539d3ad92d7cd94a25daff9e10851088" rel="external nofollow noopener noreferrer" target="_blank">a7fe6c01539d3ad92d7cd94a25daff9e10851088</a> 。</p>
<blockquote>
<p><strong>Motivation</strong>:</p>
<p>As we may access the metrics exposed of PooledByteBufAllocator from another thread then the allocations happen we need to ensure we synchronize on the PoolArena to ensure correct visibility.</p>
<p><strong>Modifications</strong>:</p>
<p>Synchronize on the PoolArena to ensure correct visibility.</p>
<p><strong>Result</strong>:</p>
<p>Fix multi-thread issues on the metrics</p>
</blockquote>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>老艿艿有点二，在 <code>#allocateNode(int normCapacity)</code> 方法卡了很久。因为没看到 <code>memoryMap</code> 和 <code>depthMap</code> 数组，下标是从 1 开始的！！！我恨那。</p>
<p>参考如下文章：</p>
<ul>
<li>占小狼 <a href="https://www.jianshu.com/p/c4bd37a3555b" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出Netty内存管理 PoolChunk》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/70181af2972a" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–PoolChunk》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk/" data-id="ck4pl3fp700e7fgcfqrbzod6p" class="article-share-link">分享</a>

</footer>
-->
</div>
