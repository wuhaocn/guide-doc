<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— ChannelPipeline（一）之初始化
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/intro-2/?self">《精尽 Netty 源码分析 —— Netty 简介（二）之核心组件》</a> 中，对 EventLoopGroup 和 EventLoop 做了定义，我们再来回顾下：</p>
<blockquote>
<p>ChannelPipeline 为 ChannelHandler 的<strong>链</strong>，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline ，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。</p>
</blockquote>
<p>因为 ChannelPipeline 涉及的代码量较大，所以笔者会分成好几篇文章分别分享。而本文，我们来分享 ChannelPipeline 的<strong>初始化</strong>。也因此，本文更多是体现 ChannelPipeline 的<strong>整体性</strong>，所以不会过多介绍每个类的具体的<strong>每个方法</strong>的实现。</p>
<h1 id="2-ChannelPipeline"><a href="#2-ChannelPipeline" class="headerlink" title="2. ChannelPipeline"></a>2. ChannelPipeline</h1><p><code>io.netty.channel.ChannelPipeline</code> ，继承 ChannelInboundInvoker、ChannelOutboundInvoker、Iterable 接口，Channel Pipeline 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelPipeline</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ChannelInboundInvoker</span>, <span class="title">ChannelOutboundInvoker</span>, <span class="title">Iterable</span>&lt;<span class="title">Entry</span>&lt;<span class="title">String</span>, <span class="title">ChannelHandler</span>&gt;&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 添加 ChannelHandler 相关 ==========</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addBefore</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addBefore</span><span class="params">(EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addAfter</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addAfter</span><span class="params">(EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(ChannelHandler... handlers)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, ChannelHandler... handlers)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, ChannelHandler... handlers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 移除 ChannelHandler 相关 ==========</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">remove</span><span class="params">(String name)</span></span>;</span><br><span class="line">    &lt;T extends ChannelHandler&gt; <span class="function">T <span class="title">remove</span><span class="params">(Class&lt;T&gt; handlerType)</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 替换 ChannelHandler 相关 ==========</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">replace</span><span class="params">(ChannelHandler oldHandler, String newName, ChannelHandler newHandler)</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">replace</span><span class="params">(String oldName, String newName, ChannelHandler newHandler)</span></span>;</span><br><span class="line">    &lt;T extends ChannelHandler&gt; <span class="function">T <span class="title">replace</span><span class="params">(Class&lt;T&gt; oldHandlerType, String newName, ChannelHandler newHandler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 查询 ChannelHandler 相关 ==========</span></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">firstContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">lastContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">get</span><span class="params">(String name)</span></span>;</span><br><span class="line">    &lt;T extends ChannelHandler&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; handlerType)</span></span>;</span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">context</span><span class="params">(ChannelHandler handler)</span></span>;</span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">context</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">ChannelHandlerContext <span class="title">context</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span></span>;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">names</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== Channel 相关 ==========</span></span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== ChannelInboundInvoker 相关 ==========    </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelUnregistered</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelInactive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireUserEventTriggered</span><span class="params">(Object event)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelReadComplete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== ChannelOutboundInvoker 相关 ==========    </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>虽然接口的方法比较多，笔者做了归类如下：</p>
<ul>
<li>ChannelHandler 的增删改查的相关方法。</li>
<li>Channel 的相关方法，目前只有一个。</li>
<li>继承自 ChannelInboundInvoker 的相关方法。</li>
<li>继承自 ChannelOutboundInvoker 的相关方法。</li>
</ul>
<p>有可能会疑惑为什么继承 Iterable 接口？因为 ChannelPipeline 是 ChannelHandler 的<strong>链</strong>。</p>
<p>ChannelPipeline 的类图如下：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_01/01.png" title="ChannelPipeline 类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_01/01.png" alt="ChannelPipeline 类图"></a><span class="caption">ChannelPipeline 类图</span></p>
<h2 id="2-1-ChannelInboundInvoker"><a href="#2-1-ChannelInboundInvoker" class="headerlink" title="2.1 ChannelInboundInvoker"></a>2.1 ChannelInboundInvoker</h2><p><code>io.netty.channel.ChannelInboundInvoker</code> ，Channel Inbound Invoker( 调用者 ) 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelUnregistered</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelInactive</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireUserEventTriggered</span><span class="params">(Object event)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelReadComplete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通知 Channel 事件的接口方法。</li>
</ul>
<h2 id="2-2-ChannelOutboundInvoker"><a href="#2-2-ChannelOutboundInvoker" class="headerlink" title="2.2 ChannelOutboundInvoker"></a>2.2 ChannelOutboundInvoker</h2><p><code>io.netty.channel.ChannelOutboundInvoker</code> ，Channel Outbound Invoker( 调用者 ) 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ========== Channel 操作相关 ==========    </span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">deregister</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">deregister</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== Promise 相关 ==========    </span></span><br><span class="line"><span class="function">ChannelPromise <span class="title">newPromise</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelProgressivePromise <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">newSucceededFuture</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">newFailedFuture</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"><span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>发起 Channel 操作的接口方法。</li>
<li>创建 Promise 对象的接口方法。</li>
</ul>
<h2 id="2-3-Outbound-v-s-Inbound-事件"><a href="#2-3-Outbound-v-s-Inbound-事件" class="headerlink" title="2.3 Outbound v.s Inbound 事件"></a>2.3 Outbound v.s Inbound 事件</h2><p>在 <a href="https://segmentfault.com/a/1190000007309311" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 二 贯穿Netty 的大动脉 ── ChannelPipeline (二)》</a> 中，笔者看到一个比较不错的总结：</p>
<blockquote>
<p>老艿艿：因为要加一些注释，所以暂时不使用引用。</p>
</blockquote>
<p><strong>对于 Outbound 事件</strong>：</p>
<ul>
<li>Outbound 事件是【请求】事件(由 Connect 发起一个请求, 并最终由 Unsafe 处理这个请求)</li>
<li>Outbound 事件的发起者是 Channel</li>
<li>Outbound 事件的处理者是 Unsafe</li>
<li><p>Outbound 事件在 Pipeline 中的传输方向是 <code>tail</code> -&gt; <code>head</code> </p>
<blockquote>
<p>旁白：Outbound 翻译为“出站”，所以从 <code>tail</code>( 尾 )到 <code>head</code>( 头 )也合理。</p>
<p>至于什么是 <code>head</code> 和 <code>tail</code> ，等看了具体的 ChannelPipeline 实现类 DefaultChannelPipeline 再说。</p>
</blockquote>
</li>
<li><p>在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Handler, 则需要调用 <code>ctx.xxx</code> (例如 <code>ctx.connect</code> ) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</p>
</li>
<li>Outbound 事件流: <code>Context.OUT_EVT</code> -&gt; <code>Connect.findContextOutbound</code> -&gt; <code>nextContext.invokeOUT_EVT</code> -&gt; <code>nextHandler.OUT_EVT</code> -&gt; <code>nextContext.OUT_EVT</code></li>
</ul>
<p><strong>对于 Inbound 事件</strong>：</p>
<ul>
<li>Inbound 事件是【通知】事件, 当某件事情已经就绪后, 通知上层.</li>
<li>Inbound 事件发起者是 Unsafe</li>
<li>Inbound 事件的处理者是 TailContext, 如果用户没有实现自定义的处理方法, 那么Inbound 事件默认的处理者是 TailContext, 并且其处理方法是空实现.</li>
<li><p>Inbound 事件在 Pipeline 中传输方向是 <code>head</code>( 头 ) -&gt; <code>tail</code>( 尾 )</p>
<blockquote>
<p>旁白：Inbound 翻译为“入站”，所以从 <code>head</code>( 头 )到 <code>tail</code>( 尾 )也合理。</p>
</blockquote>
</li>
<li><p>在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Handler, 则需要调用 <code>ctx.fireIN_EVT</code> (例如 <code>ctx.fireChannelActive</code> ) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</p>
</li>
<li>Inbound 事件流: <code>Context.fireIN_EVT</code> -&gt; <code>Connect.findContextInbound</code> -&gt; <code>nextContext.invokeIN_EVT</code> -&gt; <code>nextHandler.IN_EVT</code> -&gt; <code>nextContext.fireIN_EVT</code></li>
</ul>
<p>Outbound 和 Inbound 事件十分的镜像, 并且 Context 与 Handler 直接的调用关系是否容易混淆, 因此读者在阅读这里的源码时, 需要特别的注意。</p>
<h1 id="3-DefaultChannelPipeline"><a href="#3-DefaultChannelPipeline" class="headerlink" title="3. DefaultChannelPipeline"></a>3. DefaultChannelPipeline</h1><p><code>io.netty.channel.DefaultChannelPipeline</code> ，实现 ChannelPipeline 接口，默认 ChannelPipeline 实现类。😈 实际上，也只有这个实现类。</p>
<h2 id="3-1-静态属性"><a href="#3-1-静态属性" class="headerlink" title="3.1 静态属性"></a>3.1 静态属性</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #head} 的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEAD_NAME = generateName0(HeadContext.class);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #tail} 的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAIL_NAME = generateName0(TailContext.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 名字({<span class="doctag">@link</span> AbstractChannelHandlerContext#name})缓存 ，基于 ThreadLocal ，用于生成在线程中唯一的名字。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt; nameCaches = <span class="keyword">new</span> FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt;() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Class&lt;?&gt;, String&gt; initialValue() <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #estimatorHandle} 的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;DefaultChannelPipeline, MessageSizeEstimator.Handle&gt; ESTIMATOR =</span><br><span class="line">        AtomicReferenceFieldUpdater.newUpdater(</span><br><span class="line">                DefaultChannelPipeline.class, MessageSizeEstimator.Handle.class, <span class="string">"estimatorHandle"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>HEAD_NAME</code> 和 <code>TAIL_NAME</code> 静态属性，通过调用 <code>#generateName0(Class&lt;?&gt; handlerType)</code> 方法，生成对应的名字。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateName0</span><span class="params">(Class&lt;?&gt; handlerType)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> StringUtil.simpleClassName(handlerType) + <span class="string">"#0"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>即 <code>HEAD_NAME = "HeadContext#0"</code>，<code>TAIL_NAME= "TailContext#0"</code> 。</li>
</ul>
</li>
<li><code>nameCaches</code> 静态属性，名字( <code>AbstractChannelHandlerContext.name</code> )缓存 ，基于 ThreadLocal ，用于生成<strong>在线程中唯一的名字</strong>。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler">《精尽 Netty 源码解析 —— Pipeline（二）之添加 ChannelHandler》</a> 。</li>
<li><code>ESTIMATOR</code> 静态属性，<code>estimatorHandle</code> 属性的<strong>原子</strong>更新器。</li>
</ul>
<h2 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 Channel 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功的 Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelFuture succeededFuture;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不进行通知的 Promise 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于一些方法执行，需要传入 Promise 类型的方法参数，但是不需要进行通知，就传入该值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> io.netty.channel.AbstractChannel.AbstractUnsafe#safeSetSuccess(ChannelPromise) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> VoidChannelPromise voidPromise;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1008 DefaultChannelPipeline 字段用途</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> touch = ResourceLeakDetector.isEnabled();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子执行器集合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认情况下，ChannelHandler 使用 Channel 所在的 EventLoop 作为执行器。</span></span><br><span class="line"><span class="comment"> * 但是如果有需要，也可以自定义执行器。详细解析，见 {<span class="doctag">@link</span> #childExecutor(EventExecutorGroup)} 。</span></span><br><span class="line"><span class="comment"> * 实际情况下，基本不会用到。和基友【闪电侠】沟通过。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1008 DefaultChannelPipeline 字段用途</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> MessageSizeEstimator.Handle estimatorHandle;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否首次注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> firstRegistration = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the head of a linked list that is processed by {<span class="doctag">@link</span> #callHandlerAddedForAllHandlers()} and so process</span></span><br><span class="line"><span class="comment"> * all the pending {<span class="doctag">@link</span> #callHandlerAdded0(AbstractChannelHandlerContext)}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We only keep the head because it is expected that the list is used infrequently and its size is small.</span></span><br><span class="line"><span class="comment"> * Thus full iterations to do insertions is assumed to be a good compromised to saving memory and tail management</span></span><br><span class="line"><span class="comment"> * complexity.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 准备添加 ChannelHandler 的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set to {<span class="doctag">@code</span> true} once the {<span class="doctag">@link</span> AbstractChannel} is registered.Once set to {<span class="doctag">@code</span> true} the value will never</span></span><br><span class="line"><span class="comment"> * change.</span></span><br><span class="line"><span class="comment"> * Channel 是否已注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> registered;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    <span class="comment">// succeededFuture 的创建</span></span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// voidPromise 的创建</span></span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Tail 及诶点</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    <span class="comment">// 创建 Head 节点</span></span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>); <span class="comment">// &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相互指向 &lt;3&gt;</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>head</code> 属性，Head 节点，在构造方法的 <code>&lt;1&gt;</code> 处初始化。详细解析，见 <a href="#">「4.2 HeadContext」</a> 。</li>
<li><code>tail</code> 节点，Tail 节点，在构造方法的 <code>&lt;2&gt;</code> 处初始化。详细解析，见 <a href="#">「4.3 TailContext」</a> 。</li>
<li><p>在构造方法的 <code>&lt;3&gt;</code> 处，<code>head</code> 节点向<strong>下</strong>指向 <code>tail</code> 节点，<code>tail</code> 节点向<strong>上</strong>指向 <code>head</code> 节点，从而形成<strong>相互</strong>的指向。即如下图所示：</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 pipeline(一)》</a></p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_01/02.png" title="pipeline 节点链(默认)" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_01/02.png" alt="pipeline 节点链(默认)"></a><span class="caption">pipeline 节点链(默认)</span></p>
</blockquote>
<ul>
<li>pipeline 中的节点的数据结构是 ChannelHandlerContext 类。每个 ChannelHandlerContext 包含<strong>一个</strong> ChannelHandler、它的<strong>上下</strong>节点( <strong>从而形成 ChannelHandler 链</strong> )、以及其他上下文。详细解析，见 <a href="#">「4. ChannelHandlerContext」</a> 。</li>
<li><p>默认情况下，pipeline 有 <code>head</code> 和 <code>tail</code> 节点，形成默认的 ChannelHandler 链。而我们可以在它们之间，加入自定义的 ChannelHandler 节点。如下图所示：</p>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 pipeline(一)》</a></p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_01/03.png" title="pipeline 节点链(自定义)" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_01/03.png" alt="pipeline 节点链(自定义)"></a><span class="caption">pipeline 节点链(自定义)</span></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>childExecutors</code> 属性，子执行器集合。默认情况下，ChannelHandler 使用 Channel 所在的 EventLoop 作为执行器。</p>
<ul>
<li>但是如果有需要，也可以自定义执行器。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler">《精尽 Netty 源码解析 —— Pipeline（二）之添加 ChannelHandler》</a> 。</li>
<li>实际情况下，基本不会用到。和基友【闪电侠】沟通过。</li>
</ul>
</li>
<li><code>pendingHandlerCallbackHead</code> 属性，准备添加 ChannelHandler 的回调。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler">《精尽 Netty 源码解析 —— Pipeline（二）之添加 ChannelHandler》</a> 。</li>
<li><code>registered</code> 属性，Channel 是否已注册。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler">《精尽 Netty 源码解析 —— Pipeline（二）之添加 ChannelHandler》</a> 。</li>
<li><code>firstRegistration</code> 属性，是否首次注册。详细解析，见 <a href="http://svip.iocoder.cn/Netty/Pipeline-2-add-channel-handler">《精尽 Netty 源码解析 —— Pipeline（二）之添加 ChannelHandler》</a> 。</li>
</ul>
<h2 id="3-3-其他方法"><a href="#3-3-其他方法" class="headerlink" title="3.3 其他方法"></a>3.3 其他方法</h2><p>DefaultChannelPipeline 中的其他方法，详细解析，见后续的文章。</p>
<h1 id="4-ChannelHandlerContext"><a href="#4-ChannelHandlerContext" class="headerlink" title="4. ChannelHandlerContext"></a>4. ChannelHandlerContext</h1><p><code>io.netty.channel.ChannelHandlerContext</code> ，继承 ChannelInboundInvoker、ChannelOutboundInvoker、AttributeMap 接口，ChannelHandler Context( 上下文 )接口，作为 ChannelPipeline 中的<strong>节点</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ========== Context 相关 ==========</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">EventExecutor <span class="title">executor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelHandler <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRemoved</span><span class="params">()</span></span>; <span class="comment">// 是否已经移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== ByteBuf 相关 ==========    </span></span><br><span class="line"><span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== ChannelInboundInvoker 相关 ==========    </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelRegistered</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelUnregistered</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelActive</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelInactive</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireUserEventTriggered</span><span class="params">(Object evt)</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelReadComplete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== ChannelOutboundInvoker 相关 ==========</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ChannelHandlerContext <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== AttributeMap 相关 ==========</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;T&gt; <span class="function">Attribute&lt;T&gt; <span class="title">attr</span><span class="params">(AttributeKey&lt;T&gt; key)</span></span>;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; key)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>虽然接口的方法比较多，笔者做了归类如下：</p>
<ul>
<li>Context 相关的接口方法。</li>
<li>继承自 ChannelInboundInvoker 的相关方法，<em>和 ChannelPipeline 一样</em>。</li>
<li>继承自 ChannelOutboundInvoker 的相关方法，<em>和 ChannelPipeline 一样</em>。</li>
<li>继承自 AttributeMap 的相关方法，实际上已经废弃( <code>@Deprecated</code> )了，不再从 ChannelHandlerContext 中获取，而是从 Channel 中获取。</li>
</ul>
<p>ChannelHandlerContext 的类图如下：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_06_01/04.png" title="ChannelHandlerContext 类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_01/04.png" alt="ChannelHandlerContext 类图"></a><span class="caption">ChannelHandlerContext 类图</span></p>
<ul>
<li>😈 类图中的 AttributeMap 和 DefaultAttributeMap 可以无视。</li>
</ul>
<h2 id="4-1-AbstractChannelHandlerContext"><a href="#4-1-AbstractChannelHandlerContext" class="headerlink" title="4.1 AbstractChannelHandlerContext"></a>4.1 AbstractChannelHandlerContext</h2><p><code>io.netty.channel.AbstractChannelHandlerContext</code> ，实现 ChannelHandlerContext、ResourceLeakHint 接口，继承 DefaultAttributeMap 类，ChannelHandlerContext 抽象基类。</p>
<h3 id="4-1-1-静态属性"><a href="#4-1-1-静态属性" class="headerlink" title="4.1.1 静态属性"></a>4.1.1 静态属性</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Neither {<span class="doctag">@link</span> ChannelHandler#handlerAdded(ChannelHandlerContext)}</span></span><br><span class="line"><span class="comment"> * nor {<span class="doctag">@link</span> ChannelHandler#handlerRemoved(ChannelHandlerContext)} was called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ChannelHandler#handlerAdded(ChannelHandlerContext)} is about to be called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD_PENDING = <span class="number">1</span>; <span class="comment">// 添加准备中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ChannelHandler#handlerAdded(ChannelHandlerContext)} was called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD_COMPLETE = <span class="number">2</span>; <span class="comment">// 已添加</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ChannelHandler#handlerRemoved(ChannelHandlerContext)} was called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVE_COMPLETE = <span class="number">3</span>; <span class="comment">// 已移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #handlerState} 的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractChannelHandlerContext&gt; HANDLER_STATE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(AbstractChannelHandlerContext.class, <span class="string">"handlerState"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 非静态属性 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> handlerState = INIT;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>handlerState</code> 属性( <strong>非静态</strong>属性，放这里主要是为了统一讲 )，处理器状态。共有 <strong>4</strong> 种状态。状态变迁如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_06_01/05.png" title="`handlerState` 变迁" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_06_01/05.png" alt="`handlerState` 变迁"></a><span class="caption">`handlerState` 变迁</span><ul>
<li>详细解析，见 <a href="#">「4.1.3 setAddComplete」</a>、<a href="#">「4.1.4 setRemoved」</a>、<a href="#">「4.1.5 setAddPending」</a> 中。</li>
</ul>
</li>
<li><code>HANDLER_STATE_UPDATER</code> <strong>静态</strong>属性，<code>handlerState</code> 的原子更新器。</li>
</ul>
<h3 id="4-1-2-构造方法"><a href="#4-1-2-构造方法" class="headerlink" title="4.1.2 构造方法"></a>4.1.2 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> AbstractChannelHandlerContext next;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> AbstractChannelHandlerContext prev;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为 inbound</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> inbound;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为 outbound</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> outbound;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 pipeline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否使用有序的 EventExecutor ( {<span class="doctag">@link</span> #executor} )，即 OrderedEventExecutor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Will be set to null if no child executor should be used, otherwise it will be set to the</span></span><br><span class="line"><span class="comment">// child executor.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventExecutor 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功的 Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture succeededFuture;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lazily instantiated tasks used to trigger events to a handler with different executor. 懒加载</span></span><br><span class="line"><span class="comment">// There is no need to make this volatile as at worse it will just create a few more instances then needed.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 Channel ReadComplete 事件的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable invokeChannelReadCompleteTask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 Channel Read 事件的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable invokeReadTask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 Channel WritableStateChanged 事件的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable invokeChannelWritableStateChangedTask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 flush 事件的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable invokeFlushTask;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> handlerState = INIT;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,</span><br><span class="line">                              <span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) {</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.inbound = inbound;</span><br><span class="line">    <span class="keyword">this</span>.outbound = outbound;</span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor; <span class="comment">// &lt;1&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>next</code>、<code>prev</code> 属性，分别记录上、下一个节点。</li>
<li>Handler 相关属性：<ul>
<li>在 AbstractChannelHandlerContext 抽象类中，按照我们上文的分享，应该会看到一个类型为 ChannelHandler 的处理器，但是<strong>实际并不是这样</strong>。而是，😈 我们下文 DefaultChannelHandlerContext、TailContext、HeadContext 见。</li>
<li><code>inbound</code>、<code>outbound</code> 属性，分别是否为 Inbound、Outbound 处理器。</li>
<li><code>name</code> 属性，处理器名字。</li>
<li><code>handlerState</code> 属性，处理器状态，初始为 <code>INIT</code> 。</li>
</ul>
</li>
<li><code>executor</code> 属性，EventExecutor 对象<ul>
<li><code>ordered</code> 属性，是否使用有序的 <code>executor</code>，即 OrderedEventExecutor ，在构造方法的 <code>&lt;1&gt;</code> 处理的初始化。</li>
</ul>
</li>
<li><code>pipeline</code> 属性，所属 DefaultChannelPipeline 对象。</li>
</ul>
<h3 id="4-1-3-setAddComplete"><a href="#4-1-3-setAddComplete" class="headerlink" title="4.1.3 setAddComplete"></a>4.1.3 setAddComplete</h3><p><code>#setAddComplete()</code> 方法，设置 ChannelHandler 添加完成。完成后，状态有两种结果：</p>
<ol>
<li><code>REMOVE_COMPLETE</code></li>
<li><code>ADD_COMPLETE</code></li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddComplete</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> oldState = handlerState;</span><br><span class="line">        <span class="comment">// Ensure we never update when the handlerState is REMOVE_COMPLETE already.</span></span><br><span class="line">        <span class="comment">// oldState is usually ADD_PENDING but can also be REMOVE_COMPLETE when an EventExecutor is used that is not</span></span><br><span class="line">        <span class="comment">// exposing ordering guarantees.</span></span><br><span class="line">        <span class="keyword">if</span> (oldState == REMOVE_COMPLETE || HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, ADD_COMPLETE)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>循环 + CAS 保证多线程下的安全变更 <code>handlerState</code> 属性。</li>
</ul>
<h3 id="4-1-4-setRemoved"><a href="#4-1-4-setRemoved" class="headerlink" title="4.1.4 setRemoved"></a>4.1.4 setRemoved</h3><p><code>#setRemoved()</code> 方法，设置 ChannelHandler 已移除。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRemoved</span><span class="params">()</span> </span>{</span><br><span class="line">    handlerState = REMOVE_COMPLETE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-1-5-setAddPending"><a href="#4-1-5-setAddPending" class="headerlink" title="4.1.5 setAddPending"></a>4.1.5 setAddPending</h3><p><code>#setAddPending()</code> 方法，设置 ChannelHandler 准备添加中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddPending</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> updated = HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, INIT, ADD_PENDING);</span><br><span class="line">    <span class="keyword">assert</span> updated; <span class="comment">// This should always be true as it MUST be called before setAddComplete() or setRemoved().</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当且仅当 <code>INIT</code> 可修改为 <code>ADD_PENDING</code> 。理论来说，这是一个绝对会成功的操作，原因见英文注释。</li>
</ul>
<h3 id="4-1-6-其他方法"><a href="#4-1-6-其他方法" class="headerlink" title="4.1.6 其他方法"></a>4.1.6 其他方法</h3><p>AbstractChannelHandlerContext 中的其他方法，详细解析，见后续的文章。</p>
<h2 id="4-2-HeadContext"><a href="#4-2-HeadContext" class="headerlink" title="4.2 HeadContext"></a>4.2 HeadContext</h2><p>HeadContext ，实现 ChannelOutboundHandler、ChannelInboundHandler 接口，继承 AbstractChannelHandlerContext 抽象类，<strong>pipe 头节点</strong> Context 实现类。</p>
<blockquote>
<p>HeadContext 是 DefaultChannelPipeline 的内部类。</p>
</blockquote>
<h3 id="4-2-1-构造方法"><a href="#4-2-1-构造方法" class="headerlink" title="4.2.1 构造方法"></a>4.2.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">HeadContext(DefaultChannelPipeline pipeline) {</span><br><span class="line">    <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    unsafe = pipeline.channel().unsafe(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    setAddComplete(); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用父 AbstractChannelHandlerContext  的构造方法，设置 <code>inbound = false</code>、<code>outbound = true</code> 。</li>
<li><p><code>&lt;2&gt;</code> 处，使用 Channel 的 Unsafe 作为 <code>unsafe</code> 属性。HeadContext 实现 ChannelOutboundHandler 接口的方法，都会调用 Unsafe 对应的方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.disconnect(promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.close(promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.deregister(promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">    unsafe.beginRead();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.flush();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这也就是为什么设置 <code>outbound = true</code> 的原因。</li>
</ul>
</li>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>#setAddComplete()</code> 方法，设置 ChannelHandler 添加完成。此时，<code>handlerStatus</code> 会变成 <code>ADD_COMPLETE</code> 状态。</p>
</li>
</ul>
<h3 id="4-2-2-handler"><a href="#4-2-2-handler" class="headerlink" title="4.2.2 handler"></a>4.2.2 handler</h3><p><code>#handler()</code> 方法，返回自己作为 Context 的 <strong>ChannelHandler</strong> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 HeadContext ，实现 ChannelOutboundHandler、ChannelInboundHandler 接口，而它们本身就是 ChannelHandler 。</li>
</ul>
<h3 id="4-2-3-其他方法"><a href="#4-2-3-其他方法" class="headerlink" title="4.2.3 其他方法"></a>4.2.3 其他方法</h3><p>HeadContext 中的其他方法，详细解析，见后续的文章。 </p>
<h2 id="4-3-TailContext"><a href="#4-3-TailContext" class="headerlink" title="4.3 TailContext"></a>4.3 TailContext</h2><p>TailContext ，实现 ChannelInboundHandler 接口，继承 AbstractChannelHandlerContext 抽象类，<strong>pipe 尾节点</strong> Context 实现类。</p>
<blockquote>
<p>TailContext 是 DefaultChannelPipeline 的内部类。</p>
</blockquote>
<h3 id="4-3-1-构造方法"><a href="#4-3-1-构造方法" class="headerlink" title="4.3.1 构造方法"></a>4.3.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">TailContext(DefaultChannelPipeline pipeline) {</span><br><span class="line">    <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    setAddComplete(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用父 AbstractChannelHandlerContext  的构造方法，设置 <code>inbound = true</code>、<code>outbound = false</code> ，和 HeadContext <strong>相反</strong>。</li>
<li><code>&lt;2&gt;</code> 处，调用 <code>#setAddComplete()</code> 方法，设置 ChannelHandler 添加完成。此时，<code>handlerStatus</code> 会变成 <code>ADD_COMPLETE</code> 状态。</li>
</ul>
<h3 id="4-3-2-handler"><a href="#4-3-2-handler" class="headerlink" title="4.3.2 handler"></a>4.3.2 handler</h3><p><code>#handler()</code> 方法，返回自己作为 Context 的 <strong>ChannelHandler</strong> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 HeadContext ，实现 ChannelInboundHandler 接口，而它们本身就是 ChannelHandler 。</li>
</ul>
<h3 id="4-3-3-其他方法"><a href="#4-3-3-其他方法" class="headerlink" title="4.3.3 其他方法"></a>4.3.3 其他方法</h3><p>TailContext 中的其他方法，详细解析，见后续的文章。 </p>
<h2 id="4-4-DefaultChannelHandlerContext"><a href="#4-4-DefaultChannelHandlerContext" class="headerlink" title="4.4 DefaultChannelHandlerContext"></a>4.4 DefaultChannelHandlerContext</h2><p><code>io.netty.channel.DefaultChannelHandlerContext</code> ，实现 AbstractChannelHandlerContext 抽象类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    DefaultChannelHandlerContext(</span><br><span class="line">            DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) {</span><br><span class="line">        <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler)); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.handler = handler; <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInbound</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelInboundHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOutbound</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelOutboundHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不同于 HeadContext、TailContext，它们自身就是一个 Context 的同时，也是一个 ChannelHandler 。而 DefaultChannelHandlerContext 是<strong>内嵌</strong> 一个 ChannelHandler 对象，即 <code>handler</code> 。这个属性通过构造方法传入，在 <code>&lt;2&gt;</code> 处进行赋值。</li>
<li><code>&lt;1&gt;</code> 处，调用父 AbstractChannelHandlerContext  的构造方法，通过判断传入的 <code>handler</code> 是否为 ChannelInboundHandler 和 ChannelOutboundHandler 来分别判断是否为 <code>inbound</code> 和 <code>outbound</code> 。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>推荐阅读如下文章：</p>
<ul>
<li>闪电侠 <a href="https://www.jianshu.com/p/6efa9c5fa702" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 pipeline(一)》</a></li>
<li>永顺 <a href="https://segmentfault.com/a/1190000007308934" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 二 贯穿Netty 的大动脉 ── ChannelPipeline (一)》</a></li>
<li>占小狼 <a href="https://www.jianshu.com/p/3876874306d5" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 ChannelPipeline》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ChannelPipeline-1-init/" data-id="ck4pl3foy00djfgcf0due8euj" class="article-share-link">分享</a>

</footer>
-->
</div>
