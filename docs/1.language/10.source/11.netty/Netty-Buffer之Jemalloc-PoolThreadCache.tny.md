<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 Jemalloc（六）PoolThreadCache
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena》</a> 一文中，我们看到 PoolArena 在分配( <code>#allocate(...)</code> )和释放( <code>#free(...)</code> )内存的过程中，无可避免会出现 <code>synchronized</code> 的身影。虽然锁的粒度不是很大，但是如果一个 PoolArena 如果被<strong>多个</strong>线程引用，带来的线程锁的同步和竞争。并且，如果在锁竞争的过程中，申请 Direct ByteBuffer ，那么带来的线程等待就可能是<strong>几百毫秒</strong>的时间。</p>
<p>那么该如何解决呢？如下图红框所示：</p>
<blockquote>
<p>FROM <a href="http://brionas.github.io/2015/01/31/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="external nofollow noopener noreferrer" target="_blank">《jemalloc源码解析-内存管理》</a></p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_09_16/01.png" title="大体结构" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_16/01.png" alt="大体结构"></a><span class="caption">大体结构</span></p>
</blockquote>
<p>给<strong>每个</strong>线程引入其<strong>独有</strong>的 tcache 线程缓存。</p>
<ul>
<li>在释放已分配的内存块时，不放回到 Chunk 中，而是缓存到 tcache 中。</li>
<li>在分配内存块时，优先从 tcache 获取。无法获取到，再从 Chunk 中分配。</li>
</ul>
<p>通过这样的方式，尽可能的避免多线程的同步和竞争。</p>
<h1 id="2-PoolThreadCache"><a href="#2-PoolThreadCache" class="headerlink" title="2. PoolThreadCache"></a>2. PoolThreadCache</h1><p><code>io.netty.buffer.PoolThreadCache</code> ，Netty 对 Jemalloc tcache 的实现类，内存分配的线程缓存。</p>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对应的 Heap PoolArena 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对应的 Direct PoolArena 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hold the caches for the different size classes, which are tiny, small and normal.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heap 类型的 tiny Subpage 内存块缓存数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;<span class="keyword">byte</span>[]&gt;[] tinySubPageHeapCaches;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heap 类型的 small Subpage 内存块缓存数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;<span class="keyword">byte</span>[]&gt;[] smallSubPageHeapCaches;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heap 类型的 normal 内存块缓存数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;<span class="keyword">byte</span>[]&gt;[] normalHeapCaches;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Direct 类型的 tiny Subpage 内存块缓存数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Direct 类型的 small Subpage 内存块缓存数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Direct 类型的 normal 内存块缓存数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Used for bitshifting when calculate the index of normal caches later</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于计算请求分配的 normal 类型的内存块，在 {<span class="doctag">@link</span> #normalDirectCaches} 数组中的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认为 log2(pageSize) = log2(8192) = 13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numShiftsNormalDirect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于计算请求分配的 normal 类型的内存块，在 {<span class="doctag">@link</span> #normalHeapCaches} 数组中的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认为 log2(pageSize) = log2(8192) = 13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numShiftsNormalHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> allocations;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #allocations} 到达该阀值，释放缓存</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 默认为 8192 次</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #free()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freeSweepAllocationThreshold;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: PoolThreadCache(PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena, PoolArena&lt;ByteBuffer&gt; directArena,</span><br><span class="line">  <span class="number">2</span>:                 <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span><br><span class="line">  <span class="number">3</span>:                 <span class="keyword">int</span> maxCachedBufferCapacity, <span class="keyword">int</span> freeSweepAllocationThreshold) {</span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (maxCachedBufferCapacity &lt; <span class="number">0</span>) {</span><br><span class="line">  <span class="number">5</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxCachedBufferCapacity: "</span></span><br><span class="line">  <span class="number">6</span>:                 + maxCachedBufferCapacity + <span class="string">" (expected: &gt;= 0)"</span>);</span><br><span class="line">  <span class="number">7</span>:     }</span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">this</span>.freeSweepAllocationThreshold = freeSweepAllocationThreshold;</span><br><span class="line">  <span class="number">9</span>:     <span class="keyword">this</span>.heapArena = heapArena;</span><br><span class="line"> <span class="number">10</span>:     <span class="keyword">this</span>.directArena = directArena;</span><br><span class="line"> <span class="number">11</span>: </span><br><span class="line"> <span class="number">12</span>:     <span class="comment">// 初始化 Direct 类型的内存块缓存</span></span><br><span class="line"> <span class="number">13</span>:     <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">14</span>:         <span class="comment">// 创建 tinySubPageDirectCaches</span></span><br><span class="line"> <span class="number">15</span>:         tinySubPageDirectCaches = createSubPageCaches(tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line"> <span class="number">16</span>:         <span class="comment">// 创建 smallSubPageDirectCaches</span></span><br><span class="line"> <span class="number">17</span>:         smallSubPageDirectCaches = createSubPageCaches(smallCacheSize, directArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"> <span class="number">18</span>: </span><br><span class="line"> <span class="number">19</span>:         <span class="comment">// 计算 numShiftsNormalDirect</span></span><br><span class="line"> <span class="number">20</span>:         numShiftsNormalDirect = log2(directArena.pageSize);</span><br><span class="line"> <span class="number">21</span>:         <span class="comment">// 创建 normalDirectCaches</span></span><br><span class="line"> <span class="number">22</span>:         normalDirectCaches = createNormalCaches(normalCacheSize, maxCachedBufferCapacity, directArena);</span><br><span class="line"> <span class="number">23</span>: </span><br><span class="line"> <span class="number">24</span>:         <span class="comment">// 增加 directArena 的线程引用计数</span></span><br><span class="line"> <span class="number">25</span>:         directArena.numThreadCaches.getAndIncrement();</span><br><span class="line"> <span class="number">26</span>:     } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">27</span>:         <span class="comment">// No directArea is configured so just null out all caches</span></span><br><span class="line"> <span class="number">28</span>:         tinySubPageDirectCaches = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">29</span>:         smallSubPageDirectCaches = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">30</span>:         normalDirectCaches = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">31</span>:         numShiftsNormalDirect = -<span class="number">1</span>;</span><br><span class="line"> <span class="number">32</span>:     }</span><br><span class="line"> <span class="number">33</span>:     <span class="comment">// 初始化 Heap 类型的内存块缓存。同上面部分。</span></span><br><span class="line"> <span class="number">34</span>:     <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">35</span>:         <span class="comment">// Create the caches for the heap allocations</span></span><br><span class="line"> <span class="number">36</span>:         tinySubPageHeapCaches = createSubPageCaches(tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line"> <span class="number">37</span>:         smallSubPageHeapCaches = createSubPageCaches(smallCacheSize, heapArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"> <span class="number">38</span>: </span><br><span class="line"> <span class="number">39</span>:         numShiftsNormalHeap = log2(heapArena.pageSize);</span><br><span class="line"> <span class="number">40</span>:         normalHeapCaches = createNormalCaches(normalCacheSize, maxCachedBufferCapacity, heapArena);</span><br><span class="line"> <span class="number">41</span>: </span><br><span class="line"> <span class="number">42</span>:         heapArena.numThreadCaches.getAndIncrement();</span><br><span class="line"> <span class="number">43</span>:     } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">44</span>:         <span class="comment">// No heapArea is configured so just null out all caches</span></span><br><span class="line"> <span class="number">45</span>:         tinySubPageHeapCaches = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">46</span>:         smallSubPageHeapCaches = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">47</span>:         normalHeapCaches = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">48</span>:         numShiftsNormalHeap = -<span class="number">1</span>;</span><br><span class="line"> <span class="number">49</span>:     }</span><br><span class="line"> <span class="number">50</span>: </span><br><span class="line"> <span class="number">51</span>:     <span class="comment">// 校验参数，保证 PoolThreadCache 可缓存内存块。</span></span><br><span class="line"> <span class="number">52</span>:     <span class="comment">// Only check if there are caches in use.</span></span><br><span class="line"> <span class="number">53</span>:     <span class="keyword">if</span> ((tinySubPageDirectCaches != <span class="keyword">null</span> || smallSubPageDirectCaches != <span class="keyword">null</span> || normalDirectCaches != <span class="keyword">null</span></span><br><span class="line"> <span class="number">54</span>:             || tinySubPageHeapCaches != <span class="keyword">null</span> || smallSubPageHeapCaches != <span class="keyword">null</span> || normalHeapCaches != <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">55</span>:             &amp;&amp; freeSweepAllocationThreshold &lt; <span class="number">1</span>) {</span><br><span class="line"> <span class="number">56</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"freeSweepAllocationThreshold: "</span> + freeSweepAllocationThreshold + <span class="string">" (expected: &gt; 0)"</span>);</span><br><span class="line"> <span class="number">57</span>:     }</span><br><span class="line"> <span class="number">58</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然代码比较多，主要分为 Heap 和 Direct 两种内存。</li>
<li>Direct 相关<ul>
<li><code>directArena</code> 属性，对应的 Heap PoolArena 对象。</li>
<li><code>tinySubPageDirectCaches</code> 属性，Direct 类型的 tiny Subpage 内存块缓存数组。<ul>
<li>默认情况下，数组大小为 512 。 </li>
<li>在【第 15 行】的代码，调用 <code>#createSubPageCaches(int cacheSize, int numCaches, SizeClass sizeClass)</code> 方法，创建 MemoryRegionCache 数组。详细解析，见 <a href="#">「2.2 createSubPageCaches」</a> 。</li>
</ul>
</li>
<li><code>smallSubPageDirectCaches</code> 属性，Direct 类型的 small Subpage 内存块缓存数组。<ul>
<li>默认情况下，数组大小为 256 。</li>
<li>在【第 17 行】的代码，调用 <code>#createSubPageCaches(int cacheSize, int numCaches, SizeClass sizeClass)</code> 方法，创建 MemoryRegionCache 数组。详细解析，见 <a href="#">「2.2 createSubPageCaches」</a> 。</li>
</ul>
</li>
<li><code>normalDirectCaches</code> 属性，Direct 类型的 normal Page 内存块缓存数组。<ul>
<li>默认情况下，数组大小为 64 。</li>
<li>在【第 22 行】的代码，调用 <code>#createNormalCaches(int cacheSize, int maxCachedBufferCapacity, PoolArena&lt;T&gt; area)</code> 方法，创建 MemoryRegionCache 数组。详细解析，见 <a href="#">「2.3 createNormalCaches」</a> 。</li>
<li><code>numShiftsNormalDirect</code> 属性，用于计算请求分配的 normal 类型的内存块，在 <code>normalDirectCaches</code> 数组中的位置。<ul>
<li>默认情况下，数值为 13 。</li>
<li>在【第 20 行】的代码，调用 <code>#log2(int pageSize)</code> 方法， <code>log2(pageSize) = log2(8192) = 13</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>在【第 25 行】的代码，增加 <code>directArena</code> 的线程引用计数。通过这样的方式，我们能够知道，一个 PoolArena 对象，被多少线程所引用。</li>
</ul>
</li>
<li>Heap 相关，和【Direct 相关】基本<strong>类似</strong>。</li>
<li><code>allocations</code> 属性，分配次数计数器。每次分配时，该计数器 + 1 。<ul>
<li><code>freeSweepAllocationThreshold</code> 属性，当 <code>allocations</code> 到达该阀值时，调用 <code>#free()</code> 方法，释放缓存。同时，会重置 <code>allocations</code> 计数器为 0 。</li>
</ul>
</li>
</ul>
<h2 id="2-2-createSubPageCaches"><a href="#2-2-createSubPageCaches" class="headerlink" title="2.2 createSubPageCaches"></a>2.2 createSubPageCaches</h2><p><code>#createSubPageCaches(int cacheSize, int numCaches, SizeClass sizeClass)</code> 方法，创建 Subpage 内存块缓存数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// tiny 类型，默认 cacheSize = PooledByteBufAllocator.DEFAULT_TINY_CACHE_SIZE = 512 , numCaches = PoolArena.numTinySubpagePools = 512 &gt;&gt;&gt; 4 = 32</span></span><br><span class="line"><span class="comment">// small 类型，默认 cacheSize = PooledByteBufAllocator.DEFAULT_SMALL_CACHE_SIZE = 256 , numCaches = pageSize - 9 = 13 - 9 = 4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createSubPageCaches(<span class="keyword">int</span> cacheSize, <span class="keyword">int</span> numCaches, SizeClass sizeClass) {</span><br><span class="line">    <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span> &amp;&amp; numCaches &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[numCaches];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) {</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> maybe use cacheSize / cache.length</span></span><br><span class="line">            cache[i] = <span class="keyword">new</span> SubPageMemoryRegionCache&lt;T&gt;(cacheSize, sizeClass);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的 Subpage 内存块缓存数组，实际和 <code>PoolArena.tinySubpagePools</code> 和 <code>PoolArena.smallSubpagePools</code> 数组<strong>大小保持一致</strong>。从而实现，相同大小的内存，能对应相同的数组下标。<ul>
<li><code>sizeClass</code> = <code>tiny</code> 时， 默认 <code>cacheSize</code> = <code>PooledByteBufAllocator.DEFAULT_TINY_CACHE_SIZE = 512</code> , <code>numCaches</code> = <code>PoolArena.numTinySubpagePools = 512 &gt;&gt;&gt; 4 = 32</code> 。</li>
<li><code>sizeClass</code> = <code>small</code> 时，默认 <code>cacheSize</code> = <code>PooledByteBufAllocator.DEFAULT_SMALL_CACHE_SIZE = 256</code> , <code>numCaches</code> = <code>pageSize - 9 = 13 - 9 = 4</code> 。</li>
</ul>
</li>
<li>创建的数组，每个元素的类型为 SubPageMemoryRegionCache 。详细解析，见 <a href="#">「3.X.1 SubPageMemoryRegionCache」</a> 。</li>
</ul>
<h2 id="2-3-createNormalCaches"><a href="#2-3-createNormalCaches" class="headerlink" title="2.3 createNormalCaches"></a>2.3 createNormalCaches</h2><p><code>#createSubPageCaches(int cacheSize, int numCaches, SizeClass sizeClass)</code> 方法，创建 Normal Page 内存块缓存数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">// normal 类型，默认 cacheSize = PooledByteBufAllocator.DEFAULT_NORMAL_CACHE_SIZE = 64 , maxCachedBufferCapacity = PoolArena.DEFAULT_MAX_CACHED_BUFFER_CAPACITY = 32 * 1024 = 32KB</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createNormalCaches(<span class="keyword">int</span> cacheSize, <span class="keyword">int</span> maxCachedBufferCapacity, PoolArena&lt;T&gt; area) {</span><br><span class="line">    <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span> &amp;&amp; maxCachedBufferCapacity &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// &lt;1&gt; 计算数组大小</span></span><br><span class="line">        <span class="keyword">int</span> max = Math.min(area.chunkSize, maxCachedBufferCapacity);</span><br><span class="line">        <span class="keyword">int</span> arraySize = Math.max(<span class="number">1</span>, log2(max / area.pageSize) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[arraySize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) {</span><br><span class="line">            cache[i] = <span class="keyword">new</span> NormalMemoryRegionCache&lt;T&gt;(cacheSize);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>maxCachedBufferCapacity</code> 属性，缓存的 Normal 内存块的最大容量，避免过大的 Normal 内存块被缓存，占用过多通过。默认情况下，<code>maxCachedBufferCapacity = PoolArena.DEFAULT_MAX_CACHED_BUFFER_CAPACITY = 32 * 1024 = 32KB</code> 。也就说，在 <code>&lt;1&gt;</code> 处，<code>arraySize</code> 的计算<strong>数组大小</strong>的结果为 3 。刚好是 <code>cache[0] = 8KB</code>、<code>cache[1] = 16KB</code>、<code>cache[2] = 32KB</code> 。那么，如果申请的 Normal 内存块大小为 <code>64KB</code> ，超过了数组大小，所以无法被缓存。😈 是不是和原先自己认为的 <code>maxCachedBufferCapacity</code> 实现最大容量的想法，有点不同。</li>
<li>创建的数组，每个元素的类型为 SubPageMemoryRegionCache 。详细解析，见 <a href="#">「3.X.2 NormalMemoryRegionCache」</a> 。</li>
</ul>
<h2 id="2-4-cache"><a href="#2-4-cache" class="headerlink" title="2.4 cache"></a>2.4 cache</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForTiny(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) {</span><br><span class="line">    <span class="comment">// 获得数组下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = PoolArena.tinyIdx(normCapacity);</span><br><span class="line">    <span class="keyword">if</span> (area.isDirect()) {</span><br><span class="line">        <span class="keyword">return</span> cache(tinySubPageDirectCaches, idx);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache(tinySubPageHeapCaches, idx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForSmall(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) {</span><br><span class="line">    <span class="comment">// 获得数组下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = PoolArena.smallIdx(normCapacity);</span><br><span class="line">    <span class="keyword">if</span> (area.isDirect()) {</span><br><span class="line">        <span class="keyword">return</span> cache(smallSubPageDirectCaches, idx);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache(smallSubPageHeapCaches, idx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForNormal(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) {</span><br><span class="line">    <span class="keyword">if</span> (area.isDirect()) {</span><br><span class="line">        <span class="comment">// 获得数组下标</span></span><br><span class="line">        <span class="keyword">int</span> idx = log2(normCapacity &gt;&gt; numShiftsNormalDirect);</span><br><span class="line">        <span class="keyword">return</span> cache(normalDirectCaches, idx);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获得数组下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = log2(normCapacity &gt;&gt; numShiftsNormalHeap);</span><br><span class="line">    <span class="keyword">return</span> cache(normalHeapCaches, idx);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>三个方法，分别获取内存容量对应所在的 MemoryRegionCache 对象。通过调用 <code>#cache(MemoryRegionCache&lt;T&gt;[] cache, int idx)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MemoryRegionCache&lt;T&gt; <span class="title">cache</span><span class="params">(MemoryRegionCache&lt;T&gt;[] cache, <span class="keyword">int</span> idx)</span> </span>{</span><br><span class="line">    <span class="comment">// 不在范围内，说明不缓存该容量的内存块</span></span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span> || idx &gt; cache.length - <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获得 MemoryRegionCache 对象</span></span><br><span class="line">    <span class="keyword">return</span> cache[idx];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<hr>
<p>当然，考虑到使用便利，封装了 <code>#cache(PoolArena&lt;?&gt; area, int normCapacity, SizeClass sizeClass)</code> 方法，支持获取对应内存类型的 MemoryRegionCache 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cache(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity, SizeClass sizeClass) {</span><br><span class="line">    <span class="keyword">switch</span> (sizeClass) {</span><br><span class="line">    <span class="keyword">case</span> Normal:</span><br><span class="line">        <span class="keyword">return</span> cacheForNormal(area, normCapacity);</span><br><span class="line">    <span class="keyword">case</span> Small:</span><br><span class="line">        <span class="keyword">return</span> cacheForSmall(area, normCapacity);</span><br><span class="line">    <span class="keyword">case</span> Tiny:</span><br><span class="line">        <span class="keyword">return</span> cacheForTiny(area, normCapacity);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-5-add"><a href="#2-5-add" class="headerlink" title="2.5 add"></a>2.5 add</h2><p><code>#add(PoolArena&lt;?&gt; area, PoolChunk chunk, long handle, int normCapacity, SizeClass sizeClass)</code> 方法，添加内存块到 PoolThreadCache 的指定 MemoryRegionCache 的队列中，进行缓存。并且，返回是否添加成功。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add {<span class="doctag">@link</span> PoolChunk} and {<span class="doctag">@code</span> handle} to the cache if there is enough room.</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if it fit into the cache {<span class="doctag">@code</span> false} otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>({ <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> })</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolArena&lt;?&gt; area, PoolChunk chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, SizeClass sizeClass)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得对应的 MemoryRegionCache 对象</span></span><br><span class="line">    MemoryRegionCache&lt;?&gt; cache = cache(area, normCapacity, sizeClass);</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加到 MemoryRegionCache 内存块中</span></span><br><span class="line">    <span class="keyword">return</span> cache.add(chunk, handle);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。</li>
<li>在 <code>PoolArea#free(PoolChunk&lt;T&gt; chunk, long handle, int normCapacity, PoolThreadCache cache)</code> 中，调用该方法。所以，可以结合 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-5-Jemalloc-Arena">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（五）PoolArena》</a> 的 <a href="#">「2.6 free」</a> 一起看看罗。</li>
</ul>
<h2 id="2-6-allocate"><a href="#2-6-allocate" class="headerlink" title="2.6 allocate"></a>2.6 allocate</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Try to allocate a tiny buffer out of the cache. Returns {<span class="doctag">@code</span> true} if successful {<span class="doctag">@code</span> false} otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocateTiny</span><span class="params">(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocate(cacheForTiny(area, normCapacity), buf, reqCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Try to allocate a small buffer out of the cache. Returns {<span class="doctag">@code</span> true} if successful {<span class="doctag">@code</span> false} otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocateSmall</span><span class="params">(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocate(cacheForSmall(area, normCapacity), buf, reqCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Try to allocate a small buffer out of the cache. Returns {<span class="doctag">@code</span> true} if successful {<span class="doctag">@code</span> false} otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocateNormal</span><span class="params">(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>三个方法，从缓存中分别获取不同容量大小的内存块，初始化到 PooledByteBuf 对象中。通过调用 <code>#allocate(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, int reqCapacity)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (cache == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// no cache found so just return false here</span></span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 分配内存块，并初始化到 MemoryRegionCache 中</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">boolean</span> allocated = cache.allocate(buf, reqCapacity);</span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// 到达阀值，整理缓存</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">if</span> (++ allocations &gt;= freeSweepAllocationThreshold) {</span><br><span class="line"><span class="number">10</span>:         allocations = <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>:         trim();</span><br><span class="line"><span class="number">12</span>:     }</span><br><span class="line"><span class="number">13</span>:     <span class="comment">// 返回是否分配成功</span></span><br><span class="line"><span class="number">14</span>:     <span class="keyword">return</span> allocated;</span><br><span class="line"><span class="number">15</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 7 行：调用 <code>MemoryRegionCache#allocate(buf, reqCapacity)</code> 方法，从缓存中分配内存块，并初始化到 MemoryRegionCache 中。</li>
<li>第 8 至 12 行：增加 <code>allocations</code> 计数。若到达阀值( <code>freeSweepAllocationThreshold</code> )，重置计数，并调用 <code>#trim()</code> 方法，整理缓存。详细解析，见 <a href="#">「2.7 trim」</a> 。</li>
<li>第 14 行：返回是否分配成功。如果从缓存中分配失败，后续就从 PoolArena 中获取内存块。</li>
</ul>
</li>
</ul>
<h2 id="2-7-free"><a href="#2-7-free" class="headerlink" title="2.7 free"></a>2.7 free</h2><p><code>#trim()</code> 方法，整理缓存，释放使用<strong>频度</strong>较少的内存块缓存。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">free</span><span class="params">(MemoryRegionCache&lt;?&gt; cache)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache.free();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>{</span><br><span class="line">    trim(tinySubPageDirectCaches);</span><br><span class="line">    trim(smallSubPageDirectCaches);</span><br><span class="line">    trim(normalDirectCaches);</span><br><span class="line">    trim(tinySubPageHeapCaches);</span><br><span class="line">    trim(smallSubPageHeapCaches);</span><br><span class="line">    trim(normalHeapCaches);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">(MemoryRegionCache&lt;?&gt;[] caches)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (caches == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (MemoryRegionCache&lt;?&gt; c: caches) {</span><br><span class="line">        trim(c);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">(MemoryRegionCache&lt;?&gt; cache)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    cache.trim();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>会调用所有 MemoryRegionCache 的 <code>#trim()</code> 方法，整理每个内存块缓存。详细解析，见 <a href="#">「3.6 trim」</a> 。</li>
</ul>
<h2 id="2-8-finalize"><a href="#2-8-finalize" class="headerlink" title="2.8 finalize"></a>2.8 finalize</h2><p><code>#finalize()</code> 方法，对象销毁时，清空缓存等等。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="doctag">TODO:</span> In the future when we move to Java9+ we should use java.lang.ref.Cleaner.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// &lt;1&gt; 调用父 finalize</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 清空缓存</span></span><br><span class="line">        free();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Should be called if the Thread that uses this cache is about to exist to release resources out of the cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;2&gt; 清空缓存</span></span><br><span class="line">    <span class="keyword">int</span> numFreed = free(tinySubPageDirectCaches) +</span><br><span class="line">            free(smallSubPageDirectCaches) +</span><br><span class="line">            free(normalDirectCaches) +</span><br><span class="line">            free(tinySubPageHeapCaches) +</span><br><span class="line">            free(smallSubPageHeapCaches) +</span><br><span class="line">            free(normalHeapCaches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numFreed &gt; <span class="number">0</span> &amp;&amp; logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"Freed {} thread-local buffer(s) from thread: {}"</span>, numFreed, Thread.currentThread().getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3.1&gt; 减小 directArena 的线程引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) {</span><br><span class="line">        directArena.numThreadCaches.getAndDecrement();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3.2&gt; 减小 heapArena 的线程引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) {</span><br><span class="line">        heapArena.numThreadCaches.getAndDecrement();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">free</span><span class="params">(MemoryRegionCache&lt;?&gt;[] caches)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (caches == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numFreed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (MemoryRegionCache&lt;?&gt; c: caches) {</span><br><span class="line">        numFreed += free(c);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> numFreed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看。主要是 <code>&lt;1&gt;</code>、<code>&lt;2&gt;</code>、<code>&lt;3.1&gt;/&lt;3.2&gt;</code> 三个点。</li>
</ul>
<h1 id="3-MemoryRegionCache"><a href="#3-MemoryRegionCache" class="headerlink" title="3. MemoryRegionCache"></a>3. MemoryRegionCache</h1><p>MemoryRegionCache ，是 PoolThreadCache 的内部静态类，<strong>内存块缓存</strong>。在其内部，有一个<strong>队列</strong>，存储缓存的内存块。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_09_16/02.png" title="MemoryRegionCache" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_09_16/02.png" alt="MemoryRegionCache"></a><span class="caption">MemoryRegionCache</span></p>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryRegionCache</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> #queue} 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列。里面存储内存块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Entry&lt;T&gt;&gt; queue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SizeClass sizeClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配次数计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> allocations;</span><br><span class="line"></span><br><span class="line">    MemoryRegionCache(<span class="keyword">int</span> size, SizeClass sizeClass) {</span><br><span class="line">        <span class="keyword">this</span>.size = MathUtil.safeFindNextPositivePowerOfTwo(size);</span><br><span class="line">        queue = PlatformDependent.newFixedMpscQueue(<span class="keyword">this</span>.size); <span class="comment">// &lt;1&gt; MPSC</span></span><br><span class="line">        <span class="keyword">this</span>.sizeClass = sizeClass;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略其它方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sizeClass</code> 属性，内存类型。</li>
<li><p><code>queue</code> 属性，队列，里面存储内存块。每个元素为 Entry 对象，对应一个内存块。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recycler 处理器，用于回收 Entry 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PoolChunk 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PoolChunk&lt;T&gt; chunk;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存块在 {<span class="doctag">@link</span> #chunk} 的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> handle = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entry(Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle) {</span><br><span class="line">        <span class="keyword">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 置空</span></span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        handle = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 回收 Entry 对象</span></span><br><span class="line">        recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>chunk</code> 和 <code>handle</code> 属性，可以唯一确认一个内存块。</li>
<li><code>recyclerHandle</code> 属性，用于回收 Entry 对象，用于 <code>#recycle()</code> 方法中。</li>
</ul>
</li>
<li><code>size</code> 属性，队列大小。</li>
<li><code>allocations</code> 属性，分配次数计数器。</li>
<li>在 <code>&lt;1&gt;</code> 处理，我们可以看到创建的 <code>queue</code> 属性，类型为 MPSC( Multiple Producer Single Consumer ) 队列，即<strong>多个</strong>生产者<strong>单一</strong>消费者。为什么使用 MPSC 队列呢?<ul>
<li>多个生产者，指的是多个线程，移除( 释放 )内存块出队列。</li>
<li>单个消费者，指的是单个线程，添加( 缓存 )内存块到队列。 </li>
</ul>
</li>
</ul>
<h2 id="3-2-newEntry"><a href="#3-2-newEntry" class="headerlink" title="3.2 newEntry"></a>3.2 newEntry</h2><p><code>#newEntry(PoolChunk&lt;?&gt; chunk, long handle)</code> 方法，创建 Entry 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Entry <span class="title">newEntry</span><span class="params">(PoolChunk&lt;?&gt; chunk, <span class="keyword">long</span> handle)</span> </span>{</span><br><span class="line">    <span class="comment">// 从 Recycler 对象中，获得 Entry 对象</span></span><br><span class="line">    Entry entry = RECYCLER.get();</span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    entry.chunk = chunk;</span><br><span class="line">    entry.handle = handle;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;Entry&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;Entry&gt;() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Entry <span class="title">newObject</span><span class="params">(Handle&lt;Entry&gt; handle)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Entry(handle); <span class="comment">// 创建 Entry 对象</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-3-add"><a href="#3-3-add" class="headerlink" title="3.3 add"></a>3.3 add</h2><p><code>#add(PoolChunk&lt;T&gt; chunk, long handle)</code> 方法，添加( 缓存 )内存块到队列，并返回是否添加成功。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add to cache if not already full.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 Entry 对象</span></span><br><span class="line">    Entry&lt;T&gt; entry = newEntry(chunk, handle);</span><br><span class="line">    <span class="comment">// 添加到队列</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = queue.offer(entry);</span><br><span class="line">    <span class="comment">// 若添加失败，说明队列已满，回收 Entry 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!queued) {</span><br><span class="line">        <span class="comment">// If it was not possible to cache the chunk, immediately recycle the entry</span></span><br><span class="line">        entry.recycle();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queued; <span class="comment">// 是否添加成功</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-4-allocate"><a href="#3-4-allocate" class="headerlink" title="3.4 allocate"></a>3.4 allocate</h2><p><code>#allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity)</code> 方法，从队列中获取缓存的内存块，初始化到 PooledByteBuf 对象中，并返回是否分配成功。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate something out of the cache if possible and remove the entry from the cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取并移除队列首个 Entry 对象</span></span><br><span class="line">    Entry&lt;T&gt; entry = queue.poll();</span><br><span class="line">    <span class="comment">// 获取失败，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;1&gt; 初始化内存块到 PooledByteBuf 对象中 </span></span><br><span class="line">    initBuf(entry.chunk, entry.handle, buf, reqCapacity);</span><br><span class="line">    <span class="comment">// 回收 Entry 对象</span></span><br><span class="line">    entry.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 allocations 计数。因为分配总是在相同线程，所以不需要考虑线程安全的问题</span></span><br><span class="line">    <span class="comment">// allocations is not thread-safe which is fine as this is only called from the same thread all time.</span></span><br><span class="line">    ++ allocations;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回 true ，分配成功</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。</li>
<li><p>在 <code>&lt;1&gt;</code> 处，调用 <code>#initBuf(PoolChunk&lt;T&gt; chunk, long handle, PooledByteBuf&lt;T&gt; buf, int reqCapacity)</code> <strong>抽象</strong>方法，初始化内存块到 PooledByteBuf 对象中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init the {<span class="doctag">@link</span> PooledByteBuf} using the provided chunk and handle with the capacity restrictions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>该<strong>抽象</strong>方法需要子类 SubPageMemoryRegionCache 和 NormalMemoryRegionCache 来实现。并且，这也是 MemoryRegionCache 的<strong>唯一</strong>的抽象方法。</li>
</ul>
</li>
</ul>
<h2 id="3-5-free"><a href="#3-5-free" class="headerlink" title="3.5 free"></a>3.5 free</h2><p><code>#free(...)</code> 方法，清除队列。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除队列中的全部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Clear out this cache and free up all previous cached {<span class="doctag">@link</span> PoolChunk}s and {<span class="doctag">@code</span> handle}s.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">free</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> free(Integer.MAX_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除队列中的指定数量元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">free</span><span class="params">(<span class="keyword">int</span> max)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> numFreed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; numFreed &lt; max; numFreed++) {</span><br><span class="line">        <span class="comment">// 获取并移除首元素</span></span><br><span class="line">        Entry&lt;T&gt; entry = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 释放缓存的内存块回 Chunk 中</span></span><br><span class="line">            freeEntry(entry); &lt;<span class="number">1</span>&gt;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// all cleared</span></span><br><span class="line">            <span class="keyword">return</span> numFreed;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> numFreed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。</li>
<li><p><code>&lt;1&gt;</code> 处， 释放缓存的内存块回 Chunk 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">freeEntry</span><span class="params">(Entry entry)</span> </span>{</span><br><span class="line">    PoolChunk chunk = entry.chunk;</span><br><span class="line">    <span class="keyword">long</span> handle = entry.handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收 Entry 对象</span></span><br><span class="line">    <span class="comment">// recycle now so PoolChunk can be GC'ed.</span></span><br><span class="line">    entry.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放缓存的内存块回 Chunk 中</span></span><br><span class="line">    chunk.arena.freeChunk(chunk, handle, sizeClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="3-6-trim"><a href="#3-6-trim" class="headerlink" title="3.6 trim"></a>3.6 trim</h2><p>这块当时没太看懂，后来读了 <a href="https://www.jianshu.com/p/9177b7dabd37" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–PoolThreadCache》</a> 文章后，看懂了 <code>#trim()</code> 方法。引用如下：</p>
<blockquote>
<p>在分配过程还有一个<code>trim()</code>方法，当分配操作达到一定阈值（Netty默认8192）时，没有被分配出去的缓存空间都要被释放，以防止内存泄漏，核心代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类MemoryRegionCache</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// allocations 表示已经重新分配出去的ByteBuf个数</span></span><br><span class="line">    <span class="keyword">int</span> free = size - allocations;  </span><br><span class="line">    allocations = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在一定阈值内还没被分配出去的空间将被释放</span></span><br><span class="line">    <span class="keyword">if</span> (free &gt; <span class="number">0</span>) {</span><br><span class="line">        free(free); <span class="comment">// 释放队列中的节点</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>也就是说，期望一个 MemoryRegionCache <strong>频繁</strong>进行回收-分配，这样 <code>allocations</code> &gt; <code>size</code> ，将不会释放队列中的任何一个节点表示的内存空间；</p>
<p>但如果长时间没有分配，则应该释放这一部分空间，防止内存占据过多。Tiny请求缓存512 个节点，由此可知当使用率超过 <code>512 / 8192 = 6.25%</code> 时就不会释放节点。</p>
</blockquote>
<h2 id="3-X1-SubPageMemoryRegionCache"><a href="#3-X1-SubPageMemoryRegionCache" class="headerlink" title="3.X1 SubPageMemoryRegionCache"></a>3.X1 SubPageMemoryRegionCache</h2><p>SubPageMemoryRegionCache ，是 PoolThreadCache 的内部静态类，继承 MemoryRegionCache 抽象类，<strong>Subpage</strong> MemoryRegionCache 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache used for buffers which are backed by TINY or SMALL size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubPageMemoryRegionCache</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MemoryRegionCache</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    SubPageMemoryRegionCache(<span class="keyword">int</span> size, SizeClass sizeClass) {</span><br><span class="line">        <span class="keyword">super</span>(size, sizeClass);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line">        <span class="comment">// 初始化 Subpage 内存块到 PooledByteBuf 对象中</span></span><br><span class="line">        chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-X2-NormalMemoryRegionCache"><a href="#3-X2-NormalMemoryRegionCache" class="headerlink" title="3.X2 NormalMemoryRegionCache"></a>3.X2 NormalMemoryRegionCache</h2><p>NormalMemoryRegionCache ，是 PoolThreadCache 的内部静态类，继承 MemoryRegionCache 抽象类，<strong>Page</strong> MemoryRegionCache 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache used for buffers which are backed by NORMAL size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalMemoryRegionCache</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MemoryRegionCache</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    NormalMemoryRegionCache(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">super</span>(size, SizeClass.Normal);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>{</span><br><span class="line">        <span class="comment">// 初始化 Page 内存块到 PooledByteBuf 对象中</span></span><br><span class="line">        chunk.initBuf(buf, handle, reqCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>嘿嘿，比想象中简单蛮多的一篇文章。</p>
<p>推荐阅读文章：</p>
<ul>
<li>Hypercube <a href="https://www.jianshu.com/p/9177b7dabd37" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（十）–PoolThreadCache》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-3-6-Jemalloc-ThreadCache/" data-id="ck4pl3fpa00egfgcfp620fla3" class="article-share-link">分享</a>

</footer>
-->
</div>
