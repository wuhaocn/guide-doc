<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（七）之 EventLoop 处理定时任务
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接 <a href="http://svip.iocoder.cn/Netty/EventLoop-6-EventLoop-handle-normal-task">《精尽 Netty 源码解析 —— EventLoop（六）之 EventLoop 处理普通任务》</a> ，分享【处理<strong>定时任务</strong>】的部分。</p>
<p>因为 AbstractScheduledEventExecutor 在 <a href="精尽 Netty 源码解析 —— EventLoop（三）之 EventLoop 初始化">《精尽 Netty 源码解析 —— EventLoop（三）之 EventLoop 初始化》</a> 并未分享，并且它是本文的<strong>处理定时任务的前置</strong>，所以本文先写这部分内容。</p>
<h1 id="2-ScheduledFutureTask"><a href="#2-ScheduledFutureTask" class="headerlink" title="2. ScheduledFutureTask"></a>2. ScheduledFutureTask</h1><p><code>io.netty.util.concurrent.ScheduledFutureTask</code> ，实现 ScheduledFuture、PriorityQueueNode 接口，继承 PromiseTask 抽象类，Netty 定时任务。</p>
<blockquote>
<p>老艿艿：也有文章喜欢把“定时任务”叫作“调度任务”，意思是相同的，本文统一使用“定时任务”。</p>
</blockquote>
<h2 id="2-1-静态属性"><a href="#2-1-静态属性" class="headerlink" title="2.1 静态属性"></a>2.1 静态属性</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务序号生成器，通过 AtomicLong 实现递增发号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextTaskId = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时任务时间起点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.nanoTime();</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>nextTaskId</code> 静态属性，任务序号生成器，通过 AtomicLong 实现<strong>递增</strong>发号。</li>
<li><p><code>START_TIME</code> 静态属性，定时任务时间<strong>起点</strong>。在 ScheduledFutureTask 中，定时任务的执行时间，都是基于 <code>START_TIME</code> 做<strong>相对</strong>时间。😈 至于为什么使用相对时间？笔者暂时没有搞清楚。</p>
<ul>
<li>笔者也搜索了下和 <code>System.nanoTime()</code> 相关的内容，唯一能看的是 <a href="http://hold-on.iteye.com/blog/1943436" rel="external nofollow noopener noreferrer" target="_blank">《System.nanoTime() 的隐患》</a> ，但是应该不是这个原因。 </li>
<li><p>和我的大表弟普架交流了一波，他的理解是：</p>
<blockquote>
<p>因为是定时调度，我改了系统时间也没关系<br>存的是距离下次调度还要多长时间<br>不受系统时间影响<br>最大的好处</p>
</blockquote>
<ul>
<li>哎哟，牛逼如我大表弟啊！！！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-nanoTime"><a href="#2-2-nanoTime" class="headerlink" title="2.2 nanoTime"></a>2.2 nanoTime</h2><p><code>#nanoTime()</code> <strong>静态</strong>方法，获得当前时间，这个是相对 <code>START_TIME</code> 来算的。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是个重要的方法，后续很多方法都会调用到它。</li>
</ul>
<h2 id="2-3-deadlineNanos"><a href="#2-3-deadlineNanos" class="headerlink" title="2.3 deadlineNanos"></a>2.3 deadlineNanos</h2><p><code>#deadlineNanos(long delay)</code> <strong>静态</strong>方法，获得任务执行时间，这个也是相对 <code>START_TIME</code> 来算的。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延迟时长，单位：纳秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 获得任务执行时间，也是相对 {<span class="doctag">@link</span> #START_TIME} 来算的。</span></span><br><span class="line"><span class="comment"> *          实际上，返回的结果，会用于 {<span class="doctag">@link</span> #deadlineNanos} 字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">deadlineNanos</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> deadlineNanos = nanoTime() + delay;</span><br><span class="line">    <span class="comment">// Guard against overflow 防御性编程</span></span><br><span class="line">    <span class="keyword">return</span> deadlineNanos &lt; <span class="number">0</span> ? Long.MAX_VALUE : deadlineNanos;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-4-构造方法"><a href="#2-4-构造方法" class="headerlink" title="2.4 构造方法"></a>2.4 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = nextTaskId.getAndIncrement();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行时间，即到了该时间，该任务就会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> deadlineNanos;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行周期</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * =0 - 只执行一次</span></span><br><span class="line"><span class="comment"> * &gt;0 - 按照计划执行时间计算</span></span><br><span class="line"><span class="comment"> * &lt;0 - 按照实际执行时间计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 推荐阅读文章 https://blog.csdn.net/gtuu0123/article/details/6040159</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> queueIndex = INDEX_NOT_IN_QUEUE;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(</span><br><span class="line">        AbstractScheduledEventExecutor executor,</span><br><span class="line">        Runnable runnable, V result, <span class="keyword">long</span> nanoTime) {</span><br><span class="line">    <span class="keyword">this</span>(executor, toCallable(runnable, result), nanoTime);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(</span><br><span class="line">        AbstractScheduledEventExecutor executor,</span><br><span class="line">        Callable&lt;V&gt; callable, <span class="keyword">long</span> nanoTime, <span class="keyword">long</span> period) {</span><br><span class="line">    <span class="keyword">super</span>(executor, callable);</span><br><span class="line">    <span class="keyword">if</span> (period == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"period: 0 (expected: != 0)"</span>);</span><br><span class="line">    }</span><br><span class="line">    deadlineNanos = nanoTime;</span><br><span class="line">    periodNanos = period;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(</span><br><span class="line">        AbstractScheduledEventExecutor executor,</span><br><span class="line">        Callable&lt;V&gt; callable, <span class="keyword">long</span> nanoTime) {</span><br><span class="line">    <span class="keyword">super</span>(executor, callable);</span><br><span class="line">    deadlineNanos = nanoTime;</span><br><span class="line">    periodNanos = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个字段比较简单，胖友看上面的注释。</li>
</ul>
<h2 id="2-5-delayNanos"><a href="#2-5-delayNanos" class="headerlink" title="2.5 delayNanos"></a>2.5 delayNanos</h2><p><code>#delayNanos(...)</code> 方法，获得距离指定时间，还要多久可执行。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 距离当前时间，还要多久可执行。若为负数，直接返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">delayNanos</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>, deadlineNanos() - nanoTime());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentTimeNanos 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 距离指定时间，还要多久可执行。若为负数，直接返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">delayNanos</span><span class="params">(<span class="keyword">long</span> currentTimeNanos)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>, deadlineNanos() - (currentTimeNanos - START_TIME));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unit.convert(delayNanos(), TimeUnit.NANOSECONDS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-6-run"><a href="#2-6-run" class="headerlink" title="2.6 run"></a>2.6 run</h2><p><code>#run()</code> 方法，执行定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="function"><span class="keyword">assert</span> <span class="title">executor</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (periodNanos == <span class="number">0</span>) {</span><br><span class="line"> <span class="number">6</span>:             <span class="comment">// 设置任务不可取消</span></span><br><span class="line"> <span class="number">7</span>:             <span class="keyword">if</span> (setUncancellableInternal()) {</span><br><span class="line"> <span class="number">8</span>:                 <span class="comment">// 执行任务</span></span><br><span class="line"> <span class="number">9</span>:                 V result = task.call();</span><br><span class="line"><span class="number">10</span>:                 <span class="comment">// 通知任务执行成功</span></span><br><span class="line"><span class="number">11</span>:                 setSuccessInternal(result);</span><br><span class="line"><span class="number">12</span>:             }</span><br><span class="line"><span class="number">13</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">14</span>:             <span class="comment">// 判断任务并未取消</span></span><br><span class="line"><span class="number">15</span>:             <span class="comment">// check if is done as it may was cancelled</span></span><br><span class="line"><span class="number">16</span>:             <span class="keyword">if</span> (!isCancelled()) {</span><br><span class="line"><span class="number">17</span>:                 <span class="comment">// 执行任务</span></span><br><span class="line"><span class="number">18</span>:                 task.call();</span><br><span class="line"><span class="number">19</span>:                 <span class="keyword">if</span> (!executor().isShutdown()) {</span><br><span class="line"><span class="number">20</span>:                     <span class="comment">// 计算下次执行时间</span></span><br><span class="line"><span class="number">21</span>:                     <span class="keyword">long</span> p = periodNanos;</span><br><span class="line"><span class="number">22</span>:                     <span class="keyword">if</span> (p &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">23</span>:                         deadlineNanos += p;</span><br><span class="line"><span class="number">24</span>:                     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">25</span>:                         deadlineNanos = nanoTime() - p;</span><br><span class="line"><span class="number">26</span>:                     }</span><br><span class="line"><span class="number">27</span>:                     <span class="comment">// 判断任务并未取消</span></span><br><span class="line"><span class="number">28</span>:                     <span class="keyword">if</span> (!isCancelled()) {</span><br><span class="line"><span class="number">29</span>:                         <span class="comment">// 重新添加到任务队列，等待下次定时执行</span></span><br><span class="line"><span class="number">30</span>:                         <span class="comment">// scheduledTaskQueue can never be null as we lazy init it before submit the task!</span></span><br><span class="line"><span class="number">31</span>:                         Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue =</span><br><span class="line"><span class="number">32</span>:                                 ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue;</span><br><span class="line"><span class="number">33</span>:                         <span class="keyword">assert</span> scheduledTaskQueue != <span class="keyword">null</span>;</span><br><span class="line"><span class="number">34</span>:                         scheduledTaskQueue.add(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">35</span>:                     }</span><br><span class="line"><span class="number">36</span>:                 }</span><br><span class="line"><span class="number">37</span>:             }</span><br><span class="line"><span class="number">38</span>:         }</span><br><span class="line"><span class="number">39</span>:     <span class="comment">// 发生异常，通知任务执行失败</span></span><br><span class="line"><span class="number">40</span>:     } <span class="keyword">catch</span> (Throwable cause) {</span><br><span class="line"><span class="number">41</span>:         setFailureInternal(cause);</span><br><span class="line"><span class="number">42</span>:     }</span><br><span class="line"><span class="number">43</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：校验，必须在 EventLoop 的线程中。</li>
<li>根据不同的任务执行周期 <code>periodNanos</code> ，在执行任务会略有不同。当然，大体是相同的。</li>
<li>第 5 至 12 行：执行周期为“<strong>只执行一次</strong>”的定时任务。<ul>
<li>第 7 行：调用 <code>PromiseTask#setUncancellableInternal()</code> 方法，设置任务不可取消。具体的方法实现，我们在后续关于 Promise 的文章中分享。</li>
<li>第 9 行：【重要】调用 <code>Callable#call()</code> 方法，执行任务。</li>
<li>第 11 行：调用 <code>PromiseTask#setSuccessInternal(V result)</code> 方法，回调通知注册在定时任务上的监听器。为什么能这么做呢？因为 ScheduledFutureTask 继承了 PromiseTask 抽象类。</li>
</ul>
</li>
<li>第 13 至 38 行：执行周期为“<strong>固定周期</strong>”的定时任务。<ul>
<li>第 16 行：调用 <code>DefaultPromise#isCancelled()</code> 方法，判断任务是否已经取消。这一点，和【第 7 行】的代码，<strong>是不同的</strong>。具体的方法实现，我们在后续关于 Promise 的文章中分享。</li>
<li>第 18 行：【重要】调用 <code>Callable#call()</code> 方法，执行任务。</li>
<li>第 19 行：判断 EventExecutor 并未关闭。</li>
<li>第 20 至 26 行：计算下次定时执行的时间。不同的执行 <code>fixed</code> 方式，计算方式不同。其中【第 25 行】的 <code>- p</code> 的代码，因为 <code>p</code> 是负数，所以通过<strong>负负得正</strong>来计算。另外，这块会修改定时任务的 <code>deadlineNanos</code> 属性，从而变成新的定时任务执行时间。</li>
<li>第 28 行：和【第 16 行】的代码是<strong>一致</strong>的。</li>
<li>第 29 至 34 行：重新添加到定时任务队列 <code>scheduledTaskQueue</code> 中，等待下次定时执行。</li>
</ul>
</li>
<li>第 39 至 42 行：发生异常，调用 <code>PromiseTask#setFailureInternal(Throwable cause)</code> 方法，回调通知注册在定时任务上的监听器。</li>
</ul>
<h2 id="2-7-cancel"><a href="#2-7-cancel" class="headerlink" title="2.7 cancel"></a>2.7 cancel</h2><p>有两个方法，可以取消定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> canceled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="comment">// 取消成功，移除出定时任务队列</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) {</span><br><span class="line">        ((AbstractScheduledEventExecutor) executor()).removeScheduled(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> canceled;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除任务</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancelWithoutRemove</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>差别在于，是否 调用 <code>AbstractScheduledEventExecutor#removeScheduled(ScheduledFutureTask)</code> 方法，从定时任务队列移除自己。</li>
</ul>
<h2 id="2-8-compareTo"><a href="#2-8-compareTo" class="headerlink" title="2.8 compareTo"></a>2.8 compareTo</h2><p><code>#compareTo(Delayed o)</code> 方法，用于队列( ScheduledFutureTask 使用 PriorityQueue 作为<strong>优先级队列</strong> )排序。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;</span><br><span class="line">    <span class="keyword">long</span> d = deadlineNanos() - that.deadlineNanos();</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (id &lt; that.id) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (id == that.id) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>按照 <code>deadlineNanos</code>、<code>id</code> 属性<strong>升序</strong>排序。</li>
</ul>
<h2 id="2-9-priorityQueueIndex"><a href="#2-9-priorityQueueIndex" class="headerlink" title="2.9 priorityQueueIndex"></a>2.9 priorityQueueIndex</h2><p><code>#priorityQueueIndex(...)</code> 方法，获得或设置 <code>queueIndex</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priorityQueueIndex</span><span class="params">(DefaultPriorityQueue&lt;?&gt; queue)</span> </span>{ <span class="comment">// 获得</span></span><br><span class="line">    <span class="keyword">return</span> queueIndex;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priorityQueueIndex</span><span class="params">(DefaultPriorityQueue&lt;?&gt; queue, <span class="keyword">int</span> i)</span> </span>{ <span class="comment">// 设置</span></span><br><span class="line">    queueIndex = i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 ScheduledFutureTask 实现 PriorityQueueNode 接口，所以需要实现这两个方法。</li>
</ul>
<h1 id="3-AbstractScheduledEventExecutor"><a href="#3-AbstractScheduledEventExecutor" class="headerlink" title="3. AbstractScheduledEventExecutor"></a>3. AbstractScheduledEventExecutor</h1><p><code>io.netty.util.concurrent.AbstractScheduledEventExecutor</code> ，继承 AbstractEventExecutor 抽象类，<strong>支持定时任务</strong>的 EventExecutor 的抽象类。</p>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时任务队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractScheduledEventExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractScheduledEventExecutor</span><span class="params">(EventExecutorGroup parent)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>scheduledTaskQueue</code> 属性，定时任务队列。</li>
</ul>
<h2 id="3-2-scheduledTaskQueue"><a href="#3-2-scheduledTaskQueue" class="headerlink" title="3.2 scheduledTaskQueue"></a>3.2 scheduledTaskQueue</h2><p><code>#scheduledTaskQueue()</code> 方法，获得定时任务队列。若未初始化，则进行创建。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时任务排序器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;ScheduledFutureTask&lt;?&gt;&gt; SCHEDULED_FUTURE_TASK_COMPARATOR =</span><br><span class="line">        <span class="keyword">new</span> Comparator&lt;ScheduledFutureTask&lt;?&gt;&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ScheduledFutureTask&lt;?&gt; o1, ScheduledFutureTask&lt;?&gt; o2)</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2); <span class="comment">//</span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() {</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="keyword">null</span>) {</span><br><span class="line">        scheduledTaskQueue = <span class="keyword">new</span> DefaultPriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;(</span><br><span class="line">                SCHEDULED_FUTURE_TASK_COMPARATOR,</span><br><span class="line">                <span class="comment">// Use same initial capacity as java.util.PriorityQueue</span></span><br><span class="line">                <span class="number">11</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的队列是 <code>io.netty.util.internal.DefaultPriorityQueue</code> 类型。具体的代码实现，本文先不解析。在这里，我们只要知道它是一个<strong>优先级</strong>队列，通过 <code>SCHEDULED_FUTURE_TASK_COMPARATOR</code> 来比较排序 ScheduledFutureTask 的任务优先级( 顺序 )。</li>
<li><code>SCHEDULED_FUTURE_TASK_COMPARATOR</code> 的具体实现，是调用 <a href="#">「2.8 compareTo」</a> 方法来实现，所以队列<strong>首个</strong>任务，就是<strong>第一个</strong>需要执行的定时任务。</li>
</ul>
<h2 id="3-3-nanoTime"><a href="#3-3-nanoTime" class="headerlink" title="3.3 nanoTime"></a>3.3 nanoTime</h2><p><code>#nanoTime()</code> <strong>静态</strong>方法，获得当前时间。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ScheduledFutureTask.nanoTime();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用 <a href="#">「2.2 nanoTime」</a> 方法。</li>
</ul>
<h2 id="3-4-schedule"><a href="#3-4-schedule" class="headerlink" title="3.4 schedule"></a>3.4 schedule</h2><p><code>#schedule(final ScheduledFutureTask&lt;V&gt; task)</code> 方法，提交定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) {</span><br><span class="line">        <span class="comment">// 添加到定时任务队列</span></span><br><span class="line">        scheduledTaskQueue().add(task);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 通过 EventLoop 的线程，添加到定时任务队列</span></span><br><span class="line">        execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                scheduledTaskQueue().add(task);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>必须在 EventLoop 的线程中，<strong>才能</strong>添加到定时任务到队列中。</li>
</ul>
<p>在 ScheduledFutureTask 中，有四个方法，会调用 <code>#schedule(final ScheduledFutureTask&lt;V&gt; task)</code> 方法，分别创建 <strong>3</strong> 种不同类型的定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>{</span><br><span class="line">    ObjectUtil.checkNotNull(callable, <span class="string">"callable"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>) {</span><br><span class="line">        delay = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 无视，已经废弃</span></span><br><span class="line">    validateScheduled0(delay, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schedule(<span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(</span><br><span class="line">            <span class="keyword">this</span>, callable, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) {</span><br><span class="line">    ObjectUtil.checkNotNull(command, <span class="string">"command"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">    <span class="keyword">if</span> (initialDelay &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"initialDelay: %d (expected: &gt;= 0)"</span>, initialDelay));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"period: %d (expected: &gt; 0)"</span>, period));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 无视，已经废弃</span></span><br><span class="line">    validateScheduled0(initialDelay, unit);</span><br><span class="line">    validateScheduled0(period, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schedule(<span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">            <span class="keyword">this</span>, Executors.&lt;Void&gt;callable(command, <span class="keyword">null</span>), <span class="comment">// Runnable =&gt; Callable</span></span><br><span class="line">            ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), unit.toNanos(period)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) {</span><br><span class="line">    ObjectUtil.checkNotNull(command, <span class="string">"command"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">    <span class="keyword">if</span> (initialDelay &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"initialDelay: %d (expected: &gt;= 0)"</span>, initialDelay));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"delay: %d (expected: &gt; 0)"</span>, delay));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 无视，已经废弃</span></span><br><span class="line">    validateScheduled0(initialDelay, unit);</span><br><span class="line">    validateScheduled0(delay, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schedule(<span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">            <span class="keyword">this</span>, Executors.&lt;Void&gt;callable(command, <span class="keyword">null</span>), <span class="comment">// Runnable =&gt; Callable</span></span><br><span class="line">            ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), -unit.toNanos(delay)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个方法，前面都是校验参数的代码，重点是在最后对 <code>#schedule(final ScheduledFutureTask&lt;V&gt; task)</code> 方法的调用。</li>
</ul>
<h2 id="3-5-removeScheduled"><a href="#3-5-removeScheduled" class="headerlink" title="3.5 removeScheduled"></a>3.5 removeScheduled</h2><p><code>#removeScheduled(final ScheduledFutureTask&lt;?&gt; task)</code> 方法，移除出定时任务队列。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeScheduled</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;?&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) {</span><br><span class="line">        <span class="comment">// 移除出定时任务队列</span></span><br><span class="line">        scheduledTaskQueue().removeTyped(task);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 通过 EventLoop 的线程，移除出定时任务队列</span></span><br><span class="line">        execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                removeScheduled(task);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>必须在 EventLoop 的线程中，<strong>才能</strong>移除出定时任务队列。</li>
</ul>
<h2 id="3-6-hasScheduledTasks"><a href="#3-6-hasScheduledTasks" class="headerlink" title="3.6 hasScheduledTasks"></a>3.6 hasScheduledTasks</h2><p><code>#hasScheduledTasks()</code> 方法，判断是否有可执行的定时任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if a scheduled task is ready for processing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasScheduledTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    <span class="comment">// 获得队列首个定时任务。不会从队列中，移除该任务</span></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == <span class="keyword">null</span> ? <span class="keyword">null</span> : scheduledTaskQueue.peek();</span><br><span class="line">    <span class="comment">// 判断该任务是否到达可执行的时间</span></span><br><span class="line">    <span class="keyword">return</span> scheduledTask != <span class="keyword">null</span> &amp;&amp; scheduledTask.deadlineNanos() &lt;= nanoTime();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友直接看方法注释。</li>
</ul>
<h2 id="3-7-peekScheduledTask"><a href="#3-7-peekScheduledTask" class="headerlink" title="3.7 peekScheduledTask"></a>3.7 peekScheduledTask</h2><p><code>#peekScheduledTask()</code> 方法，获得队列首个定时任务。不会从队列中，移除该任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ScheduledFutureTask&lt;?&gt; peekScheduledTask() {</span><br><span class="line">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue.peek();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-8-nextScheduledTaskNano"><a href="#3-8-nextScheduledTaskNano" class="headerlink" title="3.8 nextScheduledTaskNano"></a>3.8 nextScheduledTaskNano</h2><p><code>#nextScheduledTaskNano()</code> 方法，获得定时任务队列，距离当前时间，还要多久可执行。</p>
<ul>
<li>若队列<strong>为空</strong>，则返回 <code>-1</code> 。</li>
<li>若队列<strong>非空</strong>，若为负数，直接返回 0 。实际等价，ScheduledFutureTask#delayNanos() 方法。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the nanoseconds when the next scheduled task is ready to be run or {<span class="doctag">@code</span> -1} if no task is scheduled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextScheduledTaskNano</span><span class="params">()</span> </span>{</span><br><span class="line">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    <span class="comment">// 获得队列首个定时任务。不会从队列中，移除该任务</span></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == <span class="keyword">null</span> ? <span class="keyword">null</span> : scheduledTaskQueue.peek();</span><br><span class="line">    <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 距离当前时间，还要多久可执行。若为负数，直接返回 0 。实际等价，ScheduledFutureTask#delayNanos() 方法。</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>, scheduledTask.deadlineNanos() - nanoTime());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>基本可以等价 <a href="#">「2.5 delayNanos」</a> 的方法。</li>
</ul>
<h2 id="3-9-pollScheduledTask"><a href="#3-9-pollScheduledTask" class="headerlink" title="3.9 pollScheduledTask"></a>3.9 pollScheduledTask</h2><p><code>#pollScheduledTask(...)</code> 方法，获得指定时间内，定时任务队列<strong>首个</strong>可执行的任务，并且从队列中移除。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #pollScheduledTask(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Runnable <span class="title">pollScheduledTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> pollScheduledTask(nanoTime()); <span class="comment">// 当前时间</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> Runnable} which is ready to be executed with the given {<span class="doctag">@code</span> nanoTime}.</span></span><br><span class="line"><span class="comment"> * You should use {<span class="doctag">@link</span> #nanoTime()} to retrieve the correct {<span class="doctag">@code</span> nanoTime}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Runnable <span class="title">pollScheduledTask</span><span class="params">(<span class="keyword">long</span> nanoTime)</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    <span class="comment">// 获得队列首个定时任务。不会从队列中，移除该任务</span></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == <span class="keyword">null</span> ? <span class="keyword">null</span> : scheduledTaskQueue.peek();</span><br><span class="line">    <span class="comment">// 直接返回，若获取不到</span></span><br><span class="line">    <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定时间内，则返回该任务</span></span><br><span class="line">    <span class="keyword">if</span> (scheduledTask.deadlineNanos() &lt;= nanoTime) {</span><br><span class="line">        scheduledTaskQueue.remove(); <span class="comment">// 移除任务</span></span><br><span class="line">        <span class="keyword">return</span> scheduledTask;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-10-cancelScheduledTasks"><a href="#3-10-cancelScheduledTasks" class="headerlink" title="3.10 cancelScheduledTasks"></a>3.10 cancelScheduledTasks</h2><p><code>#cancelScheduledTasks()</code> 方法，取消定时任务队列的所有任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancel all scheduled tasks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method MUST be called only when {<span class="doctag">@link</span> #inEventLoop()} is {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cancelScheduledTasks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若队列为空，直接返回</span></span><br><span class="line">    PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    <span class="keyword">if</span> (isNullOrEmpty(scheduledTaskQueue)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环，取消所有任务</span></span><br><span class="line">    <span class="keyword">final</span> ScheduledFutureTask&lt;?&gt;[] scheduledTasks = scheduledTaskQueue.toArray(<span class="keyword">new</span> ScheduledFutureTask&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ScheduledFutureTask&lt;?&gt; task : scheduledTasks) {</span><br><span class="line">        task.cancelWithoutRemove(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    scheduledTaskQueue.clearIgnoringIndexes();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNullOrEmpty</span><span class="params">(Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; queue)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> queue == <span class="keyword">null</span> || queue.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。</li>
</ul>
<h1 id="4-SingleThreadEventExecutor"><a href="#4-SingleThreadEventExecutor" class="headerlink" title="4. SingleThreadEventExecutor"></a>4. SingleThreadEventExecutor</h1><p>在 <a href="http://svip.iocoder.cn/Netty/EventLoop-6-EventLoop-handle-normal-task?self">《精尽 Netty 源码解析 —— EventLoop（六）之 EventLoop 处理普通任务》</a> 中，有个 <code>#fetchFromScheduledTaskQueue()</code> 方法，将定时任务队列 <code>scheduledTaskQueue</code> 到达可执行的任务，添加到任务队列 <code>taskQueue</code> 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchFromScheduledTaskQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获得当前时间</span></span><br><span class="line">    <span class="keyword">long</span> nanoTime = AbstractScheduledEventExecutor.nanoTime();</span><br><span class="line">    <span class="comment">// 获得指定时间内，定时任务队列**首个**可执行的任务，并且从队列中移除。</span></span><br><span class="line">    Runnable scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">    <span class="comment">// 不断从定时任务队列中，获得</span></span><br><span class="line">    <span class="keyword">while</span> (scheduledTask != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 将定时任务添加到 taskQueue 中。若添加失败，则结束循环，返回 false ，表示未获取完所有课执行的定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (!taskQueue.offer(scheduledTask)) {</span><br><span class="line">            <span class="comment">// 将定时任务添加回 scheduledTaskQueue 中</span></span><br><span class="line">            <span class="comment">// No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span></span><br><span class="line">            scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获得指定时间内，定时任务队列**首个**可执行的任务，并且从队列中移除。</span></span><br><span class="line">        scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回 true ，表示获取完所有可执行的定时任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友看下笔者的详细代码注释。哈哈哈</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>没有彩蛋，简单水文一篇。</p>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-7-EventLoop-handle-schedule-task/" data-id="ck4pl3fox00difgcfymj1f461" class="article-share-link">分享</a>

</footer>
-->
</div>
