<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Channel（五）之 flush 操作
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接 <a href="http://svip.iocoder.cn/Netty/Channel-4-write/">《精尽 Netty 源码解析 —— Channel（四）之 write 操作》</a> ，分享 Netty Channel 的 <code>#flush()</code> 方法，刷新<strong>内存队列</strong>，将其中的数据写入到对端。</p>
<p>在本文中，我们会发现，<code>#flush()</code> 方法和 <code>#write(Object msg, ...)</code> <strong>正常</strong>情况下，经历的流程是<strong>差不多</strong>的，例如在 pipeline 中对事件的传播，从 <code>tail</code> 节点传播到 <code>head</code> 节点，最终交由 Unsafe 处理，而差异点就是 Unsafe 的处理方式<strong>不同</strong>：</p>
<ul>
<li>write 方法：将数据写到<strong>内存队列</strong>中。</li>
<li>flush 方法：刷新<strong>内存队列</strong>，将其中的数据写入到对端。</li>
</ul>
<p>当然，上述描述仅仅指的是<strong>正常</strong>情况下，在<strong>异常</strong>情况下会有所不同。我们知道，Channel 大多数情况下是<strong>可写</strong>的，所以不需要专门去注册 <code>SelectionKey.OP_WRITE</code> 事件。所以在 Netty 的实现中，默认 Channel 是<strong>可写</strong>的，当写入失败的时候，再去注册 <code>SelectionKey.OP_WRITE</code> 事件。这意味着什么呢？在 <code>#flush()</code> 方法中，如果写入数据到 Channel 失败，会通过注册 <code>SelectionKey.OP_WRITE</code> 事件，然后在轮询到 Channel <strong>可写</strong> 时，再“回调” <code>#forceFlush()</code> 方法。</p>
<p>是不是非常巧妙？！让我直奔代码，大口吃肉，潇洒撸码。</p>
<blockquote>
<p>下文的 <a href="#">「2.」</a>、<a href="#">「3.」</a>、<a href="#">「4.」</a>、<a href="#">「5.」</a> 和 <a href="http://svip.iocoder.cn/Netty/Channel-4-write">《精尽 Netty 源码解析 —— Channel（四）之 write 操作》</a> 非常<strong>类似</strong>，所以胖友可以快速浏览。真正的<strong>差异</strong>，从 <a href="#">「6.」</a> 开始。</p>
</blockquote>
<h1 id="2-AbstractChannel"><a href="#2-AbstractChannel" class="headerlink" title="2. AbstractChannel"></a>2. AbstractChannel</h1><p>AbstractChannel 对 <code>#flush()</code> 方法的实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line">    pipeline.flush();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用对应的 <code>ChannelPipeline#flush()</code> 方法，将 flush 事件在 pipeline 上传播。详细解析，见 <a href="#">「3. DefaultChannelPipeline」</a> 。<ul>
<li>最终会传播 flush 事件到 <code>head</code> 节点，刷新<strong>内存队列</strong>，将其中的数据写入到对端。详细解析，见 <a href="#">「5. HeadContext」</a> 。</li>
</ul>
</li>
</ul>
<h1 id="3-DefaultChannelPipeline"><a href="#3-DefaultChannelPipeline" class="headerlink" title="3. DefaultChannelPipeline"></a>3. DefaultChannelPipeline</h1><p><code>DefaultChannelPipeline#flush()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line">    tail.flush();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用 <code>TailContext#flush()</code> 方法，将 flush 事件在 pipeline 中，从尾节点向头节点传播。详细解析，见 <a href="#">「4. TailContext」</a> 。</li>
</ul>
<h1 id="4-TailContext"><a href="#4-TailContext" class="headerlink" title="4. TailContext"></a>4. TailContext</h1><p>TailContext 对 <code>TailContext#flush()</code> 方法的实现，是从 AbstractChannelHandlerContext 抽象类继承，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 获得下一个 Outbound 节点</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line"> <span class="number">5</span>:     EventExecutor executor = next.executor();</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 在 EventLoop 的线程中</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (executor.inEventLoop()) {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 执行 flush 事件到下一个节点</span></span><br><span class="line"> <span class="number">9</span>:         next.invokeFlush();</span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 不在 EventLoop 的线程中</span></span><br><span class="line"><span class="number">11</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 创建 flush 任务</span></span><br><span class="line"><span class="number">13</span>:         Runnable task = next.invokeFlushTask;</span><br><span class="line"><span class="number">14</span>:         <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">15</span>:             next.invokeFlushTask = task = <span class="keyword">new</span> Runnable() {</span><br><span class="line"><span class="number">16</span>:                 <span class="meta">@Override</span></span><br><span class="line"><span class="number">17</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">18</span>:                     next.invokeFlush();</span><br><span class="line"><span class="number">19</span>:                 }</span><br><span class="line"><span class="number">20</span>:             };</span><br><span class="line"><span class="number">21</span>:         }</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 提交到 EventLoop 的线程中，执行该任务</span></span><br><span class="line"><span class="number">23</span>:         safeExecute(executor, task, channel().voidPromise(), <span class="keyword">null</span>);</span><br><span class="line"><span class="number">24</span>:     }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">27</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：调用 <code>#findContextOutbound()</code> 方法，获得<strong>下一个</strong> Outbound 节点。</li>
<li>第 7 行：<strong>在</strong> EventLoop 的线程中。<ul>
<li>第 12 至 15 行：调用 <code>AbstractChannelHandlerContext#invokeFlush()()</code> 方法，执行 flush 事件到下一个节点。</li>
<li>后续的逻辑，和 <a href="http://svip.iocoder.cn/Netty/Pipeline-4-outbound/">《精尽 Netty 源码解析 —— ChannelPipeline（四）之 Outbound 事件的传播》</a> 分享的 <strong>bind</strong> 事件在 pipeline 中的传播是<strong>基本一致</strong>的。</li>
<li>随着 flush <strong>事件</strong>不断的向下一个节点传播，最终会到达 HeadContext 节点。详细解析，见 <a href="#">「5. HeadContext」</a> 。</li>
</ul>
</li>
<li>第 16 行：<strong>不在</strong> EventLoop 的线程中。<ul>
<li>第 12 至 21 行：创建 flush 任务。该任务的内部的调用【第 18 行】的代码，和【第 9 行】的代码是<strong>一致</strong>的。</li>
<li>第 23 行：调用 <code>#safeExecute(executor, task, promise, m)</code> 方法，提交到 EventLoop 的线程中，执行该任务。从而实现，<strong>在</strong> EventLoop 的线程中，执行 flush 事件到下一个节点。</li>
</ul>
</li>
</ul>
<h1 id="5-HeadContext"><a href="#5-HeadContext" class="headerlink" title="5. HeadContext"></a>5. HeadContext</h1><p>在 pipeline 中，flush 事件最终会到达 HeadContext 节点。而 HeadContext 的 <code>#flush()</code> 方法，会处理该事件，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.flush();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用 <code>AbstractUnsafe#flush()</code> 方法，刷新<strong>内存队列</strong>，将其中的数据写入到对端。详细解析，见 <a href="#">「6. AbstractUnsafe」</a> 。</li>
</ul>
<h1 id="6-AbstractUnsafe"><a href="#6-AbstractUnsafe" class="headerlink" title="6. AbstractUnsafe"></a>6. AbstractUnsafe</h1><p><code>AbstractUnsafe#flush()</code> 方法，刷新<strong>内存队列</strong>，将其中的数据写入到对端。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     assertEventLoop();</span><br><span class="line"> <span class="number">4</span>: </span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 内存队列为 null ，一般是 Channel 已经关闭，所以直接返回。</span></span><br><span class="line"> <span class="number">6</span>:     ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">9</span>:     }</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 标记内存队列开始 flush</span></span><br><span class="line"><span class="number">12</span>:     outboundBuffer.addFlush();</span><br><span class="line"><span class="number">13</span>:     <span class="comment">// 执行 flush</span></span><br><span class="line"><span class="number">14</span>:     flush0();</span><br><span class="line"><span class="number">15</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 至 9 行：内存队列为 <code>null</code> ，一般是 Channel <strong>已经关闭</strong>，所以直接返回。</li>
<li>第 12 行：调用 <code>ChannelOutboundBuffer#addFlush()</code> 方法，标记内存队列开始 <strong>flush</strong> 。详细解析，见 <a href="#">「8.4 addFlush」</a> 。</li>
<li><p>第 14 行：调用 <code>#flush0()</code> 方法，执行 flush 操作。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否正在 flush 中，即正在调用 {<span class="doctag">@link</span> #flush0()} 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> inFlush0;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="number">3</span>:     <span class="comment">// 正在 flush 中，所以直接返回。</span></span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (inFlush0) {</span><br><span class="line">  <span class="number">5</span>:         <span class="comment">// Avoid re-entrance</span></span><br><span class="line">  <span class="number">6</span>:         <span class="keyword">return</span>;</span><br><span class="line">  <span class="number">7</span>:     }</span><br><span class="line">  <span class="number">8</span>: </span><br><span class="line">  <span class="number">9</span>:     <span class="comment">// 内存队列为 null ，一般是 Channel 已经关闭，所以直接返回。</span></span><br><span class="line"> <span class="number">10</span>:     <span class="comment">// 内存队列为空，无需 flush ，所以直接返回</span></span><br><span class="line"> <span class="number">11</span>:     <span class="keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line"> <span class="number">12</span>:     <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span> || outboundBuffer.isEmpty()) {</span><br><span class="line"> <span class="number">13</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">14</span>:     }</span><br><span class="line"> <span class="number">15</span>: </span><br><span class="line"> <span class="number">16</span>:     <span class="comment">// 标记正在 flush 中。</span></span><br><span class="line"> <span class="number">17</span>:     inFlush0 = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">18</span>: </span><br><span class="line"> <span class="number">19</span>:     <span class="comment">// 若未激活，通知 flush 失败</span></span><br><span class="line"> <span class="number">20</span>:     <span class="comment">// Mark all pending write requests as failure if the channel is inactive.</span></span><br><span class="line"> <span class="number">21</span>:     <span class="keyword">if</span> (!isActive()) {</span><br><span class="line"> <span class="number">22</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">23</span>:             <span class="keyword">if</span> (isOpen()) {</span><br><span class="line"> <span class="number">24</span>:                 outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">25</span>:             } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">26</span>:                 <span class="comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span></span><br><span class="line"> <span class="number">27</span>:                 outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line"> <span class="number">28</span>:             }</span><br><span class="line"> <span class="number">29</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">30</span>:             <span class="comment">// 标记不在 flush 中。</span></span><br><span class="line"> <span class="number">31</span>:             inFlush0 = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">32</span>:         }</span><br><span class="line"> <span class="number">33</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">34</span>:     }</span><br><span class="line"> <span class="number">35</span>: </span><br><span class="line"> <span class="number">36</span>:     <span class="comment">// 执行真正的写入到对端</span></span><br><span class="line"> <span class="number">37</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">38</span>:         doWrite(outboundBuffer);</span><br><span class="line"> <span class="number">39</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"> <span class="number">40</span>:         <span class="comment">// TODO 芋艿 细节</span></span><br><span class="line"> <span class="number">41</span>:         <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException &amp;&amp; config().isAutoClose()) {</span><br><span class="line"> <span class="number">42</span>:             <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 43:              * Just call {<span class="doctag">@link</span> #close(ChannelPromise, Throwable, boolean)} here which will take care of</span></span><br><span class="line"><span class="comment"> 44:              * failing all flushed messages and also ensure the actual close of the underlying transport</span></span><br><span class="line"><span class="comment"> 45:              * will happen before the promises are notified.</span></span><br><span class="line"><span class="comment"> 46:              *</span></span><br><span class="line"><span class="comment"> 47:              * This is needed as otherwise {<span class="doctag">@link</span> #isActive()} , {<span class="doctag">@link</span> #isOpen()} and {<span class="doctag">@link</span> #isWritable()}</span></span><br><span class="line"><span class="comment"> 48:              * may still return {<span class="doctag">@code</span> true} even if the channel should be closed as result of the exception.</span></span><br><span class="line"><span class="comment"> 49:              */</span></span><br><span class="line"> <span class="number">50</span>:             close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line"> <span class="number">51</span>:         } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">52</span>:             <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">53</span>:                 shutdownOutput(voidPromise(), t);</span><br><span class="line"> <span class="number">54</span>:             } <span class="keyword">catch</span> (Throwable t2) {</span><br><span class="line"> <span class="number">55</span>:                 close(voidPromise(), t2, FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line"> <span class="number">56</span>:             }</span><br><span class="line"> <span class="number">57</span>:         }</span><br><span class="line"> <span class="number">58</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">59</span>:         <span class="comment">// 标记不在 flush 中。</span></span><br><span class="line"> <span class="number">60</span>:         inFlush0 = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">61</span>:     }</span><br><span class="line"> <span class="number">62</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>inFlush0</code> 字段，是否正在 flush 中，即正在调用 <code>#flush0()</code> 中。</li>
<li>第 3 至 7 行：正在 flush 中，所以直接返回。</li>
<li>第 9 至 14 行：<ul>
<li><code>outboundBuffer == null</code> ，内存队列为 <code>null</code> ，一般是 Channel 已经<strong>关闭</strong>，所以直接返回。</li>
<li><code>outboundBuffer.isEmpty()</code> ，内存队列为空，无需 flush ，所以直接返回。</li>
</ul>
</li>
<li>第 17 行：设置 <code>inFlush0</code> 为 <code>true</code> ，表示正在 flush 中。</li>
<li>第 19 至 34 行：调用 <code>#isActive()</code> 方法，发现 Channel <strong>未激活</strong>，在根据 Channel <strong>是否打开</strong>，调用 <code>ChannelOutboundBuffer#failFlushed(Throwable cause, boolean notify)</code> 方法，通知 flush 失败<strong>异常</strong>。详细解析，见 <a href="#">「8.6 failFlushed」</a> 。<ul>
<li>第 29 至 33 行：最终，设置 <code>inFlush0</code> 为 <code>false</code> ，表示结束 flush 操作，最后 <code>return</code> 返回。</li>
</ul>
</li>
<li>第 38 行：调用 <code>AbstractChannel#doWrite(outboundBuffer)</code> 方法，<strong>执行真正的写入到对端</strong>。详细解析，见 <a href="#">「7. NioSocketChannel」</a> 。<ul>
<li>第 39 至 57 行：TODO 芋艿 细节</li>
<li>第 58 至 61 行：同【第 29 至 33】的代码和目的。</li>
</ul>
</li>
</ul>
</li>
<li><p>实际上，AbstractNioUnsafe <strong>重写</strong>了 <code>#flush0()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Flush immediately only when there's no pending flush.</span></span><br><span class="line">    <span class="comment">// If there's a pending flush operation, event loop will call forceFlush() later,</span></span><br><span class="line">    <span class="comment">// and thus there's no need to call it now.</span></span><br><span class="line">    <span class="keyword">if</span> (!isFlushPending()) {</span><br><span class="line">        <span class="keyword">super</span>.flush0();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>在执行父类 AbstractUnsafe 的 <code>#flush0()</code> 方法时，先调用 <code>AbstractNioUnsafe#isFlushPending()</code> 判断，是否已经处于 flush <strong>准备</strong>中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFlushPending</span><span class="params">()</span> </span>{</span><br><span class="line">    SelectionKey selectionKey = selectionKey();</span><br><span class="line">    <span class="keyword">return</span> selectionKey.isValid() <span class="comment">// 合法</span></span><br><span class="line">            &amp;&amp; (selectionKey.interestOps() &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>; <span class="comment">// 对 SelectionKey.OP_WRITE 事件不感兴趣。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>是不是有点懵 x ？在文初，我们提到：“所以在 Netty 的实现中，默认 Channel 是<strong>可写</strong>的，当写入失败的时候，再去注册 <code>SelectionKey.OP_WRITE</code> 事件。这意味着什么呢？在 <code>#flush()</code> 方法中，如果写入数据到 Channel 失败，会通过注册 <code>SelectionKey.OP_WRITE</code> 事件，然后在轮询到 Channel <strong>可写</strong> 时，再“回调” <code>#forceFlush()</code> 方法”。</li>
<li>这就是这段代码的目的，如果处于对 <code>SelectionKey.OP_WRITE</code> 事件感兴趣，说明 Channel 此时是<strong>不可写</strong>的，那么调用父类 AbstractUnsafe 的 <code>#flush0()</code> 方法，<strong>也没有意义</strong>，所以就不调用。</li>
<li>😈 逻辑上，略微有点复杂，胖友好好理解下。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="7-NioSocketChannel"><a href="#7-NioSocketChannel" class="headerlink" title="7. NioSocketChannel"></a>7. NioSocketChannel</h1><p><code>AbstractChannel#doWrite(ChannelOutboundBuffer in)</code> <strong>抽象</strong>方法，<strong>执行真正的写入到对端</strong>。定义在 AbstractChannel <strong>抽象</strong>类中，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush the content of the given buffer to the remote peer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>NioSocketChannel 对该<strong>抽象</strong>方法，实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">3</span>:     SocketChannel ch = javaChannel();</span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得自旋写入次数</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">do</span> {</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 内存队列为空，结束循环，直接返回</span></span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (in.isEmpty()) {</span><br><span class="line"> <span class="number">9</span>:             <span class="comment">// 取消对 SelectionKey.OP_WRITE 的感兴趣</span></span><br><span class="line"><span class="number">10</span>:             <span class="comment">// All written so clear OP_WRITE</span></span><br><span class="line"><span class="number">11</span>:             clearOpWrite();</span><br><span class="line"><span class="number">12</span>:             <span class="comment">// Directly return here so incompleteWrite(...) is not called.</span></span><br><span class="line"><span class="number">13</span>:             <span class="keyword">return</span>;</span><br><span class="line"><span class="number">14</span>:         }</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:         <span class="comment">// 获得每次写入的最大字节数</span></span><br><span class="line"><span class="number">17</span>:         <span class="comment">// Ensure the pending writes are made of ByteBufs only.</span></span><br><span class="line"><span class="number">18</span>:         <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line"><span class="number">19</span>:         <span class="comment">// 从内存队列中，获得要写入的 ByteBuffer 数组</span></span><br><span class="line"><span class="number">20</span>:         ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line"><span class="number">21</span>:         <span class="comment">// 写入的 ByteBuffer 数组的个数</span></span><br><span class="line"><span class="number">22</span>:         <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</span><br><span class="line"><span class="number">23</span>: </span><br><span class="line"><span class="number">24</span>:         <span class="comment">// 写入 ByteBuffer 数组，到对端</span></span><br><span class="line"><span class="number">25</span>:         <span class="comment">// Always us nioBuffers() to workaround data-corruption.</span></span><br><span class="line"><span class="number">26</span>:         <span class="comment">// See https://github.com/netty/netty/issues/2761</span></span><br><span class="line"><span class="number">27</span>:         <span class="keyword">switch</span> (nioBufferCnt) {</span><br><span class="line"><span class="number">28</span>:             <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="number">29</span>:                 <span class="comment">// 芋艿 TODO 1014 扣 doWrite0 的细节</span></span><br><span class="line"><span class="number">30</span>:                 <span class="comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span></span><br><span class="line"><span class="number">31</span>:                 writeSpinCount -= doWrite0(in);</span><br><span class="line"><span class="number">32</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">33</span>:             <span class="keyword">case</span> <span class="number">1</span>: {</span><br><span class="line"><span class="number">34</span>:                 <span class="comment">// Only one ByteBuf so use non-gathering write</span></span><br><span class="line"><span class="number">35</span>:                 <span class="comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span></span><br><span class="line"><span class="number">36</span>:                 <span class="comment">// to check if the total size of all the buffers is non-zero.</span></span><br><span class="line"><span class="number">37</span>:                 ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</span><br><span class="line"><span class="number">38</span>:                 <span class="keyword">int</span> attemptedBytes = buffer.remaining();</span><br><span class="line"><span class="number">39</span>:                 <span class="comment">// 执行 NIO write 调用，写入单个 ByteBuffer 对象到对端</span></span><br><span class="line"><span class="number">40</span>:                 <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</span><br><span class="line"><span class="number">41</span>:                 <span class="comment">// 写入字节小于等于 0 ，说明 NIO Channel 不可写，所以注册 SelectionKey.OP_WRITE ，等待 NIO Channel 可写，并返回以结束循环</span></span><br><span class="line"><span class="number">42</span>:                 <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) {</span><br><span class="line"><span class="number">43</span>:                     incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">44</span>:                     <span class="keyword">return</span>;</span><br><span class="line"><span class="number">45</span>:                 }</span><br><span class="line"><span class="number">46</span>:                 <span class="comment">// TODO 芋艿 调整每次写入的最大字节数</span></span><br><span class="line"><span class="number">47</span>:                 adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line"><span class="number">48</span>:                 <span class="comment">// 从内存队列中，移除已经写入的数据( 消息 )</span></span><br><span class="line"><span class="number">49</span>:                 in.removeBytes(localWrittenBytes);</span><br><span class="line"><span class="number">50</span>:                 <span class="comment">// 写入次数减一</span></span><br><span class="line"><span class="number">51</span>:                 --writeSpinCount;</span><br><span class="line"><span class="number">52</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">53</span>:             }</span><br><span class="line"><span class="number">54</span>:             <span class="keyword">default</span>: {</span><br><span class="line"><span class="number">55</span>:                 <span class="comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span></span><br><span class="line"><span class="number">56</span>:                 <span class="comment">// to check if the total size of all the buffers is non-zero.</span></span><br><span class="line"><span class="number">57</span>:                 <span class="comment">// We limit the max amount to int above so cast is safe</span></span><br><span class="line"><span class="number">58</span>:                 <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</span><br><span class="line"><span class="number">59</span>:                 <span class="comment">// 执行 NIO write 调用，写入多个 ByteBuffer 到对端</span></span><br><span class="line"><span class="number">60</span>:                 <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</span><br><span class="line"><span class="number">61</span>:                 <span class="comment">// 写入字节小于等于 0 ，说明 NIO Channel 不可写，所以注册 SelectionKey.OP_WRITE ，等待 NIO Channel 可写，并返回以结束循环</span></span><br><span class="line"><span class="number">62</span>:                 <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) {</span><br><span class="line"><span class="number">63</span>:                     incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">64</span>:                     <span class="keyword">return</span>;</span><br><span class="line"><span class="number">65</span>:                 }</span><br><span class="line"><span class="number">66</span>:                 <span class="comment">// TODO 芋艿 调整每次写入的最大字节数</span></span><br><span class="line"><span class="number">67</span>:                 <span class="comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span></span><br><span class="line"><span class="number">68</span>:                 adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line"><span class="number">69</span>:                 <span class="comment">// 从内存队列中，移除已经写入的数据( 消息 )</span></span><br><span class="line"><span class="number">70</span>:                 in.removeBytes(localWrittenBytes);</span><br><span class="line"><span class="number">71</span>:                 <span class="comment">// 写入次数减一</span></span><br><span class="line"><span class="number">72</span>:                 --writeSpinCount;</span><br><span class="line"><span class="number">73</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">74</span>:             }</span><br><span class="line"><span class="number">75</span>:         }</span><br><span class="line"><span class="number">76</span>:     } <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>); <span class="comment">// 循环自旋写入</span></span><br><span class="line"><span class="number">77</span>: </span><br><span class="line"><span class="number">78</span>:     <span class="comment">// 内存队列中的数据未完全写入，说明 NIO Channel 不可写，所以注册 SelectionKey.OP_WRITE ，等待 NIO Channel 可写</span></span><br><span class="line"><span class="number">79</span>:     incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line"><span class="number">80</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：调用 <code>#javaChannel()</code> 方法，获得 Java NIO <strong>原生</strong> SocketChannel 。</li>
<li><p>第 5 行：调用 <code>ChannelConfig#getWriteSpinCount()</code> 方法，获得<strong>自旋</strong>写入次数 N 。在【第 6 至 76 行】的代码，我们可以看到，不断<strong>自旋</strong>写入 N 次，直到完成写入结束。关于该配置项，官方注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the maximum loop count for a write operation until {<span class="doctag">@link</span> WritableByteChannel#write(ByteBuffer)} returns a non-zero value.</span></span><br><span class="line"><span class="comment"> * It is similar to what a spin lock is used for in concurrency programming.</span></span><br><span class="line"><span class="comment"> * It improves memory utilization and write throughput depending on the platform that JVM runs on.  The default value is {<span class="doctag">@code</span> 16}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWriteSpinCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认值为 <code>DefaultChannelConfig.writeSpinCount = 16</code> ，可配置修改，一般不需要。</li>
</ul>
</li>
<li>第 6 至 76 行：不断<strong>自旋</strong>写入 N 次，直到完成写入结束。</li>
<li><p>第 8 行：调用 <code>ChannelOutboundBuffer#isEmpty()</code> 方法，内存队列为空，结束循环，直接返回。</p>
<ul>
<li><p>第 10 行：因为在 Channel <strong>不可写</strong>的时候，会注册 <code>SelectionKey.OP_WRITE</code> ，等待 NIO Channel 可写。而后会”回调” <code>#forceFlush()</code> 方法，该方法内部也会调用 <code>#doWrite(ChannelOutboundBuffer in)</code> 方法。所以在完成内部队列的数据向对端写入时候，需要调用 <code>#clearOpWrite()</code>  方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clearOpWrite</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span></span><br><span class="line">    <span class="comment">// from the EventLoop</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/2104</span></span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) { <span class="comment">// 合法</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="comment">// 若注册了 SelectionKey.OP_WRITE ，则进行取消</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) {</span><br><span class="line">        key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 胖友看下代码注释。</li>
</ul>
</li>
</ul>
</li>
<li>第 18 行：调用 <code>NioSocketChannelConfig#getMaxBytesPerGatheringWrite()</code> 方法，获得每次写入的最大字节数。// TODO 芋艿 调整每次写入的最大字节数</li>
<li>第 20 行：调用 <code>ChannelOutboundBuffer#nioBuffers(int maxCount, long maxBytes)</code> 方法，从内存队列中，获得要写入的 ByteBuffer 数组。<strong>注意</strong>，如果内存队列中数据量很大，可能获得的仅仅是一部分数据。详细解析，见 <a href="#">「8.5 nioBuffers」</a> 。<ul>
<li>第 22 行：获得写入的 ByteBuffer 数组的个数。为什么不直接调用数组的 <code>#length()</code> 方法呢？因为返回的 ByteBuffer 数组是<strong>预先生成的数组缓存</strong>，存在不断重用的情况，所以不能直接使用 <code>#length()</code> 方法，而是要调用 <code>ChannelOutboundBuffer#nioBufferCount()</code> 方法，获得写入的 ByteBuffer 数组的个数。详细解析，见 <a href="#">「8.5 nioBuffers」</a> 。</li>
<li>后续根据 <code>nioBufferCnt</code> 的数值，分成<strong>三种</strong>情况。</li>
</ul>
</li>
<li><strong>(づ￣3￣)づ╭❤～ 第一种</strong>，<code>nioBufferCnt = 0</code> 。</li>
<li>芋艿 TODO 1014 扣 doWrite0 的细节，应该是内部的数据为 FileRegion ，可以暂时无视，不影响本文理解。</li>
<li><strong>(づ￣3￣)づ╭❤～ 第二种</strong>，<code>nioBufferCnt = 1</code> 。</li>
<li>第 40 行：调用 Java <strong>原生</strong> <code>SocketChannel#write(ByteBuffer buffer)</code> 方法，执行 NIO write 调用，写入<strong>单个</strong> ByteBuffer 对象到对端。</li>
<li><p>第 42 行：写入字节小于等于 0 ，说明 NIO Channel <strong>不可写</strong>，所以注册 <code>SelectionKey.OP_WRITE</code> ，等待 NIO Channel <strong>可写</strong>，并返回以结束循环。</p>
<ul>
<li><p>第 43 行：调用 <code>AbstractNioByteChannel#incompleteWrite(true)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incompleteWrite</span><span class="params">(<span class="keyword">boolean</span> setOpWrite)</span> </span>{</span><br><span class="line">    <span class="comment">// Did not write completely.</span></span><br><span class="line">    <span class="comment">// true ，注册对 SelectionKey.OP_WRITE 事件感兴趣</span></span><br><span class="line">    <span class="keyword">if</span> (setOpWrite) {</span><br><span class="line">        setOpWrite();</span><br><span class="line">    <span class="comment">// false ，取消对 SelectionKey.OP_WRITE 事件感兴趣</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then</span></span><br><span class="line">        <span class="comment">// use our write quantum. In this case we no longer want to set the write OP because the socket is still</span></span><br><span class="line">        <span class="comment">// writable (as far as we know). We will find out next time we attempt to write if the socket is writable</span></span><br><span class="line">        <span class="comment">// and set the write OP if necessary.</span></span><br><span class="line">        clearOpWrite();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Schedule flush again later so other tasks can be picked up in the meantime</span></span><br><span class="line">        <span class="comment">// 立即发起下一次 flush 任务</span></span><br><span class="line">        eventLoop().execute(flushTask); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>setOpWrite</code> 为 <code>true</code> ，调用 <code>#setOpWrite()</code> 方法，注册对 <code>SelectionKey.OP_WRITE</code> 事件感兴趣。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setOpWrite</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span></span><br><span class="line">    <span class="comment">// from the EventLoop</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/2104</span></span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) { <span class="comment">// 合法</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="comment">// 注册 SelectionKey.OP_WRITE 事件的感兴趣</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) {</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>【第 43 行】的代码，就是这种情况。</li>
</ul>
</li>
<li><code>setOpWrite</code> 为 <code>false</code> ，调用 <code>#clearOpWrite()</code> 方法，取消对 SelectionKey.OP_WRITE 事件感兴趣。而后，在 <code>&lt;1&gt;</code> 处，立即发起下一次 flush 任务。</li>
</ul>
</li>
</ul>
</li>
<li>第 47 行：TODO 芋艿 调整每次写入的最大字节数</li>
<li>第 49 行：调用 <code>ChannelOutboundBuffer#removeBytes(long writtenBytes)</code> 方法啊，从内存队列中，移除已经写入的数据( 消息 )。详细解析，见 <a href="#">「8.7 removeBytes」</a> 。</li>
<li>第 51 行：写入次数减一。</li>
<li><strong>(づ￣3￣)づ╭❤～ 第三种</strong>，<code>nioBufferCnt &gt; 1</code> 。和【第二种】基本相同，差别是在于【第 60 行】的代码，调用 Java <strong>原生</strong> <code>SocketChannel#write(ByteBuffer[] srcs, int offset, int length)</code> 方法，执行 NIO write 调用，写入<strong>多个</strong> ByteBuffer 对象到对端。😈 批量一次性写入，提升性能。</li>
<li>=========== 结束 ===========</li>
<li>第 79 行：通过 <code>writeSpinCount &lt; 0</code> 来判断，内存队列中的数据<strong>是否</strong>未完全写入。从目前逻辑看下来，笔者认为只会返回 <code>true</code> ，即内存队列中的数据未完全写入，说明 NIO Channel 不可写，所以注册 <code>SelectionKey.OP_WRITE</code> ，等待 NIO Channel 可写。因此，调用 <code>#incompleteWrite(true)</code> 方法。<ul>
<li>举个例子，最后一次写入，Channel 的缓冲区还剩下 10 字节可写，内存队列中剩余 90 字节，那么可以成功写入 10 字节，剩余 80 字节。😈  也就说，此时 Channel 不可写落。</li>
</ul>
</li>
</ul>
<h2 id="7-1-乱入"><a href="#7-1-乱入" class="headerlink" title="7.1 乱入"></a>7.1 乱入</h2><blockquote>
<p>老艿艿：临时插入下 AbstractNioByteChannel 和 AbstractNioMessageChannel 实现类对 <code>#doWrite(ChannelOutboundBuffer in)</code> 方法的实现。不感兴趣的胖友，可以直接跳过。</p>
</blockquote>
<p><strong>AbstractNioByteChannel</strong></p>
<p>虽然，AbstractNioByteChannel 实现了 <code>#doWrite(ChannelOutboundBuffer in)</code> 方法，但是子类 NioSocketChannel 又覆盖实现了该方法，所以可以忽略 AbstractNioByteChannel 的实现方法了。</p>
<p>那么为什么 AbstractNioByteChannel 会实现了 <code>#doWrite(ChannelOutboundBuffer in)</code> 方法呢？因为 NioUdtByteConnectorChannel 和 NioUdtByteRendezvousChannel 会使用到该方法。但是，这两个类已经被<strong>标记废弃</strong>，因为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">transport udt is deprecated and so the user knows it will be removed in the future.</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>来自 Netty 官方提交的注释说明。</li>
</ul>
<p><strong>AbstractNioMessageChannel</strong></p>
<p>虽然，AbstractNioMessageChannel 实现了 <code>#doWrite(ChannelOutboundBuffer in)</code> 方法，但是对于 NioServerSocketChannel 来说，暂时没有意义，因为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doWriteMessage</span><span class="params">(Object msg, ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">filterOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>两个方法，都是直接抛出 UnsupportedOperationException 异常。</li>
</ul>
<p>那么为什么 AbstractNioMessageChannel 会实现了 <code>#doWrite(ChannelOutboundBuffer in)</code> 方法呢？因为 NioDatagramChannel 和 NioSctpChannel <strong>等等</strong>会使用到该方法。感兴趣的胖友，可以自己研究下。</p>
<h1 id="8-ChannelOutboundBuffer"><a href="#8-ChannelOutboundBuffer" class="headerlink" title="8. ChannelOutboundBuffer"></a>8. ChannelOutboundBuffer</h1><p><code>io.netty.channel.ChannelOutboundBuffer</code> ，<strong>内存队列</strong>。</p>
<ul>
<li>在 write 操作时，将数据写到 ChannelOutboundBuffer 中。</li>
<li>在 flush 操作时，将 ChannelOutboundBuffer 的数据写入到对端。</li>
</ul>
<h2 id="8-1-Entry"><a href="#8-1-Entry" class="headerlink" title="8.1 Entry"></a>8.1 Entry</h2><p>在 write 操作时，将数据写到 ChannelOutboundBuffer 中，都会产生一个 Entry 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycler 对象，用于重用 Entry 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;Entry&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;Entry&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Entry <span class="title">newObject</span><span class="params">(Handle&lt;Entry&gt; handle)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Entry(handle);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycler 处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;Entry&gt; handle;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一条 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry next;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息（数据）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object msg;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #msg} 转化的 NIO ByteBuffer 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer[] bufs;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #msg} 转化的 NIO ByteBuffer 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer buf;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ChannelPromise promise;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已写入的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> progress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长度，可读字节数数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> total;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个 Entry 预计占用的内存大小，计算方式为消息( {<span class="doctag">@link</span> #msg} )的字节数 + Entry 对象自身占用内存的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pendingSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #msg} 转化的 NIO ByteBuffer 的数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当 = 1 时，使用 {<span class="doctag">@link</span> #buf}</span></span><br><span class="line"><span class="comment"> * 当 &gt; 1 时，使用 {<span class="doctag">@link</span> #bufs}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> count = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否取消写入对端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(Handle&lt;Entry&gt; handle)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>RECYCLER</code> <strong>静态</strong>属性，用于<strong>重用</strong> Entry 对象。<ul>
<li><code>handle</code> 属性，Recycler 处理器，用于<strong>回收</strong> Entry 对象。</li>
</ul>
</li>
<li><code>next</code> 属性，指向<strong>下一条</strong> Entry 。通过它，形成 ChannelOutboundBuffer 内部的链式存储<strong>每条写入数据</strong>的数据结构。</li>
<li><p><code>msg</code> 属性，写入的消息( 数据 )。</p>
<ul>
<li><code>promise</code> 属性，Promise 对象。当数据写入成功后，可以通过它回调通知结果。</li>
<li><p><code>total</code> 属性，长度，可读字节数。通过 <code>#total(Object msg)</code> 方法来计算。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">total</span><span class="params">(Object msg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) {</span><br><span class="line">        <span class="keyword">return</span> ((ByteBuf) msg).readableBytes();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) {</span><br><span class="line">        <span class="keyword">return</span> ((FileRegion) msg).count();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBufHolder) {</span><br><span class="line">        <span class="keyword">return</span> ((ByteBufHolder) msg).content().readableBytes();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从这个方法，我们看到，<code>msg</code> 的类型，有 ByteBuf、FileRegion、ByteBufHolder 。</li>
</ul>
</li>
<li><code>process</code> 属性，已写入的字节数。详细解析，见 <a href="#">「8.7.1 process」</a> 。</li>
</ul>
</li>
<li><code>count</code> 属性，<code>msg</code> 属性转化的 NIO ByteBuffer 的数量。<ul>
<li><code>bufs</code> 属性，当 <code>count &gt; 0</code> 时使用，表示 <code>msg</code> 属性转化的 NIO ByteBuffer 数组。</li>
<li><code>buf</code> 属性，当 <code>count = 0</code> 时使用，表示 <code>msg</code> 属性转化的 NIO ByteBuffer 对象。</li>
</ul>
</li>
<li><code>cancelled</code> 属性，是否取消写入对端。</li>
<li><code>pendingSize</code> 属性，每个 Entry 预计占用的内存大小，计算方式为消息( <code>msg</code> )的字节数 + Entry 对象自身占用内存的大小。</li>
</ul>
<h3 id="8-1-1-newInstance"><a href="#8-1-1-newInstance" class="headerlink" title="8.1.1 newInstance"></a>8.1.1 newInstance</h3><p><code>#newInstance(Object msg, int size, long total, ChannelPromise promise)</code> <strong>静态</strong>方法，创建 Entry 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Entry <span class="title">newInstance</span><span class="params">(Object msg, <span class="keyword">int</span> size, <span class="keyword">long</span> total, ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 Recycler 重用对象</span></span><br><span class="line">    Entry entry = RECYCLER.get();</span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    entry.msg = msg;</span><br><span class="line">    entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;</span><br><span class="line">    entry.total = total;</span><br><span class="line">    entry.promise = promise;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 Recycler 来<strong>重用</strong> Entry 对象。</li>
</ul>
<h3 id="8-1-2-recycle"><a href="#8-1-2-recycle" class="headerlink" title="8.1.2 recycle"></a>8.1.2 recycle</h3><p><code>#recycle()</code> 方法，<strong>回收</strong> Entry 对象，以为下次<strong>重用</strong>该对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 重置属性</span></span><br><span class="line">    next = <span class="keyword">null</span>;</span><br><span class="line">    bufs = <span class="keyword">null</span>;</span><br><span class="line">    buf = <span class="keyword">null</span>;</span><br><span class="line">    msg = <span class="keyword">null</span>;</span><br><span class="line">    promise = <span class="keyword">null</span>;</span><br><span class="line">    progress = <span class="number">0</span>;</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    pendingSize = <span class="number">0</span>;</span><br><span class="line">    count = -<span class="number">1</span>;</span><br><span class="line">    cancelled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 回收 Entry 对象</span></span><br><span class="line">    handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-1-3-recycleAndGetNext"><a href="#8-1-3-recycleAndGetNext" class="headerlink" title="8.1.3 recycleAndGetNext"></a>8.1.3 recycleAndGetNext</h3><p><code>#recycleAndGetNext()</code> 方法，获得下一个 Entry 对象，并<strong>回收</strong>当前 Entry 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Entry <span class="title">recycleAndGetNext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获得下一个 Entry 对象</span></span><br><span class="line">    Entry next = <span class="keyword">this</span>.next;</span><br><span class="line">    <span class="comment">// 回收当前 Entry 对象</span></span><br><span class="line">    recycle();</span><br><span class="line">    <span class="comment">// 返回下一个 Entry 对象</span></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-1-4-cancel"><a href="#8-1-4-cancel" class="headerlink" title="8.1.4 cancel"></a>8.1.4 cancel</h3><p><code>#cancel()</code> 方法，标记 Entry 对象，取消写入到对端。在 ChannelOutboundBuffer 里，Entry 数组是通过<strong>链式</strong>的方式进行组织，而当某个 Entry 对象( <strong>节点</strong> )如果需要取消写入到对端，是通过设置 <code>canceled = true</code> 来<strong>标记删除</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!cancelled) {</span><br><span class="line">        <span class="comment">// 标记取消</span></span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> pSize = pendingSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放消息( 数据 )相关的资源</span></span><br><span class="line">        <span class="comment">// release message and replace with an empty buffer</span></span><br><span class="line">        ReferenceCountUtil.safeRelease(msg);</span><br><span class="line">        <span class="comment">// 设置为空 ByteBuf</span></span><br><span class="line">        msg = Unpooled.EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置空属性</span></span><br><span class="line">        pendingSize = <span class="number">0</span>;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">        progress = <span class="number">0</span>;</span><br><span class="line">        bufs = <span class="keyword">null</span>;</span><br><span class="line">        buf = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 pSize</span></span><br><span class="line">        <span class="keyword">return</span> pSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-2-构造方法"><a href="#8-2-构造方法" class="headerlink" title="8.2 构造方法"></a>8.2 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry 对象自身占用内存的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Assuming a 64-bit JVM:</span></span><br><span class="line"><span class="comment">//  - 16 bytes object header</span></span><br><span class="line"><span class="comment">//  - 8 reference fields</span></span><br><span class="line"><span class="comment">//  - 2 long fields</span></span><br><span class="line"><span class="comment">//  - 2 int fields</span></span><br><span class="line"><span class="comment">//  - 1 boolean field</span></span><br><span class="line"><span class="comment">//  - padding</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD = SystemPropertyUtil.getInt(<span class="string">"io.netty.transport.outboundBufferEntrySizeOverhead"</span>, <span class="number">96</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(ChannelOutboundBuffer.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程对应的 ByteBuffer 数组缓存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 每次调用 {<span class="doctag">@link</span> #nioBuffers(int, long)} 会重新生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;ByteBuffer[]&gt; NIO_BUFFERS = <span class="keyword">new</span> FastThreadLocal&lt;ByteBuffer[]&gt;() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ByteBuffer[] initialValue() <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ByteBuffer[<span class="number">1024</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Channel 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个( 开始 ) flush Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// The Entry that is the first in the linked-list structure that was flushed</span></span><br><span class="line"><span class="keyword">private</span> Entry flushedEntry;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个未 flush Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// The Entry which is the first unflushed in the linked-list structure</span></span><br><span class="line"><span class="keyword">private</span> Entry unflushedEntry;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// The Entry which represents the tail of the buffer</span></span><br><span class="line"><span class="keyword">private</span> Entry tailEntry;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已 flush 但未写入对端的 Entry 数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #addFlush()}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of flushed entries that are not written yet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flushed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #NIO_BUFFERS} 数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nioBufferCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #NIO_BUFFERS} 字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nioBufferSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正在通知 flush 失败中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> inFail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #totalPendingSize} 的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;ChannelOutboundBuffer&gt; TOTAL_PENDING_SIZE_UPDATER = AtomicLongFieldUpdater.newUpdater(ChannelOutboundBuffer.class, <span class="string">"totalPendingSize"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总共等待 flush 到对端的内存大小，通过 {<span class="doctag">@link</span> Entry#pendingSize} 来合计。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"UnusedDeclaration"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> totalPendingSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #unwritable} 的原子更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;ChannelOutboundBuffer&gt; UNWRITABLE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ChannelOutboundBuffer.class, <span class="string">"unwritable"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否不可写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"UnusedDeclaration"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> unwritable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发 Channel 可写的改变的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Runnable fireChannelWritabilityChangedTask;</span><br><span class="line"></span><br><span class="line">ChannelOutboundBuffer(AbstractChannel channel) {</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>channel</code> 属性，所属的 Channel 对象。</li>
<li>链式结构<ul>
<li><code>flushedEntry</code> 属性，第一个( 开始 ) flush Entry 。</li>
<li><code>unflushedEntry</code> 属性，第一个<strong>未</strong> flush Entry 。</li>
<li><code>tailEntry</code> 属性，尾 Entry 。</li>
<li><code>flushed</code> 属性， 已 flush 但未写入对端的 Entry 数量。</li>
<li>指向关系是 <code>Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</code> 。这样看，可能有点抽象，下文源码解析详细理解。</li>
</ul>
</li>
<li><code>NIO_BUFFERS</code> <strong>静态</strong>属性，线程对应的 NIO ByteBuffer 数组缓存。在 <code>AbstractChannel#doWrite(ChannelOutboundBuffer)</code> 方法中，会调用 <code>ChannelOutbound#nioBuffers(int maxCount, long maxBytes)</code> 方法，初始化数组缓存。 详细解析，见 <a href="#">「8.6 nioBuffers」</a> 中。<ul>
<li><code>nioBufferCount</code> 属性：NIO ByteBuffer 数组的<strong>数组</strong>大小。</li>
<li><code>nioBufferSize</code> 属性：NIO ByteBuffer 数组的字<strong>节</strong>大小。</li>
</ul>
</li>
<li><code>inFail</code> 属性，正在通知 flush 失败中。详细解析，见 <a href="#">「8.8 failFlushed」</a> 中。 </li>
<li>ChannelOutboundBuffer 写入控制相关。😈 详细解析，见 <a href="#">「10. ChannelOutboundBuffer」</a> 。 <ul>
<li><code>unwritable</code> 属性，是否不可写。<ul>
<li><code>UNWRITABLE_UPDATER</code> 静态属性，<code>unwritable</code> 属性的原子更新器。</li>
</ul>
</li>
<li><code>totalPendingSize</code> 属性，所有 Entry 预计占用的内存大小，通过 <code>Entry.pendingSize</code> 来合计。<ul>
<li><code>TOTAL_PENDING_SIZE_UPDATER</code> 静态属性，<code>totalPendingSize</code> 属性的原子更新器。         </li>
</ul>
</li>
<li><code>fireChannelWritabilityChangedTask</code> 属性，触发 Channel 可写的改变的<strong>任务</strong>。</li>
<li><code>CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD</code> <strong>静态</strong>属性，每个 Entry 对象自身占用内存的大小。为什么占用的 96 字节呢？<ul>
<li><code>- 16 bytes object header</code> ，对象头，16 字节。</li>
<li><code>- 8 reference fields</code> ，实际是 6 个<strong>对象引用</strong>字段，6 * 8 = 48 字节。</li>
<li><code>- 2 long fields</code> ，2 个 <code>long</code> 字段，2 * 8 = 16 字节。</li>
<li><code>- 2 int fields</code> ，1 个 <code>int</code> 字段，2 * 4 = 8 字节。</li>
<li><code>- 1 boolean field</code> ，1 个 <code>boolean</code> 字段，1 字节。</li>
<li><code>padding</code> ，补齐 8 字节的整数倍，因此 7 字节。</li>
<li>因此，合计 96 字节( 64 位的 JVM 虚拟机，并且不考虑压缩 )。</li>
<li>如果不理解的胖友，可以看看 <a href="https://www.jianshu.com/p/12a3c97dc2b7" rel="external nofollow noopener noreferrer" target="_blank">《JVM中 对象的内存布局 以及 实例分析》</a> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-3-addMessage"><a href="#8-3-addMessage" class="headerlink" title="8.3 addMessage"></a>8.3 addMessage</h2><p><code>#addMessage(Object msg, int size, ChannelPromise promise)</code> 方法，写入消息( 数据 )到内存队列。<strong>注意</strong>，<code>promise</code> 只有在真正完成写入到对端操作，才会进行通知。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * Add given message to this {<span class="doctag">@link</span> ChannelOutboundBuffer}. The given {<span class="doctag">@link</span> ChannelPromise} will be notified once</span></span><br><span class="line"><span class="comment"> 3:  * the message was written.</span></span><br><span class="line"><span class="comment"> 4:  */</span></span><br><span class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// 创建新 Entry 对象</span></span><br><span class="line"> <span class="number">7</span>:     Entry entry = Entry.newInstance(msg, size, total(msg), promise);</span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// 若 tailEntry 为空，将 flushedEntry 也设置为空。防御型编程，实际不会出现</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">10</span>:         flushedEntry = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">11</span>:     <span class="comment">// 若 tailEntry 非空，将原 tailEntry 指向新 Entry</span></span><br><span class="line"><span class="number">12</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">13</span>:         Entry tail = tailEntry;</span><br><span class="line"><span class="number">14</span>:         tail.next = entry;</span><br><span class="line"><span class="number">15</span>:     }</span><br><span class="line"><span class="number">16</span>:     <span class="comment">// 更新 tailEntry 为新 Entry</span></span><br><span class="line"><span class="number">17</span>:     tailEntry = entry;</span><br><span class="line"><span class="number">18</span>:     <span class="comment">// 若 unflushedEntry 为空，更新为新 Entry</span></span><br><span class="line"><span class="number">19</span>:     <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">20</span>:         unflushedEntry = entry;</span><br><span class="line"><span class="number">21</span>:     }</span><br><span class="line"><span class="number">22</span>: </span><br><span class="line"><span class="number">23</span>:     <span class="comment">// 增加 totalPendingSize 计数</span></span><br><span class="line"><span class="number">24</span>:     <span class="comment">// increment pending bytes after adding message to the unflushed arrays.</span></span><br><span class="line"><span class="number">25</span>:     <span class="comment">// See https://github.com/netty/netty/issues/1619</span></span><br><span class="line"><span class="number">26</span>:     incrementPendingOutboundBytes(entry.pendingSize, <span class="keyword">false</span>);</span><br><span class="line"><span class="number">27</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 7 行：调用 <code>#newInstance(Object msg, int size, long total, ChannelPromise promise)</code> <strong>静态</strong>方法，创建 Entry 对象。</li>
<li>第 11 至 17 行：修改<strong>尾</strong>节点 <code>tailEntry</code> 为新的 Entry 节点。<ul>
<li>第 8 至 10 行：若 <code>tailEntry</code> 为空，将 <code>flushedEntry</code> 也设置为空。防御型编程，实际不会出现，胖友可以忽略。😈 当然，原因在 <code>#removeEntry(Entry e)</code> 方法。</li>
<li>第 11 至 15 行：若 <code>tailEntry</code> 非空，将原 <code>tailEntry.next</code> 指向<strong>新</strong> Entry 。</li>
<li>第 17 行：更新原 <code>tailEntry</code> 为新 Entry 。</li>
</ul>
</li>
<li>第 18 至 21 行：若 <code>unflushedEntry</code> 为空，则更新为新 Entry ，此时相当于<strong>首</strong>节点。</li>
<li>第 23 至 26 行：<code>#incrementPendingOutboundBytes(long size, ...)</code> 方法，增加 <code>totalPendingSize</code> 计数。详细解析，见 <a href="#">「10.1 incrementPendingOutboundBytes」</a> 。</li>
</ul>
<hr>
<p>可能有点抽象，我们来看看基友【闪电侠】对这块的解析：</p>
<blockquote>
<p>FROM 闪电侠 <a href="https://www.jianshu.com/p/feaeaab2ce56" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 writeAndFlush 全解析》</a></p>
<p>初次调用 <code>addMessage</code> 之后，各个指针的情况为</p>
<p><a href="http://static2.iocoder.cn/1ff7a5d2b08b9e6160dd92e74e68145f" title="" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/1ff7a5d2b08b9e6160dd92e74e68145f" alt=""></a></p>
<p><code>fushedEntry</code>指向空，<code>unFushedEntry</code>和 <code>tailEntry</code> 都指向新加入的节点</p>
<p>第二次调用 <code>addMessage</code> 之后，各个指针的情况为</p>
<p><a href="http://static2.iocoder.cn/1f939423f079ff491b90c8300e7ef3ea" title="" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/1f939423f079ff491b90c8300e7ef3ea" alt=""></a></p>
<p>第 n 次调用 <code>addMessage</code>之后，各个指针的情况为</p>
<p><a href="http://static2.iocoder.cn/c0077b0dc86ecf1b791a99eeb9664fc3" title="" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/c0077b0dc86ecf1b791a99eeb9664fc3" alt=""></a></p>
<p>可以看到，调用 n 次 <code>addMessage</code> ，<code>flushedEntry</code> 指针一直指向 NULL ，表示现在还未有节点需要写出到 Socket 缓冲区，而<code>unFushedEntry</code> 之后有 n 个节点，表示当前还有n个节点尚未写出到 Socket 缓冲区中去</p>
</blockquote>
<h2 id="8-4-addFlush"><a href="#8-4-addFlush" class="headerlink" title="8.4 addFlush"></a>8.4 addFlush</h2><p><code>#addFlush()</code> 方法，标记内存队列每个 Entry 对象，开始 <strong>flush</strong> 。代码如下：</p>
<blockquote>
<p>老艿艿：总觉得这个方法名取的有点奇怪，胖友可以直接看英文注释。😈 我“翻译”不好，哈哈哈。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFlush</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// There is no need to process all entries if there was already a flush before and no new messages</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// where added in the meantime.</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">//</span></span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// See https://github.com/netty/netty/issues/2577</span></span><br><span class="line"> <span class="number">6</span>:     Entry entry = unflushedEntry;</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (entry != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 若 flushedEntry 为空，赋值为 unflushedEntry ，用于记录第一个( 开始 ) flush 的 Entry 。</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (flushedEntry == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">10</span>:             <span class="comment">// there is no flushedEntry yet, so start with the entry</span></span><br><span class="line"><span class="number">11</span>:             flushedEntry = entry;</span><br><span class="line"><span class="number">12</span>:         }</span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 计算 flush 的数量，并设置每个 Entry 对应的 Promise 不可取消</span></span><br><span class="line"><span class="number">14</span>:         <span class="keyword">do</span> {</span><br><span class="line"><span class="number">15</span>:             <span class="comment">// 增加 flushed</span></span><br><span class="line"><span class="number">16</span>:             flushed ++;</span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 设置 Promise 不可取消</span></span><br><span class="line"><span class="number">18</span>:             <span class="keyword">if</span> (!entry.promise.setUncancellable()) { <span class="comment">// 设置失败</span></span><br><span class="line"><span class="number">19</span>:                 <span class="comment">// 减少 totalPending 计数</span></span><br><span class="line"><span class="number">20</span>:                 <span class="comment">// Was cancelled so make sure we free up memory and notify about the freed bytes</span></span><br><span class="line"><span class="number">21</span>:                 <span class="keyword">int</span> pending = entry.cancel();</span><br><span class="line"><span class="number">22</span>:                 decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">23</span>:             }</span><br><span class="line"><span class="number">24</span>:             <span class="comment">// 获得下一个 Entry</span></span><br><span class="line"><span class="number">25</span>:             entry = entry.next;</span><br><span class="line"><span class="number">26</span>:         } <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:         <span class="comment">// 设置 unflushedEntry 为空，表示所有都 flush</span></span><br><span class="line"><span class="number">29</span>:         <span class="comment">// All flushed so reset unflushedEntry</span></span><br><span class="line"><span class="number">30</span>:         unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">31</span>:     }</span><br><span class="line"><span class="number">32</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 6 至 7 行：若 <code>unflushedEntry</code> 为空，说明每个 Entry 对象已经“标记” flush 。<strong>注意</strong>，“标记”的方式，不是通过 Entry 对象有一个 <code>flushed</code> 字段，而是 <code>flushedEntry</code> 属性，指向第一个( 开始 ) flush 的 Entry ，而 <code>unflushedEntry</code> 置空。</li>
<li>第 8 至 12 行：若 <code>flushedEntry</code> 为空，赋值为 <code>unflushedEntry</code> ，用于记录第一个( 开始 ) flush 的 Entry 。</li>
<li>第 13 至 26 行：计算需要 flush 的 Entry 数量，并设置每个 Entry 对应的 Promise <strong>不可取消</strong>。<ul>
<li>第 18 至 23 行：<code>#decrementPendingOutboundBytes(long size, ...)</code> 方法，减少 <code>totalPendingSize</code> 计数。</li>
</ul>
</li>
<li>第 30 行：设置 <code>unflushedEntry</code> 为空。</li>
</ul>
<hr>
<p>可能有点抽象，我们来看看基友【闪电侠】对这块的解析：</p>
<blockquote>
<p>FROM 闪电侠 <a href="https://www.jianshu.com/p/feaeaab2ce56" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 writeAndFlush 全解析》</a></p>
<p>可以结合前面的图来看，首先拿到 <code>unflushedEntry</code> 指针，然后将 <code>flushedEntry</code> 指向 <code>unflushedEntry</code> 所指向的节点，调用完毕之后，三个指针的情况如下所示</p>
<p><a href="http://static2.iocoder.cn/ecb3df153a3df70464b524838b559232" title="" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/ecb3df153a3df70464b524838b559232" alt=""></a></p>
</blockquote>
<hr>
<blockquote>
<p>老艿艿：再次切回到老艿艿的频道，呼呼。</p>
</blockquote>
<p>当一次需要从内存队列写到对端的数据量非常大，那么可能写着写着 Channel 的缓存区不够，导致 Channel 此时不可写。但是，这一轮 <code>#addFlush(...)</code> 标记的 Entry 对象并没有都写到对端。例如，准备写到对端的 Entry 的数量是 <code>flush = 10</code> 个，结果只写了 6 个，那么就剩下 <code>flush = 4</code> 。</p>
<p>但是的但是，<code>#addMessage(...)</code> 可能又不断写入新的消息( 数据 )到 ChannelOutboundBuffer 中。那会出现什么情况呢？会“分”成两段：</p>
<ul>
<li><code>&lt;1&gt;</code> 段：自节点 <code>flushedEntry</code> 开始的 <code>flush</code> 个 Entry 节点，需要写入到对端。</li>
<li><code>&lt;2&gt;</code> 段：自节点 <code>unFlushedEntry</code> 开始的 Entry 节点，需要调用 <code>#addFlush()</code> 方法，添加到 <code>&lt;1&gt;</code> 段中。</li>
</ul>
<p>这就很好的解释两个事情：</p>
<ol>
<li>为什么 <code>#addFlush()</code> 方法，命名是以 <code>"add"</code> 开头。</li>
<li>ChannelOutboundBuffer 的链式结构，为什么不是 <code>head</code> 和 <code>tail</code> <strong>两个</strong>节点，而是 <code>flushedEntry</code>、<code>unFlushedEntry</code>、<code>flushedEntry</code> <strong>三个</strong>节点。在此处，请允许老艿艿爆个粗口：真他 x 的巧妙啊。</li>
</ol>
<h3 id="8-4-1-size"><a href="#8-4-1-size" class="headerlink" title="8.4.1 size"></a>8.4.1 size</h3><p><code>#size()</code> 方法，获得 <code>flushed</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of flushed messages in this {<span class="doctag">@link</span> ChannelOutboundBuffer}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> flushed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-4-2-isEmpty"><a href="#8-4-2-isEmpty" class="headerlink" title="8.4.2 isEmpty"></a>8.4.2 isEmpty</h3><p><code>#isEmpty()</code> 方法，是否为空。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if there are flushed messages in this {<span class="doctag">@link</span> ChannelOutboundBuffer} or {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> flushed == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-5-current"><a href="#8-5-current" class="headerlink" title="8.5 current"></a>8.5 current</h2><p><code>#current()</code> 方法，获得<strong>当前</strong>要写入对端的消息( 数据 )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the current message to write or {<span class="doctag">@code</span> null} if nothing was flushed before and so is ready to be written.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>{</span><br><span class="line">    Entry entry = flushedEntry;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry.msg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>即，返回的是 <code>flushedEntry</code> 的消息( 数据 )。</li>
</ul>
<h2 id="8-6-nioBuffers"><a href="#8-6-nioBuffers" class="headerlink" title="8.6 nioBuffers"></a>8.6 nioBuffers</h2><p><code>#nioBuffers(int maxCount, long maxBytes)</code> 方法，获得当前要写入到对端的 NIO ByteBuffer 数组，并且获得的数组大小不得超过 <code>maxCount</code> ，字节数不得超过 <code>maxBytes</code> 。我们知道，在写入数据到 ChannelOutboundBuffer 时，一般使用的是 Netty ByteBuf 对象，但是写到 NIO SocketChannel 时，则必须使用 NIO ByteBuffer 对象，因此才有了这个方法。考虑到性能，这个方法里会使用到“<strong>缓存</strong>”，所以看起来会比较绕一丢丢。OK，开始看代码落：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an array of direct NIO buffers if the currently pending messages are made of {<span class="doctag">@link</span> ByteBuf} only.</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #nioBufferCount()} and {<span class="doctag">@link</span> #nioBufferSize()} will return the number of NIO buffers in the returned</span></span><br><span class="line"><span class="comment"> * array and the total number of readable bytes of the NIO buffers respectively.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that the returned array is reused and thus should not escape</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> AbstractChannel#doWrite(ChannelOutboundBuffer)}.</span></span><br><span class="line"><span class="comment"> * Refer to {<span class="doctag">@link</span> NioSocketChannel#doWrite(ChannelOutboundBuffer)} for an example.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxCount The maximum amount of buffers that will be added to the return value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxBytes A hint toward the maximum number of bytes to include as part of the return value. Note that this</span></span><br><span class="line"><span class="comment"> *                 value maybe exceeded because we make a best effort to include at least 1 {<span class="doctag">@link</span> ByteBuffer}</span></span><br><span class="line"><span class="comment"> *                 in the return value to ensure write progress is made.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">     </span><br><span class="line">  <span class="number">1</span>: <span class="keyword">public</span> ByteBuffer[] nioBuffers(<span class="keyword">int</span> maxCount, <span class="keyword">long</span> maxBytes) {</span><br><span class="line">  <span class="number">2</span>:     <span class="keyword">assert</span> maxCount &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">assert</span> maxBytes &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">long</span> nioBufferSize = <span class="number">0</span>;</span><br><span class="line">  <span class="number">5</span>:     <span class="keyword">int</span> nioBufferCount = <span class="number">0</span>;</span><br><span class="line">  <span class="number">6</span>:     <span class="comment">// 获得当前线程的 NIO ByteBuffer 数组缓存。</span></span><br><span class="line">  <span class="number">7</span>:     <span class="keyword">final</span> InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">  <span class="number">8</span>:     ByteBuffer[] nioBuffers = NIO_BUFFERS.get(threadLocalMap);</span><br><span class="line">  <span class="number">9</span>:     <span class="comment">// 从 flushedEntry 节点，开始向下遍历</span></span><br><span class="line"> <span class="number">10</span>:     Entry entry = flushedEntry;</span><br><span class="line"> <span class="number">11</span>:     <span class="keyword">while</span> (isFlushedEntry(entry) &amp;&amp; entry.msg <span class="keyword">instanceof</span> ByteBuf) {</span><br><span class="line"> <span class="number">12</span>:         <span class="comment">// 若 Entry 节点已经取消，忽略。</span></span><br><span class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (!entry.cancelled) {</span><br><span class="line"> <span class="number">14</span>:             ByteBuf buf = (ByteBuf) entry.msg;</span><br><span class="line"> <span class="number">15</span>:             <span class="comment">// 获得消息( 数据 )开始读取位置</span></span><br><span class="line"> <span class="number">16</span>:             <span class="keyword">final</span> <span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"> <span class="number">17</span>:             <span class="comment">// 获得消息( 数据 )可读取的字节数</span></span><br><span class="line"> <span class="number">18</span>:             <span class="keyword">final</span> <span class="keyword">int</span> readableBytes = buf.writerIndex() - readerIndex;</span><br><span class="line"> <span class="number">19</span>: </span><br><span class="line"> <span class="number">20</span>:             <span class="comment">// 若无可读取的数据，忽略。</span></span><br><span class="line"> <span class="number">21</span>:             <span class="keyword">if</span> (readableBytes &gt; <span class="number">0</span>) {</span><br><span class="line"> <span class="number">22</span>:                 <span class="comment">// 前半段，可读取的字节数，不能超过 maxBytes</span></span><br><span class="line"> <span class="number">23</span>:                 <span class="comment">// 后半段，如果第一条数据，就已经超过 maxBytes ，那么只能“强行”读取，否则会出现一直无法读取的情况。</span></span><br><span class="line"> <span class="number">24</span>:                 <span class="keyword">if</span> (maxBytes - readableBytes &lt; nioBufferSize &amp;&amp; nioBufferCount != <span class="number">0</span>) {</span><br><span class="line"> <span class="number">25</span>:                     <span class="comment">// If the nioBufferSize + readableBytes will overflow maxBytes, and there is at least one entry</span></span><br><span class="line"> <span class="number">26</span>:                     <span class="comment">// we stop populate the ByteBuffer array. This is done for 2 reasons:</span></span><br><span class="line"> <span class="number">27</span>:                     <span class="comment">// 1. bsd/osx don't allow to write more bytes then Integer.MAX_VALUE with one writev(...) call</span></span><br><span class="line"> <span class="number">28</span>:                     <span class="comment">// and so will return 'EINVAL', which will raise an IOException. On Linux it may work depending</span></span><br><span class="line"> <span class="number">29</span>:                     <span class="comment">// on the architecture and kernel but to be safe we also enforce the limit here.</span></span><br><span class="line"> <span class="number">30</span>:                     <span class="comment">// 2. There is no sense in putting more data in the array than is likely to be accepted by the</span></span><br><span class="line"> <span class="number">31</span>:                     <span class="comment">// OS.</span></span><br><span class="line"> <span class="number">32</span>:                     <span class="comment">//</span></span><br><span class="line"> <span class="number">33</span>:                     <span class="comment">// See also:</span></span><br><span class="line"> <span class="number">34</span>:                     <span class="comment">// - https://www.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2</span></span><br><span class="line"> <span class="number">35</span>:                     <span class="comment">// - http://linux.die.net/man/2/writev</span></span><br><span class="line"> <span class="number">36</span>:                     <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">37</span>:                 }</span><br><span class="line"> <span class="number">38</span>:                 <span class="comment">// 增加 nioBufferSize</span></span><br><span class="line"> <span class="number">39</span>:                 nioBufferSize += readableBytes;</span><br><span class="line"> <span class="number">40</span>:                 <span class="comment">// 初始 Entry 节点的 NIO ByteBuffer 数量</span></span><br><span class="line"> <span class="number">41</span>:                 <span class="keyword">int</span> count = entry.count;</span><br><span class="line"> <span class="number">42</span>:                 <span class="keyword">if</span> (count == -<span class="number">1</span>) {</span><br><span class="line"> <span class="number">43</span>:                     <span class="comment">//noinspection ConstantValueVariableUse</span></span><br><span class="line"> <span class="number">44</span>:                     entry.count = count = buf.nioBufferCount();</span><br><span class="line"> <span class="number">45</span>:                 }</span><br><span class="line"> <span class="number">46</span>:                 <span class="comment">// 如果超过 NIO ByteBuffer 数组的大小，进行扩容。</span></span><br><span class="line"> <span class="number">47</span>:                 <span class="keyword">int</span> neededSpace = min(maxCount, nioBufferCount + count);</span><br><span class="line"> <span class="number">48</span>:                 <span class="keyword">if</span> (neededSpace &gt; nioBuffers.length) {</span><br><span class="line"> <span class="number">49</span>:                     nioBuffers = expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);</span><br><span class="line"> <span class="number">50</span>:                     NIO_BUFFERS.set(threadLocalMap, nioBuffers);</span><br><span class="line"> <span class="number">51</span>:                 }</span><br><span class="line"> <span class="number">52</span>:                 <span class="comment">// 初始化 Entry 节点的 buf / bufs 属性</span></span><br><span class="line"> <span class="number">53</span>:                 <span class="keyword">if</span> (count == <span class="number">1</span>) {</span><br><span class="line"> <span class="number">54</span>:                     ByteBuffer nioBuf = entry.buf;</span><br><span class="line"> <span class="number">55</span>:                     <span class="keyword">if</span> (nioBuf == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">56</span>:                         <span class="comment">// cache ByteBuffer as it may need to create a new ByteBuffer instance if its a</span></span><br><span class="line"> <span class="number">57</span>:                         <span class="comment">// derived buffer</span></span><br><span class="line"> <span class="number">58</span>:                         entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);</span><br><span class="line"> <span class="number">59</span>:                     }</span><br><span class="line"> <span class="number">60</span>:                     nioBuffers[nioBufferCount++] = nioBuf;</span><br><span class="line"> <span class="number">61</span>:                 } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">62</span>:                     ByteBuffer[] nioBufs = entry.bufs;</span><br><span class="line"> <span class="number">63</span>:                     <span class="keyword">if</span> (nioBufs == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">64</span>:                         <span class="comment">// cached ByteBuffers as they may be expensive to create in terms</span></span><br><span class="line"> <span class="number">65</span>:                         <span class="comment">// of Object allocation</span></span><br><span class="line"> <span class="number">66</span>:                         entry.bufs = nioBufs = buf.nioBuffers();</span><br><span class="line"> <span class="number">67</span>:                     }</span><br><span class="line"> <span class="number">68</span>:                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nioBufs.length &amp;&amp; nioBufferCount &lt; maxCount; ++i) {</span><br><span class="line"> <span class="number">69</span>:                         ByteBuffer nioBuf = nioBufs[i];</span><br><span class="line"> <span class="number">70</span>:                         <span class="keyword">if</span> (nioBuf == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">71</span>:                             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">72</span>:                         } <span class="keyword">else</span> <span class="keyword">if</span> (!nioBuf.hasRemaining()) {</span><br><span class="line"> <span class="number">73</span>:                             <span class="keyword">continue</span>;</span><br><span class="line"> <span class="number">74</span>:                         }</span><br><span class="line"> <span class="number">75</span>:                         nioBuffers[nioBufferCount++] = nioBuf;</span><br><span class="line"> <span class="number">76</span>:                     }</span><br><span class="line"> <span class="number">77</span>:                 }</span><br><span class="line"> <span class="number">78</span>: </span><br><span class="line"> <span class="number">79</span>:                 <span class="comment">// 到达 maxCount 上限，结束循环。老艿艿的想法，这里最好改成 nioBufferCount &gt;= maxCount ，是有可能会超过的</span></span><br><span class="line"> <span class="number">80</span>:                 <span class="keyword">if</span> (nioBufferCount == maxCount) {</span><br><span class="line"> <span class="number">81</span>:                     <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">82</span>:                 }</span><br><span class="line"> <span class="number">83</span>:             }</span><br><span class="line"> <span class="number">84</span>:         }</span><br><span class="line"> <span class="number">85</span>: </span><br><span class="line"> <span class="number">86</span>:         <span class="comment">// 下一个 Entry节点</span></span><br><span class="line"> <span class="number">87</span>:         entry = entry.next;</span><br><span class="line"> <span class="number">88</span>:     }</span><br><span class="line"> <span class="number">89</span>: </span><br><span class="line"> <span class="number">90</span>:     <span class="comment">// 设置 nioBufferCount 和 nioBufferSize 属性</span></span><br><span class="line"> <span class="number">91</span>:     <span class="keyword">this</span>.nioBufferCount = nioBufferCount;</span><br><span class="line"> <span class="number">92</span>:     <span class="keyword">this</span>.nioBufferSize = nioBufferSize;</span><br><span class="line"> <span class="number">93</span>: </span><br><span class="line"> <span class="number">94</span>:     <span class="keyword">return</span> nioBuffers;</span><br><span class="line"> <span class="number">95</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 至 5 行：初始 <code>nioBufferSize</code>、<code>nioBufferCount</code> 计数。</li>
<li>第 6 至 8 行：获得当前线程的 NIO ByteBuffer 数组缓存。<ul>
<li>关于 InternalThreadLocalMap 和 FastThreadLocal ，胖友可以暂时忽略，后续的文章，详细解析。</li>
</ul>
</li>
<li><p>第 10 至 11 行：从 <code>flushedEntry</code> 节点，开始向下遍历。</p>
<ul>
<li><p>调用 <code>#isFlushedEntry(Entry entry)</code> 方法，判断是否为已经“标记”为 flush 的 Entry 节点。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFlushedEntry</span><span class="params">(Entry e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> e != <span class="keyword">null</span> &amp;&amp; e != unflushedEntry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>e != unflushedEntry</code> ，就是我们在 <a href="#">「8.4 addFlush」</a> 最后部分讲的，思考下。</li>
</ul>
</li>
<li><code>entry.msg instanceof ByteBuf</code> ，消息( 数据 )类型为 ByteBuf 。实际上，<code>msg</code> 的类型也可能是 FileRegion 。如果 ChannelOutboundBuffer 里的消息都是 FileRegion 类型，那就会导致这个方法返回为<strong>空</strong> NIO ByteBuffer 数组。</li>
</ul>
</li>
<li>第 13 行：若 Entry 节点已经取消，忽略。</li>
<li>第 14 至 18 行：获得消息( 数据 )开始读取位置和可读取的字节数。<ul>
<li>第 21 行：若无可读取的数据，忽略。</li>
</ul>
</li>
<li>第 22 至 37 行：<ul>
<li>前半段 <code>maxBytes - readableBytes &lt; nioBufferSize</code> ，当前 ByteBuf 可读取的字节数，不能超过 <code>maxBytes</code> 。这个比较好理解。</li>
<li>后半段 <code>nioBufferCount != 0</code> ，如果<strong>第一条</strong>数据，就已经超过 <code>maxBytes</code> ，那么只能“强行”读取，否则会出现一直无法读取的情况( 因为不能跳过这条 😈 )。</li>
</ul>
</li>
<li>第 39 行：增加 <code>nioBufferSize</code> 。</li>
<li>第 40 至 45 行：调用 <code>ByteBuf#nioBufferCount()</code> 方法，初始 Entry 节点的  <code>count</code> 属性( NIO ByteBuffer 数量)。<ul>
<li>使用 <code>count == -1</code> 的原因是，<code>Entry.count</code> 未初始化时，为 <code>-1</code> 。</li>
</ul>
</li>
<li>第 47 至 51 行：如果超过 NIO ByteBuffer 数组的大小，调用 <code>#expandNioBufferArray(ByteBuffer[] array, int neededSpace, int size)</code> 方法，进行扩容。详细解析，见 <a href="#">「8.6.1 expandNioBufferArray」</a> 。</li>
<li>第 52 至 77 行：初始 Entry 节点的  <code>buf</code> 或 <code>bufs</code> 属性。<ul>
<li>当 <code>count = 1</code> 时，调用 <code>ByteBuf#internalNioBuffer(readerIndex, readableBytes)</code> 方法，获得 NIO ByteBuffer 对象。</li>
<li>当 <code>count &gt; 1</code> 时，调用 <code>ByteBuf#nioBuffers()</code> 方法，获得 NIO ByteBuffer 数组。</li>
<li>通过 <code>nioBuffers[nioBufferCount++] = nioBuf</code> ，将 NIO ByteBuffer 赋值到结果数组 <code>nioBuffers</code> 中，并增加 <code>nioBufferCount</code> 。</li>
</ul>
</li>
<li>第 79 至 82 行：到达 <code>maxCount</code> 上限，结束循环。老艿艿的想法，这里最好改成 <code>nioBufferCount &gt;= maxCount</code> ，是有可能会超过的。</li>
<li>第 87 行：<strong>下一个 Entry 节点</strong>。</li>
<li>第 90 至 92 行：设置 ChannelOutboundBuffer 的 <code>nioBufferCount</code> 和 <code>nioBufferSize</code> 属性。</li>
</ul>
<h3 id="8-6-1-expandNioBufferArray"><a href="#8-6-1-expandNioBufferArray" class="headerlink" title="8.6.1 expandNioBufferArray"></a>8.6.1 expandNioBufferArray</h3><p><code>#expandNioBufferArray(ByteBuffer[] array, int neededSpace, int size)</code> 方法，进行 NIO ByteBuff 数组的<strong>扩容</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer[] expandNioBufferArray(ByteBuffer[] array, <span class="keyword">int</span> neededSpace, <span class="keyword">int</span> size) {</span><br><span class="line">    <span class="comment">// 计算扩容后的数组的大小，按照 2 倍计算</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = array.length;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// double capacity until it is big enough</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/1890</span></span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">while</span> (neededSpace &gt; newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的 ByteBuffer 数组</span></span><br><span class="line">    ByteBuffer[] newArray = <span class="keyword">new</span> ByteBuffer[newCapacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制老的 ByteBuffer 数组到新的 ByteBuffer 数组中</span></span><br><span class="line">    System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看下注释。</li>
</ul>
<h3 id="8-6-2-nioBufferCount"><a href="#8-6-2-nioBufferCount" class="headerlink" title="8.6.2 nioBufferCount"></a>8.6.2 nioBufferCount</h3><p><code>#nioBufferCount()</code> 方法，返回 <code>nioBufferCount</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of {<span class="doctag">@link</span> ByteBuffer} that can be written out of the {<span class="doctag">@link</span> ByteBuffer} array that was</span></span><br><span class="line"><span class="comment"> * obtained via {<span class="doctag">@link</span> #nioBuffers()}. This method &lt;strong&gt;MUST&lt;/strong&gt; be called after {<span class="doctag">@link</span> #nioBuffers()}</span></span><br><span class="line"><span class="comment"> * was called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nioBufferCount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nioBufferCount;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-6-3-nioBufferSize"><a href="#8-6-3-nioBufferSize" class="headerlink" title="8.6.3 nioBufferSize"></a>8.6.3 nioBufferSize</h3><p><code>#nioBufferSize()</code> 方法，返回 <code>nioBufferSize</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of bytes that can be written out of the {<span class="doctag">@link</span> ByteBuffer} array that was</span></span><br><span class="line"><span class="comment"> * obtained via {<span class="doctag">@link</span> #nioBuffers()}. This method &lt;strong&gt;MUST&lt;/strong&gt; be called after {<span class="doctag">@link</span> #nioBuffers()}</span></span><br><span class="line"><span class="comment"> * was called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nioBufferSize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nioBufferSize;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-7-removeBytes"><a href="#8-7-removeBytes" class="headerlink" title="8.7 removeBytes"></a>8.7 removeBytes</h2><p><code>#removeBytes(long writtenBytes)</code> 方法，移除已经写入 <code>writtenBytes</code> 字节对应的 Entry 对象 / 对象们。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBytes</span><span class="params">(<span class="keyword">long</span> writtenBytes)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 循环移除</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 获得当前消息( 数据 )</span></span><br><span class="line"> <span class="number">5</span>:         Object msg = current();</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> ByteBuf)) {</span><br><span class="line"> <span class="number">7</span>:             <span class="keyword">assert</span> writtenBytes == <span class="number">0</span>;</span><br><span class="line"> <span class="number">8</span>:             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">9</span>:         }</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:         <span class="keyword">final</span> ByteBuf buf = (ByteBuf) msg;</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 获得消息( 数据 )开始读取位置</span></span><br><span class="line"><span class="number">13</span>:         <span class="keyword">final</span> <span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 获得消息( 数据 )可读取的字节数</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">final</span> <span class="keyword">int</span> readableBytes = buf.writerIndex() - readerIndex;</span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 当前消息( 数据 )已被写完到对端</span></span><br><span class="line"><span class="number">18</span>:         <span class="keyword">if</span> (readableBytes &lt;= writtenBytes) {</span><br><span class="line"><span class="number">19</span>:             <span class="keyword">if</span> (writtenBytes != <span class="number">0</span>) {</span><br><span class="line"><span class="number">20</span>:                 <span class="comment">// 处理当前消息的 Entry 的写入进度</span></span><br><span class="line"><span class="number">21</span>:                 progress(readableBytes);</span><br><span class="line"><span class="number">22</span>:                 <span class="comment">// 减小 writtenBytes</span></span><br><span class="line"><span class="number">23</span>:                 writtenBytes -= readableBytes;</span><br><span class="line"><span class="number">24</span>:             }</span><br><span class="line"><span class="number">25</span>:             <span class="comment">// 移除当前消息对应的 Entry</span></span><br><span class="line"><span class="number">26</span>:             remove();</span><br><span class="line"><span class="number">27</span>:         <span class="comment">// 当前消息( 数据 )未被写完到对端</span></span><br><span class="line"><span class="number">28</span>:         } <span class="keyword">else</span> { <span class="comment">// readableBytes &gt; writtenBytes</span></span><br><span class="line"><span class="number">29</span>:             <span class="keyword">if</span> (writtenBytes != <span class="number">0</span>) {</span><br><span class="line"><span class="number">30</span>:                 <span class="comment">// 标记当前消息的 ByteBuf 的读取位置</span></span><br><span class="line"><span class="number">31</span>:                 buf.readerIndex(readerIndex + (<span class="keyword">int</span>) writtenBytes);</span><br><span class="line"><span class="number">32</span>:                 <span class="comment">// 处理当前消息的 Entry 的写入进度</span></span><br><span class="line"><span class="number">33</span>:                 progress(writtenBytes);</span><br><span class="line"><span class="number">34</span>:             }</span><br><span class="line"><span class="number">35</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>:         }</span><br><span class="line"><span class="number">37</span>:     }</span><br><span class="line"><span class="number">38</span>: </span><br><span class="line"><span class="number">39</span>:     <span class="comment">// 清除 NIO ByteBuff 数组的缓存</span></span><br><span class="line"><span class="number">40</span>:     clearNioBuffers();</span><br><span class="line"><span class="number">41</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：<strong>循环</strong>，移除已经写入 <code>writtenBytes</code> 字节对应的 Entry 对象。<ul>
<li>第 5 行：调用 <code>#current()</code> 方法，获得当前消息( 数据 )。</li>
<li>第 12 至 15 行：获得消息( 数据 )开始读取位置和可读取的字节数。</li>
<li><code>&lt;1&gt;</code> 当前消息( 数据 )<strong>已</strong>被写完到对端。</li>
<li>第 21 行：调用 <code>#progress(long amount)</code> 方法，处理当前消息的 Entry 的写入进度。详细解析，见 <a href="#">「8.7.1 progress」</a> 。</li>
<li>第 23 行：减小 <code>writtenBytes</code> 。</li>
<li>第 26 行：调用 <code>#remove()</code> 方法，移除当前消息对应的 Entry 对象。详细解析，见 <a href="#">「8.7.2 remove」</a> 。</li>
<li><code>&lt;2》</code> 当前消息( 数据 )<strong>未</strong>被写完到对端。</li>
<li>第 31 行：调用 <code>ByteBuf#readerIndex(readerIndex)</code> 方法，标记当前消息的 ByteBuf 的<strong>读取位置</strong>。</li>
<li>第 33 行：调用 <code>#progress(long amount)</code> 方法，处理当前消息的 Entry 的写入进度。</li>
<li>第 35 行：<code>break</code> ，结束循环。</li>
</ul>
</li>
<li>第 40 行：调用 <code>#clearNioBuffers()</code> 方法，<strong>清除</strong> NIO ByteBuff 数组的缓存。详细解析，见 <a href="#">「8.7.4 clearNioBuffers」</a> 。 </li>
</ul>
<h3 id="8-7-1-progress"><a href="#8-7-1-progress" class="headerlink" title="8.7.1 progress"></a>8.7.1 progress</h3><p><code>#progress(long amount)</code> 方法，处理当前消息的 Entry 的写入进度，主要是<strong>通知</strong> Promise 消息写入的进度。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Notify the {<span class="doctag">@link</span> ChannelPromise} of the current message about writing progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">progress</span><span class="params">(<span class="keyword">long</span> amount)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     Entry e = flushedEntry;</span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">assert</span> e != <span class="keyword">null</span>;</span><br><span class="line">  <span class="number">4</span>:     ChannelPromise p = e.promise;</span><br><span class="line">  <span class="number">5</span>:     <span class="keyword">if</span> (p <span class="keyword">instanceof</span> ChannelProgressivePromise) {</span><br><span class="line">  <span class="number">6</span>:         <span class="comment">// 设置 Entry 对象的 progress 属性</span></span><br><span class="line">  <span class="number">7</span>:         <span class="keyword">long</span> progress = e.progress + amount;</span><br><span class="line">  <span class="number">8</span>:         e.progress = progress;</span><br><span class="line">  <span class="number">9</span>:         <span class="comment">// 通知 ChannelProgressivePromise 进度</span></span><br><span class="line"> <span class="number">10</span>:         ((ChannelProgressivePromise) p).tryProgress(progress, e.total);</span><br><span class="line"> <span class="number">11</span>:     }</span><br><span class="line"> <span class="number">12</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 行：若 <code>promise</code> 的类型是 ChannelProgressivePromise 类型。</li>
<li>第 6 至 8 行：设置 Entry 对象的 <code>progress</code> 属性。</li>
<li>第 10 行：调用 <code>ChannelProgressivePromise#tryProgress(progress, total)</code> 方法，通知 ChannelProgressivePromise 进度。</li>
</ul>
<h3 id="8-7-2-remove"><a href="#8-7-2-remove" class="headerlink" title="8.7.2 remove"></a>8.7.2 remove</h3><p><code>#remove()</code> 方法，移除当前消息对应的 Entry 对象，并 Promise 通知成功。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     Entry e = flushedEntry;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (e == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 清除 NIO ByteBuff 数组的缓存</span></span><br><span class="line"> <span class="number">5</span>:         clearNioBuffers();</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">7</span>:     }</span><br><span class="line"> <span class="number">8</span>:     Object msg = e.msg;</span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:     ChannelPromise promise = e.promise;</span><br><span class="line"><span class="number">11</span>:     <span class="keyword">int</span> size = e.pendingSize;</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:     <span class="comment">// 移除指定 Entry 对象</span></span><br><span class="line"><span class="number">14</span>:     removeEntry(e);</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="keyword">if</span> (!e.cancelled) {</span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 释放消息( 数据 )相关的资源</span></span><br><span class="line"><span class="number">18</span>:         <span class="comment">// only release message, notify and decrement if it was not canceled before.</span></span><br><span class="line"><span class="number">19</span>:         ReferenceCountUtil.safeRelease(msg);</span><br><span class="line"><span class="number">20</span>:         <span class="comment">// 通知 Promise 执行成功</span></span><br><span class="line"><span class="number">21</span>:         safeSuccess(promise);</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 减少 totalPending 计数</span></span><br><span class="line"><span class="number">23</span>:         decrementPendingOutboundBytes(size, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">24</span>:     }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:     <span class="comment">// 回收 Entry 对象</span></span><br><span class="line"><span class="number">27</span>:     <span class="comment">// recycle the entry</span></span><br><span class="line"><span class="number">28</span>:     e.recycle();</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">31</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 14 行：调用 <code>#removeEntry(Entry e)</code> 方法，移除<strong>指定</strong> Entry 对象。详细解析，见 <a href="#">「8.7.3 removeEntry」</a> 。</li>
<li>第 16 行：若 Entry 已取消，则忽略。</li>
<li>第 19 行：<code>ReferenceCountUtil#safeRelease(msg)</code> 方法，释放消息( 数据 )相关的资源。</li>
<li><p>第 21 行：【<strong>重要</strong>】调用 <code>#safeSuccess(promise)</code> 方法，通知 Promise 执行成功。此处才是，真正触发 <code>Channel#write(...)</code> 或 <code>Channel#writeAndFlush(...)</code> 方法，返回的 Promise 的通知。<code>#safeSuccess(promise)</code> 方法的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeSuccess</span><span class="params">(ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="comment">// Only log if the given promise is not of type VoidChannelPromise as trySuccess(...) is expected to return</span></span><br><span class="line">    <span class="comment">// false.</span></span><br><span class="line">    PromiseNotificationUtil.trySuccess(promise, <span class="keyword">null</span>, promise <span class="keyword">instanceof</span> VoidChannelPromise ? <span class="keyword">null</span> : logger);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 23 行：<code>#decrementPendingOutboundBytes(long size, ...)</code> 方法，减少 <code>totalPendingSize</code> 计数。</p>
</li>
<li>第 28 行：调用 <code>Entry#recycle()</code> 方法，<strong>回收</strong> Entry 对象。</li>
</ul>
<h3 id="8-7-3-removeEntry"><a href="#8-7-3-removeEntry" class="headerlink" title="8.7.3 removeEntry"></a>8.7.3 removeEntry</h3><p><code>#removeEntry(Entry e)</code> 方法，移除<strong>指定</strong> Entry 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(Entry e)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 已移除完已 flush 的 Entry 节点，置空 flushedEntry、tailEntry、unflushedEntry 。</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (-- flushed == <span class="number">0</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// processed everything</span></span><br><span class="line"> <span class="number">5</span>:         flushedEntry = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (e == tailEntry) {</span><br><span class="line"> <span class="number">7</span>:             tailEntry = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">8</span>:             unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">9</span>:         }</span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 未移除完已 flush 的 Entry 节点，flushedEntry 指向下一个 Entry 对象</span></span><br><span class="line"><span class="number">11</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">12</span>:         flushedEntry = e.next;</span><br><span class="line"><span class="number">13</span>:     }</span><br><span class="line"><span class="number">14</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 9 行：<strong>已</strong>移除完已 flush 的<strong>所有</strong> Entry 节点，置空 <code>flushedEntry</code>、<code>tailEntry</code>、<code>unflushedEntry</code> 。</li>
<li>第 10 至 13 行：<strong>未</strong>移除完已 flush 的<strong>所有</strong> Entry 节点，<code>flushedEntry</code> 指向<strong>下一个</strong> Entry 对象。</li>
</ul>
<h3 id="8-7-4-clearNioBuffers"><a href="#8-7-4-clearNioBuffers" class="headerlink" title="8.7.4 clearNioBuffers"></a>8.7.4 clearNioBuffers</h3><p><code>#clearNioBuffers()</code> 方法，<strong>清除</strong> NIO ByteBuff 数组的缓存。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Clear all ByteBuffer from the array so these can be GC'ed.</span></span><br><span class="line"><span class="comment">// See https://github.com/netty/netty/issues/3837</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearNioBuffers</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> count = nioBufferCount;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 归零 nioBufferCount 。老艿艿觉得，应该把 nioBufferSize 也归零</span></span><br><span class="line">        nioBufferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 置空 NIO ByteBuf 数组</span></span><br><span class="line">        Arrays.fill(NIO_BUFFERS.get(), <span class="number">0</span>, count, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。主要目的是 help gc 。</li>
</ul>
<h2 id="8-8-failFlushed"><a href="#8-8-failFlushed" class="headerlink" title="8.8 failFlushed"></a>8.8 failFlushed</h2><p><code>#failFlushed(Throwable cause, boolean notify)</code> 方法，写入数据到对端<strong>失败</strong>，进行后续的处理，详细看代码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">failFlushed</span><span class="params">(Throwable cause, <span class="keyword">boolean</span> notify)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 正在通知 flush 失败中，直接返回</span></span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// Make sure that this method does not reenter.  A listener added to the current promise can be notified by the</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// current thread in the tryFailure() call of the loop below, and the listener can trigger another fail() call</span></span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// indirectly (usually by closing the channel.)</span></span><br><span class="line"> <span class="number">6</span>:     <span class="comment">//</span></span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// See https://github.com/netty/netty/issues/1501</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (inFail) {</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">10</span>:     }</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:     <span class="keyword">try</span> {</span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 标记正在通知 flush 失败中</span></span><br><span class="line"><span class="number">14</span>:         inFail = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">15</span>:         <span class="comment">// 循环，移除所有已 flush 的 Entry 节点们</span></span><br><span class="line"><span class="number">16</span>:         <span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="number">17</span>:             <span class="keyword">if</span> (!remove0(cause, notify)) {</span><br><span class="line"><span class="number">18</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">19</span>:             }</span><br><span class="line"><span class="number">20</span>:         }</span><br><span class="line"><span class="number">21</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 标记不在通知 flush 失败中</span></span><br><span class="line"><span class="number">23</span>:         inFail = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">24</span>:     }</span><br><span class="line"><span class="number">25</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 10 行：正在通知 flush 失败中，直接返回。</li>
<li>第 14 行：标记正在通知 flush 失败中，即 <code>inFail = true</code> 。</li>
<li>第 15 至 20 行：循环，调用 <code>#remove0(Throwable cause, boolean notifyWritability)</code> 方法，移除<strong>所有</strong>已 flush 的 Entry 节点们。详细解析，见 <a href="#">「8. remove0」</a> 中。</li>
<li>第 21 至 24 行：标记不在通知 flush 失败中，即 <code>inFail = false</code> 。</li>
</ul>
<h3 id="8-8-1-remove0"><a href="#8-8-1-remove0" class="headerlink" title="8.8.1 remove0"></a>8.8.1 remove0</h3><p><code>#remove0(Throwable cause, boolean notifyWritability)</code> 方法，移除当前消息对应的 Entry 对象，并 Promise 通知异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove0</span><span class="params">(Throwable cause, <span class="keyword">boolean</span> notifyWritability)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     Entry e = flushedEntry;</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 所有 flush 的 Entry 节点，都已经写到对端</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (e == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// // 清除 NIO ByteBuff 数组的缓存</span></span><br><span class="line"> <span class="number">6</span>:         clearNioBuffers();</span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 没有后续的 flush 的 Entry 节点</span></span><br><span class="line"> <span class="number">8</span>:     }</span><br><span class="line"> <span class="number">9</span>:     Object msg = e.msg;</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>:     ChannelPromise promise = e.promise;</span><br><span class="line"><span class="number">12</span>:     <span class="keyword">int</span> size = e.pendingSize;</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:     removeEntry(e);</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="keyword">if</span> (!e.cancelled) {</span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 释放消息( 数据 )相关的资源</span></span><br><span class="line"><span class="number">18</span>:         <span class="comment">// only release message, fail and decrement if it was not canceled before.</span></span><br><span class="line"><span class="number">19</span>:         ReferenceCountUtil.safeRelease(msg);</span><br><span class="line"><span class="number">20</span>:         <span class="comment">// 通知 Promise 执行失败</span></span><br><span class="line"><span class="number">21</span>:         safeFail(promise, cause);</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 减少 totalPendingSize 计数</span></span><br><span class="line"><span class="number">23</span>:         decrementPendingOutboundBytes(size, <span class="keyword">false</span>, notifyWritability);</span><br><span class="line"><span class="number">24</span>:     }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:     <span class="comment">// 回收 Entry 对象</span></span><br><span class="line"><span class="number">27</span>:     <span class="comment">// recycle the entry</span></span><br><span class="line"><span class="number">28</span>:     e.recycle();</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:     <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 还有后续的 flush 的 Entry 节点</span></span><br><span class="line"><span class="number">31</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 8 行：若<strong>所有</strong> flush 的 Entry 节点，都已经写到对端，则调用 <code>#clearNioBuffers()</code> 方法，清除 NIO ByteBuff 数组的缓存。</li>
<li>第 14 行：调用 <code>#removeEntry(Entry e)</code> 方法，移除<strong>指定</strong> Entry 对象。详细解析，见 <a href="#">「8.7.3 removeEntry」</a> 。</li>
<li>第 16 行：若 Entry 已取消，则忽略。</li>
<li>第 19 行：<code>ReferenceCountUtil#safeRelease(msg)</code> 方法，释放消息( 数据 )相关的资源。</li>
<li><p>第 21 行：【<strong>重要</strong>】调用 <code>#safeFail(promise)</code> 方法，通知 Promise 执行失败。此处才是，真正触发 <code>Channel#write(...)</code> 或 <code>Channel#writeAndFlush(...)</code> 方法，返回的 Promise 的通知。<code>#safeFail(promise)</code> 方法的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeFail</span><span class="params">(ChannelPromise promise, Throwable cause)</span> </span>{</span><br><span class="line">    <span class="comment">// Only log if the given promise is not of type VoidChannelPromise as tryFailure(...) is expected to return</span></span><br><span class="line">    <span class="comment">// false.</span></span><br><span class="line">    PromiseNotificationUtil.tryFailure(promise, cause, promise <span class="keyword">instanceof</span> VoidChannelPromise ? <span class="keyword">null</span> : logger);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 23 行：调用 <code>#decrementPendingOutboundBytes(long size, ...)</code> 方法，减少 <code>totalPendingSize</code> 计数。</p>
</li>
<li>第 28 行：调用 <code>Entry#recycle()</code> 方法，<strong>回收</strong> Entry 对象。</li>
</ul>
<h2 id="8-9-forEachFlushedMessage"><a href="#8-9-forEachFlushedMessage" class="headerlink" title="8.9 forEachFlushedMessage"></a>8.9 forEachFlushedMessage</h2><p>TODO 1015 forEachFlushedMessage 在 <code>netty-transport-native-poll</code> 和 <code>netty-transport-native-kqueue</code> 中使用，在后续的文章解析。</p>
<h2 id="8-10-close"><a href="#8-10-close" class="headerlink" title="8.10 close"></a>8.10 close</h2><p><code>#close(...)</code> 方法，关闭 ChannelOutboundBuffer ，进行后续的处理，详细看代码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ClosedChannelException cause)</span> </span>{</span><br><span class="line">    close(cause, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> Throwable cause, <span class="keyword">final</span> <span class="keyword">boolean</span> allowChannelOpen)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// 正在通知 flush 失败中</span></span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">if</span> (inFail) {</span><br><span class="line">  <span class="number">4</span>:         <span class="comment">// 提交 EventLoop 的线程中，执行关闭</span></span><br><span class="line">  <span class="number">5</span>:         channel.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">  <span class="number">6</span>:             <span class="meta">@Override</span></span><br><span class="line">  <span class="number">7</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="number">8</span>:                 close(cause, allowChannelOpen);</span><br><span class="line">  <span class="number">9</span>:             }</span><br><span class="line"> <span class="number">10</span>:         });</span><br><span class="line"> <span class="number">11</span>:         <span class="comment">// 返回</span></span><br><span class="line"> <span class="number">12</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">13</span>:     }</span><br><span class="line"> <span class="number">14</span>: </span><br><span class="line"> <span class="number">15</span>:     <span class="comment">// 标记正在通知 flush 失败中</span></span><br><span class="line"> <span class="number">16</span>:     inFail = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">17</span>: </span><br><span class="line"> <span class="number">18</span>:     <span class="keyword">if</span> (!allowChannelOpen &amp;&amp; channel.isOpen()) {</span><br><span class="line"> <span class="number">19</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"close() must be invoked after the channel is closed."</span>);</span><br><span class="line"> <span class="number">20</span>:     }</span><br><span class="line"> <span class="number">21</span>: </span><br><span class="line"> <span class="number">22</span>:     <span class="keyword">if</span> (!isEmpty()) {</span><br><span class="line"> <span class="number">23</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"close() must be invoked after all flushed writes are handled."</span>);</span><br><span class="line"> <span class="number">24</span>:     }</span><br><span class="line"> <span class="number">25</span>: </span><br><span class="line"> <span class="number">26</span>:     <span class="comment">// Release all unflushed messages.</span></span><br><span class="line"> <span class="number">27</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">28</span>:         <span class="comment">// 从 unflushedEntry 节点，开始向下遍历</span></span><br><span class="line"> <span class="number">29</span>:         Entry e = unflushedEntry;</span><br><span class="line"> <span class="number">30</span>:         <span class="keyword">while</span> (e != <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">31</span>:             <span class="comment">// 减少 totalPendingSize</span></span><br><span class="line"> <span class="number">32</span>:             <span class="comment">// Just decrease; do not trigger any events via decrementPendingOutboundBytes()</span></span><br><span class="line"> <span class="number">33</span>:             <span class="keyword">int</span> size = e.pendingSize;</span><br><span class="line"> <span class="number">34</span>:             TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, -size);</span><br><span class="line"> <span class="number">35</span>: </span><br><span class="line"> <span class="number">36</span>:             <span class="keyword">if</span> (!e.cancelled) {</span><br><span class="line"> <span class="number">37</span>:                 <span class="comment">// 释放消息( 数据 )相关的资源</span></span><br><span class="line"> <span class="number">38</span>:                 ReferenceCountUtil.safeRelease(e.msg);</span><br><span class="line"> <span class="number">39</span>:                 <span class="comment">// 通知 Promise 执行失败</span></span><br><span class="line"> <span class="number">40</span>:                 safeFail(e.promise, cause);</span><br><span class="line"> <span class="number">41</span>:             }</span><br><span class="line"> <span class="number">42</span>:             <span class="comment">// 回收当前节点，并获得下一个 Entry 节点</span></span><br><span class="line"> <span class="number">43</span>:             e = e.recycleAndGetNext();</span><br><span class="line"> <span class="number">44</span>:         }</span><br><span class="line"> <span class="number">45</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">46</span>:         <span class="comment">// 标记在在通知 flush 失败中</span></span><br><span class="line"> <span class="number">47</span>:         inFail = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">48</span>:     }</span><br><span class="line"> <span class="number">49</span>: </span><br><span class="line"> <span class="number">50</span>:     <span class="comment">// 清除 NIO ByteBuff 数组的缓存。</span></span><br><span class="line"> <span class="number">51</span>:     clearNioBuffers();</span><br><span class="line"> <span class="number">52</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：正在通知 flush 失败中：<ul>
<li>第 5 至 10 行: 提交 EventLoop 的线程中，执行关闭。</li>
<li>第 12 行：<code>return</code> 返回。</li>
</ul>
</li>
<li>第 16 行：标记正在通知 flush 失败中，即 <code>inFail = true</code> 。</li>
<li>第 28 至 30 行：从 <code>unflushedEntry</code> 节点，开始向下遍历。<ul>
<li>第 31 至 34 行：减少 <code>totalPendingSize</code> 计数。</li>
<li>第 36 行：若 Entry 已取消，则忽略。</li>
<li>第 38 行：调用 <code>ReferenceCountUtil#safeRelease(msg)</code> 方法，释放消息( 数据 )相关的资源。</li>
<li>第 40 行：【<strong>重要</strong>】调用 <code>#safeFail(promise)</code> 方法，通知 Promise 执行失败。此处才是，真正触发 <code>Channel#write(...)</code> 或 <code>Channel#writeAndFlush(...)</code> 方法，返回的 Promise 的通知。</li>
<li>第 43 行：调用 <code>Entry#recycleAndGetNext()</code> 方法，回收当前节点，并获得下一个 Entry 节点。</li>
</ul>
</li>
<li>第 45 至 48 行：标记不在通知 flush 失败中，即 <code>inFail = false</code> 。</li>
<li>第 51 行：调用 <code>#clearNioBuffers()</code> 方法，<strong>清除</strong> NIO ByteBuff 数组的缓存。</li>
</ul>
<h1 id="9-NioEventLoop"><a href="#9-NioEventLoop" class="headerlink" title="9. NioEventLoop"></a>9. NioEventLoop</h1><p>在上文 <a href="#">「7. NioSocketChannel」</a> 中，在写入到 Channel 到对端，若 TCP 数据发送缓冲区<strong>已满</strong>，这将导致 Channel <strong>不写可</strong>，此时会注册对该 Channel 的 <code>SelectionKey.OP_WRITE</code> 事件感兴趣。从而实现，再在 Channel 可写后，进行<strong>强制</strong> flush 。这块的逻辑，在 <code>NioEventLoop#processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 中实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OP_WRITE 事件就绪</span></span><br><span class="line"><span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line"><span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">    <span class="comment">// 向 Channel 写入数据</span></span><br><span class="line">    ch.unsafe().forceFlush();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>通过 Selector 轮询到 Channel 的 <code>OP_WRITE</code> 就绪时，调用 <code>AbstractNioUnsafe#forceFlush()</code> 方法，强制 flush 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractNioUnsafe.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forceFlush</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// directly call super.flush0() to force a flush now</span></span><br><span class="line">    <span class="keyword">super</span>.flush0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>后续的逻辑，又回到 <a href="#">「6. AbstractUnsafe」</a> 小节的 <code>#flush0()</code> 流程。</li>
<li>在完成强制 flush 之后，会取消对 <code>SelectionKey.OP_WRITE</code> 事件的感兴趣。</li>
</ul>
</li>
</ul>
<h2 id="9-1-如何模拟"><a href="#9-1-如何模拟" class="headerlink" title="9.1 如何模拟"></a>9.1 如何模拟</h2><ol>
<li><p>配置服务端 ServerBootstrap 的启动参数如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">.childOption(ChannelOption.SO_SNDBUF, <span class="number">5</span>) <span class="comment">// Socket 参数，TCP 数据发送缓冲区大小。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>telnet</code> 到启动的服务端，发送相对长的命令，例如 <code>"abcdefghijklmnopqrstuvw11321321321nhdkslk"</code> 。</p>
</li>
</ol>
<h1 id="10-ChannelOutboundBuffer-写入控制"><a href="#10-ChannelOutboundBuffer-写入控制" class="headerlink" title="10. ChannelOutboundBuffer 写入控制"></a>10. ChannelOutboundBuffer 写入控制</h1><p>当我们不断调用 <code>#addMessage(Object msg, int size, ChannelPromise promise)</code> 方法，添加消息到 ChannelOutboundBuffer 内存队列中，如果<strong>不及时</strong> flush 写到对端( 例如程序一直未调用 <code>Channel#flush()</code> 方法，或者对端接收数据比较慢导致 Channel 不可写 )，可能会导致 <strong>OOM 内存溢出</strong>。所以，在 ChannelOutboundBuffer 使用 <code>totalPendingSize</code> 属性，存储所有 Entry 预计占用的内存大小( <code>pendingSize</code> )。</p>
<ul>
<li>在 <code>totalPendingSize</code> 大于高水位阀值时( <code>ChannelConfig.writeBufferHighWaterMark</code> ，默认值为 64 KB )，<strong>关闭</strong>写开关( <code>unwritable</code> )。详细解析，见 <a href="#">「10.1 incrementPendingOutboundBytes」</a> 。</li>
<li>在 <code>totalPendingSize</code> 小于低水位阀值时( <code>ChannelConfig.writeBufferLowWaterMark</code> ，默认值为 32 KB )，<strong>打开</strong>写开关( <code>unwritable</code> )。详细解析，见 <a href="#">「10.2 decrementPendingOutboundBytes」</a> 。</li>
</ul>
<p>该功能，对应 Github 提交为 <a href="https://github.com/netty/netty/commit/e3cb9935c0b63357e3d51867cffe624129e7e1dd" rel="external nofollow noopener noreferrer" target="_blank">《Take memory overhead of ChannelOutboundBuffer / PendingWriteQueue into account》</a> 。</p>
<h2 id="10-1-incrementPendingOutboundBytes"><a href="#10-1-incrementPendingOutboundBytes" class="headerlink" title="10.1 incrementPendingOutboundBytes"></a>10.1 incrementPendingOutboundBytes</h2><p><code>#incrementPendingOutboundBytes(long size, ...)</code> 方法，增加 <code>totalPendingSize</code> 计数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * Increment the pending bytes which will be written at some point.</span></span><br><span class="line"><span class="comment"> 3:  * This method is thread-safe!</span></span><br><span class="line"><span class="comment"> 4:  */</span></span><br><span class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">void</span> <span class="title">incrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size)</span> </span>{</span><br><span class="line"> <span class="number">6</span>:     incrementPendingOutboundBytes(size, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">7</span>: }</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater)</span> </span>{</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">12</span>:     }</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 增加 totalPendingSize 计数</span></span><br><span class="line"><span class="number">15</span>:     <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, size);</span><br><span class="line"><span class="number">16</span>:     <span class="comment">// totalPendingSize 大于高水位阀值时，设置为不可写</span></span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) {</span><br><span class="line"><span class="number">18</span>:         setUnwritable(invokeLater);</span><br><span class="line"><span class="number">19</span>:     }</span><br><span class="line"><span class="number">20</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 15 行：增加 <code>totalPendingSize</code> 计数。</li>
<li><p>第 16 至 19 行：<code>totalPendingSize</code> 大于高水位阀值时，调用 <code>#setUnwritable(boolean invokeLater)</code> 方法，设置为不可写。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnwritable</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 或位操作，修改第 0 位 bits 为 1</span></span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue | <span class="number">1</span>;</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// CAS 设置 unwritable 为新值</span></span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) {</span><br><span class="line"> <span class="number">8</span>:             <span class="comment">// 若之前可写，现在不可写，触发 Channel WritabilityChanged 事件到 pipeline 中。</span></span><br><span class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (oldValue == <span class="number">0</span> &amp;&amp; newValue != <span class="number">0</span>) {</span><br><span class="line"><span class="number">10</span>:                 fireChannelWritabilityChanged(invokeLater);</span><br><span class="line"><span class="number">11</span>:             }</span><br><span class="line"><span class="number">12</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">13</span>:         }</span><br><span class="line"><span class="number">14</span>:     }</span><br><span class="line"><span class="number">15</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 行：<code>for</code> 循环，直到 CAS 修改成功</li>
<li>第 5 行：或位操作，修改第 0 位 bits 为 1 。😈 比较神奇的是，<code>unwritable</code> 的类型不是 <code>boolean</code> ，而是 <code>int</code> 类型。通过每个 bits ，来表示<strong>哪种</strong>类型不可写。感兴趣的胖友，可以看看 <code>io.netty.handler.traffic.AbstractTrafficShapingHandler</code> ，使用了第 1、2、3 bits 。</li>
<li>第 7 行：CAS 设置 <code>unwritable</code> 为新值。</li>
<li>第 8 至 11 行：若之前可写，现在不可写，调用 <code>#fireChannelWritabilityChanged(boolean invokeLater)</code> 方法，触发 Channel WritabilityChanged 事件到 pipeline 中。详细解析，见 <a href="#">「10.3 fireChannelWritabilityChanged」</a> 。</li>
</ul>
</li>
</ul>
<h3 id="10-1-1-bytesBeforeUnwritable"><a href="#10-1-1-bytesBeforeUnwritable" class="headerlink" title="10.1.1 bytesBeforeUnwritable"></a>10.1.1 bytesBeforeUnwritable</h3><p><code>#bytesBeforeUnwritable()</code> 方法，获得距离<strong>不可写</strong>还有多少字节数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">bytesBeforeUnwritable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> bytes = channel.config().getWriteBufferHighWaterMark() - totalPendingSize;</span><br><span class="line">    <span class="comment">// If bytes is negative we know we are not writable, but if bytes is non-negative we have to check writability.</span></span><br><span class="line">    <span class="comment">// Note that totalPendingSize and isWritable() use different volatile variables that are not synchronized</span></span><br><span class="line">    <span class="comment">// together. totalPendingSize will be updated before isWritable().</span></span><br><span class="line">    <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> isWritable() ? bytes : <span class="number">0</span>; <span class="comment">// 判断 #isWritable() 的原因是，可能已经被设置不可写</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>基于<strong>高水位</strong>阀值来判断。</li>
</ul>
<h2 id="10-2-decrementPendingOutboundBytes"><a href="#10-2-decrementPendingOutboundBytes" class="headerlink" title="10.2 decrementPendingOutboundBytes"></a>10.2 decrementPendingOutboundBytes</h2><p><code>#decrementPendingOutboundBytes(long size, ...)</code> 方法，减少 <code>totalPendingSize</code> 计数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * Decrement the pending bytes which will be written at some point.</span></span><br><span class="line"><span class="comment"> 3:  * This method is thread-safe!</span></span><br><span class="line"><span class="comment"> 4:  */</span></span><br><span class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">void</span> <span class="title">decrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size)</span> </span>{</span><br><span class="line"> <span class="number">6</span>:     decrementPendingOutboundBytes(size, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">7</span>: }</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater, <span class="keyword">boolean</span> notifyWritability)</span> </span>{</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">12</span>:     }</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 减少 totalPendingSize 计数</span></span><br><span class="line"><span class="number">15</span>:     <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, -size);</span><br><span class="line"><span class="number">16</span>:     <span class="comment">// totalPendingSize 小于低水位阀值时，设置为可写</span></span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark()) {</span><br><span class="line"><span class="number">18</span>:         setWritable(invokeLater);</span><br><span class="line"><span class="number">19</span>:     }</span><br><span class="line"><span class="number">20</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 15 行：减少 <code>totalPendingSize</code> 计数。</li>
<li><p>第 16 至 19 行：<code>totalPendingSize</code> 小于低水位阀值时，调用 <code>#setWritable(boolean invokeLater)</code> 方法，设置为可写。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWritable</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 并位操作，修改第 0 位 bits 为 0</span></span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue &amp; ~<span class="number">1</span>;</span><br><span class="line"> <span class="number">6</span>:         <span class="comment">// CAS 设置 unwritable 为新值</span></span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) {</span><br><span class="line"> <span class="number">8</span>:             <span class="comment">// 若之前不可写，现在可写，触发 Channel WritabilityChanged 事件到 pipeline 中。</span></span><br><span class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (oldValue != <span class="number">0</span> &amp;&amp; newValue == <span class="number">0</span>) {</span><br><span class="line"><span class="number">10</span>:                 fireChannelWritabilityChanged(invokeLater);</span><br><span class="line"><span class="number">11</span>:             }</span><br><span class="line"><span class="number">12</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">13</span>:         }</span><br><span class="line"><span class="number">14</span>:     }</span><br><span class="line"><span class="number">15</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 行：<code>for</code> 循环，直到 CAS 修改成功</li>
<li>第 5 行：并位操作，修改第 0 位 bits 为 0 。</li>
<li>第 7 行：CAS 设置 <code>unwritable</code> 为新值。</li>
<li>第 8 至 11 行：若之前可写，现在不可写，调用 <code>#fireChannelWritabilityChanged(boolean invokeLater)</code> 方法，触发 Channel WritabilityChanged 事件到 pipeline 中。详细解析，见 <a href="#">「10.3 fireChannelWritabilityChanged」</a> 。</li>
</ul>
</li>
</ul>
<h3 id="10-2-1-bytesBeforeWritable"><a href="#10-2-1-bytesBeforeWritable" class="headerlink" title="10.2.1 bytesBeforeWritable"></a>10.2.1 bytesBeforeWritable</h3><p><code>#bytesBeforeWritable()</code> 方法，获得距离<strong>可写</strong>还要多少字节数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get how many bytes must be drained from the underlying buffer until {<span class="doctag">@link</span> #isWritable()} returns {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment"> * This quantity will always be non-negative. If {<span class="doctag">@link</span> #isWritable()} is {<span class="doctag">@code</span> true} then 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">bytesBeforeWritable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> bytes = totalPendingSize - channel.config().getWriteBufferLowWaterMark();</span><br><span class="line">    <span class="comment">// If bytes is negative we know we are writable, but if bytes is non-negative we have to check writability.</span></span><br><span class="line">    <span class="comment">// Note that totalPendingSize and isWritable() use different volatile variables that are not synchronized</span></span><br><span class="line">    <span class="comment">// together. totalPendingSize will be updated before isWritable().</span></span><br><span class="line">    <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> isWritable() ? <span class="number">0</span> : bytes; <span class="comment">// 判断 #isWritable() 的原因是，可能已经被设置不可写</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>基于<strong>低水位</strong>阀值来判断。</li>
</ul>
<h2 id="10-3-fireChannelWritabilityChanged"><a href="#10-3-fireChannelWritabilityChanged" class="headerlink" title="10.3 fireChannelWritabilityChanged"></a>10.3 fireChannelWritabilityChanged</h2><p><code>#fireChannelWritabilityChanged(boolean invokeLater)</code> 方法，触发 Channel WritabilityChanged 事件到 pipeline 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireChannelWritabilityChanged</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">    <span class="comment">// 延迟执行，即提交 EventLoop 中触发 Channel WritabilityChanged 事件到 pipeline 中</span></span><br><span class="line">    <span class="keyword">if</span> (invokeLater) {</span><br><span class="line">        Runnable task = fireChannelWritabilityChangedTask;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">            fireChannelWritabilityChangedTask = task = <span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    pipeline.fireChannelWritabilityChanged();</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line">        }</span><br><span class="line">        channel.eventLoop().execute(task);</span><br><span class="line">    <span class="comment">// 直接触发 Channel WritabilityChanged 事件到 pipeline 中</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pipeline.fireChannelWritabilityChanged();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据 <code>invokeLater</code> 的值，分成两种方式，调用 <code>ChannelPipeline#fireChannelWritabilityChanged()</code> 方法，触发 Channel WritabilityChanged 事件到 pipeline 中。具体，胖友看下代码注释。</li>
<li>后续的流程，就是 <a href="http://svip.iocoder.cn/Netty/Pipeline-5-inbound/">《精尽 Netty 源码解析 —— ChannelPipeline（五）之 Inbound 事件的传播》</a> 。</li>
<li>通过 Channel WritabilityChanged 事件，配合 <code>io.netty.handler.stream.ChunkedWriteHandler</code> 处理器，实现 ChannelOutboundBuffer 写入的控制，避免 OOM 。ChunkedWriteHandler 的具体代码实现，我们在后续的文章，详细解析。<ul>
<li>所以，有一点要注意，ChannelOutboundBuffer 的 <code>unwritable</code> 属性，仅仅作为一个是否不可写的<strong>开关</strong>，具体需要配合响应的 ChannelHandler 处理器，才能实现“不可写”的功能。</li>
</ul>
</li>
</ul>
<h2 id="10-4-isWritable"><a href="#10-4-isWritable" class="headerlink" title="10.4 isWritable"></a>10.4 isWritable</h2><p><code>#isWritable()</code> 方法，是否可写。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if and only if {<span class="doctag">@linkplain</span> #totalPendingWriteBytes() the total number of pending bytes} did</span></span><br><span class="line"><span class="comment"> * not exceed the write watermark of the {<span class="doctag">@link</span> Channel} and</span></span><br><span class="line"><span class="comment"> * no {<span class="doctag">@linkplain</span> #setUserDefinedWritability(int, boolean) user-defined writability flag} has been set to</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> false}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unwritable == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果 <code>unwritable</code> 大于 0 ，则表示不可写。😈 一定要注意！！！</li>
</ul>
<h3 id="10-4-1-getUserDefinedWritability"><a href="#10-4-1-getUserDefinedWritability" class="headerlink" title="10.4.1 getUserDefinedWritability"></a>10.4.1 getUserDefinedWritability</h3><p><code>#getUserDefinedWritability(int index)</code> 方法，获得指定 bits 是否可写。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if and only if the user-defined writability flag at the specified index is set to</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUserDefinedWritability</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (unwritable &amp; writabilityMask(index)) == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writabilityMask</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">// 不能 &lt; 1 ，因为第 0 bits 为 ChannelOutboundBuffer 自己使用</span></span><br><span class="line">    <span class="comment">// 不能 &gt; 31 ，因为超过 int 的 bits 范围</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; <span class="number">31</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index: "</span> + index + <span class="string">" (expected: 1~31)"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>为什么方法名字上会带有 <code>"UserDefined"</code> 呢？因为 <code>index</code> 不能使用 0 ，表示只允许使用用户定义( <code>"UserDefined"</code> ) bits 位，即 <code>[1, 31]</code> 。</li>
</ul>
<h3 id="10-4-2-setUserDefinedWritability"><a href="#10-4-2-setUserDefinedWritability" class="headerlink" title="10.4.2 setUserDefinedWritability"></a>10.4.2 setUserDefinedWritability</h3><p><code>#setUserDefinedWritability(int index, boolean writable)</code> 方法，设置指定 bits 是否可写。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets a user-defined writability flag at the specified index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDefinedWritability</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> writable)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置可写</span></span><br><span class="line">    <span class="keyword">if</span> (writable) {</span><br><span class="line">        setUserDefinedWritability(index);</span><br><span class="line">    <span class="comment">// 设置不可写</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        clearUserDefinedWritability(index);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUserDefinedWritability</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mask = ~writabilityMask(index);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue &amp; mask;</span><br><span class="line">        <span class="comment">// CAS 设置 unwritable 为新值</span></span><br><span class="line">        <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) {</span><br><span class="line">            <span class="comment">// 若之前不可写，现在可写，触发 Channel WritabilityChanged 事件到 pipeline 中。</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != <span class="number">0</span> &amp;&amp; newValue == <span class="number">0</span>) {</span><br><span class="line">                fireChannelWritabilityChanged(<span class="keyword">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearUserDefinedWritability</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mask = writabilityMask(index);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue | mask;</span><br><span class="line">        <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) {</span><br><span class="line">            <span class="comment">// 若之前可写，现在不可写，触发 Channel WritabilityChanged 事件到 pipeline 中。</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue == <span class="number">0</span> &amp;&amp; newValue != <span class="number">0</span>) {</span><br><span class="line">                fireChannelWritabilityChanged(<span class="keyword">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看噢。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>比想象中，长的多的多的一篇文章。总的来说，绝大部分细节，都已经扣到，美滋滋。如果有解释不够清晰或错误的细节，一起多多沟通呀。</p>
<p>写完这篇，我简直疯了。。。。</p>
<p>推荐阅读文章：</p>
<ul>
<li>莫那一鲁道 <a href="https://www.jianshu.com/p/311425d1c72f" rel="external nofollow noopener noreferrer" target="_blank">《Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）》</a></li>
<li>tomas家的小拨浪鼓 <a href="https://www.jianshu.com/p/a3443cacd081" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码解析 ——— writeAndFlush流程分析》</a></li>
<li>闪电侠 <a href="https://www.jianshu.com/p/feaeaab2ce56" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之 writeAndFlush 全解析》</a></li>
<li>占小狼 <a href="https://www.jianshu.com/p/1ad424c53e80" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出 Netty write》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/9258af254e1d" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（六）–Channel源码实现》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Channel-5-flush/" data-id="ck4pl3fr100hbfgcfsc4t9ar0" class="article-share-link">分享</a>

</footer>
-->
</div>
