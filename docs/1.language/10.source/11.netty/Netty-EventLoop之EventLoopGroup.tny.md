<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（二）之 EventLoopGroup
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/intro-2/?self">《精尽 Netty 源码分析 —— Netty 简介（二）之核心组件》</a> 中，对 EventLoopGroup 和 EventLoop 做了定义，我们再来回顾下：</p>
<blockquote>
<ul>
<li>Channel 为Netty 网络操作抽象类，EventLoop 负责处理注册到其上的 Channel 处理 I/O 操作，两者配合参与 I/O 操作。</li>
<li>EventLoopGroup 是一个 EventLoop 的分组，它可以获取到一个或者多个 EventLoop 对象，因此它提供了迭代出 EventLoop 对象的方法。</li>
</ul>
</blockquote>
<p>在 <a href="#">《精尽 Netty 源码分析 —— 启动》</a> 中，我们特别熟悉的一段代码就是：</p>
<ul>
<li><code>new NioEventLoopGroup()</code> ，创建一个 EventLoopGroup 对象。</li>
<li><code>EventLoopGroup#register(Channel channel)</code> ，将 Channel 注册到 EventLoopGroup 上。</li>
</ul>
<p>那么，本文我们分享 EventLoopGroup 的具体代码实现，来一探究竟。</p>
<h1 id="2-类结构图"><a href="#2-类结构图" class="headerlink" title="2. 类结构图"></a>2. 类结构图</h1><p>EventLoopGroup 的整体类结构如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_05_04/01.png" title="EventLoopGroup 类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_05_04/01.png" alt="EventLoopGroup 类图"></a><span class="caption">EventLoopGroup 类图</span></p>
<ul>
<li>红框部分，为 EventLoopGroup 相关的类关系。其他部分，为 EventLoop 相关的类关系。</li>
<li>因为我们实际上使用的是 <strong>NioEventLoopGroup</strong> 和 NioEventLoop ，所以笔者省略了其它相关的类，例如 OioEventLoopGroup、EmbeddedEventLoop 等等。</li>
</ul>
<p>下面，我们逐层看看每个接口和类的实现代码。</p>
<h1 id="3-EventExecutorGroup"><a href="#3-EventExecutorGroup" class="headerlink" title="3. EventExecutorGroup"></a>3. EventExecutorGroup</h1><p><code>io.netty.util.concurrent.EventExecutorGroup</code> ，实现 Iterable、ScheduledExecutorService 接口，EventExecutor ( 事件执行器 )的分组接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 自定义接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShuttingDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优雅关闭</span></span><br><span class="line">Future&lt;?&gt; shutdownGracefully();</span><br><span class="line">Future&lt;?&gt; shutdownGracefully(<span class="keyword">long</span> quietPeriod, <span class="keyword">long</span> timeout, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; terminationFuture();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择一个 EventExecutor 对象</span></span><br><span class="line"><span class="function">EventExecutor <span class="title">next</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 实现自 Iterable 接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Iterator&lt;EventExecutor&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 实现自 ExecutorService 接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 实现自 ScheduledExecutorService 接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个接口的方法的意思比较好理解，笔者就不一一赘述了。</li>
<li>比较特殊的是，接口方法返回类型为 Future 不是 Java 原生的 <code>java.util.concurrent.Future</code> ，而是 Netty 自己实现的 Future 接口。详细解析，见后续文章。</li>
<li>EventExecutorGroup 自身不执行任务，而是将任务 <code>#submit(...)</code> 或 <code>#schedule(...)</code> 给自己管理的 EventExecutor 的分组。至于提交给哪一个 EventExecutor ，一般是通过 <code>#next()</code> 方法，选择一个 EventExecutor 。</li>
</ul>
<h1 id="4-AbstractEventExecutorGroup"><a href="#4-AbstractEventExecutorGroup" class="headerlink" title="4. AbstractEventExecutorGroup"></a>4. AbstractEventExecutorGroup</h1><p><code>io.netty.util.concurrent.AbstractEventExecutorGroup</code> ，实现 EventExecutorGroup 接口，EventExecutor ( 事件执行器 )的分组抽象类。</p>
<h2 id="4-1-submit"><a href="#4-1-submit" class="headerlink" title="4.1 submit"></a>4.1 submit</h2><p><code>#submit(...)</code> 方法，提交<strong>一个</strong>普通任务到 EventExecutor 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">return</span> next().submit(task);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().submit(task, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().submit(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>提交的 EventExecutor ，通过 <code>#next()</code> 方法选择。</li>
</ul>
<h2 id="4-2-schedule"><a href="#4-2-schedule" class="headerlink" title="4.2 schedule"></a>4.2 schedule</h2><p><code>#schedule(...)</code> 方法，提交<strong>一个</strong>定时任务到 EventExecutor 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">return</span> next().schedule(command, delay, unit);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().schedule(callable, delay, unit);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">return</span> next().scheduleAtFixedRate(command, initialDelay, period, unit);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">return</span> next().scheduleWithFixedDelay(command, initialDelay, delay, unit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>提交的 EventExecutor ，通过 <code>#next()</code> 方法选择。</li>
</ul>
<h2 id="4-3-execute"><a href="#4-3-execute" class="headerlink" title="4.3 execute"></a>4.3 execute</h2><p><code>#execute(...)</code> 方法，在 EventExecutor 中执行<strong>一个</strong>普通任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    next().execute(command);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>执行的 EventExecutor ，通过 <code>#next()</code> 方法选择。</li>
<li>看起来 <code>#execute(...)</code> 和 <code>#submit(...)</code> 方法有几分相似，具体的差异，由 EventExecutor 的实现决定。</li>
</ul>
<h2 id="4-4-invokeAll"><a href="#4-4-invokeAll" class="headerlink" title="4.4 invokeAll"></a>4.4 invokeAll</h2><p><code>#invokeAll(...)</code> 方法，在 EventExecutor 中执行<strong>多个</strong>普通任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;java.util.concurrent.Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">return</span> next().invokeAll(tasks);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;java.util.concurrent.Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">return</span> next().invokeAll(tasks, timeout, unit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>执行的 EventExecutor ，通过 <code>#next()</code> 方法选择。并且，多个任务使用同一个 EventExecutor 。</li>
</ul>
<h2 id="4-5-invokeAny"><a href="#4-5-invokeAny" class="headerlink" title="4.5 invokeAny"></a>4.5 invokeAny</h2><p><code>#invokeAll(...)</code> 方法，在 EventExecutor 中执行<strong>多个</strong>普通任务，有<strong>一个</strong>执行完成即可。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    <span class="keyword">return</span> next().invokeAny(tasks);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>{</span><br><span class="line">    <span class="keyword">return</span> next().invokeAny(tasks, timeout, unit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>执行的 EventExecutor ，通过 <code>#next()</code> 方法选择。并且，多个任务使用同一个 EventExecutor 。</li>
</ul>
<h2 id="4-6-shutdown"><a href="#4-6-shutdown" class="headerlink" title="4.6 shutdown"></a>4.6 shutdown</h2><p><code>#shutdown(...)</code> 方法，关闭 EventExecutorGroup 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully() {</span><br><span class="line">    <span class="keyword">return</span> shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD <span class="comment">/* 2 */</span>, DEFAULT_SHUTDOWN_TIMEOUT <span class="comment">/* 15 */</span>, TimeUnit.SECONDS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>{</span><br><span class="line">    shutdown();</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的 <code>#shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit)</code> 和 <code>#shutdown()</code> 方法，由子类实现。</li>
</ul>
<h1 id="5-MultithreadEventExecutorGroup"><a href="#5-MultithreadEventExecutorGroup" class="headerlink" title="5. MultithreadEventExecutorGroup"></a>5. MultithreadEventExecutorGroup</h1><p><code>io.netty.util.concurrent.MultithreadEventExecutorGroup</code> ，继承 AbstractEventExecutorGroup 抽象类，<strong>基于多线程</strong>的 EventExecutor ( 事件执行器 )的分组抽象类。</p>
<h2 id="5-1-构造方法"><a href="#5-1-构造方法" class="headerlink" title="5.1 构造方法"></a>5.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventExecutor 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不可变( 只读 )的 EventExecutor 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #MultithreadEventExecutorGroup(int, Executor, EventExecutorChooserFactory, Object...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;EventExecutor&gt; readonlyChildren;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已终止的 EventExecutor 数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger terminatedChildren = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于终止 EventExecutor 的异步 Future</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventExecutor 选择器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, threadFactory == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory), args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) {</span><br><span class="line">  <span class="number">3</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">  <span class="number">4</span>:     }</span><br><span class="line">  <span class="number">5</span>: </span><br><span class="line">  <span class="number">6</span>:     <span class="comment">// 创建执行器</span></span><br><span class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (executor == <span class="keyword">null</span>) {</span><br><span class="line">  <span class="number">8</span>:         executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">  <span class="number">9</span>:     }</span><br><span class="line"> <span class="number">10</span>: </span><br><span class="line"> <span class="number">11</span>:     <span class="comment">// 创建 EventExecutor 数组</span></span><br><span class="line"> <span class="number">12</span>:     children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"> <span class="number">13</span>: </span><br><span class="line"> <span class="number">14</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) {</span><br><span class="line"> <span class="number">15</span>:         <span class="keyword">boolean</span> success = <span class="keyword">false</span>; <span class="comment">// 是否创建成功</span></span><br><span class="line"> <span class="number">16</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">17</span>:             <span class="comment">// 创建 EventExecutor 对象</span></span><br><span class="line"> <span class="number">18</span>:             children[i] = newChild(executor, args);</span><br><span class="line"> <span class="number">19</span>:             <span class="comment">// 标记创建成功</span></span><br><span class="line"> <span class="number">20</span>:             success = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">21</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"> <span class="number">22</span>:             <span class="comment">// 创建失败，抛出 IllegalStateException 异常</span></span><br><span class="line"> <span class="number">23</span>:             <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line"> <span class="number">24</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line"> <span class="number">25</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">26</span>:             <span class="comment">// 创建失败，关闭所有已创建的 EventExecutor</span></span><br><span class="line"> <span class="number">27</span>:             <span class="keyword">if</span> (!success) {</span><br><span class="line"> <span class="number">28</span>:                 <span class="comment">// 关闭所有已创建的 EventExecutor</span></span><br><span class="line"> <span class="number">29</span>:                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) {</span><br><span class="line"> <span class="number">30</span>:                     children[j].shutdownGracefully();</span><br><span class="line"> <span class="number">31</span>:                 }</span><br><span class="line"> <span class="number">32</span>:                 <span class="comment">// 确保所有已创建的 EventExecutor 已关闭</span></span><br><span class="line"> <span class="number">33</span>:                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) {</span><br><span class="line"> <span class="number">34</span>:                     EventExecutor e = children[j];</span><br><span class="line"> <span class="number">35</span>:                     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">36</span>:                         <span class="keyword">while</span> (!e.isTerminated()) {</span><br><span class="line"> <span class="number">37</span>:                             e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line"> <span class="number">38</span>:                         }</span><br><span class="line"> <span class="number">39</span>:                     } <span class="keyword">catch</span> (InterruptedException interrupted) {</span><br><span class="line"> <span class="number">40</span>:                         <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line"> <span class="number">41</span>:                         Thread.currentThread().interrupt();</span><br><span class="line"> <span class="number">42</span>:                         <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">43</span>:                     }</span><br><span class="line"> <span class="number">44</span>:                 }</span><br><span class="line"> <span class="number">45</span>:             }</span><br><span class="line"> <span class="number">46</span>:         }</span><br><span class="line"> <span class="number">47</span>:     }</span><br><span class="line"> <span class="number">48</span>: </span><br><span class="line"> <span class="number">49</span>:     <span class="comment">// 创建 EventExecutor 选择器</span></span><br><span class="line"> <span class="number">50</span>:     chooser = chooserFactory.newChooser(children);</span><br><span class="line"> <span class="number">51</span>: </span><br><span class="line"> <span class="number">52</span>:     <span class="comment">// 创建监听器，用于 EventExecutor 终止时的监听</span></span><br><span class="line"> <span class="number">53</span>:     <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() {</span><br><span class="line"> <span class="number">54</span>: </span><br><span class="line"> <span class="number">55</span>:         <span class="meta">@Override</span></span><br><span class="line"> <span class="number">56</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">57</span>:             <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) { <span class="comment">// 全部关闭</span></span><br><span class="line"> <span class="number">58</span>:                 terminationFuture.setSuccess(<span class="keyword">null</span>); <span class="comment">// 设置结果，并通知监听器们。</span></span><br><span class="line"> <span class="number">59</span>:             }</span><br><span class="line"> <span class="number">60</span>:         }</span><br><span class="line"> <span class="number">61</span>: </span><br><span class="line"> <span class="number">62</span>:     };</span><br><span class="line"> <span class="number">63</span>:     <span class="comment">// 设置监听器到每个 EventExecutor 上</span></span><br><span class="line"> <span class="number">64</span>:     <span class="keyword">for</span> (EventExecutor e: children) {</span><br><span class="line"> <span class="number">65</span>:         e.terminationFuture().addListener(terminationListener);</span><br><span class="line"> <span class="number">66</span>:     }</span><br><span class="line"> <span class="number">67</span>: </span><br><span class="line"> <span class="number">68</span>:     <span class="comment">// 创建不可变( 只读 )的 EventExecutor 数组</span></span><br><span class="line"> <span class="number">69</span>:     Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line"> <span class="number">70</span>:     Collections.addAll(childrenSet, children);</span><br><span class="line"> <span class="number">71</span>:     readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line"> <span class="number">72</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>每个属性的定义，胖友直接看代码注释。</li>
<li>方法参数 <code>executor</code> ，执行器。详细解析，见 <a href="#">「5.2 ThreadPerTaskExecutor」</a> 。<ul>
<li>第 6 至 9 行：若 <code>executor</code> 为空，则创建执行器。</li>
</ul>
</li>
<li>第 12 行：创建 EventExecutor 数组。<ul>
<li>第 18 行：调用 <code>#newChild(Executor executor, Object... args)</code> 方法，创建 EventExecutor 对象，然后设置到数组中。</li>
<li>第 21 至 24 行：创建失败，抛出 IllegalStateException 异常。</li>
<li>第 25 至 45 行：创建失败，关闭所有已创建的 EventExecutor 。</li>
</ul>
</li>
<li>第 50 行：调用 <code>EventExecutorChooserFactory#newChooser(EventExecutor[] executors)</code> 方法，创建 EventExecutor 选择器。详细解析，见 <a href="#">「5.3 EventExecutorChooserFactory」</a> 。</li>
<li>第 52 至 62 行：创建监听器，用于 EventExecutor 终止时的监听。<ul>
<li>第 55 至 60 行：回调的具体逻辑是，当所有 EventExecutor 都终止完成时，通过调用 <code>Future#setSuccess(V result)</code> 方法，通知监听器们。至于为什么设置的值是 <code>null</code> ，因为监听器们不关注具体的结果。</li>
<li>第 63 至 66 行：设置监听器到每个 EventExecutor 上。</li>
</ul>
</li>
<li>第 68 至 71 行：创建不可变( 只读 )的 EventExecutor 数组。</li>
</ul>
<h2 id="5-2-ThreadPerTaskExecutor"><a href="#5-2-ThreadPerTaskExecutor" class="headerlink" title="5.2 ThreadPerTaskExecutor"></a>5.2 ThreadPerTaskExecutor</h2><p><code>io.netty.util.concurrent.ThreadPerTaskExecutor</code> ，实现 Executor 接口，每个任务一个线程的执行器实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程工厂对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>threadFactory</code> 属性，线程工厂对象。Netty 实现自定义的 ThreadFactory 类，为 <code>io.netty.util.concurrent.DefaultThreadFactory</code> 。关于 DefaultThreadFactory 比较简单，胖友可以自己看看。</li>
<li><code>#execute(Runnable command)</code> 方法，通过 <code>ThreadFactory#newThread(Runnable)</code> 方法，创建一个 Thread ，然后调用 <code>Thread#start()</code> 方法，<strong>启动线程执行任务</strong>。</li>
</ul>
<h2 id="5-3-EventExecutorChooserFactory"><a href="#5-3-EventExecutorChooserFactory" class="headerlink" title="5.3 EventExecutorChooserFactory"></a>5.3 EventExecutorChooserFactory</h2><p><code>io.netty.util.concurrent.EventExecutorChooserFactory</code> ，EventExecutorChooser 工厂接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorChooserFactory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个 EventExecutorChooser 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns a new {<span class="doctag">@link</span> EventExecutorChooser}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  EventExecutor 选择器接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Chooses the next {<span class="doctag">@link</span> EventExecutor} to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnstableApi</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorChooser</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选择下一个 EventExecutor 对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Returns the new {<span class="doctag">@link</span> EventExecutor} to use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">EventExecutor <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#newChooser(EventExecutor[] executors)</code> 方法，创建一个 EventExecutorChooser 对象。</li>
<li>EventExecutorChooser 接口，EventExecutor 选择器接口。<ul>
<li><code>#next()</code> 方法，选择下一个 EventExecutor 对象。</li>
</ul>
</li>
</ul>
<h3 id="5-3-1-DefaultEventExecutorChooserFactory"><a href="#5-3-1-DefaultEventExecutorChooserFactory" class="headerlink" title="5.3.1 DefaultEventExecutorChooserFactory"></a>5.3.1 DefaultEventExecutorChooserFactory</h3><p><code>io.netty.util.concurrent.DefaultEventExecutorChooserFactory</code> ，实现 EventExecutorChooserFactory 接口，默认 EventExecutorChooser 工厂实现类。代码如下</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultEventExecutorChooserFactory INSTANCE = <span class="keyword">new</span> DefaultEventExecutorChooserFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultEventExecutorChooserFactory</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) { <span class="comment">// 是否为 2 的幂次方</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>INSTANCE</code> <strong>静态</strong>属性，单例。</li>
<li><code>#newChooser(EventExecutor[] executors)</code> 方法，调用 <code>#isPowerOfTwo(int val)</code> 方法，判断 EventExecutor 数组的大小是否为 2 的幂次方。<ul>
<li>若是，创建 PowerOfTwoEventExecutorChooser 对象。详细解析，见 <a href="#">「5.3.3 PowerOfTwoEventExecutorChooser」</a> 。</li>
<li>若否，创建 GenericEventExecutorChooser 对象。详细解析，见 <a href="#">「5.3.2 GenericEventExecutorChooser」</a> 。</li>
</ul>
</li>
<li><code>#isPowerOfTwo(int val)</code> 方法，为什么 <code>(val &amp; -val) == val</code> 可以判断数字是否为 2 的幂次方呢？<ul>
<li>我们以 8 来举个例子。<ul>
<li>8 的二进制为 <code>1000</code> 。</li>
<li>-8 的二进制使用补码表示。所以，先求反生成反码为 <code>0111</code> ，然后加一生成补码为 <code>1000</code> 。</li>
<li>8 和 -8 并操作后，还是 8 。</li>
<li>实际上，以 2 为幂次方的数字，都是最高位为 1 ，剩余位为 0 ，所以对应的负数，求完补码还是自己。</li>
</ul>
</li>
<li>胖友也可以自己试试非 2 的幂次方数字的效果。</li>
</ul>
</li>
</ul>
<h3 id="5-3-2-GenericEventExecutorChooser"><a href="#5-3-2-GenericEventExecutorChooser" class="headerlink" title="5.3.2 GenericEventExecutorChooser"></a>5.3.2 GenericEventExecutorChooser</h3><p>GenericEventExecutorChooser 实现 EventExecutorChooser 接口，通用的 EventExecutor 选择器实现类。代码如下：</p>
<blockquote>
<p>GenericEventExecutorChooser 内嵌在 DefaultEventExecutorChooserFactory 类中。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自增序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EventExecutor 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">    GenericEventExecutorChooser(EventExecutor[] executors) {</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>实现比较<strong>简单</strong>，使用 <code>idx</code> 自增，并使用 EventExecutor 数组的大小来取余。</li>
</ul>
<h3 id="5-3-3-PowerOfTwoEventExecutorChooser"><a href="#5-3-3-PowerOfTwoEventExecutorChooser" class="headerlink" title="5.3.3 PowerOfTwoEventExecutorChooser"></a>5.3.3 PowerOfTwoEventExecutorChooser</h3><p>PowerOfTwoEventExecutorChooser 实现 EventExecutorChooser 接口，基于 EventExecutor 数组的大小为 2 的幂次方的 EventExecutor 选择器实现类。这是一个优化的实现，代码如下：</p>
<blockquote>
<p>PowerOfTwoEventExecutorChooser 内嵌在 DefaultEventExecutorChooserFactory 类中。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自增序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EventExecutor 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) {</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>实现比较<strong>巧妙</strong>，通过 <code>idx</code> 自增，并使用【EventExecutor 数组的大小 - 1】进行进行 <code>&amp;</code> 并操作。<ul>
<li>因为 <code>-</code> ( 二元操作符 ) 的计算优先级高于 <code>&amp;</code> ( 一元操作符 ) 。</li>
<li>因为 EventExecutor 数组的大小是以 2 为幂次方的数字，那么减一后，除了最高位是 0 ，剩余位都为 1 ( 例如 8 减一后等于 7 ，而 7 的二进制为 0111 。)，那么无论 <code>idx</code> 无论如何递增，再进行 <code>&amp;</code> 并操作，都不会超过 EventExecutor 数组的大小。并且，还能保证顺序递增。</li>
</ul>
</li>
</ul>
<h2 id="5-4-newDefaultThreadFactory"><a href="#5-4-newDefaultThreadFactory" class="headerlink" title="5.4 newDefaultThreadFactory"></a>5.4 newDefaultThreadFactory</h2><p><code>#newDefaultThreadFactory()</code> 方法，创建线程工厂对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ThreadFactory <span class="title">newDefaultThreadFactory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory(getClass());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的对象为 DefaultThreadFactory ，并且使用类名作为 <code>poolType</code> 。</li>
</ul>
<h2 id="5-5-next"><a href="#5-5-next" class="headerlink" title="5.5 next"></a>5.5 next</h2><p><code>#next()</code> 方法，选择下一个 EventExecutor 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> chooser.next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-6-iterator"><a href="#5-6-iterator" class="headerlink" title="5.6 iterator"></a>5.6 iterator</h2><p><code>#iterator()</code> 方法，获得 EventExecutor 数组的迭代器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;EventExecutor&gt; <span class="title">iterator</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> readonlyChildren.iterator();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>为了避免调用方，获得迭代器后，对 EventExecutor 数组进行修改，所以返回是<strong>不可变</strong>的 EventExecutor 数组 <code>readonlyChildren</code> 的迭代器。</li>
</ul>
<h2 id="5-7-executorCount"><a href="#5-7-executorCount" class="headerlink" title="5.7 executorCount"></a>5.7 executorCount</h2><p><code>#executorCount()</code> 方法，获得 EventExecutor 数组的大小。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">executorCount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> children.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-8-newChild"><a href="#5-8-newChild" class="headerlink" title="5.8 newChild"></a>5.8 newChild</h2><p><code>#newChild(Executor executor, Object... args)</code> <strong>抽象</strong>方法，创建 EventExecutor 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> EventExecutor <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>子类实现该方法，创建其对应的 EventExecutor 实现类的对象。</li>
</ul>
<h2 id="5-9-关闭相关方法"><a href="#5-9-关闭相关方法" class="headerlink" title="5.9 关闭相关方法"></a>5.9 关闭相关方法</h2><p>如下是关闭相关的方法，比较简单，胖友自己研究：</p>
<ul>
<li><code>#terminationFuture()</code></li>
<li><code>#shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit)</code></li>
<li><code>#shutdown()</code></li>
<li><code>#awaitTermination(long timeout, TimeUnit unit)</code></li>
<li><code>#isShuttingDown()</code></li>
<li><code>#isShutdown()</code></li>
<li><code>#isTerminated()</code></li>
</ul>
<h1 id="6-EventLoopGroup"><a href="#6-EventLoopGroup" class="headerlink" title="6. EventLoopGroup"></a>6. EventLoopGroup</h1><p><code>io.netty.channel.EventExecutorGroup</code> ，继承 EventExecutorGroup 接口，EventLoop 的分组接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 自定义接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a {<span class="doctag">@link</span> Channel} with this {<span class="doctag">@link</span> EventLoop}. The returned {<span class="doctag">@link</span> ChannelFuture}</span></span><br><span class="line"><span class="comment"> * will get notified once the registration was complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span></span>;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel, ChannelPromise promise)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 实现自 EventExecutorGroup 接口 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">EventLoop <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#next()</code> 方法，选择下一个 EventLoop 对象。</li>
<li><code>#register(...)</code> 方法，注册 Channel 到 EventLoopGroup 中。实际上，EventLoopGroup 会分配一个 EventLoop 给该 Channel 注册。</li>
</ul>
<h1 id="7-MultithreadEventLoopGroup"><a href="#7-MultithreadEventLoopGroup" class="headerlink" title="7. MultithreadEventLoopGroup"></a>7. MultithreadEventLoopGroup</h1><p><code>io.netty.channel.MultithreadEventLoopGroup</code> ，实现 EventLoopGroup 接口，继承 MultithreadEventExecutorGroup 抽象类，<strong>基于多线程</strong>的 EventLoop 的分组抽象类。</p>
<h2 id="7-1-构造方法"><a href="#7-1-构造方法" class="headerlink" title="7.1 构造方法"></a>7.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 EventLoop 线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"-Dio.netty.eventLoopThreads: {}"</span>, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, chooserFactory, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>DEFAULT_EVENT_LOOP_THREADS</code> 属性，EventLoopGroup 默认拥有的 EventLoop 数量。因为一个 EventLoop 对应一个线程，所以为 CPU 数量 * 2 。<ul>
<li>为什么会 * 2 呢？因为目前 CPU 基本都是超线程，<strong>一个 CPU 可对应 2 个线程</strong>。</li>
<li>在构造方法未传入 <code>nThreads</code> 方法参数时，使用 <code>DEFAULT_EVENT_LOOP_THREADS</code> 。</li>
</ul>
</li>
</ul>
<h2 id="7-2-newDefaultThreadFactory"><a href="#7-2-newDefaultThreadFactory" class="headerlink" title="7.2 newDefaultThreadFactory"></a>7.2 newDefaultThreadFactory</h2><p>newDefaultThreadFactory</p>
<p><code>#newDefaultThreadFactory()</code> 方法，创建线程工厂对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ThreadFactory <span class="title">newDefaultThreadFactory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory(getClass(), Thread.MAX_PRIORITY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>覆盖父类方法，增加了线程优先级为 <code>Thread.MAX_PRIORITY</code> 。</li>
</ul>
<h2 id="7-3-next"><a href="#7-3-next" class="headerlink" title="7.3 next"></a>7.3 next</h2><p><code>#next()</code> 方法，选择下一个 EventLoop 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (EventLoop) <span class="keyword">super</span>.next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>覆盖父类方法，将返回值转换成 EventLoop 类。</li>
</ul>
<h2 id="7-4-newChild"><a href="#7-4-newChild" class="headerlink" title="7.4 newChild"></a>7.4 newChild</h2><p><code>#newChild(Executor executor, Object... args)</code> <strong>抽象</strong>方法，创建 EventExecutor 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>覆盖父类方法，返回值改为 EventLoop 类。</li>
</ul>
<h2 id="7-5-register"><a href="#7-5-register" class="headerlink" title="7.5 register"></a>7.5 register</h2><p><code>#register()</code> 方法，注册 Channel 到 EventLoopGroup 中。实际上，EventLoopGroup 会分配一个 EventLoop 给该 Channel 注册。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().register(promise);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel, ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().register(channel, promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Channel 注册的 EventLoop ，通过 <code>#next()</code> 方法来选择。</li>
</ul>
<h1 id="8-NioEventLoopGroup"><a href="#8-NioEventLoopGroup" class="headerlink" title="8. NioEventLoopGroup"></a>8. NioEventLoopGroup</h1><p><code>io.netty.channel.nio.NioEventLoopGroup</code> ，继承 MultithreadEventLoopGroup 抽象类，NioEventLoop 的分组实现类。</p>
<h2 id="8-1-构造方法"><a href="#8-1-构造方法" class="headerlink" title="8.1 构造方法"></a>8.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, threadFactory, SelectorProvider.provider());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> nThreads, ThreadFactory threadFactory, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, threadFactory, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SelectorProvider selectorProvider, <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory,</span><br><span class="line">            RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory, rejectedExecutionHandler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>构造方法比较多，主要是明确了父构造方法的 <code>Object ... args</code> 方法参数：<ul>
<li>第一个参数，<code>selectorProvider</code> ，<code>java.nio.channels.spi.SelectorProvider</code> ，用于创建 Java NIO Selector 对象。</li>
<li>第二个参数，<code>selectStrategyFactory</code> ，<code>io.netty.channel.SelectStrategyFactory</code> ，选择策略工厂。详细解析，见后续文章。</li>
<li>第三个参数，<code>rejectedExecutionHandler</code> ，<code>io.netty.channel.SelectStrategyFactory</code> ，拒绝执行处理器。详细解析，见后续文章。</li>
</ul>
</li>
</ul>
<h2 id="8-2-newChild"><a href="#8-2-newChild" class="headerlink" title="8.2 newChild"></a>8.2 newChild</h2><p><code>#newChild(Executor executor, Object... args)</code> 方法，创建 NioEventLoop 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor,</span><br><span class="line">            (SelectorProvider) args[<span class="number">0</span>], ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>Object... args</code> 方法参数，传入给 NioEventLoop 创建需要的参数。</li>
</ul>
<h2 id="8-3-setIoRatio"><a href="#8-3-setIoRatio" class="headerlink" title="8.3 setIoRatio"></a>8.3 setIoRatio</h2><p><code>#setIoRatio(int ioRatio)</code> 方法，设置所有 EventLoop 的 IO 任务占用执行时间的比例。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the percentage of the desired amount of time spent for I/O in the child event loops.  The default value is</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIoRatio</span><span class="params">(<span class="keyword">int</span> ioRatio)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: <span class="keyword">this</span>) {</span><br><span class="line">        ((NioEventLoop) e).setIoRatio(ioRatio);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-4-rebuildSelectors"><a href="#8-4-rebuildSelectors" class="headerlink" title="8.4 rebuildSelectors"></a>8.4 rebuildSelectors</h2><p><code>#rebuildSelectors()</code> 方法，重建所有 EventLoop 的 Selector 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the current {<span class="doctag">@link</span> Selector}s of the child event loops with newly created {<span class="doctag">@link</span> Selector}s to work</span></span><br><span class="line"><span class="comment"> * around the  infamous epoll 100% CPU bug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebuildSelectors</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: <span class="keyword">this</span>) {</span><br><span class="line">        ((NioEventLoop) e).rebuildSelector();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 JDK 有 <a href="https://www.jianshu.com/p/da4398743b5a" rel="external nofollow noopener noreferrer" target="_blank">epoll 100% CPU Bug</a> 。实际上，NioEventLoop 当触发该 Bug 时，也会<strong>自动</strong>调用 <code>NioEventLoop#rebuildSelector()</code> 方法，进行重建 Selector 对象，以修复该问题。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>还是比较简单的文章。如果有不清晰的地方，也可以阅读如下文章：</p>
<ul>
<li>永顺 <a href="https://segmentfault.com/a/1190000007403873#articleHeader2" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)》</a> 的 <a href="#">「NioEventLoopGroup 实例化过程」</a> 小节。</li>
<li>Hypercube <a href="https://www.jianshu.com/p/da4398743b5a" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（四）—— EventLoop-1》</a> </li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-2-EventLoopGroup/" data-id="ck4pl3fov00dbfgcfofixgmcn" class="article-share-link">分享</a>

</footer>
-->
</div>
