<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码分析 —— 启动（二）之客户端
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来分享 Bootstrap 分享 Netty 客户端。因为我们日常使用 Netty 主要使用 NIO 部分，所以本文也只分享 Netty NIO 客户端。</p>
<h1 id="2-Bootstrap-示例"><a href="#2-Bootstrap-示例" class="headerlink" title="2. Bootstrap 示例"></a>2. Bootstrap 示例</h1><p>下面，我们先来看一个 ServerBootstrap 的使用示例，就是我们在 <a href="http://svip.iocoder.cn/Netty/build-debugging-environment/#5-2-EchoClient">《精尽 Netty 源码分析 —— 调试环境搭建》</a> 搭建的 EchoClient 示例。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">"ssl"</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String HOST = System.getProperty(<span class="string">"host"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = Integer.parseInt(System.getProperty(<span class="string">"size"</span>, <span class="string">"256"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// Configure SSL.git</span></span><br><span class="line">        <span class="comment">// 配置 SSL</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) {</span><br><span class="line">            sslCtx = SslContextBuilder.forClient()</span><br><span class="line">                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the client.</span></span><br><span class="line">        <span class="comment">// 创建一个 EventLoopGroup 对象</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 创建 Bootstrap 对象</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group) <span class="comment">// 设置使用的 EventLoopGroup</span></span><br><span class="line">             .channel(NioSocketChannel.class) <span class="comment">// 设置要被实例化的为 NioSocketChannel 类</span></span><br><span class="line">             .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>) <span class="comment">// 设置 NioSocketChannel 的可选项</span></span><br><span class="line">             .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() { <span class="comment">// 设置 NioSocketChannel 的处理器</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) {</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));</span><br><span class="line">                     }</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                 }</span><br><span class="line">             });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            <span class="comment">// 连接服务器，并同步等待成功，即启动客户端</span></span><br><span class="line">            ChannelFuture f = b.connect(HOST, PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            <span class="comment">// 监听客户端关闭，并阻塞等待</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// Shut down the event loop to terminate all threads.</span></span><br><span class="line">            <span class="comment">// 优雅关闭一个 EventLoopGroup 对象</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>示例比较简单，已经添加中文注释，胖友自己查看。</li>
</ul>
<h1 id="3-Bootstrap"><a href="#3-Bootstrap" class="headerlink" title="3. Bootstrap"></a>3. Bootstrap</h1><p><code>io.netty.bootstrap.Bootstrap</code> ，实现 AbstractBootstrap 抽象类，用于 Client 的启动器实现类。</p>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认地址解析器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AddressResolverGroup&lt;?&gt; DEFAULT_RESOLVER = DefaultAddressResolverGroup.INSTANCE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动类配置对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BootstrapConfig config = <span class="keyword">new</span> BootstrapConfig(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址解析器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> AddressResolverGroup&lt;SocketAddress&gt; resolver = (AddressResolverGroup&lt;SocketAddress&gt;) DEFAULT_RESOLVER;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress remoteAddress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bootstrap</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bootstrap</span><span class="params">(Bootstrap bootstrap)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(bootstrap);</span><br><span class="line">    resolver = bootstrap.resolver;</span><br><span class="line">    remoteAddress = bootstrap.remoteAddress;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>config</code> 属性，BootstrapConfig 对象，启动类配置对象。</li>
<li><code>resolver</code> 属性，地址解析器对象。绝大多数情况下，使用 <code>DEFAULT_RESOLVER</code> 即可。</li>
<li><code>remoteAddress</code> 属性，连接地址。</li>
</ul>
<h2 id="3-2-resolver"><a href="#3-2-resolver" class="headerlink" title="3.2 resolver"></a>3.2 resolver</h2><p><code>#resolver(AddressResolverGroup&lt;?&gt; resolver)</code> 方法，设置 <code>resolver</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">resolver</span><span class="params">(AddressResolverGroup&lt;?&gt; resolver)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.resolver = (AddressResolverGroup&lt;SocketAddress&gt;) (resolver == <span class="keyword">null</span> ? DEFAULT_RESOLVER : resolver);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-3-remoteAddress"><a href="#3-3-remoteAddress" class="headerlink" title="3.3 remoteAddress"></a>3.3 remoteAddress</h2><p><code>#remoteAddress(...)</code> 方法，设置 <code>remoteAddress</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">resolver</span><span class="params">(AddressResolverGroup&lt;?&gt; resolver)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.resolver = (AddressResolverGroup&lt;SocketAddress&gt;) (resolver == <span class="keyword">null</span> ? DEFAULT_RESOLVER : resolver);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">remoteAddress</span><span class="params">(SocketAddress remoteAddress)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">remoteAddress</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>{</span><br><span class="line">    remoteAddress = InetSocketAddress.createUnresolved(inetHost, inetPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">remoteAddress</span><span class="params">(InetAddress inetHost, <span class="keyword">int</span> inetPort)</span> </span>{</span><br><span class="line">    remoteAddress = <span class="keyword">new</span> InetSocketAddress(inetHost, inetPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-4-validate"><a href="#3-4-validate" class="headerlink" title="3.4 validate"></a>3.4 validate</h2><p><code>#validate()</code> 方法，校验配置是否正确。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">validate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 父类校验</span></span><br><span class="line">    <span class="keyword">super</span>.validate();</span><br><span class="line">    <span class="comment">// handler 非空</span></span><br><span class="line">    <span class="keyword">if</span> (config.handler() == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"handler not set"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <code>#connect(...)</code> 方法中，连接服务端时，会调用该方法进行校验。</li>
</ul>
<h2 id="3-5-clone"><a href="#3-5-clone" class="headerlink" title="3.5 clone"></a>3.5 clone</h2><p><code>#clone(...)</code> 方法，克隆 Bootstrap 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">clone</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bootstrap(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bootstrap <span class="title">clone</span><span class="params">(EventLoopGroup group)</span> </span>{</span><br><span class="line">    Bootstrap bs = <span class="keyword">new</span> Bootstrap(<span class="keyword">this</span>);</span><br><span class="line">    bs.group = group;</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>两个克隆方法，都是调用参数为 <code>bootstrap</code> 为 Bootstrap 构造方法，克隆一个 Bootstrap 对象。差别在于，下面的方法，多了对 <code>group</code> 属性的赋值。</li>
</ul>
<h2 id="3-6-connect"><a href="#3-6-connect" class="headerlink" title="3.6 connect"></a>3.6 connect</h2><p><code>#connect(...)</code> 方法，连接服务端，即启动客户端。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 校验必要参数</span></span><br><span class="line">    validate();</span><br><span class="line">    SocketAddress remoteAddress = <span class="keyword">this</span>.remoteAddress;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"remoteAddress not set"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析远程地址，并进行连接</span></span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(InetAddress inetHost, <span class="keyword">int</span> inetPort)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> connect(<span class="keyword">new</span> InetSocketAddress(inetHost, inetPort));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验必要参数</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"remoteAddress"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析远程地址，并进行连接</span></span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验必要参数</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"remoteAddress"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析远程地址，并进行连接</span></span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, localAddress);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>该方法返回的是 ChannelFuture 对象，也就是<strong>异步</strong>的连接服务端，启动客户端。如果需要<strong>同步</strong>，则需要调用 <code>ChannelFuture#sync()</code> 方法。</li>
</ul>
<p><code>#connect(...)</code> 方法，核心流程如下图：</p>
<p><code>#bind(...)</code> 方法，核心流程如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Netty/2018_04_05/01.png" title="核心流程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_04_05/01.png" alt="核心流程"></a><span class="caption">核心流程</span></p>
<ul>
<li>主要有 5 个步骤，下面我们来拆解代码，看看和我们在 <a href="http://svip.iocoder.cn/Netty/nio-5-demo/?self">《精尽 Netty 源码分析 —— NIO 基础（五）之示例》</a> 的 NioClient 的代码，是<strong>怎么对应</strong>的。</li>
<li>相比 <code>#bind(...)</code> 方法的流程，主要是<strong>绿色</strong>的 2 个步骤。</li>
</ul>
<h3 id="3-6-1-doResolveAndConnect"><a href="#3-6-1-doResolveAndConnect" class="headerlink" title="3.6.1 doResolveAndConnect"></a>3.6.1 doResolveAndConnect</h3><p><code>#doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 初始化并注册一个 Channel 对象，因为注册是异步的过程，所以返回一个 ChannelFuture 对象。</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line"> <span class="number">5</span>: </span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (regFuture.isDone()) {</span><br><span class="line"> <span class="number">7</span>:         <span class="comment">// 若执行失败，直接进行返回。</span></span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (!regFuture.isSuccess()) {</span><br><span class="line"> <span class="number">9</span>:             <span class="keyword">return</span> regFuture;</span><br><span class="line"><span class="number">10</span>:         }</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 解析远程地址，并进行连接</span></span><br><span class="line"><span class="number">12</span>:         <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line"><span class="number">13</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line"><span class="number">16</span>:         regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line"><span class="number">17</span>: </span><br><span class="line"><span class="number">18</span>:             <span class="meta">@Override</span></span><br><span class="line"><span class="number">19</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="number">20</span>:                 <span class="comment">// Directly obtain the cause and do a null check so we only need one volatile read in case of a</span></span><br><span class="line"><span class="number">21</span>:                 <span class="comment">// failure.</span></span><br><span class="line"><span class="number">22</span>:                 Throwable cause = future.cause();</span><br><span class="line"><span class="number">23</span>:                 <span class="keyword">if</span> (cause != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">24</span>:                     <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line"><span class="number">25</span>:                     <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line"><span class="number">26</span>:                     promise.setFailure(cause);</span><br><span class="line"><span class="number">27</span>:                 } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">28</span>:                     <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line"><span class="number">29</span>:                     <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line"><span class="number">30</span>:                     promise.registered();</span><br><span class="line"><span class="number">31</span>: </span><br><span class="line"><span class="number">32</span>:                     <span class="comment">// 解析远程地址，并进行连接</span></span><br><span class="line"><span class="number">33</span>:                     doResolveAndConnect0(channel, remoteAddress, localAddress, promise);</span><br><span class="line"><span class="number">34</span>:                 }</span><br><span class="line"><span class="number">35</span>:             }</span><br><span class="line"><span class="number">36</span>: </span><br><span class="line"><span class="number">37</span>:         });</span><br><span class="line"><span class="number">38</span>:         <span class="keyword">return</span> promise;</span><br><span class="line"><span class="number">39</span>:     }</span><br><span class="line"><span class="number">40</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：调用 <code>#initAndRegister()</code> 方法，初始化并注册一个 Channel 对象。因为注册是<strong>异步</strong>的过程，所以返回一个 ChannelFuture 对象。详细解析，见 <a href="#">「3.7 initAndRegister」</a> 。<ul>
<li>第 6 至 10 行：若执行失败，直接进行返回 <code>regFuture</code> 对象。 </li>
</ul>
</li>
<li>第 9 至 37 行：因为注册是<strong>异步</strong>的过程，有可能已完成，有可能未完成。所以实现代码分成了【第 12 行】和【第 13 至 37 行】分别处理已完成和未完成的情况。<ul>
<li><strong>核心</strong>在【第 12 行】或者【第 33 行】的代码，调用 <code>#doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise)</code> 方法，解析远程地址，并进行连接。</li>
<li>如果<strong>异步</strong>注册对应的 ChanelFuture 未完成，则调用 <code>ChannelFuture#addListener(ChannelFutureListener)</code> 方法，添加监听器，在<strong>注册</strong>完成后，进行回调执行 <code>#doResolveAndConnect0(...)</code> 方法的逻辑。详细解析，见 <a href="#">「3.6.2 doResolveAndConnect0」</a> 。</li>
<li>所以总结来说，<strong>resolve 和 connect 的逻辑，执行在 register 的逻辑之后</strong>。</li>
</ul>
</li>
</ul>
<h3 id="3-6-2-doResolveAndConnect0"><a href="#3-6-2-doResolveAndConnect0" class="headerlink" title="3.6.2 doResolveAndConnect0"></a>3.6.2 doResolveAndConnect0</h3><blockquote>
<p>老艿艿：此小节的内容，胖友先看完 <a href="#">「3.7 initAndRegister」</a> 的内容在回过头来看。因为 <code>#doResolveAndConnect0(...)</code> 方法的执行，在 <code>#initAndRegister()</code> 方法之后。</p>
</blockquote>
<p><code>#doResolveAndConnect0(...)</code> 方法，解析远程地址，并进行连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect0</span><span class="params">(<span class="keyword">final</span> Channel channel, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">2</span>:                                            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">final</span> EventLoop eventLoop = channel.eventLoop();</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">final</span> AddressResolver&lt;SocketAddress&gt; resolver = <span class="keyword">this</span>.resolver.getResolver(eventLoop);</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {</span><br><span class="line"> <span class="number">8</span>:             <span class="comment">// Resolver has no idea about what to do with the specified remote address or it's resolved already.</span></span><br><span class="line"> <span class="number">9</span>:             doConnect(remoteAddress, localAddress, promise);</span><br><span class="line"><span class="number">10</span>:             <span class="keyword">return</span> promise;</span><br><span class="line"><span class="number">11</span>:         }</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 解析远程地址</span></span><br><span class="line"><span class="number">14</span>:         <span class="keyword">final</span> Future&lt;SocketAddress&gt; resolveFuture = resolver.resolve(remoteAddress);</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> (resolveFuture.isDone()) {</span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 解析远程地址失败，关闭 Channel ，并回调通知 promise 异常</span></span><br><span class="line"><span class="number">18</span>:             <span class="keyword">final</span> Throwable resolveFailureCause = resolveFuture.cause();</span><br><span class="line"><span class="number">19</span>:             <span class="keyword">if</span> (resolveFailureCause != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">20</span>:                 <span class="comment">// Failed to resolve immediately</span></span><br><span class="line"><span class="number">21</span>:                 channel.close();</span><br><span class="line"><span class="number">22</span>:                 promise.setFailure(resolveFailureCause);</span><br><span class="line"><span class="number">23</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">24</span>:                 <span class="comment">// Succeeded to resolve immediately; cached? (or did a blocking lookup)</span></span><br><span class="line"><span class="number">25</span>:                 <span class="comment">// 连接远程地址</span></span><br><span class="line"><span class="number">26</span>:                 doConnect(resolveFuture.getNow(), localAddress, promise);</span><br><span class="line"><span class="number">27</span>:             }</span><br><span class="line"><span class="number">28</span>:             <span class="keyword">return</span> promise;</span><br><span class="line"><span class="number">29</span>:         }</span><br><span class="line"><span class="number">30</span>: </span><br><span class="line"><span class="number">31</span>:         <span class="comment">// Wait until the name resolution is finished.</span></span><br><span class="line"><span class="number">32</span>:         resolveFuture.addListener(<span class="keyword">new</span> FutureListener&lt;SocketAddress&gt;() {</span><br><span class="line"><span class="number">33</span>:             <span class="meta">@Override</span></span><br><span class="line"><span class="number">34</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;SocketAddress&gt; future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="number">35</span>:                 <span class="comment">// 解析远程地址失败，关闭 Channel ，并回调通知 promise 异常</span></span><br><span class="line"><span class="number">36</span>:                 <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">37</span>:                     channel.close();</span><br><span class="line"><span class="number">38</span>:                     promise.setFailure(future.cause());</span><br><span class="line"><span class="number">39</span>:                 <span class="comment">// 解析远程地址成功，连接远程地址</span></span><br><span class="line"><span class="number">40</span>:                 } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">41</span>:                     doConnect(future.getNow(), localAddress, promise);</span><br><span class="line"><span class="number">42</span>:                 }</span><br><span class="line"><span class="number">43</span>:             }</span><br><span class="line"><span class="number">44</span>:         });</span><br><span class="line"><span class="number">45</span>:     } <span class="keyword">catch</span> (Throwable cause) {</span><br><span class="line"><span class="number">46</span>:         <span class="comment">// 发生异常，并回调通知 promise 异常</span></span><br><span class="line"><span class="number">47</span>:         promise.tryFailure(cause);</span><br><span class="line"><span class="number">48</span>:     }</span><br><span class="line"><span class="number">49</span>:     <span class="keyword">return</span> promise;</span><br><span class="line"><span class="number">50</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 14 行：使用 <code>resolver</code> 解析远程地址。因为解析是<strong>异步</strong>的过程，所以返回一个 Future 对象。<ul>
<li>详细的解析远程地址的代码，考虑到暂时不是本文的重点，所以暂时省略。😈 老艿艿猜测胖友应该也暂时不感兴趣，哈哈哈。</li>
</ul>
</li>
<li>第 16 至 44 行：因为注册是<strong>异步</strong>的过程，有可能已完成，有可能未完成。所以实现代码分成了【第 16 至 29 行】和【第 31 至 44 行】分别处理已完成和未完成的情况。<ul>
<li><strong>核心</strong>在【第 26 行】或者【第 41 行】的代码，调用 <code>#doConnect(...)</code> 方法，连接远程地址。</li>
<li>如果<strong>异步</strong>解析对应的 Future 未完成，则调用 <code>Future#addListener(FutureListener)</code> 方法，添加监听器，在<strong>解析</strong>完成后，进行回调执行 <code>#doConnect(...)</code> 方法的逻辑。详细解析，见 见 <a href="#">「3.13.3 doConnect」</a> 。</li>
<li>所以总结来说，<strong>connect 的逻辑，执行在 resolve 的逻辑之后</strong>。 </li>
<li>老艿艿目前使用 <a href="#">「2. Bootstrap 示例」</a> 测试下来，符合【第 16 至 30 行】的条件，即无需走<strong>异步</strong>的流程。</li>
</ul>
</li>
</ul>
<h3 id="3-6-3-doConnect"><a href="#3-6-3-doConnect" class="headerlink" title="3.6.3 doConnect"></a>3.6.3 doConnect</h3><p><code>#doConnect(...)</code> 方法，执行 Channel 连接远程地址的逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise)</span> </span>{</span><br><span class="line"> <span class="number">2</span>: </span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// the pipeline in its channelRegistered() implementation.</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">final</span> Channel channel = connectPromise.channel();</span><br><span class="line"> <span class="number">6</span>:     channel.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line"> <span class="number">7</span>: </span><br><span class="line"> <span class="number">8</span>:         <span class="meta">@Override</span></span><br><span class="line"> <span class="number">9</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">10</span>:             <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">11</span>:                 channel.connect(remoteAddress, connectPromise);</span><br><span class="line"><span class="number">12</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">13</span>:                 channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line"><span class="number">14</span>:             }</span><br><span class="line"><span class="number">15</span>:             connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line"><span class="number">16</span>:         }</span><br><span class="line"><span class="number">17</span>: </span><br><span class="line"><span class="number">18</span>:     });</span><br><span class="line"><span class="number">19</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 6 行：调用 EventLoop 执行 Channel 连接远程地址的逻辑。但是，实际上当前线程已经是 EventLoop 所在的线程了，为何还要这样操作呢？答案在【第 3 至 4 行】的英语注释。感叹句，Netty 虽然代码量非常庞大且复杂，但是英文注释真的是非常齐全，包括 Github 的 issue 对代码提交的描述，也非常健全。</li>
<li>第 10 至 14 行：调用 <code>Channel#connect(...)</code> 方法，执行 Channel 连接远程地址的逻辑。后续的方法栈调用如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_04_05/02.png" title="Channel connect 流程" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_04_05/02.png" alt="Channel connect 流程"></a><span class="caption">Channel connect 流程</span><ul>
<li>还是老样子，我们先省略掉 pipeline 的内部实现代码，从 <code>AbstractNioUnsafe#connect(final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise)</code> 方法，继续向下分享。</li>
</ul>
</li>
</ul>
<p><code>AbstractNioUnsafe#connect(final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise)</code> 方法，执行 Channel 连接远程地址的逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 目前有正在连接远程地址的 ChannelPromise ，则直接抛出异常，禁止同时发起多个连接。</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">10</span>:             <span class="comment">// Already a connect in process.</span></span><br><span class="line"><span class="number">11</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line"><span class="number">12</span>:         }</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 记录 Channel 是否激活</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line"><span class="number">16</span>: </span><br><span class="line"><span class="number">17</span>:         <span class="comment">// 执行连接远程地址</span></span><br><span class="line"><span class="number">18</span>:         <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) {</span><br><span class="line"><span class="number">19</span>:             fulfillConnectPromise(promise, wasActive);</span><br><span class="line"><span class="number">20</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">21</span>:             <span class="comment">// 记录 connectPromise</span></span><br><span class="line"><span class="number">22</span>:             connectPromise = promise;</span><br><span class="line"><span class="number">23</span>:             <span class="comment">// 记录 requestedRemoteAddress</span></span><br><span class="line"><span class="number">24</span>:             requestedRemoteAddress = remoteAddress;</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:             <span class="comment">// 使用 EventLoop 发起定时任务，监听连接远程地址超时。若连接超时，则回调通知 connectPromise 超时异常。</span></span><br><span class="line"><span class="number">27</span>:             <span class="comment">// Schedule connect timeout.</span></span><br><span class="line"><span class="number">28</span>:             <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis(); <span class="comment">// 默认 30 * 1000 毫秒</span></span><br><span class="line"><span class="number">29</span>:             <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">30</span>:                 connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() {</span><br><span class="line"><span class="number">31</span>:                     <span class="meta">@Override</span></span><br><span class="line"><span class="number">32</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="number">33</span>:                         ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line"><span class="number">34</span>:                         ConnectTimeoutException cause = <span class="keyword">new</span> ConnectTimeoutException(<span class="string">"connection timed out: "</span> + remoteAddress);</span><br><span class="line"><span class="number">35</span>:                         <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) {</span><br><span class="line"><span class="number">36</span>:                             close(voidPromise());</span><br><span class="line"><span class="number">37</span>:                         }</span><br><span class="line"><span class="number">38</span>:                     }</span><br><span class="line"><span class="number">39</span>:                 }, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="number">40</span>:             }</span><br><span class="line"><span class="number">41</span>: </span><br><span class="line"><span class="number">42</span>:             <span class="comment">// 添加监听器，监听连接远程地址取消。</span></span><br><span class="line"><span class="number">43</span>:             promise.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line"><span class="number">44</span>:                 <span class="meta">@Override</span></span><br><span class="line"><span class="number">45</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="number">46</span>:                     <span class="keyword">if</span> (future.isCancelled()) {</span><br><span class="line"><span class="number">47</span>:                         <span class="comment">// 取消定时任务</span></span><br><span class="line"><span class="number">48</span>:                         <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">49</span>:                             connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">50</span>:                         }</span><br><span class="line"><span class="number">51</span>:                         <span class="comment">// 置空 connectPromise</span></span><br><span class="line"><span class="number">52</span>:                         connectPromise = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">53</span>:                         close(voidPromise());</span><br><span class="line"><span class="number">54</span>:                     }</span><br><span class="line"><span class="number">55</span>:                 }</span><br><span class="line"><span class="number">56</span>:             });</span><br><span class="line"><span class="number">57</span>:         }</span><br><span class="line"><span class="number">58</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">59</span>:         <span class="comment">// 回调通知 promise 发生异常</span></span><br><span class="line"><span class="number">60</span>:         promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line"><span class="number">61</span>:         closeIfClosed();</span><br><span class="line"><span class="number">62</span>:     }</span><br><span class="line"><span class="number">63</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 8 至 12 行：目前有正在连接远程地址的 ChannelPromise ，则直接抛出异常，禁止同时发起多个连接。<code>connectPromise</code> 变量，定义在 AbstractNioChannel 类中，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目前正在连接远程地址的 ChannelPromise 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The future of the current connection attempt.  If not null, subsequent</span></span><br><span class="line"><span class="comment"> * connection attempts will fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ChannelPromise connectPromise;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 15 行：调用 <code>#isActive()</code> 方法，获得 Channel 是否激活。NioSocketChannel 对该方法的实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>{</span><br><span class="line">    SocketChannel ch = javaChannel();</span><br><span class="line">    <span class="keyword">return</span> ch.isOpen() &amp;&amp; ch.isConnected();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>判断 SocketChannel 是否处于打开，并且连接的状态。此时，一般返回的是 <code>false</code> 。</li>
</ul>
</li>
<li><p>第 18 行：调用 <code>#doConnect(SocketAddress remoteAddress, SocketAddress localAddress)</code> 方法，执行连接远程地址。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// NioSocketChannel.java</span></span><br><span class="line">  <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">  <span class="number">3</span>:     <span class="comment">// 绑定本地地址</span></span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) {</span><br><span class="line">  <span class="number">5</span>:         doBind0(localAddress);</span><br><span class="line">  <span class="number">6</span>:     }</span><br><span class="line">  <span class="number">7</span>: </span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">boolean</span> success = <span class="keyword">false</span>; <span class="comment">// 执行是否成功</span></span><br><span class="line">  <span class="number">9</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">10</span>:         <span class="comment">// 连接远程地址</span></span><br><span class="line"> <span class="number">11</span>:         <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line"> <span class="number">12</span>:         <span class="comment">// 若未连接完成，则关注连接( OP_CONNECT )事件。</span></span><br><span class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (!connected) {</span><br><span class="line"> <span class="number">14</span>:             selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line"> <span class="number">15</span>:         }</span><br><span class="line"> <span class="number">16</span>:         <span class="comment">// 标记执行是否成功</span></span><br><span class="line"> <span class="number">17</span>:         success = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">18</span>:         <span class="comment">// 返回是否连接完成</span></span><br><span class="line"> <span class="number">19</span>:         <span class="keyword">return</span> connected;</span><br><span class="line"> <span class="number">20</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">21</span>:         <span class="comment">// 执行失败，则关闭 Channel</span></span><br><span class="line"> <span class="number">22</span>:         <span class="keyword">if</span> (!success) {</span><br><span class="line"> <span class="number">23</span>:             doClose();</span><br><span class="line"> <span class="number">24</span>:         }</span><br><span class="line"> <span class="number">25</span>:     }</span><br><span class="line"> <span class="number">26</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 6 行：若 <code>localAddress</code> 非空，则调用 <code>#doBind0(SocketAddress)</code> 方法，绑定本地地址。一般情况下，NIO Client 是不需要绑定本地地址的。默认情况下，系统会随机分配一个可用的本地地址，进行绑定。</li>
<li><p>第 11 行：调用 <code>SocketUtils#connect(SocketChannel socketChannel, SocketAddress remoteAddress)</code> 方法，Java 原生 NIO SocketChannel 连接 远程地址，并返回是否连接完成( 成功 )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">final</span> SocketChannel socketChannel, <span class="keyword">final</span> SocketAddress remoteAddress)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Boolean&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">                <span class="keyword">return</span> socketChannel.connect(remoteAddress);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    } <span class="keyword">catch</span> (PrivilegedActionException e) {</span><br><span class="line">        <span class="keyword">throw</span> (IOException) e.getCause();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>可能有胖友有和我一样的疑问，为什么将 connect 操作包在 AccessController 中呢？我们来看下 SocketUtils 类的注释：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides socket operations with privileges enabled. This is necessary for applications that use the</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> SecurityManager} to restrict {<span class="doctag">@link</span> SocketPermission} to their application. By asserting that these</span></span><br><span class="line"><span class="comment"> * operations are privileged, the operations can proceed even if some code in the calling chain lacks the appropriate</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> SocketPermission}.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一般情况下，我们用不到，所以也可以暂时不用理解。</li>
<li>感兴趣的胖友，可以 Google “AccessController” 关键字，或者阅读 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Java 安全模型介绍》</a> 。</li>
</ul>
</li>
</ul>
</li>
<li><p>【重要】第 12 至 15 行：若连接未完成( <code>connected == false</code> )时，我们可以看到，调用 <code>SelectionKey#interestOps(ops)</code> 方法，添加连接事件( <code>SelectionKey.OP_CONNECT</code> )为感兴趣的事件。也就说，也就是说，当连接远程地址成功时，Channel 对应的 Selector 将会轮询到该事件，可以进一步处理。</p>
</li>
<li>第 20 至 25 行：若执行失败( <code>success == false</code> )时，调用 <code>#doClose()</code> 方法，关闭 Channel 。</li>
</ul>
</li>
<li>第 18 至 19 行：笔者测试下来，<code>#doConnect(SocketChannel socketChannel, SocketAddress remoteAddress)</code> 方法的结果为 <code>false</code> ，所以不会执行【第 19 行】代码的 <code>#fulfillConnectPromise(ChannelPromise promise, boolean wasActive)</code> 方法，而是执行【第 20 至 57 行】的代码逻辑。</li>
<li>第 22 行：记录 <code>connectPromise</code> 。</li>
<li><p>第 24 行：记录 <code>requestedRemoteAddress</code> 。<code>requestedRemoteAddress</code> 变量，在 AbstractNioChannel 类中定义，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正在连接的远程地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> SocketAddress requestedRemoteAddress;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 26 至 40 行：调用 <code>EventLoop#schedule(Runnable command, long delay, TimeUnit unit)</code> 方法，发起定时任务 <code>connectTimeoutFuture</code> ，监听连接远程地址<strong>是否超时</strong>。若连接超时，则回调通知 <code>connectPromise</code> 超时异常。<code>connectPromise</code> 变量，在 AbstractNioChannel 类中定义，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接超时监听 ScheduledFuture 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ScheduledFuture&lt;?&gt; connectTimeoutFuture;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 42 至 57 行：调用 <code>ChannelPromise#addListener(ChannelFutureListener)</code> 方法，添加监听器，监听连接远程地址<strong>是否取消</strong>。若取消，则取消 <code>connectTimeoutFuture</code> 任务，并置空 <code>connectPromise</code> 。这样，客户端 Channel 可以发起下一次连接。</p>
</li>
</ul>
<h3 id="3-6-4-finishConnect"><a href="#3-6-4-finishConnect" class="headerlink" title="3.6.4 finishConnect"></a>3.6.4 finishConnect</h3><p>看到此处，可能胖友会有疑问，客户端的连接在哪里完成呢？答案在 <code>AbstractNioUnsafe#finishConnect()</code> 方法中。而该方法通过 Selector 轮询到 <code>SelectionKey.OP_CONNECT</code> 事件时，进行触发。调用栈如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_04_05/03.png" title="finishConnect 调用栈" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_04_05/03.png" alt="finishConnect 调用栈"></a><span class="caption">finishConnect 调用栈</span></p>
<pre><code>* 哈哈哈，还是老样子，我们先省略掉 EventLoop 的内部实现代码，从 `AbstractNioUnsafe#finishConnect()` 方法，继续向下分享。
</code></pre><p><code>AbstractNioUnsafe#finishConnect()</code> 方法，完成客户端的连接。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishConnect</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// Note this method is invoked by the event loop only if the connection attempt was</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// neither cancelled nor timed out.</span></span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 判断是否在 EventLoop 的线程中。</span></span><br><span class="line"> <span class="number">6</span>:     <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="number">7</span>: </span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">9</span>:         <span class="comment">// 获得 Channel 是否激活</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line"><span class="number">11</span>:         <span class="comment">// 执行完成连接</span></span><br><span class="line"><span class="number">12</span>:         doFinishConnect();</span><br><span class="line"><span class="number">13</span>:         <span class="comment">// 通知 connectPromise 连接完成</span></span><br><span class="line"><span class="number">14</span>:         fulfillConnectPromise(connectPromise, wasActive);</span><br><span class="line"><span class="number">15</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line"><span class="number">16</span>:         <span class="comment">// 通知 connectPromise 连接异常</span></span><br><span class="line"><span class="number">17</span>:         fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));</span><br><span class="line"><span class="number">18</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">19</span>:         <span class="comment">// 取消 connectTimeoutFuture 任务</span></span><br><span class="line"><span class="number">20</span>:         <span class="comment">// Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &gt; 0 is used</span></span><br><span class="line"><span class="number">21</span>:         <span class="comment">// See https://github.com/netty/netty/issues/1770</span></span><br><span class="line"><span class="number">22</span>:         <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">23</span>:             connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">24</span>:         }</span><br><span class="line"><span class="number">25</span>:         <span class="comment">// 置空 connectPromise</span></span><br><span class="line"><span class="number">26</span>:         connectPromise = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">27</span>:     }</span><br><span class="line"><span class="number">28</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 6 行：判断是否在 EventLoop 的线程中。</li>
<li>第 10 行：调用 <code>#isActive()</code> 方法，获得 Channel 是否激活。笔者调试时，此时返回 <code>false</code> ，因为连接还没完成。</li>
<li>第 12 行：调用 <code>#doFinishConnect()</code> 方法，执行完成连接的逻辑。详细解析，见 <a href="#">「3.6.4.1 doFinishConnect」</a> 。</li>
<li>第 14 行：执行完成连接<strong>成功</strong>，调用 <code>#fulfillConnectPromise(ChannelPromise promise, boolean wasActive)</code> 方法，通知 <code>connectPromise</code> 连接完成。详细解析，见 <a href="#">「3.6.4.2 fulfillConnectPromise 成功」</a> 。</li>
<li>第 15 至 17 行：执行完成连接<strong>异常</strong>，调用 <code>#fulfillConnectPromise(ChannelPromise promise, Throwable cause)</code> 方法，通知 <code>connectPromise</code> 连接异常。详细解析，见 <a href="#">「3.6.4.3 fulfillConnectPromise 异常」</a> 。</li>
<li>第 18 至 27 行：执行完成连接<strong>结束</strong>，取消 <code>connectTimeoutFuture</code> 任务，并置空 <code>connectPromise</code> 。</li>
</ul>
<h4 id="3-6-4-1-doFinishConnect"><a href="#3-6-4-1-doFinishConnect" class="headerlink" title="3.6.4.1 doFinishConnect"></a>3.6.4.1 doFinishConnect</h4><p><code>NioSocketChannel#doFinishConnect()</code> 方法，执行完成连接的逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFinishConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (!javaChannel().finishConnect()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>【重要】是不是非常熟悉的，调用 <code>SocketChannel#finishConnect()</code> 方法，完成连接。😈 美滋滋。</li>
</ul>
<h4 id="3-6-4-2-fulfillConnectPromise-成功"><a href="#3-6-4-2-fulfillConnectPromise-成功" class="headerlink" title="3.6.4.2 fulfillConnectPromise 成功"></a>3.6.4.2 fulfillConnectPromise 成功</h4><p><code>AbstractNioUnsafe#fulfillConnectPromise(ChannelPromise promise, Throwable cause)</code> 方法，通知 <code>connectPromise</code> 连接完成。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (promise == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// Closed via cancellation and the promise has been notified already.</span></span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">5</span>:     }</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 获得 Channel 是否激活</span></span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span></span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// We still need to ensure we call fireChannelActive() in this case.</span></span><br><span class="line"><span class="number">10</span>:     <span class="keyword">boolean</span> active = isActive();</span><br><span class="line"><span class="number">11</span>: </span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 回调通知 promise 执行成功</span></span><br><span class="line"><span class="number">13</span>:     <span class="comment">// trySuccess() will return false if a user cancelled the connection attempt.</span></span><br><span class="line"><span class="number">14</span>:     <span class="keyword">boolean</span> promiseSet = promise.trySuccess();</span><br><span class="line"><span class="number">15</span>: </span><br><span class="line"><span class="number">16</span>:     <span class="comment">// 若 Channel 是新激活的，触发通知 Channel 已激活的事件。</span></span><br><span class="line"><span class="number">17</span>:     <span class="comment">// Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span></span><br><span class="line"><span class="number">18</span>:     <span class="comment">// because what happened is what happened.</span></span><br><span class="line"><span class="number">19</span>:     <span class="keyword">if</span> (!wasActive &amp;&amp; active) {</span><br><span class="line"><span class="number">20</span>:         pipeline().fireChannelActive();</span><br><span class="line"><span class="number">21</span>:     }</span><br><span class="line"><span class="number">22</span>: </span><br><span class="line"><span class="number">23</span>:     <span class="comment">// If a user cancelled the connection attempt, close the channel, which is followed by channelInactive().</span></span><br><span class="line"><span class="number">24</span>:     <span class="comment">// TODO 芋艿</span></span><br><span class="line"><span class="number">25</span>:     <span class="keyword">if</span> (!promiseSet) {</span><br><span class="line"><span class="number">26</span>:         close(voidPromise());</span><br><span class="line"><span class="number">27</span>:     }</span><br><span class="line"><span class="number">28</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 10 行：调用 <code>#isActive()</code> 方法，获得 Channel 是否激活。笔者调试时，此时返回 <code>true</code> ，因为连接已经完成。 </li>
<li><p>第 14 行：回调通知 <code>promise</code> 执行成功。此处的通知，对应回调的是我们添加到 <code>#connect(...)</code> 方法返回的 ChannelFuture 的 ChannelFutureListener 的监听器。示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ChannelFuture f = b.connect(HOST, PORT).addListener(<span class="keyword">new</span> ChannelFutureListener() { <span class="comment">// 回调的就是我！！！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"连接完成"</span>);</span><br><span class="line">    }</span><br><span class="line">}).sync();</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li>第 19 行：因为 <code>wasActive == false</code> 并且 <code>active == true</code> ，因此，Channel 可以认为是<strong>新激活</strong>的，满足【第 20 行】代码的执行条件。<ul>
<li>第 40 行：调用 <code>DefaultChannelPipeline#fireChannelActive()</code> 方法，触发 Channel 激活的事件。【重要】后续的流程，和 NioServerSocketChannel 一样，也就说，会调用到 <code>AbstractUnsafe#beginRead()</code> 方法。这意味着什么呢？将我们创建 NioSocketChannel 时，设置的 <code>readInterestOp = SelectionKey.OP_READ</code> 添加为感兴趣的事件。也就说，客户端可以读取服务端发送来的数据。</li>
<li>关于 <code>AbstractUnsafe#beginRead()</code> 方法的解析，见 <a href="http://svip.iocoder.cn/Netty/bootstrap-1-server/?self">《精尽 Netty 源码分析 —— 启动（一）之服务端》的 「3.13.3 beginRead」</a> 部分。</li>
</ul>
</li>
<li>第 23 至 27 行：TODO 芋艿 1004  fulfillConnectPromise promiseSet</li>
</ul>
<h4 id="3-6-4-3-fulfillConnectPromise-异常"><a href="#3-6-4-3-fulfillConnectPromise-异常" class="headerlink" title="3.6.4.3 fulfillConnectPromise 异常"></a>3.6.4.3 fulfillConnectPromise 异常</h4><p><code>#fulfillConnectPromise(ChannelPromise promise, Throwable cause)</code> 方法，通知 <code>connectPromise</code> 连接异常。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, Throwable cause)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (promise == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// Closed via cancellation and the promise has been notified already.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调通知 promise 发生异常</span></span><br><span class="line">    <span class="comment">// Use tryFailure() instead of setFailure() to avoid the race against cancel().</span></span><br><span class="line">    promise.tryFailure(cause);</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    closeIfClosed();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较简单，已经添加中文注释，胖友自己查看。</li>
</ul>
<h2 id="3-7-initAndRegister"><a href="#3-7-initAndRegister" class="headerlink" title="3.7 initAndRegister"></a>3.7 initAndRegister</h2><p>Bootstrap 继承 AbstractBootstrap 抽象类，所以 <code>#initAndRegister()</code> 方法的流程上是一致的。所以和 ServerBootstrap 的差别在于：</p>
<ol>
<li>创建的 Channel 对象不同。</li>
<li>初始化 Channel 配置的代码实现不同。</li>
</ol>
<h3 id="3-7-1-创建-Channel-对象"><a href="#3-7-1-创建-Channel-对象" class="headerlink" title="3.7.1 创建 Channel 对象"></a>3.7.1 创建 Channel 对象</h3><p>考虑到本文的内容，我们以 NioSocketChannel 的创建过程作为示例。创建 NioSocketChannel 对象的流程，和 NioServerSocketChannel 基本是一致的，所以流程图我们就不提供了，直接开始撸源码。</p>
<h4 id="3-7-1-1-NioSocketChannel"><a href="#3-7-1-1-NioSocketChannel" class="headerlink" title="3.7.1.1 NioSocketChannel"></a>3.7.1.1 NioSocketChannel</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannelConfig config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(newSocket(provider));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>DEFAULT_SELECTOR_PROVIDER</code> <strong>静态</strong>属性，默认的 SelectorProvider 实现类。</li>
<li><code>config</code> 属性，Channel 对应的配置对象。每种 Channel 实现类，也会对应一个 ChannelConfig 实现类。例如，NioSocketChannel 类，对应 SocketChannelConfig 配置类。</li>
<li><p>在构造方法中，调用 <code>#newSocket(SelectorProvider provider)</code> 方法，创建 NIO 的 ServerSocketChannel 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  Use the {<span class="doctag">@link</span> SelectorProvider} to open {<span class="doctag">@link</span> SocketChannel} and so remove condition in</span></span><br><span class="line"><span class="comment">         *  {<span class="doctag">@link</span> SelectorProvider#provider()} which is called by each SocketChannel.open() otherwise.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  See &lt;a href="https://github.com/netty/netty/issues/2308"&gt;#2308&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> provider.openSocketChannel();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to open a socket."</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 是不是很熟悉这样的代码，效果和 <code>SocketChannel#open()</code> 方法创建 SocketChannel 对象是一致。</li>
</ul>
</li>
<li><p><code>#NioSocketChannel(SocketChannel channel)</code> 构造方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SocketChannel socket)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, socket);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用父 AbstractNioByteChannel 的构造方法。详细解析，见 <a href="#">「3.7.1.2 AbstractNioByteChannel」</a> 。</li>
<li>初始化 <code>config</code> 属性，创建 NioSocketChannelConfig 对象。</li>
</ul>
</li>
</ul>
<h4 id="3-7-1-2-AbstractNioByteChannel"><a href="#3-7-1-2-AbstractNioByteChannel" class="headerlink" title="3.7.1.2 AbstractNioByteChannel"></a>3.7.1.2 AbstractNioByteChannel</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用父 AbstractNioChannel 的构造方法。后续的构造方法，和 NioServerSocketChannel 是一致的。<ul>
<li>注意传入的 SelectionKey 的值为 <code>OP_READ</code> 。 </li>
</ul>
</li>
</ul>
<h3 id="3-7-2-初始化-Channel-配置"><a href="#3-7-2-初始化-Channel-配置" class="headerlink" title="3.7.2 初始化 Channel 配置"></a>3.7.2 初始化 Channel 配置</h3><p><code>#init(Channel channel)</code> 方法，初始化 Channel 配置。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加处理器到 pipeline 中</span></span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Channel 的可选项集合</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) {</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Channel 的属性集合</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) {</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) {</span><br><span class="line">            channel.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较简单，已经添加中文注释，胖友自己查看。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>撸完 Netty 服务端启动之后，再撸 Netty 客户端启动之后，出奇的顺手。美滋滋。</p>
<p>另外，也推荐如下和 Netty 客户端启动相关的文章，以加深理解：</p>
<ul>
<li>杨武兵 <a href="https://my.oschina.net/ywbrj042/blog/868798" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析系列 —— Bootstrap》</a></li>
<li>永顺 <a href="https://segmentfault.com/a/1190000007282789" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/bootstrap-2-client/" data-id="ck4pl3fov00ddfgcf8dhfhujw" class="article-share-link">分享</a>

</footer>
-->
</div>
