<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 ByteBufAllocator（一）简介
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来分享 ByteBufAllocator 。它是 ByteBuf 的分配器，负责创建 ByteBuf 对象。它的子类类图如下：<a href="http://static2.iocoder.cn/images/Netty/2018_08_20/01.png" title="类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_20/01.png" alt="类图"></a><span class="caption">类图</span></p>
<p>主要有三个子类：</p>
<ul>
<li>PreferHeapByteBufAllocator ，倾向创建 <strong>Heap</strong> ByteBuf 的分配器。</li>
<li>PooledByteBufAllocator ，基于<strong>内存池</strong>的 ByteBuf 的分配器。</li>
<li>UnpooledByteBufAllocator ，<strong>普通</strong>的 ByteBuf 的分配器。</li>
</ul>
<p>本文分享上面类图红框部分，后面两篇文章再分别分享 UnpooledByteBufAllocator 和 PooledByteBufAllocator 。</p>
<h1 id="2-ByteBufAllocator"><a href="#2-ByteBufAllocator" class="headerlink" title="2. ByteBufAllocator"></a>2. ByteBufAllocator</h1><p><code>io.netty.buffer.ByteBufAllocator</code> ，ByteBuf 分配器<strong>接口</strong>。</p>
<p>还是老样子，我们逐个来看看每个方法。</p>
<h2 id="2-1-DEFAULT"><a href="#2-1-DEFAULT" class="headerlink" title="2.1 DEFAULT"></a>2.1 DEFAULT</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>默认 ByteBufAllocator 对象，通过 <code>ByteBufUtil.DEFAULT_ALLOCATOR</code> 中获得。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator DEFAULT_ALLOCATOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="comment">// 读取 ByteBufAllocator 配置</span></span><br><span class="line">    String allocType = SystemPropertyUtil.get(<span class="string">"io.netty.allocator.type"</span>, PlatformDependent.isAndroid() ? <span class="string">"unpooled"</span> : <span class="string">"pooled"</span>);</span><br><span class="line">    allocType = allocType.toLowerCase(Locale.US).trim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 ByteBufAllocator 对象</span></span><br><span class="line">    ByteBufAllocator alloc;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"unpooled"</span>.equals(allocType)) {</span><br><span class="line">        alloc = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">        logger.debug(<span class="string">"-Dio.netty.allocator.type: {}"</span>, allocType);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"pooled"</span>.equals(allocType)) {</span><br><span class="line">        alloc = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">        logger.debug(<span class="string">"-Dio.netty.allocator.type: {}"</span>, allocType);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        alloc = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">        logger.debug(<span class="string">"-Dio.netty.allocator.type: pooled (unknown: {})"</span>, allocType);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    DEFAULT_ALLOCATOR = alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在非 Android 环境下，使用 PooledByteBufAllocator 作为默认  ByteBufAllocator 对象。</li>
<li>在 Android 环境下，使用 UnpooledByteBufAllocator 作为默认  ByteBufAllocator 对象。因为 Android 客户端的内存相对有限。</li>
</ul>
</li>
</ul>
<h2 id="2-2-buffer"><a href="#2-2-buffer" class="headerlink" title="2.2 buffer"></a>2.2 buffer</h2><p><code>#buffer(...)</code> 方法，创建一个 ByteBuf 对象。具体创建的是 Heap ByteBuf 还是 Direct ByteBuf ，由实现类决定。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a {<span class="doctag">@link</span> ByteBuf}. If it is a direct or heap buffer</span></span><br><span class="line"><span class="comment"> * depends on the actual implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ByteBuf <span class="title">buffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-1-ioBuffer"><a href="#2-2-1-ioBuffer" class="headerlink" title="2.2.1 ioBuffer"></a>2.2.1 ioBuffer</h3><p><code>#ioBuffer(...)</code> 方法，创建一个用于 IO 操作的 ByteBuf 对象。倾向于 Direct ByteBuf ，因为对于 IO 操作来说，性能更优。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a {<span class="doctag">@link</span> ByteBuf}, preferably a direct buffer which is suitable for I/O.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ByteBuf <span class="title">ioBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-2-heapBuffer"><a href="#2-2-2-heapBuffer" class="headerlink" title="2.2.2 heapBuffer"></a>2.2.2 heapBuffer</h3><p><code>#heapBuffer(...)</code> 方法，创建一个 Heap Buffer 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a heap {<span class="doctag">@link</span> ByteBuf}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ByteBuf <span class="title">heapBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-3-directBuffer"><a href="#2-2-3-directBuffer" class="headerlink" title="2.2.3 directBuffer"></a>2.2.3 directBuffer</h3><p><code>#directBuffer(...)</code> 方法，创建一个 Direct Buffer 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a direct {<span class="doctag">@link</span> ByteBuf} with the given initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="function">ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-3-compositeBuffer"><a href="#2-3-compositeBuffer" class="headerlink" title="2.3 compositeBuffer"></a>2.3 compositeBuffer</h2><p><code>#compositeBuffer(...)</code> 方法，创建一个 Composite ByteBuf 对象。具体创建的是 Heap ByteBuf 还是 Direct ByteBuf ，由实现类决定。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a {<span class="doctag">@link</span> CompositeByteBuf}.</span></span><br><span class="line"><span class="comment"> * If it is a direct or heap buffer depends on the actual implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-1-compositeHeapBuffer"><a href="#2-3-1-compositeHeapBuffer" class="headerlink" title="2.3.1 compositeHeapBuffer"></a>2.3.1 compositeHeapBuffer</h3><p><code>#compositeHeapBuffer(...)</code> 方法，创建一个 Composite Heap ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a heap {<span class="doctag">@link</span> CompositeByteBuf}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-2-compositeDirectBuffer"><a href="#2-3-2-compositeDirectBuffer" class="headerlink" title="2.3.2 compositeDirectBuffer"></a>2.3.2 compositeDirectBuffer</h3><p><code>#compositeDirectBuffer(...)</code> 方法，创建一个 Composite Direct ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a direct {<span class="doctag">@link</span> CompositeByteBuf}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeDirectBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CompositeByteBuf <span class="title">compositeDirectBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-4-isDirectBufferPooled"><a href="#2-4-isDirectBufferPooled" class="headerlink" title="2.4 isDirectBufferPooled"></a>2.4 isDirectBufferPooled</h2><p><code>#isDirectBufferPooled()</code> 方法，是否基于 Direct ByteBuf 对象池。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if direct {<span class="doctag">@link</span> ByteBuf}'s are pooled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectBufferPooled</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-5-calculateNewCapacity"><a href="#2-5-calculateNewCapacity" class="headerlink" title="2.5 calculateNewCapacity"></a>2.5 calculateNewCapacity</h2><p><code>#calculateNewCapacity(int minNewCapacity, int maxCapacity)</code> 方法，在 ByteBuf 扩容时，计算新的容量，该容量的值在 <code>[minNewCapacity, maxCapacity]</code> 范围内。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calculate the new capacity of a {<span class="doctag">@link</span> ByteBuf} that is used when a {<span class="doctag">@link</span> ByteBuf} needs to expand by the</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> minNewCapacity} with {<span class="doctag">@code</span> maxCapacity} as upper-bound.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-AbstractByteBufAllocator"><a href="#3-AbstractByteBufAllocator" class="headerlink" title="3. AbstractByteBufAllocator"></a>3. AbstractByteBufAllocator</h1><p><code>io.netty.buffer.AbstractByteBufAllocator</code> ，实现 ByteBufAllocator 接口，ByteBufAllocator 抽象实现类，为 PooledByteBufAllocator 和 UnpooledByteBufAllocator 提供公共的方法。</p>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否倾向创建 Direct ByteBuf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> directByDefault;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空 ByteBuf 缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuf emptyBuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instance use heap buffers by default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create new instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> preferDirect {<span class="doctag">@code</span> true} if {<span class="doctag">@link</span> #buffer(int)} should try to allocate a direct buffer rather than</span></span><br><span class="line"><span class="comment"> *                     a heap buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>{</span><br><span class="line">    directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe(); <span class="comment">// 支持 Unsafe</span></span><br><span class="line">    emptyBuf = <span class="keyword">new</span> EmptyByteBuf(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>directByDefault</code> 属性，是否倾向创建 Direct ByteBuf 。有一个前提是需要支持 Unsafe 操作。</li>
<li><code>emptyBuf</code> 属性，空 ByteBuf 缓存对象。用于 <code>#buffer()</code> 等方法，创建<strong>空</strong> ByteBuf 对象时。</li>
</ul>
<h2 id="3-2-buffer"><a href="#3-2-buffer" class="headerlink" title="3.2 buffer"></a>3.2 buffer</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) {</span><br><span class="line">        <span class="keyword">return</span> directBuffer();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heapBuffer();</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) {</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) {</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据 <code>directByDefault</code> 的值，调用 <code>#directBuffer(...)</code> 方法，还是调用 <code>#heapBuffer(...)</code> 方法。</li>
</ul>
<h3 id="3-2-1-ioBuffer"><a href="#3-2-1-ioBuffer" class="headerlink" title="3.2.1 ioBuffer"></a>3.2.1 ioBuffer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) {</span><br><span class="line">        <span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) {</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) {</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity, maxCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据是否支持 Unsafe 操作的情况，调用 <code>#directBuffer(...)</code> 方法，还是调用 <code>#heapBuffer(...)</code> 方法。</li>
</ul>
<h3 id="3-2-2-heapBuffer"><a href="#3-2-2-heapBuffer" class="headerlink" title="3.2.2 heapBuffer"></a>3.2.2 heapBuffer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认最大容量大小，无限。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CAPACITY = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 空 ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    }</span><br><span class="line">    validate(initialCapacity, maxCapacity); <span class="comment">// 校验容量的参数</span></span><br><span class="line">    <span class="comment">// 创建 Heap ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> newHeapBuffer(initialCapacity, maxCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>最终调用 <code>#newHeapBuffer(int initialCapacity, int maxCapacity)</code> <strong>抽象</strong>方法，创建 Heap ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a heap {<span class="doctag">@link</span> ByteBuf} with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为是否基于对象池的方式，创建 Heap ByteBuf 对象的实现会不同，所以需要抽象。</li>
</ul>
</li>
</ul>
<h3 id="3-2-3-directBuffer"><a href="#3-2-3-directBuffer" class="headerlink" title="3.2.3 directBuffer"></a>3.2.3 directBuffer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> directBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 空 ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    }</span><br><span class="line">    validate(initialCapacity, maxCapacity); <span class="comment">// 校验容量的参数</span></span><br><span class="line">    <span class="comment">// 创建 Direct ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>最终调用 <code>#newDirectBuffer(int initialCapacity, int maxCapacity)</code> <strong>抽象</strong>方法，创建 Direct ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a direct {<span class="doctag">@link</span> ByteBuf} with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为是否基于对象池的方式，创建 Direct ByteBuf 对象的实现会不同，所以需要抽象。</li>
</ul>
</li>
</ul>
<h2 id="3-3-compositeBuffer"><a href="#3-3-compositeBuffer" class="headerlink" title="3.3 compositeBuffer"></a>3.3 compositeBuffer</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) {</span><br><span class="line">        <span class="keyword">return</span> compositeDirectBuffer();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> compositeHeapBuffer();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) {</span><br><span class="line">        <span class="keyword">return</span> compositeDirectBuffer(maxNumComponents);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> compositeHeapBuffer(maxNumComponents);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据 <code>directByDefault</code> 的值，调用 <code>#compositeDirectBuffer(...)</code> 方法，还是调用 <code>#compositeHeapBuffer(...)</code> 方法。</li>
</ul>
<h3 id="3-3-1-compositeHeapBuffer"><a href="#3-3-1-compositeHeapBuffer" class="headerlink" title="3.3.1 compositeHeapBuffer"></a>3.3.1 compositeHeapBuffer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Composite ByteBuf 可包含的 ByteBuf 的最大数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_COMPONENTS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> compositeHeapBuffer(DEFAULT_MAX_COMPONENTS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(<span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">false</span>, maxNumComponents));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建 CompositeByteBuf 对象，并且方法参数 <code>direct</code> 为 <code>false</code> ，表示 Heap 类型。</li>
<li>调用 <code>#toLeakAwareBuffer(CompositeByteBuf)</code> 方法，装饰成 LeakAware 的 ByteBuf 对象。</li>
</ul>
<h3 id="3-3-2-compositeDirectBuffer"><a href="#3-3-2-compositeDirectBuffer" class="headerlink" title="3.3.2 compositeDirectBuffer"></a>3.3.2 compositeDirectBuffer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeDirectBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> compositeDirectBuffer(DEFAULT_MAX_COMPONENTS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeDirectBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(<span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">true</span>, maxNumComponents));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建 CompositeByteBuf 对象，并且方法参数 <code>direct</code> 为 <code>true</code> ，表示 Direct 类型。</li>
<li>调用 <code>#toLeakAwareBuffer(CompositeByteBuf)</code> 方法，装饰成 LeakAware 的 ByteBuf 对象。</li>
</ul>
<h2 id="3-4-toLeakAwareBuffer"><a href="#3-4-toLeakAwareBuffer" class="headerlink" title="3.4 toLeakAwareBuffer"></a>3.4 toLeakAwareBuffer</h2><p>在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》</a> 中的 <a href="#">「3.1 创建 LeakAware ByteBuf 对象」</a> 小节，已经详细解析。</p>
<h2 id="3-5-calculateNewCapacity"><a href="#3-5-calculateNewCapacity" class="headerlink" title="3.5 calculateNewCapacity"></a>3.5 calculateNewCapacity</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容分界线，4M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALCULATE_THRESHOLD = <span class="number">1048576</span> * <span class="number">4</span>; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">if</span> (minNewCapacity &lt; <span class="number">0</span>) {</span><br><span class="line">  <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"minNewCapacity: "</span> + minNewCapacity + <span class="string">" (expected: 0+)"</span>);</span><br><span class="line">  <span class="number">5</span>:     }</span><br><span class="line">  <span class="number">6</span>:     <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) {</span><br><span class="line">  <span class="number">7</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">  <span class="number">8</span>:                 <span class="string">"minNewCapacity: %d (expected: not greater than maxCapacity(%d)"</span>,</span><br><span class="line">  <span class="number">9</span>:                 minNewCapacity, maxCapacity));</span><br><span class="line"> <span class="number">10</span>:     }</span><br><span class="line"> <span class="number">11</span>:     <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"> <span class="number">12</span>: </span><br><span class="line"> <span class="number">13</span>:     <span class="comment">// &lt;1&gt; 等于 threshold ，直接返回 threshold 。</span></span><br><span class="line"> <span class="number">14</span>:     <span class="keyword">if</span> (minNewCapacity == threshold) {</span><br><span class="line"> <span class="number">15</span>:         <span class="keyword">return</span> threshold;</span><br><span class="line"> <span class="number">16</span>:     }</span><br><span class="line"> <span class="number">17</span>: </span><br><span class="line"> <span class="number">18</span>:     <span class="comment">// &lt;2&gt; 超过 threshold ，增加 threshold ，不超过 maxCapacity 大小。</span></span><br><span class="line"> <span class="number">19</span>:     <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line"> <span class="number">20</span>:     <span class="keyword">if</span> (minNewCapacity &gt; threshold) {</span><br><span class="line"> <span class="number">21</span>:         <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line"> <span class="number">22</span>:         <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) { <span class="comment">// 不超过 maxCapacity</span></span><br><span class="line"> <span class="number">23</span>:             newCapacity = maxCapacity;</span><br><span class="line"> <span class="number">24</span>:         } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">25</span>:             newCapacity += threshold;</span><br><span class="line"> <span class="number">26</span>:         }</span><br><span class="line"> <span class="number">27</span>:         <span class="keyword">return</span> newCapacity;</span><br><span class="line"> <span class="number">28</span>:     }</span><br><span class="line"> <span class="number">29</span>: </span><br><span class="line"> <span class="number">30</span>:     <span class="comment">// &lt;3&gt; 未超过 threshold ，从 64 开始两倍计算，不超过 4M 大小。</span></span><br><span class="line"> <span class="number">31</span>:     <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line"> <span class="number">32</span>:     <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line"> <span class="number">33</span>:     <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) {</span><br><span class="line"> <span class="number">34</span>:         newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"> <span class="number">35</span>:     }</span><br><span class="line"> <span class="number">36</span>:     <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line"> <span class="number">37</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>按照 <code>CALCULATE_THRESHOLD</code> 作为分界线，分成 3 种情况：<code>&lt;1&gt;</code>/<code>&lt;2&gt;</code>/<code>&lt;3&gt;</code> 。代码比较简单，胖友自己看注释。</li>
</ul>
<h1 id="4-PreferHeapByteBufAllocator"><a href="#4-PreferHeapByteBufAllocator" class="headerlink" title="4. PreferHeapByteBufAllocator"></a>4. PreferHeapByteBufAllocator</h1><p><code>io.netty.channel.PreferHeapByteBufAllocator</code> ，实现 ByteBufAllocator 接口，<strong>倾向创建 Heap ByteBuf</strong> 的分配器。也就是说，<code>#buffer(...)</code> 和 <code>#ioBuffer(...)</code> 和 <code>#compositeBuffer(...)</code> 方法，创建的都是 Heap ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正的分配器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator allocator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PreferHeapByteBufAllocator</span><span class="params">(ByteBufAllocator allocator)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.allocator = ObjectUtil.checkNotNull(allocator, <span class="string">"allocator"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocator.heapBuffer();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocator.heapBuffer();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> allocator.compositeHeapBuffer();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其它方法，就是调用 <code>allocator</code> 的对应的方法。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 小水文一篇。铺垫铺垫，你懂的。</p>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-2-1-ByteBufAllocator-intro/" data-id="ck4pl3fp300dvfgcfarbvedfd" class="article-share-link">分享</a>

</footer>
-->
</div>
