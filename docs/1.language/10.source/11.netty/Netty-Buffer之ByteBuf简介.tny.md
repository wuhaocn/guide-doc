<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 ByteBuf（一）简介
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>从本文开始，我们来分享 Netty ByteBuf 相关的内容。它在 <code>buffer</code> 模块中实现，在功能定位上，它和 NIO ByteBuffer 是一致的，但是强大非常多。如下是 <a href="#">《Netty 实战》</a> 对它的<strong>优点总</strong>结：</p>
<blockquote>
<ul>
<li>A01. 它可以被用户自定义的<strong>缓冲区类型</strong>扩展</li>
<li>A02. 通过内置的符合缓冲区类型实现了透明的<strong>零拷贝</strong></li>
<li>A03. 容量可以<strong>按需增长</strong></li>
<li>A04. 在读和写这两种模式之间切换不需要调用 <code>#flip()</code> 方法</li>
<li>A05. 读和写使用了<strong>不同的索引</strong></li>
<li>A06. 支持方法的<strong>链式</strong>调用</li>
<li>A07. 支持引用计数</li>
<li>A08. 支持<strong>池化</strong></li>
</ul>
</blockquote>
<ul>
<li>特别是第 A04 这点，相信很多胖友都被 NIO ByteBuffer 反人类的读模式和写模式给坑哭了。在 <a href="http://svip.iocoder.cn/Netty/nio-3-buffer/">《精尽 Netty 源码分析 —— NIO 基础（三）之 Buffer》</a> 中，我们也吐槽过了。😈</li>
<li>当然，可能胖友看着这些优点，会一脸懵逼，不要紧，边读源码边理解落。</li>
</ul>
<hr>
<blockquote>
<p>老艿艿，从下文开始，Netty ByteBuf ，我们只打 ByteBuf 。相比 NIO ByteBuffer ，它少 <code>"fer"</code> 三个字母。</p>
</blockquote>
<p>ByteBuf 的代码实现挺有趣的，但是会略有一点点深度，所以笔者会分成三大块来分享：</p>
<ul>
<li>ByteBuf 相关，主要是它的核心 API 和核心子类实现。</li>
<li>ByteBufAllocator 相关，用于创建 ByteBuf 对象。</li>
<li>Jemalloc 相关，内存管理算法，Netty 基于该算法，实现对内存高效和有效的管理。😈 这块是最最最有趣的。</li>
</ul>
<p>每一块，我们会分成几篇小的文章。而本文，我们就来对 ByteBuf 有个整体的认识，特别是核心 API 部分。</p>
<h1 id="2-ByteBuf"><a href="#2-ByteBuf" class="headerlink" title="2. ByteBuf"></a>2. ByteBuf</h1><p><code>io.netty.buffer.ByteBuf</code> ，实现 ReferenceCounted 、Comparable 接口，ByteBuf <strong>抽象类</strong>。注意，ByteBuf 是一个抽象类，而不是一个接口。当然，实际上，它主要定义了<strong>抽象</strong>方法，<strong>很少</strong>实现对应的方法。</p>
<p>关于 <code>io.netty.util.ReferenceCounted</code> 接口，对象引用计数器接口。</p>
<ul>
<li>对象的初始引用计数为 1 。</li>
<li>当引用计数器值为 0 时，表示该对象不能再被继续引用，只能被释放。</li>
<li>本文暂时不解析，我们会在 TODO 1011</li>
</ul>
<h2 id="2-1-抽象方法"><a href="#2-1-抽象方法" class="headerlink" title="2.1 抽象方法"></a>2.1 抽象方法</h2><p> 因为 ByteBuf 的方法非常多，所以笔者对它的方法做了简单的归类。Let’s Go 。</p>
<h3 id="2-1-1-基础信息"><a href="#2-1-1-基础信息" class="headerlink" title="2.1.1 基础信息"></a>2.1.1 基础信息</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>; <span class="comment">// 容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">maxCapacity</span><span class="params">()</span></span>; <span class="comment">// 最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>; <span class="comment">// 分配器，用于创建 ByteBuf 对象。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteOrder <span class="title">order</span><span class="params">()</span></span>; <span class="comment">// 字节序，即大小端。推荐阅读 http://www.ruanyifeng.com/blog/2016/11/byte-order.html</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">order</span><span class="params">(ByteOrder endianness)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">unwrap</span><span class="params">()</span></span>; <span class="comment">// 获得被包装( wrap )的 ByteBuf 对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>; <span class="comment">// 是否 NIO Direct Buffer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只读 Buffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">asReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readerIndex</span><span class="params">()</span></span>; <span class="comment">// 读取位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readerIndex</span><span class="params">(<span class="keyword">int</span> readerIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">writerIndex</span><span class="params">()</span></span>; <span class="comment">// 写入位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writerIndex</span><span class="params">(<span class="keyword">int</span> writerIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span></span>; <span class="comment">// 设置读取和写入位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readableBytes</span><span class="params">()</span></span>; <span class="comment">// 剩余可读字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">writableBytes</span><span class="params">()</span></span>; <span class="comment">// 剩余可写字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">maxWritableBytes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes, <span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">markReaderIndex</span><span class="params">()</span></span>; <span class="comment">// 标记读取位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">resetReaderIndex</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">markWriterIndex</span><span class="params">()</span></span>; <span class="comment">// 标记写入位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">resetWriterIndex</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>主要是如下四个属性：</p>
<ul>
<li><code>readerIndex</code> ，读索引。</li>
<li><code>writerIndex</code> ，写索引。</li>
<li><code>capacity</code> ，当前容量。</li>
<li><code>maxCapacity</code> ，最大容量。当 <code>writerIndex</code> 写入超过 <code>capacity</code> 时，可自动扩容。<strong>每次</strong>扩容的大小，为 <code>capacity</code> 的 2 倍。当然，前提是不能超过 <code>maxCapacity</code> 大小。</li>
</ul>
<p>所以，ByteBuf 通过 <code>readerIndex</code> 和 <code>writerIndex</code> 两个索引，解决 ByteBuffer 的读写模式的问题。</p>
<p>四个大小关系很简单：<code>readerIndex</code> &lt;= <code>writerIndex</code> &lt;= <code>capacity</code> &lt;= <code>maxCapacity</code> 。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_08_01/01.png" title="分段" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_01/01.png" alt="分段"></a><span class="caption">分段</span></p>
<ul>
<li>图中一共有三段，实际是四段，省略了 <code>capacity</code> 到 <code>maxCapacity</code> 之间的一段。</li>
<li>discardable bytes ，废弃段。一般情况下，可以理解成已读的部分。</li>
<li>readable bytes ，可读段。可通过 <code>#readXXX()</code> 方法，顺序向下读取。</li>
<li>writable bytes ，可写段。可通过 <code>#writeXXX()</code> 方法，顺序向下写入。</li>
</ul>
<p>另外，ByteBuf 还有 <code>markReaderIndex</code> 和 <code>markWriterIndex</code> 两个属性：</p>
<ul>
<li>通过对应的 <code>#markReaderIndex()</code> 和 <code>#markWriterIndex()</code> 方法，分别标记读取和写入位置。</li>
<li>通过对应的 <code>#resetReaderIndex()</code> 和 <code>#resetWriterIndex()</code> 方法，分别读取和写入位置到标记处。</li>
</ul>
<h3 id="3-1-2-读取-写入操作"><a href="#3-1-2-读取-写入操作" class="headerlink" title="3.1.2 读取 / 写入操作"></a>3.1.2 读取 / 写入操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Boolean 1 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBoolean</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Byte 1 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>  <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getUnsignedByte</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setByte</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>  <span class="title">readByte</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">readUnsignedByte</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Short 2 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShortLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getUnsignedShort</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getUnsignedShortLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setShort</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setShortLE</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">readShortLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readUnsignedShort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readUnsignedShortLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeShort</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeShortLE</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【特殊】Medium 3 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">getMedium</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMediumLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">getUnsignedMedium</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">getUnsignedMediumLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setMedium</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setMediumLE</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readMedium</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readMediumLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readUnsignedMedium</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readUnsignedMediumLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeMedium</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeMediumLE</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Int 4 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">getIntLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">getUnsignedInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">getUnsignedIntLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setIntLE</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readInt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>   <span class="title">readIntLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">readUnsignedInt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">readUnsignedIntLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeIntLE</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long 8 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">getLongLE</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setLong</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setLongLE</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">readLong</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>  <span class="title">readLongLE</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeLongLE</span><span class="params">(<span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Char 2 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span>  <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setChar</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span>  <span class="title">readChar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeChar</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float 4 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloatLE</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Float.intBitsToFloat(getIntLE(index));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setFloat</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setFloatLE</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> setIntLE(index, Float.floatToRawIntBits(value));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloatLE</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Float.intBitsToFloat(readIntLE());</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeFloatLE</span><span class="params">(<span class="keyword">float</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writeIntLE(Float.floatToRawIntBits(value));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Double 8 字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDoubleLE</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Double.longBitsToDouble(getLongLE(index));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setDouble</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setDoubleLE</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> setLongLE(index, Double.doubleToRawLongBits(value));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDoubleLE</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Double.longBitsToDouble(readLongLE());</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeDoubleLE</span><span class="params">(<span class="keyword">double</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writeLongLE(Double.doubleToRawLongBits(value));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Byte 数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf dst, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuffer dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, OutputStream out, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, GatheringByteChannel out, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, FileChannel out, <span class="keyword">long</span> position, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf src, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuffer src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, InputStream in, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, ScatteringByteChannel in, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, FileChannel in, <span class="keyword">long</span> position, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">setZero</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readSlice</span><span class="params">(<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readRetainedSlice</span><span class="params">(<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuffer dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">readBytes</span><span class="params">(OutputStream out, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">(GatheringByteChannel out, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">(FileChannel out, <span class="keyword">long</span> position, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">skipBytes</span><span class="params">(<span class="keyword">int</span> length)</span></span>; <span class="comment">// 忽略指定长度的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBytes</span><span class="params">(ByteBuf src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBytes</span><span class="params">(ByteBuf src, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBytes</span><span class="params">(ByteBuf src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeBytes</span><span class="params">(ByteBuffer src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>  <span class="title">writeBytes</span><span class="params">(InputStream in, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">writeBytes</span><span class="params">(ScatteringByteChannel in, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">writeBytes</span><span class="params">(FileChannel in, <span class="keyword">long</span> position, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeZero</span><span class="params">(<span class="keyword">int</span> length)</span></span>; <span class="comment">// 填充指定长度的 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharSequence <span class="title">getCharSequence</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length, Charset charset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">setCharSequence</span><span class="params">(<span class="keyword">int</span> index, CharSequence sequence, Charset charset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharSequence <span class="title">readCharSequence</span><span class="params">(<span class="keyword">int</span> length, Charset charset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">writeCharSequence</span><span class="params">(CharSequence sequence, Charset charset)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>虽然方法比较多，总结下来是不同数据类型的<strong>四种</strong>读写方法：</p>
<ul>
<li><code>#getXXX(index)</code> 方法，读取<strong>指定</strong>位置的数据，不改变 <code>readerIndex</code> 索引。</li>
<li><code>#readXXX()</code> 方法，读取 <code>readerIndex</code> 位置的数据，会改成 <code>readerIndex</code> 索引。</li>
<li><code>#setXXX(index, value)</code> 方法，写入数据到<strong>指定</strong>位置，不改变 <code>writeIndex</code> 索引。</li>
<li><code>#writeXXX(value)</code> 方法，写入数据到<strong>指定</strong>位置，会改变 <code>writeIndex</code> 索引。</li>
</ul>
<h3 id="2-1-3-查找-遍历操作"><a href="#2-1-3-查找-遍历操作" class="headerlink" title="2.1.3 查找 / 遍历操作"></a>2.1.3 查找 / 遍历操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">byte</span> value)</span></span>; <span class="comment">// 指定值( value ) 在 ByteBuf 中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">bytesBefore</span><span class="params">(<span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">bytesBefore</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">bytesBefore</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">forEachByte</span><span class="params">(ByteProcessor processor)</span></span>; <span class="comment">// 遍历 ByteBuf ，进行自定义处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">forEachByte</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length, ByteProcessor processor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">forEachByteDesc</span><span class="params">(ByteProcessor processor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">forEachByteDesc</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length, ByteProcessor processor)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-1-4-释放操作"><a href="#3-1-4-释放操作" class="headerlink" title="3.1.4 释放操作"></a>3.1.4 释放操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">discardReadBytes</span><span class="params">()</span></span>; <span class="comment">// 释放已读的字节空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">discardSomeReadBytes</span><span class="params">()</span></span>; <span class="comment">// 释放部分已读的字节空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清空字节空间。实际是修改 readerIndex=writerIndex=0，标记清空。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>discardReadBytes</strong></p>
<p><code>#discardReadBytes()</code> 方法，释放【所有的】<strong>废弃段</strong>的空间内存。</p>
<ul>
<li>优点：达到重用废弃段的空间内存。</li>
<li>缺点：释放的方式，是通过复制<strong>可读段</strong>到 ByteBuf 的头部。所以，频繁释放会导致性能下降。</li>
<li>总结：这是典型的问题：选择空间还是时间。具体的选择，需要看对应的场景。😈 后续的文章，我们会看到对该方法的调用。</li>
</ul>
<p>整个过程如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_08_01/02.png" title="discardReadBytes" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_01/02.png" alt="discardReadBytes"></a><span class="caption">discardReadBytes</span></p>
<p><strong>discardSomeReadBytes</strong></p>
<p><code>#discardSomeReadBytes()</code> 方法，释放【部分的】<strong>废弃段</strong>的空间内存。</p>
<p>这是对 <code>#discardSomeReadBytes()</code> 方法的这种方案，具体的实现，见 <a href="#">「4. AbstractByteBuf」</a> 中。</p>
<p><strong>clear</strong></p>
<p><code>#clear()</code> 方法，清空字节空间。实际是修改 <code>readerIndex = writerIndex = 0</code> ，标记清空。</p>
<ul>
<li>优点：通过标记来实现清空，避免置空 ByteBuf ，提升性能。</li>
<li>缺点：数据实际还存在，如果错误修改 <code>writerIndex</code> 时，会导致读到“脏”数据。</li>
</ul>
<p>整个过程如下图：<a href="http://static2.iocoder.cn/images/Netty/2018_08_01/03.png" title="discardReadBytes" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_01/03.png" alt="discardReadBytes"></a><span class="caption">discardReadBytes</span></p>
<h3 id="3-1-5-拷贝操作"><a href="#3-1-5-拷贝操作" class="headerlink" title="3.1.5 拷贝操作"></a>3.1.5 拷贝操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">copy</span><span class="params">()</span></span>; <span class="comment">// 拷贝可读部分的字节数组。独立，互相不影响。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">copy</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">slice</span><span class="params">()</span></span>; <span class="comment">// 拷贝可读部分的字节数组。共享，相互影响。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">slice</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">retainedSlice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">duplicate</span><span class="params">()</span></span>; <span class="comment">// 拷贝整个的字节数组。共享，相互影响。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">retainedDuplicate</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-1-6-转换-NIO-ByteBuffer-操作"><a href="#3-1-6-转换-NIO-ByteBuffer-操作" class="headerlink" title="3.1.6 转换 NIO ByteBuffer 操作"></a>3.1.6 转换 NIO ByteBuffer 操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ByteBuf 包含 ByteBuffer 数量。</span></span><br><span class="line"><span class="comment">// 如果返回 = 1 ，则调用 `#nioBuffer()` 方法，获得 ByteBuf 包含的 ByteBuffer 对象。</span></span><br><span class="line"><span class="comment">// 如果返回 &gt; 1 ，则调用 `#nioBuffers()` 方法，获得 ByteBuf 包含的 ByteBuffer 数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">nioBufferCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">nioBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">nioBuffer</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">internalNioBuffer</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer[] nioBuffers();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer[] nioBuffers(<span class="keyword">int</span> index, <span class="keyword">int</span> length);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-1-7-Heap-相关方法"><a href="#3-1-7-Heap-相关方法" class="headerlink" title="3.1.7 Heap 相关方法"></a>3.1.7 Heap 相关方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于 Heap 类型的 ByteBuf 对象的 byte[] 字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span>; <span class="comment">// 是否有 byte[] 字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>[] array();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-2-ByteBuf-core-impl">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（二）核心子类》</a></li>
</ul>
<h3 id="3-1-8-Unsafe-相关方法"><a href="#3-1-8-Unsafe-相关方法" class="headerlink" title="3.1.8 Unsafe 相关方法"></a>3.1.8 Unsafe 相关方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于 Unsafe 类型的 ByteBuf 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasMemoryAddress</span><span class="params">()</span></span>; <span class="comment">// 是否有内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">memoryAddress</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-2-ByteBuf-core-impl">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（二）核心子类》</a></li>
</ul>
<h3 id="3-1-9-Object-相关"><a href="#3-1-9-Object-相关" class="headerlink" title="3.1.9 Object 相关"></a>3.1.9 Object 相关</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">(Charset charset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length, Charset charset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuf buffer)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-1-10-引用计数相关"><a href="#3-1-10-引用计数相关" class="headerlink" title="3.1.10 引用计数相关"></a>3.1.10 引用计数相关</h3><p>本文暂时不解析，我们会在 TODO 1011 。</p>
<p>来自 ReferenceCounted</p>
<p><a href="https://skyao.gitbooks.io/learning-netty/content/buffer/interface_ReferenceCounted.html" rel="external nofollow noopener noreferrer" target="_blank">https://skyao.gitbooks.io/learning-netty/content/buffer/interface_ReferenceCounted.html</a> 可参考</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">touch</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">touch</span><span class="params">(Object hint)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-2-子类类图"><a href="#3-2-子类类图" class="headerlink" title="3.2 子类类图"></a>3.2 子类类图</h2><p>ByteBuf 的子类灰常灰常灰常多，胖友点击 <a href="http://static2.iocoder.cn/images/Netty/2018_08_01/04.png" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 可以进行查看。</p>
<p>本文仅分享 ByteBuf 的<strong>五个</strong>直接子类实现，如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_08_01/05.png" title="传送门" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_01/05.png" alt="传送门"></a><span class="caption">传送门</span></p>
<ul>
<li>【重点】AbstractByteBuf ，ByteBuf 抽象实现类，提供 ByteBuf 的默认实现类。可以说，是 ByteBuf 最最最重要的子类。详细解析，见 <a href="#">「4. AbstractByteBuf」</a> 。</li>
<li>EmptyByteBuf ，用于构建空 ByteBuf 对象，<code>capacity</code> 和 <code>maxCapacity</code> 均为 0 。详细解析，见 <a href="#">「5. EmptyByteBuf」</a> 。</li>
<li>WrappedByteBuf ，用于装饰 ByteBuf 对象。详细解析，见 <a href="#">「6. WrappedByteBuf」</a> 。</li>
<li>SwappedByteBuf ，用于构建具有切换<strong>字节序</strong>功能的 ByteBuf 对象。详细解析，见 <a href="#">「7. SwappedByteBuf」</a> 。</li>
<li>ReplayingDecoderByteBuf ，用于构建在 IO 阻塞条件下实现无阻塞解码的特殊 ByteBuf 对象，当要读取的数据还未接收完全时，抛出异常，交由 ReplayingDecoder处理。详细解析，见 <a href="#">「8. ReplayingDecoderByteBuf」</a> 。</li>
</ul>
<h1 id="4-AbstractByteBuf"><a href="#4-AbstractByteBuf" class="headerlink" title="4. AbstractByteBuf"></a>4. AbstractByteBuf</h1><p><code>io.netty.buffer.AbstractByteBuf</code> ，实现 ByteBuf 抽象类，ByteBuf 抽象实现类。官方注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A skeletal implementation of a buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<p>因为 AbstractByteBuf 实现类 ByteBuf 超级多的方法，所以我们还是按照 ByteBuf 的归类，逐个分析过去。</p>
<h2 id="4-1-基础信息"><a href="#4-1-基础信息" class="headerlink" title="4.1 基础信息"></a>4.1 基础信息</h2><h3 id="4-1-1-构造方法"><a href="#4-1-1-构造方法" class="headerlink" title="4.1.1 构造方法"></a>4.1.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> readerIndex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> writerIndex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #readerIndex} 的标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #writerIndex} 的标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (maxCapacity &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxCapacity: "</span> + maxCapacity + <span class="string">" (expected: &gt;= 0)"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>capacity</code> 属性，在 AbstractByteBuf 未定义，而是由子类来实现。为什么呢？在后面的文章，我们会看到，ByteBuf 根据<strong>内存类型</strong>分成 Heap 和 Direct ，它们获取 <code>capacity</code> 的值的方式不同。</li>
<li><p><code>maxCapacity</code> 属性，相关的方法： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> maxCapacity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">maxCapacity</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="4-1-2-读索引相关的方法"><a href="#4-1-2-读索引相关的方法" class="headerlink" title="4.1.2 读索引相关的方法"></a>4.1.2 读索引相关的方法</h3><p><strong>获取和设置读位置</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readerIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> readerIndex;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readerIndex</span><span class="params">(<span class="keyword">int</span> readerIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (readerIndex &lt; <span class="number">0</span> || readerIndex &gt; writerIndex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"readerIndex: %d (expected: 0 &lt;= readerIndex &lt;= writerIndex(%d))"</span>, readerIndex, writerIndex));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><strong>是否可读</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writerIndex &gt; readerIndex;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">(<span class="keyword">int</span> numBytes)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writerIndex - readerIndex &gt;= numBytes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readableBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writerIndex - readerIndex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><strong>标记和重置读位置</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">markReaderIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    markedReaderIndex = readerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">resetReaderIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    readerIndex(markedReaderIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-1-3-写索引相关的方法"><a href="#4-1-3-写索引相关的方法" class="headerlink" title="4.1.3 写索引相关的方法"></a>4.1.3 写索引相关的方法</h3><p><strong>获取和设置写位置</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writerIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writerIndex;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writerIndex</span><span class="params">(<span class="keyword">int</span> writerIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (writerIndex &lt; readerIndex || writerIndex &gt; capacity()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"writerIndex: %d (expected: readerIndex(%d) &lt;= writerIndex &lt;= capacity(%d))"</span>,</span><br><span class="line">                writerIndex, readerIndex, capacity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><strong>是否可写</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> capacity() &gt; writerIndex;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">(<span class="keyword">int</span> numBytes)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> capacity() - writerIndex &gt;= numBytes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writableBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> capacity() - writerIndex;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWritableBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> maxCapacity() - writerIndex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><strong>标记和重置写位置</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">markWriterIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    markedWriterIndex = writerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">resetWriterIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    writerIndex(markedWriterIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><strong>保证可写</strong></p>
<p><code>#ensureWritable(int minWritableBytes)</code> 方法，保证有足够的可写空间。若不够，则进行扩容。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (minWritableBytes &lt; <span class="number">0</span>) {</span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line"> <span class="number">5</span>:                 <span class="string">"minWritableBytes: %d (expected: &gt;= 0)"</span>, minWritableBytes));</span><br><span class="line"> <span class="number">6</span>:     }</span><br><span class="line"> <span class="number">7</span>:     ensureWritable0(minWritableBytes);</span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> <span class="number">9</span>: }</span><br><span class="line"><span class="number">10</span>: </span><br><span class="line"><span class="number">11</span>: <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>{</span><br><span class="line"><span class="number">12</span>:     <span class="comment">// 检查是否可访问</span></span><br><span class="line"><span class="number">13</span>:     ensureAccessible();</span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 目前容量可写，直接返回</span></span><br><span class="line"><span class="number">15</span>:     <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) {</span><br><span class="line"><span class="number">16</span>:         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">17</span>:     }</span><br><span class="line"><span class="number">18</span>: </span><br><span class="line"><span class="number">19</span>:     <span class="comment">// 超过最大上限，抛出 IndexOutOfBoundsException 异常</span></span><br><span class="line"><span class="number">20</span>:     <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) {</span><br><span class="line"><span class="number">21</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line"><span class="number">22</span>:                 <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line"><span class="number">23</span>:                 writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line"><span class="number">24</span>:     }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:     <span class="comment">// 计算新的容量。默认情况下，2 倍扩容，并且不超过最大容量上限。</span></span><br><span class="line"><span class="number">27</span>:     <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line"><span class="number">28</span>:     <span class="keyword">int</span> newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);</span><br><span class="line"><span class="number">29</span>: </span><br><span class="line"><span class="number">30</span>:     <span class="comment">// 设置新的容量大小</span></span><br><span class="line"><span class="number">31</span>:     <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line"><span class="number">32</span>:     capacity(newCapacity);</span><br><span class="line"><span class="number">33</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 13 行：调用 <code>#ensureAccessible()</code> 方法，检查是否可访问。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Should be called by every method that tries to access the buffers content to check</span></span><br><span class="line"><span class="comment"> * if the buffer was released before.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureAccessible</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (checkAccessible &amp;&amp; refCnt() == <span class="number">0</span>) { <span class="comment">// 若指向为 0 ，说明已经释放，不可继续写入。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROP_MODE = <span class="string">"io.netty.buffer.bytebuf.checkAccessible"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否检查可访问</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ensureAccessible() </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> checkAccessible;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    checkAccessible = SystemPropertyUtil.getBoolean(PROP_MODE, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"-D{}: {}"</span>, PROP_MODE, checkAccessible);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 14 至 17 行：目前容量可写，直接返回。</p>
</li>
<li>第 19 至 24 行：超过最大上限，抛出 IndexOutOfBoundsException 异常。</li>
<li>第 28 行：调用 <code>ByteBufAllocator#calculateNewCapacity(int minNewCapacity, int maxCapacity)</code> 方法，计算新的容量。默认情况下，2 倍扩容，并且不超过最大容量上限。<strong>注意</strong>，此处仅仅是计算，并没有扩容内存复制等等操作。<ul>
<li>第 32 行：调用 <code>#capacity(newCapacity)</code> 方法，设置新的容量大小。</li>
</ul>
</li>
</ul>
<p><code>#ensureWritable(int minWritableBytes, boolean force)</code> 方法，保证有足够的可写空间。若不够，则进行扩容。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes, <span class="keyword">boolean</span> force)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查是否可访问</span></span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"minWritableBytes: %d (expected: &gt;= 0)"</span>, minWritableBytes));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前容量可写，直接返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity = maxCapacity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">    <span class="comment">// 超过最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) {</span><br><span class="line">        <span class="comment">// 不强制设置，或者已经到达最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (!force || capacity() == maxCapacity) {</span><br><span class="line">            <span class="comment">// 返回 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置为最大容量</span></span><br><span class="line">        capacity(maxCapacity);</span><br><span class="line">        <span class="comment">// 返回 3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的容量。默认情况下，2 倍扩容，并且不超过最大容量上限。</span></span><br><span class="line">    <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的容量大小</span></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>和 <code>#ensureWritable(int minWritableBytes)</code> 方法，有两点不同：</p>
<ul>
<li>超过最大容量的上限时，不会抛出 IndexOutOfBoundsException 异常。</li>
<li>根据执行的过程不同，返回不同的返回值。</li>
</ul>
<p>比较简单，胖友自己看下代码。</p>
<h3 id="4-1-4-setIndex"><a href="#4-1-4-setIndex" class="headerlink" title="4.1.4 setIndex"></a>4.1.4 setIndex</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (readerIndex &lt; <span class="number">0</span> || readerIndex &gt; writerIndex || writerIndex &gt; capacity()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"readerIndex: %d, writerIndex: %d (expected: 0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity(%d))"</span>,</span><br><span class="line">                readerIndex, writerIndex, capacity()));</span><br><span class="line">    }</span><br><span class="line">    setIndex0(readerIndex, writerIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex0</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">    <span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-1-5-读索引标记位相关的方法"><a href="#4-1-5-读索引标记位相关的方法" class="headerlink" title="4.1.5 读索引标记位相关的方法"></a>4.1.5 读索引标记位相关的方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">markReaderIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    markedReaderIndex = readerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">resetReaderIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    readerIndex(markedReaderIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-1-6-写索引标记位相关的方法"><a href="#4-1-6-写索引标记位相关的方法" class="headerlink" title="4.1.6 写索引标记位相关的方法"></a>4.1.6 写索引标记位相关的方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">markWriterIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    markedWriterIndex = writerIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">resetWriterIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    writerIndex(markedWriterIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-1-7-是否只读相关"><a href="#4-1-7-是否只读相关" class="headerlink" title="4.1.7 是否只读相关"></a>4.1.7 是否只读相关</h3><p><code>#isReadOnly()</code> 方法，返回是否只读。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认返回 <code>false</code> 。子类可覆写该方法，根据情况返回结果。</li>
</ul>
<hr>
<p><code>#asReadOnly()</code> 方法，转换成只读 ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">asReadOnly</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果是只读，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isReadOnly()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 转化成只读 Buffer 对象</span></span><br><span class="line">    <span class="keyword">return</span> Unpooled.unmodifiableBuffer(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果已是只读，直接返回该 ByteBuf 对象。</li>
<li><p>如果不是只读，调用 <code>Unpooled#unmodifiableBuffer(Bytebuf)</code> 方法，转化成只读 Buffer 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a read-only buffer which disallows any modification operations</span></span><br><span class="line"><span class="comment"> * on the specified {<span class="doctag">@code</span> buffer}.  The new buffer has the same</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> readerIndex} and {<span class="doctag">@code</span> writerIndex} with the specified</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> buffer}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Use {<span class="doctag">@link</span> ByteBuf#asReadOnly()}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">unmodifiableBuffer</span><span class="params">(ByteBuf buffer)</span> </span>{</span><br><span class="line">    ByteOrder endianness = buffer.order();</span><br><span class="line">    <span class="comment">// 大端</span></span><br><span class="line">    <span class="keyword">if</span> (endianness == BIG_ENDIAN) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReadOnlyByteBuf(buffer);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 小端</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadOnlyByteBuf(buffer.order(BIG_ENDIAN)).order(LITTLE_ENDIAN);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>注意，返回的是<strong>新的</strong> <code>io.netty.buffer.ReadOnlyByteBuf</code> 对象。并且，和原 ByteBuf 对象，共享 <code>readerIndex</code> 和 <code>writerIndex</code> 索引，以及相关的数据。仅仅是说，只读，不能写入。</li>
</ul>
</li>
</ul>
<h3 id="4-1-8-ByteOrder-相关的方法"><a href="#4-1-8-ByteOrder-相关的方法" class="headerlink" title="4.1.8 ByteOrder 相关的方法"></a>4.1.8 ByteOrder 相关的方法</h3><p><code>#order()</code> 方法，获得字节序。由子类实现，因为 AbstractByteBuf 的内存类型，不确定是 Heap 还是 Direct 。</p>
<hr>
<p><code>#order(ByteOrder endianness)</code> 方法，设置字节序。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">order</span><span class="params">(ByteOrder endianness)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (endianness == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"endianness"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 未改变，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (endianness == order()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建 SwappedByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> newSwappedByteBuf();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new {<span class="doctag">@link</span> SwappedByteBuf} for this {<span class="doctag">@link</span> ByteBuf} instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SwappedByteBuf <span class="title">newSwappedByteBuf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SwappedByteBuf(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果字节序未修改，直接返回该 ByteBuf 对象。</li>
<li>如果字节序有修改，调用 <code>#newSwappedByteBuf()</code> 方法，TODO SwappedByteBuf</li>
</ul>
<h3 id="4-1-9-未实现方法"><a href="#4-1-9-未实现方法" class="headerlink" title="4.1.9 未实现方法"></a>4.1.9 未实现方法</h3><p>和 <a href="#">「2.1.1 基础信息」</a> 相关的方法，有三个未实现，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>; <span class="comment">// 分配器，用于创建 ByteBuf 对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">unwrap</span><span class="params">()</span></span>; <span class="comment">// 获得被包装( wrap )的 ByteBuf 对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>; <span class="comment">// 是否 NIO Direct Buffer</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-2-读取-写入操作"><a href="#4-2-读取-写入操作" class="headerlink" title="4.2 读取 / 写入操作"></a>4.2 读取 / 写入操作</h2><p>我们以 Int 类型为例子，来看看它的读取和写入操作的实现代码。</p>
<h3 id="4-2-1-getInt"><a href="#4-2-1-getInt" class="headerlink" title="4.2.1 getInt"></a>4.2.1 getInt</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验读取是否会超过容量</span></span><br><span class="line">    checkIndex(index, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 读取 Int 数据</span></span><br><span class="line">    <span class="keyword">return</span> _getInt(index);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>#checkIndex(index, fieldLength)</code> 方法，校验读取是否会超过<strong>容量</strong>。注意，不是超过 <code>writerIndex</code> 位置。因为，只是读取指定位置开始的 Int 数据，不会改变 <code>readerIndex</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> fieldLength)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验是否可访问</span></span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="comment">// 校验是否会超过容量</span></span><br><span class="line">    checkIndex0(index, fieldLength);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkIndex0</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> fieldLength)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (isOutOfBounds(index, fieldLength, capacity())) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"index: %d, length: %d (expected: range(0, %d))"</span>, index, fieldLength, capacity()));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MathUtil.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if the requested {<span class="doctag">@code</span> index} and {<span class="doctag">@code</span> length} will fit within {<span class="doctag">@code</span> capacity}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index The starting index.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length The length which will be utilized (starting from {<span class="doctag">@code</span> index}).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity The capacity that {<span class="doctag">@code</span> index + length} is allowed to be within.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if the requested {<span class="doctag">@code</span> index} and {<span class="doctag">@code</span> length} will fit within {<span class="doctag">@code</span> capacity}.</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> false} if this would result in an index out of bounds exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOutOfBounds</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length, <span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 只有有负数，或运算，就会有负数。</span></span><br><span class="line">    <span class="comment">// 另外，此处的越界，不仅仅有 capacity - (index + length &lt; 0 ，例如 index &lt; 0 ，也是越界</span></span><br><span class="line">    <span class="keyword">return</span> (index | length | (index + length) | (capacity - (index + length))) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p>调用 <code>#_getInt(index)</code> 方法，读取 Int 数据。这是一个<strong>抽象</strong>方法，由子类实现。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">_getInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>关于 <code>#getIntLE(int index)</code> / <code>getUnsignedInt(int index)</code> / <code>getUnsignedIntLE(int index)</code> 方法的实现，胖友自己去看。</p>
<h3 id="4-2-2-readInt"><a href="#4-2-2-readInt" class="headerlink" title="4.2.2 readInt"></a>4.2.2 readInt</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 校验读取是否会超过可读段</span></span><br><span class="line">    checkReadableBytes0(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 读取 Int 数据</span></span><br><span class="line">    <span class="keyword">int</span> v = _getInt(readerIndex);</span><br><span class="line">    <span class="comment">// 修改 readerIndex ，加上已读取字节数</span></span><br><span class="line">    readerIndex += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>#checkReadableBytes0(fieldLength)</code> 方法，校验读取是否会超过<strong>可读段</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkReadableBytes0</span><span class="params">(<span class="keyword">int</span> minimumReadableBytes)</span> </span>{</span><br><span class="line">    <span class="comment">// 是否可访问</span></span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="comment">// 是否超过写索引，即超过可读段</span></span><br><span class="line">    <span class="keyword">if</span> (readerIndex &gt; writerIndex - minimumReadableBytes) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s"</span>,</span><br><span class="line">                readerIndex, minimumReadableBytes, writerIndex, <span class="keyword">this</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>调用 <code>#_getInt(index)</code> 方法，读取 Int 数据。</p>
</li>
<li>读取完成，修改 <code>readerIndex</code> 【<strong>重要</strong> 😈】，加上已读取字节数 4 。</li>
</ul>
<p>关于 <code>#readIntLE()</code> / <code>readUnsignedInt()</code> / <code>readUnsignedIntLE()</code> 方法的实现，胖友自己去看。</p>
<h3 id="4-2-3-setInt"><a href="#4-2-3-setInt" class="headerlink" title="4.2.3 setInt"></a>4.2.3 setInt</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验写入是否会超过容量</span></span><br><span class="line">    checkIndex(index, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 设置 Int 数据</span></span><br><span class="line">    _setInt(index, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#checkIndex(index, fieldLength)</code> 方法，校验写入是否会超过<strong>容量</strong>。</li>
<li><p>调用 <code>#_setInt(index,value )</code> 方法，写入 Int 数据。这是一个<strong>抽象</strong>方法，由子类实现。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">_setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>关于 <code>#setIntLE(int index, int value)</code> 方法的实现，胖友自己去看。</p>
<p>public abstract ByteBuf writeInt(int value);<br>public abstract ByteBuf writeIntLE(int value);</p>
<h3 id="4-2-4-writeInt"><a href="#4-2-4-writeInt" class="headerlink" title="4.2.4 writeInt"></a>4.2.4 writeInt</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="comment">// 保证可写入</span></span><br><span class="line">    ensureWritable0(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 写入 Int 数据</span></span><br><span class="line">    _setInt(writerIndex, value);</span><br><span class="line">    <span class="comment">// 修改 writerIndex ，加上已写入字节数</span></span><br><span class="line">    writerIndex += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#ensureWritable0(int minWritableBytes)</code> 方法，保证可写入。</li>
<li>调用 <code>#_setInt(index, int value)</code> 方法，写入Int 数据。</li>
<li>写入完成，修改 <code>writerIndex</code> 【<strong>重要</strong> 😈】，加上已写入字节数 4 。</li>
</ul>
<h3 id="4-2-5-其它方法"><a href="#4-2-5-其它方法" class="headerlink" title="4.2.5 其它方法"></a>4.2.5 其它方法</h3><p>其它类型的读取和写入操作的实现代码，胖友自己研究落。还是有一些有意思的方法，例如：</p>
<ul>
<li><code>#writeZero(int length)</code> 方法。原本以为是循环 <code>length</code> 次写入 0 字节，结果发现会基于 <code>long</code> =&gt; <code>int</code> =&gt; <code>byte</code> 的顺序，尽可能合并写入。</li>
<li><code>#skipBytes((int length)</code> 方法</li>
</ul>
<h2 id="4-3-查找-遍历操作"><a href="#4-3-查找-遍历操作" class="headerlink" title="4.3 查找 / 遍历操作"></a>4.3 查找 / 遍历操作</h2><p>查找 / 遍历操作相关的方法，实现比较简单。所以，感兴趣的胖友，可以自己去看。</p>
<h2 id="4-4-释放操作"><a href="#4-4-释放操作" class="headerlink" title="4.4 释放操作"></a>4.4 释放操作</h2><h3 id="4-4-1-discardReadBytes"><a href="#4-4-1-discardReadBytes" class="headerlink" title="4.4.1 discardReadBytes"></a>4.4.1 discardReadBytes</h3><p><code>#discardReadBytes()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">discardReadBytes</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 校验可访问</span></span><br><span class="line"> <span class="number">4</span>:     ensureAccessible();</span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 无废弃段，直接返回</span></span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (readerIndex == <span class="number">0</span>) {</span><br><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> <span class="number">8</span>:     }</span><br><span class="line"> <span class="number">9</span>: </span><br><span class="line"><span class="number">10</span>:     <span class="comment">// 未读取完</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (readerIndex != writerIndex) {</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 将可读段复制到 ByteBuf 头</span></span><br><span class="line"><span class="number">13</span>:         setBytes(<span class="number">0</span>, <span class="keyword">this</span>, readerIndex, writerIndex - readerIndex);</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 写索引减小</span></span><br><span class="line"><span class="number">15</span>:         writerIndex -= readerIndex;</span><br><span class="line"><span class="number">16</span>:         <span class="comment">// 调整标记位</span></span><br><span class="line"><span class="number">17</span>:         adjustMarkers(readerIndex);</span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 读索引重置为 0</span></span><br><span class="line"><span class="number">19</span>:         readerIndex = <span class="number">0</span>;</span><br><span class="line"><span class="number">20</span>:     <span class="comment">// 全部读取完</span></span><br><span class="line"><span class="number">21</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 调整标记位</span></span><br><span class="line"><span class="number">23</span>:         adjustMarkers(readerIndex);</span><br><span class="line"><span class="number">24</span>:         <span class="comment">// 读写索引都重置为 0</span></span><br><span class="line"><span class="number">25</span>:         writerIndex = readerIndex = <span class="number">0</span>;</span><br><span class="line"><span class="number">26</span>:     }</span><br><span class="line"><span class="number">27</span>:     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">28</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：调用 <code>#ensureAccessible()</code> 方法，检查是否可访问。</li>
<li>第 5 至 8 行：无<strong>废弃段</strong>，直接返回。</li>
<li><p>第 10 至 19 行：未读取完，即还有<strong>可读段</strong>。</p>
<ul>
<li>第 13 行：调用 <code>#setBytes(int index, ByteBuf src, int srcIndex, int length)</code> 方法，将可读段复制到 ByteBuf 头开始。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_08_01/02.png" title="discardReadBytes" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_01/02.png" alt="discardReadBytes"></a><span class="caption">discardReadBytes</span></li>
<li>第 15 行：写索引 <code>writerIndex</code> 减小。</li>
<li><p>第 19 行：调用 <code>#adjustMarkers(int decrement)</code> 方法，调整标记位。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">adjustMarkers</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> markedReaderIndex = <span class="keyword">this</span>.markedReaderIndex;</span><br><span class="line">    <span class="comment">// 读标记位小于减少值(decrement)</span></span><br><span class="line">    <span class="keyword">if</span> (markedReaderIndex &lt;= decrement) {</span><br><span class="line">        <span class="comment">// 重置读标记位为 0</span></span><br><span class="line">        <span class="keyword">this</span>.markedReaderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 写标记位小于减少值(decrement)</span></span><br><span class="line">        <span class="keyword">int</span> markedWriterIndex = <span class="keyword">this</span>.markedWriterIndex;</span><br><span class="line">        <span class="keyword">if</span> (markedWriterIndex &lt;= decrement) {</span><br><span class="line">            <span class="comment">// 重置写标记位为 0</span></span><br><span class="line">            <span class="keyword">this</span>.markedWriterIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 减小写标记位</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">this</span>.markedWriterIndex = markedWriterIndex - decrement;</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">// 减小读写标记位</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">this</span>.markedReaderIndex = markedReaderIndex - decrement;</span><br><span class="line">        <span class="keyword">this</span>.markedWriterIndex -= decrement;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码虽然比较多，但是目的很明确，<strong>减小</strong>读写标记位。并且，通过判断，<strong>最多减小至 0</strong> 。</li>
</ul>
</li>
<li>第 19 行：<strong>仅</strong>读索引重置为 0 。</li>
</ul>
</li>
<li>第 20 至 26 行：全部读取完，即无<strong>可读段</strong>。<ul>
<li>第 23 行：调用 <code>#adjustMarkers(int decrement)</code> 方法，调整标记位。</li>
<li>第 25 行：读写索引<strong>都</strong>重置为 0 。</li>
</ul>
</li>
</ul>
<h3 id="4-4-2-discardSomeReadBytes"><a href="#4-4-2-discardSomeReadBytes" class="headerlink" title="4.4.2 discardSomeReadBytes"></a>4.4.2 discardSomeReadBytes</h3><p><code>#discardSomeReadBytes()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">discardSomeReadBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 校验可访问</span></span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="comment">// 无废弃段，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (readerIndex == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部读取完</span></span><br><span class="line">    <span class="keyword">if</span> (readerIndex == writerIndex) {</span><br><span class="line">        <span class="comment">// 调整标记位</span></span><br><span class="line">        adjustMarkers(readerIndex);</span><br><span class="line">        <span class="comment">// 读写索引都重置为 0</span></span><br><span class="line">        writerIndex = readerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取超过容量的一半，进行释放</span></span><br><span class="line">    <span class="keyword">if</span> (readerIndex &gt;= capacity() &gt;&gt;&gt; <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 将可读段复制到 ByteBuf 头</span></span><br><span class="line">        setBytes(<span class="number">0</span>, <span class="keyword">this</span>, readerIndex, writerIndex - readerIndex);</span><br><span class="line">        <span class="comment">// 写索引减小</span></span><br><span class="line">        writerIndex -= readerIndex;</span><br><span class="line">        <span class="comment">// 调整标记位</span></span><br><span class="line">        adjustMarkers(readerIndex);</span><br><span class="line">        <span class="comment">// 读索引重置为 0</span></span><br><span class="line">        readerIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>整体代码和 <code>#discardReadBytes()</code> 方法是<strong>一致的</strong>。差别在于，<code>readerIndex &gt;= capacity() &gt;&gt;&gt; 1</code> ，读取超过容量的<strong>一半</strong>时，进行释放。也就是说，在空间和时间之间，做了一个平衡。</p>
<p>😈 后续，我们来看看，Netty 具体在什么时候，调用 <code>#discardSomeReadBytes()</code> 和 <code>#discardReadBytes()</code> 方法。</p>
<h3 id="4-4-3-clear"><a href="#4-4-3-clear" class="headerlink" title="4.4.3 clear"></a>4.4.3 clear</h3><p><code>#clear()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">    readerIndex = writerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>读写索引<strong>都</strong>重置为 0 。</li>
<li>读写标记位<strong>不会</strong>重置。</li>
</ul>
<h2 id="4-5-拷贝操作"><a href="#4-5-拷贝操作" class="headerlink" title="4.5 拷贝操作"></a>4.5 拷贝操作</h2><h3 id="4-5-1-copy"><a href="#4-5-1-copy" class="headerlink" title="4.5.1 copy"></a>4.5.1 copy</h3><p><code>#copy()</code> 方法，拷贝可读部分的字节数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">copy</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> copy(readerIndex, readableBytes());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#readableBytes()</code> 方法，获得可读的字节数。</li>
<li>调用 <code>#copy(int index, int length)</code> 方法，拷贝<strong>指定部分</strong>的字节数组。独立，互相不影响。具体的实现，需要子类中实现，原因是做<strong>深</strong>拷贝，需要根据内存类型是 Heap 和 Direct 会有不同。</li>
</ul>
<h3 id="4-5-2-slice"><a href="#4-5-2-slice" class="headerlink" title="4.5.2 slice"></a>4.5.2 slice</h3><p><code>#slice()</code> 方法，拷贝可读部分的字节数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">slice</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> slice(readerIndex, readableBytes());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#readableBytes()</code> 方法，获得可读的字节数。</li>
<li><p>调用 <code>#slice(int index, int length)</code> 方法，拷贝<strong>指定部分</strong>的字节数组。共享，互相影响。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">slice</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验可访问</span></span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="comment">// 创建 UnpooledSlicedByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnpooledSlicedByteBuf(<span class="keyword">this</span>, index, length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>返回的是创建的 UnpooledSlicedByteBuf 对象。在它内部，会调用当前 ByteBuf 对象，所以这也是为什么说是<strong>共享</strong>的。或者说，我们可以认为这是一个<strong>浅</strong>拷贝。</li>
</ul>
</li>
</ul>
<hr>
<p><code>#retainedSlice()</code> 方法，在 <code>#slice()</code> 方法的基础上，引用计数加 1 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retainedSlice</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> slice(index, length).retain();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#slice(int index, int length)</code> 方法，拷贝<strong>指定部分</strong>的字节数组。也就说，返回 UnpooledSlicedByteBuf 对象。</li>
<li>调用 <code>UnpooledSlicedByteBuf#retain()</code> 方法，，引用计数加 1 。本文暂时不解析，我们会在 TODO 1011 。</li>
</ul>
<h3 id="4-5-3-duplicate"><a href="#4-5-3-duplicate" class="headerlink" title="4.5.3 duplicate"></a>4.5.3 duplicate</h3><p><code>#duplicate()</code> 方法，拷贝<strong>整个</strong>的字节数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">duplicate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 校验是否可访问</span></span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnpooledDuplicatedByteBuf(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建的 UnpooledDuplicatedByteBuf 对象。在它内部，会调用当前 ByteBuf 对象，所以这也是为什么说是<strong>共享</strong>的。或者说，我们可以认为这是一个<strong>浅</strong>拷贝。</li>
<li>它和 <code>#slice()</code> 方法的差别在于，前者是<strong>整个</strong>，后者是<strong>可写段</strong>。</li>
</ul>
<hr>
<p><code>#retainedDuplicate()</code> 方法，在 <code>#duplicate()</code> 方法的基础上，引用计数加 1 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retainedDuplicate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> duplicate().retain();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#duplicate()</code> 方法，拷贝<strong>整个</strong>的字节数组。也就说，返回 UnpooledDuplicatedByteBuf 对象。</li>
<li>调用 <code>UnpooledDuplicatedByteBuf#retain()</code> 方法，，引用计数加 1 。本文暂时不解析，我们会在 TODO 1011 。</li>
</ul>
<h2 id="4-6-转换-NIO-ByteBuffer-操作"><a href="#4-6-转换-NIO-ByteBuffer-操作" class="headerlink" title="4.6 转换 NIO ByteBuffer 操作"></a>4.6 转换 NIO ByteBuffer 操作</h2><h3 id="4-6-1-nioBuffer"><a href="#4-6-1-nioBuffer" class="headerlink" title="4.6.1 nioBuffer"></a>4.6.1 nioBuffer</h3><p><code>#nioBuffer()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">nioBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nioBuffer(readerIndex, readableBytes());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>在方法内部，会调用 <code>#nioBuffer(int index, int length)</code> 方法。而该方法，由具体的子类实现。</p>
<blockquote>
<p>FROM <a href="https://my.oschina.net/7001/blog/742236" rel="external nofollow noopener noreferrer" target="_blank">《深入研究Netty框架之ByteBuf功能原理及源码分析》</a></p>
<p>将当前 ByteBuf 的可读缓冲区( <code>readerIndex</code> 到 <code>writerIndex</code> 之间的内容) 转换为 ByteBuffer 对象，两者共享共享缓冲区的内容。对 ByteBuffer 的读写操作不会影响 ByteBuf 的读写索引。</p>
<p>注意：ByteBuffer 无法感知 ByteBuf 的动态扩展操作。ByteBuffer 的长度为<code>readableBytes()</code> 。</p>
</blockquote>
</li>
</ul>
<h3 id="4-6-2-nioBuffers"><a href="#4-6-2-nioBuffers" class="headerlink" title="4.6.2 nioBuffers"></a>4.6.2 nioBuffers</h3><p><code>#nioBuffers()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer[] nioBuffers() {</span><br><span class="line">    <span class="keyword">return</span> nioBuffers(readerIndex, readableBytes());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在方法内部，会调用 <code>#nioBuffers(int index, int length)</code> 方法。而该方法，由具体的子类实现。</li>
<li>😈 为什么会产生数组的情况呢？例如 CompositeByteBuf 。当然，后续文章，我们也会具体分享。</li>
</ul>
<h2 id="4-7-Heap-相关方法"><a href="#4-7-Heap-相关方法" class="headerlink" title="4.7 Heap 相关方法"></a>4.7 Heap 相关方法</h2><p>Heap 相关方法，在子类中实现。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-2-ByteBuf-core-impl">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（二）核心子类》</a></p>
<h2 id="4-8-Unsafe-相关方法"><a href="#4-8-Unsafe-相关方法" class="headerlink" title="4.8 Unsafe 相关方法"></a>4.8 Unsafe 相关方法</h2><p>Unsafe，在子类中实现。详细解析，见 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-2-ByteBuf-core-impl">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（二）核心子类》</a></p>
<h2 id="4-9-Object-相关"><a href="#4-9-Object-相关" class="headerlink" title="4.9 Object 相关"></a>4.9 Object 相关</h2><p>Object 相关的方法，主要调用 <code>io.netty.buffer.ByteBufUtil</code> 进行实现。而 ByteUtil 是一个非常有用的工具类，它提供了一系列静态方法，用于操作 ByteBuf 对象：<a href="http://static2.iocoder.cn/images/Netty/2018_08_01/06.png" title="ByteUtil" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_01/06.png" alt="ByteUtil"></a><span class="caption">ByteUtil</span></p>
<p>😈 因为 Object 相关的方法，实现比较简单。所以，感兴趣的胖友，可以自己去看。</p>
<h2 id="4-10-引用计数相关"><a href="#4-10-引用计数相关" class="headerlink" title="4.10 引用计数相关"></a>4.10 引用计数相关</h2><p>本文暂时不解析，我们会在 TODO 1011 。</p>
<h1 id="5-EmptyByteBuf"><a href="#5-EmptyByteBuf" class="headerlink" title="5. EmptyByteBuf"></a>5. EmptyByteBuf</h1><p><code>io.netty.buffer.EmptyByteBuf</code> ，继承 ByteBuf 抽象类，用于构建空 ByteBuf 对象，<code>capacity</code> 和 <code>maxCapacity</code> 均为 0 。</p>
<p>😈 代码实现超级简单，感兴趣的胖友，可以自己去看。</p>
<h1 id="6-WrappedByteBuf"><a href="#6-WrappedByteBuf" class="headerlink" title="6. WrappedByteBuf"></a>6. WrappedByteBuf</h1><p><code>io.netty.buffer.WrappedByteBuf</code> ，继承 ByteBuf 抽象类，用于装饰 ByteBuf 对象。构造方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被装饰的 ByteBuf 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">WrappedByteBuf</span><span class="params">(ByteBuf buf)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"buf"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>buf</code> 属性，被装饰的 ByteBuf 对象。</li>
<li><p>每个实现方法，是对 <code>buf</code> 的对应方法的调用。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> buf.capacity();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line">    buf.capacity(newCapacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h1 id="7-SwappedByteBuf"><a href="#7-SwappedByteBuf" class="headerlink" title="7. SwappedByteBuf"></a>7. SwappedByteBuf</h1><p><code>io.netty.buffer.SwappedByteBuf</code> ，继承 ByteBuf 抽象类，用于构建具有切换<strong>字节序</strong>功能的 ByteBuf 对象。构造方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原 ByteBuf 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteOrder order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SwappedByteBuf</span><span class="params">(ByteBuf buf)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"buf"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.buf = buf;</span><br><span class="line">    <span class="comment">// 初始化 order 属性</span></span><br><span class="line">    <span class="keyword">if</span> (buf.order() == ByteOrder.BIG_ENDIAN) {</span><br><span class="line">        order = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        order = ByteOrder.BIG_ENDIAN;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>buf</code> 属性，原 ByteBuf 对象。</li>
<li><code>order</code> 属性，字节数。</li>
<li><p>实际上，SwappedByteBuf 可以看成一个特殊的 WrappedByteBuf 实现，所以它除了读写操作外的方法，都是对 <code>buf</code> 的对应方法的调用。</p>
<ul>
<li><p><code>#capacity()</code> 方法，代码如下： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> buf.capacity();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>直接调用 <code>buf</code> 的对应方法。</li>
</ul>
</li>
<li><p><code>#setInt(int index, int value)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    buf.setInt(index, ByteBufUtil.swapInt(value));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByteBufUtil.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Toggles the endianness of the specified 32-bit integer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Integer.reverseBytes(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>先调用 <code>ByteBufUtil#swapInt(int value)</code> 方法，将 <code>value</code> 的值，转换成相反字节序的 Int 值。</li>
<li>后调用 <code>buf</code> 的对应方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过 SwappedByteBuf 类，我们可以很方便的修改原 ByteBuf 对象的字节序，并且无需进行内存复制。但是反过来，一定要注意，这两者是<strong>共享</strong>的。</p>
<h1 id="8-ReplayingDecoderByteBuf"><a href="#8-ReplayingDecoderByteBuf" class="headerlink" title="8. ReplayingDecoderByteBuf"></a>8. ReplayingDecoderByteBuf</h1><p><code>io.netty.handler.codec.ReplayingDecoderByteBuf</code> ，继承 ByteBuf 抽象类，用于构建在 IO 阻塞条件下实现无阻塞解码的特殊 ByteBuf对 象。当要读取的数据还未接收完全时，抛出异常，交由 ReplayingDecoder 处理。</p>
<p>细心的胖友，会看到 ReplayingDecoderByteBuf 是在 <code>codec</code> 模块，配合 ReplayingDecoder 使用。所以，本文暂时不会分享它，而是在 <a href="">《TODO 2000 ReplayingDecoderByteBuf》</a> 中，详细解析。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>每逢开篇，内容就特别啰嗦，哈哈哈哈。</p>
<p>推荐阅读如下文章：</p>
<ul>
<li>AbeJeffrey <a href="https://my.oschina.net/7001/blog/742236" rel="external nofollow noopener noreferrer" target="_blank">《深入研究Netty框架之ByteBuf功能原理及源码分析》</a></li>
<li><a href="https://skyao.gitbooks.io/learning-netty/content/buffer/inheritance.html" rel="external nofollow noopener noreferrer" target="_blank">《Netty 学习笔记 —— ByteBuf 继承结构》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-1-1-ByteBuf-intro/" data-id="ck4pl3fp400dyfgcf0fdpwvjn" class="article-share-link">分享</a>

</footer>
-->
</div>
