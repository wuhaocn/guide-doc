# NIO æœåŠ¡å™¨ï¼ˆå››ï¼‰ä¹‹ Exchange å±‚

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ï¼ˆä¸‰ï¼‰ä¹‹ Telnet å±‚ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-telnet//?self) ä¸€æ–‡ï¼Œåˆ†äº«

dubbo-remoting-api
æ¨¡å—ï¼Œ

exchange
åŒ…ï¼Œ**ä¿¡æ¯äº¤æ¢å±‚**ã€‚
**exchange** ä¿¡æ¯äº¤æ¢å±‚ï¼šå°è£…è¯·æ±‚å“åº”æ¨¡å¼ï¼ŒåŒæ­¥è½¬å¼‚æ­¥ï¼Œä»¥ Request, Response ä¸ºä¸­å¿ƒï¼Œæ‰©å±•æ¥å£ä¸º Exchanger, ExchangeChannel, ExchangeClient, ExchangeServerã€‚

åœ¨ä¸€æ¬¡ RPC è°ƒç”¨ï¼Œæ¯ä¸ª**è¯·æ±‚**( Request )ï¼Œæ˜¯å…³æ³¨å¯¹åº”çš„**å“åº”**( Response )ã€‚é‚£ä¹ˆ **transport å±‚** æä¾›çš„**ç½‘ç»œä¼ è¾“** åŠŸèƒ½ï¼Œæ˜¯æ— æ³•æ»¡è¶³ RPC çš„è¯‰æ±‚çš„ã€‚å› æ­¤ï¼Œ**exchange å±‚**ï¼Œåœ¨å…¶ **Message** ä¹‹ä¸Šï¼Œæ„é€ äº†**Request-Response** çš„æ¨¡å‹ã€‚

å®ç°ä¸Šï¼Œä¹Ÿéå¸¸ç®€å•ï¼Œå°† Message åˆ†æˆ Request å’Œ Response ä¸¤ç§ç±»å‹ï¼Œå¹¶å¢åŠ **ç¼–å·**å±æ€§ï¼Œå°† Request å’Œ Response èƒ½å¤Ÿ**ä¸€ä¸€æ˜ å°„**ã€‚

å®é™…ä¸Šï¼ŒRPC è°ƒç”¨ï¼Œä¼šæœ‰æ›´å¤šç‰¹æ€§çš„éœ€æ±‚ï¼š1ï¼‰**å¼‚æ­¥**å¤„ç†è¿”å›ç»“æœï¼›2ï¼‰å†…ç½®äº‹ä»¶ï¼›3ï¼‰ç­‰ç­‰ã€‚å› æ­¤ï¼ŒRequest å’Œ Response ä¸Šä¼šæœ‰ç±»ä¼¼**ç¼–å·**çš„**ç³»ç»Ÿå­—æ®µ**ã€‚

ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ‘ä»¬åˆ†æˆä¸¤æ®µï¼š

- åè®®å¤´( Header ) ï¼š ç³»ç»Ÿå­—æ®µï¼Œä¾‹å¦‚ç¼–å·ç­‰ã€‚
- å†…å®¹( Body ) ï¼šå…·ä½“è¯·æ±‚çš„å‚æ•°å’Œå“åº”çš„ç»“æœç­‰ã€‚

èƒ–å‹åœ¨çœ‹ä¸‹é¢è¿™å¼ å›¾ï¼Œæ˜¯å¦å°±äº²åˆ‡å¤šäº† ğŸ™‚ ï¼š

![ç±»å›¾](http://static2.iocoder.cn/images/Dubbo/2018_12_10/01.png)

æ‰€ä»¥ï¼Œ

exchange
åŒ…ï¼Œå¾ˆå¤šçš„ä»£ç ï¼Œæ˜¯åœ¨ Header çš„å¤„ç†ã€‚OK ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸‹è¿™ä¸ªåŒ…çš„**ç±»å›¾**ï¼š

![ç±»å›¾](http://static2.iocoder.cn/images/Dubbo/2018_12_10/02.png)

- ç™½è‰²éƒ¨åˆ†ï¼Œä¸ºé€šç”¨æ¥å£å’Œ

transport
åŒ…ä¸‹çš„ç±»ã€‚

- è“è‰²éƒ¨åˆ†ï¼Œä¸º

exchange
åŒ…ä¸‹çš„ç±»ã€‚

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ï¼ˆäºŒï¼‰ä¹‹ Transport å±‚ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-transport/?self) ä¸­ï¼Œæˆ‘ä»¬æåˆ°ï¼Œ**è£…é¥°å™¨è®¾è®¡æ¨¡å¼**ï¼Œæ˜¯

dubbo-remoting
é¡¹ç›®ï¼Œæœ€æ ¸å¿ƒçš„å®ç°æ–¹å¼ï¼Œæ‰€ä»¥ï¼Œ

exchange
å…¶å®æ˜¯åœ¨

transport
ä¸Šçš„**è£…é¥°**ï¼Œæä¾›ç»™

dubbo-rpc
é¡¹ç›®ä½¿ç”¨ã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥çœ‹å…·ä½“ä»£ç å®ç°ã€‚

# 2. ExchangeChannel

com.alibaba.dubbo.remoting.exchange.ExchangeChannel
ï¼Œç»§æ‰¿ Channel æ¥å£ï¼Œ**ä¿¡æ¯äº¤æ¢é€šé“**æ¥å£ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š

```
// å‘é€è¯·æ±‚
ResponseFuture request(Object request) throws RemotingException;
ResponseFuture request(Object request, int timeout) throws RemotingException;
// è·å¾—ä¿¡æ¯äº¤æ¢å¤„ç†å™¨
ExchangeHandler getExchangeHandler();
// ä¼˜é›…å…³é—­
void close(int timeout);
```

## 2.1 HeaderExchangeChannel

com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeChannel
ï¼Œå®ç° ExchangeChannel æ¥å£ï¼ŒåŸºäº**æ¶ˆæ¯å¤´éƒ¨( Header )**çš„ä¿¡æ¯äº¤æ¢é€šé“å®ç°ç±»ã€‚

### 2.1.1 æ„é€ æ–¹æ³•

```
private static final String CHANNEL_KEY = HeaderExchangeChannel.class.getName() + ".CHANNEL";
//*/*
/* é€šé“
/*/
private final Channel channel;
//*/*
/* æ˜¯å¦å…³é—­
/*/
private volatile boolean closed = false;
HeaderExchangeChannel(Channel channel) {
if (channel == null) {
throw new IllegalArgumentException("channel == null");
}
this.channel = channel;
}
```

- channel
  å±æ€§ï¼Œé€šé“ã€‚HeaderExchangeChannel æ˜¯ä¼ å…¥

channel
å±æ€§çš„**è£…é¥°å™¨**ï¼Œæ¯ä¸ªå®ç°çš„æ–¹æ³•ï¼Œéƒ½ä¼šè°ƒç”¨

channel
ã€‚å¦‚ä¸‹æ˜¯è¯¥å±æ€§çš„ä¸€ä¸ªä¾‹å­ï¼š![`channel`](http://static2.iocoder.cn/images/Dubbo/2018_12_10/03.png)

- /#getOrAddChannel(Channel)
  **é™æ€**æ–¹æ³•ï¼Œåˆ›å»º HeaderExchangeChannel å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
static HeaderExchangeChannel getOrAddChannel(Channel ch){
if (ch == null) {
return null;
}
HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY);
if (ret == null) {
ret = new HeaderExchangeChannel(ch);
if (ch.isConnected()) { // å·²è¿æ¥
ch.setAttribute(CHANNEL_KEY, ret);
}
}
return ret;
}
```

- ä¼ å…¥çš„

ch
å±æ€§ï¼Œå®é™…å°±æ˜¯

HeaderExchangeChanel.channel
å±æ€§ã€‚

- é€šè¿‡

ch.attribute
çš„

CHANNEL_KEY
é”®å€¼ï¼Œä¿è¯æœ‰ä¸”ä»…æœ‰ä¸º

ch
å±æ€§ï¼Œåˆ›å»ºå”¯ä¸€çš„ HeaderExchangeChannel å¯¹è±¡ã€‚

- è¦æ±‚**å·²è¿æ¥**ã€‚
- /#removeChannelIfDisconnected(ch)
  **é™æ€æ–¹æ³•**ï¼Œç§»é™¤ HeaderExchangeChannel å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
static void removeChannelIfDisconnected(Channel ch){
if (ch != null && !ch.isConnected()) { // æœªè¿æ¥
ch.removeAttribute(CHANNEL_KEY);
}
}
```

### 2.1.2 å‘é€è¯·æ±‚

```
1: @Override
2: public ResponseFuture request(Object request, int timeout) throws RemotingException{
3: if (closed) {
4: throw new RemotingException(this.getLocalAddress(), null, "Failed to send request " + request + ", cause: The channel " + this + " is closed!");
5: }
6: // create request. åˆ›å»ºè¯·æ±‚
7: Request req = new Request();
8: req.setVersion("2.0.0");
9: req.setTwoWay(true); // éœ€è¦å“åº”
10: req.setData(request);
11: // åˆ›å»º DefaultFuture å¯¹è±¡
12: DefaultFuture future = new DefaultFuture(channel, req, timeout);
13: try {
14: // å‘é€è¯·æ±‚
15: channel.send(req);
16: } catch (RemotingException e) { // å‘ç”Ÿå¼‚å¸¸ï¼Œå–æ¶ˆ DefaultFuture
17: future.cancel();
18: throw e;
19: }
20: // è¿”å› DefaultFuture å¯¹è±¡
21: return future;
22: }
```

- ç¬¬ 3 è‡³ 5 è¡Œï¼šè‹¥å·²ç»å…³é—­ï¼Œä¸å†å…è®¸å‘èµ·æ–°çš„è¯·æ±‚ã€‚
- ç¬¬ 6 è‡³ 10 è¡Œï¼šåˆ›å»º Request å¯¹è±¡ã€‚å…¶ä¸­ï¼Œ

twoWay = true
éœ€è¦å“åº”ï¼›

data = request
å…·ä½“æ•°æ®ã€‚

- ç¬¬ 12 è¡Œï¼šåˆ›å»º DefaultFuture å¯¹è±¡ã€‚
- ç¬¬ 13 è‡³ 15 è¡Œï¼šè°ƒç”¨

Channel/#send(req)
æ–¹æ³•ï¼Œå‘é€è¯·æ±‚ã€‚

- ç¬¬ 16 è‡³ 19 è¡Œï¼šå‘ç”Ÿ RemotingException å¼‚å¸¸ï¼Œè°ƒç”¨

DefaultFuture/#cancel()
æ–¹æ³•ï¼Œå–æ¶ˆã€‚

- ç¬¬ 21 è¡Œï¼šè¿”å› DefaultFuture å¯¹è±¡ã€‚ä»ä»£ç çš„å½¢å¼ä¸Šæ¥è¯´ï¼Œæœ‰ç‚¹ç±»ä¼¼çº¿ç¨‹æ± æäº¤ä»»åŠ¡ï¼Œè¿”å› Future å¯¹è±¡ã€‚ğŸ™‚ çœ‹åˆ° DefaultFuture çš„å…·ä½“ä»£ç ï¼Œæˆ‘ä»¬å°±ä¼šæ›´åŠ ç†è§£äº†ã€‚

### 2.1.3 ä¼˜é›…å…³é—­

```
1: @Override
2: public void close(int timeout){
3: if (closed) {
4: return;
5: }
6: closed = true;
7: // ç­‰å¾…è¯·æ±‚å®Œæˆ
8: if (timeout > 0) {
9: long start = System.currentTimeMillis();
10: while (DefaultFuture.hasFuture(channel) && System.currentTimeMillis() - start < timeout) {
11: try {
12: Thread.sleep(10);
13: } catch (InterruptedException e) {
14: logger.warn(e.getMessage(), e);
15: }
16: }
17: }
18: // å…³é—­é€šé“
19: close();
20: }
```

- ç¬¬ 3 è‡³ 6 è¡Œï¼šæ ‡è®°

closed = true
ï¼Œé¿å…å‘èµ·**æ–°**çš„è¯·æ±‚ã€‚

- ç¬¬ 7 è‡³ 17 è¡Œï¼šè°ƒç”¨

DefaultFuture/#hasFuture(channel)
æ–¹æ³•ï¼Œåˆ¤æ–­å·²å‘èµ·çš„å·²ç»æ˜¯å¦å·²ç»éƒ½å“åº”äº†ã€‚è‹¥å¦ï¼Œç­‰å¾…å®Œæˆæˆ–è¶…æ—¶ã€‚

- ç¬¬ 19 è¡Œï¼šå…³é—­**é€šé“**ã€‚

**å…¶å®ƒæ–¹æ³•**

å…¶å®ƒ**å®ç°**æ–¹æ³•ï¼Œä¸»è¦æ˜¯ç›´æ¥è°ƒç”¨

channel
çš„æ–¹æ³•ï¼Œç‚¹å‡» [ä¼ é€é—¨](https://github.com/YunaiV/dubbo/blob/2a0484941defceb9a600c7f7914ada335e3186af/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeChannel.java) æŸ¥çœ‹ä»£ç ã€‚

# 3. ExchangeClient

com.alibaba.dubbo.remoting.exchange.ExchangeClient
ï¼Œå®ç° Client ï¼ŒExchangeChannel æ¥å£ï¼Œ**ä¿¡æ¯äº¤æ¢å®¢æˆ·ç«¯**æ¥å£ã€‚

æ— è‡ªå®šä¹‰æ–¹æ³•ã€‚

## 3.1 HeaderExchangeClient

com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeClient
ï¼Œå®ç° ExchangeClient æ¥å£ï¼ŒåŸºäº**æ¶ˆæ¯å¤´éƒ¨( Header )**çš„ä¿¡æ¯äº¤æ¢å®¢æˆ·ç«¯å®ç°ç±»ã€‚

**æ„é€ æ–¹æ³•**

```
1: //*/*
2: /* å®šæ—¶å™¨çº¿ç¨‹æ± 
3: /*/
4: private static final ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2, new NamedThreadFactory("dubbo-remoting-client-heartbeat", true));
5: //*/*
6: /* å®¢æˆ·ç«¯
7: /*/
8: private final Client client;
9: //*/*
10: /* ä¿¡æ¯äº¤æ¢é€šé“
11: /*/
12: private final ExchangeChannel channel;
13: // heartbeat timer
14: //*/*
15: /* å¿ƒè·³å®šæ—¶å™¨
16: /*/
17: private ScheduledFuture<?> heartbeatTimer;
18: //*/*
19: /* æ˜¯å¦å¿ƒè·³
20: /*/
21: private int heartbeat;
22: // heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.
23: //*/*
24: /* å¿ƒè·³é—´éš”ï¼Œå•ä½ï¼šæ¯«ç§’
25: /*/
26: private int heartbeatTimeout;
27:
28: public HeaderExchangeClient(Client client, boolean needHeartbeat){
29: if (client == null) {
30: throw new IllegalArgumentException("client == null");
31: }
32: this.client = client;
33: // åˆ›å»º HeaderExchangeChannel å¯¹è±¡
34: this.channel = new HeaderExchangeChannel(client);
35: // è¯»å–å¿ƒè·³ç›¸å…³é…ç½®
36: String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);
37: this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null && dubbo.startsWith("1.0.") ? Constants.DEFAULT_HEARTBEAT : 0);
38: this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat /* 3);
39: if (heartbeatTimeout < heartbeat /* 2) { // é¿å…é—´éš”å¤ªçŸ­
40: throw new IllegalStateException("heartbeatTimeout < heartbeatInterval /* 2");
41: }
42: // å‘èµ·å¿ƒè·³å®šæ—¶å™¨
43: if (needHeartbeat) {
44: startHeatbeatTimer();
45: }
46: }
```

- client
  å±æ€§ï¼Œå®¢æˆ·ç«¯ã€‚å¦‚ä¸‹æ˜¯è¯¥å±æ€§çš„ä¸€ä¸ªä¾‹å­ï¼š![`client`](http://static2.iocoder.cn/images/Dubbo/2018_12_10/04.png)
- ç¬¬ 34 è¡Œï¼šä½¿ç”¨ä¼ å…¥çš„

client
å±æ€§ï¼Œåˆ›å»º HeaderExchangeChannel å¯¹è±¡ã€‚

- ç¬¬ 35 è‡³ 41 è¡Œï¼šè¯»å–å¿ƒè·³ç›¸å…³é…ç½®ã€‚**é»˜è®¤ï¼Œå¼€å¯å¿ƒè·³åŠŸèƒ½**ã€‚ä¸ºä»€ä¹ˆéœ€è¦æœ‰å¿ƒè·³åŠŸèƒ½å‘¢ï¼Ÿ
  FROM [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” dubbo:protocolã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-protocol.html)

å¿ƒè·³é—´éš”ï¼Œå¯¹äºé•¿è¿æ¥ï¼Œå½“ç‰©ç†å±‚æ–­å¼€æ—¶ï¼Œæ¯”å¦‚æ‹”ç½‘çº¿ï¼ŒTCP çš„ FIN æ¶ˆæ¯æ¥ä¸åŠå‘é€ï¼Œå¯¹æ–¹æ”¶ä¸åˆ°æ–­å¼€äº‹ä»¶ï¼Œæ­¤æ—¶éœ€è¦å¿ƒè·³æ¥å¸®åŠ©æ£€æŸ¥è¿æ¥æ˜¯å¦å·²æ–­å¼€

- ç¬¬ 42 è‡³ 45 è¡Œï¼šè°ƒç”¨

/#startHeatbeatTimer()
æ–¹æ³•ï¼Œå‘èµ·å¿ƒè·³å®šæ—¶å™¨ã€‚

**å‘èµ·å¿ƒè·³å®šæ—¶å™¨**

```
1: private void startHeatbeatTimer(){
2: // åœæ­¢åŸæœ‰å®šæ—¶ä»»åŠ¡
3: stopHeartbeatTimer();
4: // å‘èµ·æ–°çš„å®šæ—¶ä»»åŠ¡
5: if (heartbeat > 0) {
6: heartbeatTimer = scheduled.scheduleWithFixedDelay(
7: new HeartBeatTask(new HeartBeatTask.ChannelProvider() {
8: public Collection<Channel> getChannels(){
9: return Collections.<Channel>singletonList(HeaderExchangeClient.this);
10: }
11: }, heartbeat, heartbeatTimeout),
12: heartbeat, heartbeat, TimeUnit.MILLISECONDS);
13: }
14: }
```

- ç¬¬ 3 è¡Œï¼šè°ƒç”¨ [
  /#stopHeartbeatTimer()
  ](https://github.com/YunaiV/dubbo/blob/0f933100ad0ea81d3760d42169318904f91a45bb/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java#L176-L188) æ–¹æ³•ï¼Œåœæ­¢åŸæœ‰å®šæ—¶ä»»åŠ¡ã€‚
- ç¬¬ 5 è‡³ 13 è¡Œï¼šå‘èµ·æ–°çš„å®šæ—¶ä»»åŠ¡ã€‚

- ç¬¬ 7 è‡³ 11 è¡Œï¼šåˆ›å»ºå®šæ—¶ä»»åŠ¡ HeartBeatTask å¯¹è±¡ã€‚å…·ä½“å®ç°è§ä¸‹æ–‡ã€‚

**å…¶å®ƒæ–¹æ³•**

å…¶å®ƒ**å®ç°**æ–¹æ³•ï¼Œä¸»è¦æ˜¯ç›´æ¥è°ƒç”¨

channel
æˆ–

client
çš„æ–¹æ³•ï¼Œç‚¹å‡» [ä¼ é€é—¨](https://github.com/YunaiV/dubbo/blob/0f933100ad0ea81d3760d42169318904f91a45bb/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java) æŸ¥çœ‹ä»£ç ã€‚

# 4. ExchangeServer

com.alibaba.dubbo.remoting.exchange.ExchangeServer
ï¼Œç»§æ‰¿ Server æ¥å£ï¼Œ**ä¿¡æ¯äº¤æ¢æœåŠ¡å™¨**æ¥å£ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š

```
// è·å¾—é€šé“æ•°ç»„
Collection<ExchangeChannel> getExchangeChannels();
ExchangeChannel getExchangeChannel(InetSocketAddress remoteAddress);
```

## 4.1 HeaderExchangeServer

com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeServer
ï¼Œå®ç° ExchangeServer æ¥å£ï¼ŒåŸºäº**æ¶ˆæ¯å¤´éƒ¨( Header )**çš„ä¿¡æ¯äº¤æ¢æœåŠ¡å™¨å®ç°ç±»ã€‚
ä»£ç å®ç°ä¸Šï¼Œå’Œ HeaderExchangeChannel + HeaderExchangeClient çš„ç»¼åˆã€‚

### 4.1.1 æ„é€ æ–¹æ³•

ä»£ç å®ç°ä¸Šï¼Œå’Œ HeaderExchangeClient çš„ç±»ä¼¼ã€‚

```
//*/*
/* å®šæ—¶å™¨çº¿ç¨‹æ± 
/*/
private final ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(1, new NamedThreadFactory("dubbo-remoting-server-heartbeat", true));
//*/*
/* æœåŠ¡å™¨
/*/
private final Server server;
// heartbeat timer
//*/*
/* å¿ƒè·³å®šæ—¶å™¨
/*/
private ScheduledFuture<?> heatbeatTimer;
//*/*
/* æ˜¯å¦å¿ƒè·³
/*/
// heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.
private int heartbeat;
//*/*
/* å¿ƒè·³é—´éš”ï¼Œå•ä½ï¼šæ¯«ç§’
/*/
private int heartbeatTimeout;
//*/*
/* æ˜¯å¦å…³é—­
/*/
private AtomicBoolean closed = new AtomicBoolean(false);
public HeaderExchangeServer(Server server){
if (server == null) {
throw new IllegalArgumentException("server == null");
}
// è¯»å–å¿ƒè·³ç›¸å…³é…ç½®
this.server = server;
this.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, 0);
this.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat /* 3);
if (heartbeatTimeout < heartbeat /* 2) {
throw new IllegalStateException("heartbeatTimeout < heartbeatInterval /* 2");
}
// å‘èµ·å¿ƒè·³å®šæ—¶å™¨
startHeatbeatTimer();
}
```

### 4.1.2 å‘èµ·å¿ƒè·³å®šæ—¶å™¨

ä»£ç å®ç°ä¸Šï¼Œå’Œ HeaderExchangeClient çš„ç±»ä¼¼ã€‚

```
private void startHeatbeatTimer(){
// åœæ­¢åŸæœ‰å®šæ—¶ä»»åŠ¡
stopHeartbeatTimer();
// å‘èµ·æ–°çš„å®šæ—¶ä»»åŠ¡
if (heartbeat > 0) {
heatbeatTimer = scheduled.scheduleWithFixedDelay(
new HeartBeatTask(new HeartBeatTask.ChannelProvider() {
public Collection<Channel> getChannels(){
return Collections.unmodifiableCollection(HeaderExchangeServer.this.getChannels());
}
}, heartbeat, heartbeatTimeout),
heartbeat, heartbeat, TimeUnit.MILLISECONDS);
}
}
```

- å·®å¼‚ï¼ŒServer æŒæœ‰**å¤šæ¡** Client è¿æ¥çš„ Channel ï¼Œæ‰€ä»¥é€šè¿‡ ChannelProvider è¿”å›çš„æ˜¯**å¤šæ¡**ã€‚

### 4.1.3 é‡ç½®å±æ€§

```
@Override
public void reset(URL url){
// é‡ç½®æœåŠ¡å™¨
server.reset(url);
try {
if (url.hasParameter(Constants.HEARTBEAT_KEY)
|| url.hasParameter(Constants.HEARTBEAT_TIMEOUT_KEY)) {
int h = url.getParameter(Constants.HEARTBEAT_KEY, heartbeat);
int t = url.getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, h /* 3);
if (t < h /* 2) {
throw new IllegalStateException("heartbeatTimeout < heartbeatInterval /* 2");
}
// é‡ç½®å®šæ—¶ä»»åŠ¡
if (h != heartbeat || t != heartbeatTimeout) {
heartbeat = h;
heartbeatTimeout = t;
startHeatbeatTimer();
}
}
} catch (Throwable t) {
logger.error(t.getMessage(), t);
}
}
```

### 4.1.4 ä¼˜é›…å…³é—­

ä»£ç å®ç°ä¸Šï¼Œå’Œ HeaderExchangeChannel çš„ç±»ä¼¼ï¼Œä¸”å¤æ‚ä¸€äº›ã€‚

```
1: @Override
2: public void close(final int timeout){
3: // å…³é—­
4: startClose();
5: if (timeout > 0) {
6: final long max = (long) timeout;
7: final long start = System.currentTimeMillis();
8: // å‘é€ READONLY äº‹ä»¶ç»™æ‰€æœ‰ Client ï¼Œè¡¨ç¤º Server ä¸å¯è¯»äº†ã€‚
9: if (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, true)) {
10: sendChannelReadOnlyEvent();
11: }
12: // ç­‰å¾…è¯·æ±‚å®Œæˆ
13: while (HeaderExchangeServer.this.isRunning() && System.currentTimeMillis() - start < max) {
14: try {
15: Thread.sleep(10);
16: } catch (InterruptedException e) {
17: logger.warn(e.getMessage(), e);
18: }
19: }
20: }
21: // å…³é—­å¿ƒè·³å®šæ—¶å™¨
22: doClose();
23: // å…³é—­æœåŠ¡å™¨
24: server.close(timeout);
25: }
```

- Server å…³é—­çš„è¿‡ç¨‹ï¼Œåˆ†æˆ**ä¸¤ä¸ªé˜¶æ®µ**ï¼šæ­£åœ¨å…³é—­å’Œå·²ç»å…³é—­ã€‚
- ç¬¬ 4 è¡Œï¼šè°ƒç”¨

/#startClose()
æ–¹æ³•ï¼Œæ ‡è®°æ­£åœ¨å…³é—­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
@Override
public void startClose(){
server.startClose();
}
// AbstractPeer.java
@Override
public void startClose(){
if (isClosed()) {
return;
}
closing = true;
}
```

- ç¬¬ 8 è‡³ 11 è¡Œï¼šå‘é€ **READONLY** äº‹ä»¶ç»™æ‰€æœ‰ Client ï¼Œè¡¨ç¤º Server ä¸å†æ¥æ”¶æ–°çš„æ¶ˆæ¯ï¼Œé¿å…ä¸æ–­æœ‰**æ–°çš„æ¶ˆæ¯**æ¥æ”¶åˆ°ã€‚æ‚å®ç°çš„å‘¢ï¼Ÿä»¥ DubboInvoker ä¸¾ä¾‹å­ï¼Œ

/#isAvailable()
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
@Override
public boolean isAvailable(){
if (!super.isAvailable())
return false;
for (ExchangeClient client : clients) {
if (client.isConnected() && !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) { // åªè¯»åˆ¤æ–­
//cannot write == not Available ?
return true;
}
}
return false;
}
```

- å³ä½¿

client
å¤„äº**è¿æ¥ä¸­**ï¼Œä½†æ˜¯ Server å¤„äº**æ­£åœ¨å…³é—­ä¸­**ï¼Œä¹Ÿç®—**ä¸å¯ç”¨**ï¼Œä¸è¿›è¡Œå‘é€è¯·æ±‚( æ¶ˆæ¯ )ã€‚

- /#sendChannelReadOnlyEvent()
  æ–¹æ³•ï¼Œå¹¿æ’­å®¢æˆ·ç«¯ï¼ŒREADONLY_EVENT äº‹ä»¶ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private void sendChannelReadOnlyEvent(){
// åˆ›å»º READONLY_EVENT è¯·æ±‚
Request request = new Request();
request.setEvent(Request.READONLY_EVENT);
request.setTwoWay(false); // æ— éœ€å“åº”
request.setVersion(Version.getVersion());
// å‘é€ç»™æ‰€æœ‰ Client
Collection<Channel> channels = getChannels();
for (Channel channel : channels) {
try {
if (channel.isConnected())
channel.send(request, getUrl().getParameter(Constants.CHANNEL_READONLYEVENT_SENT_KEY, true));
} catch (RemotingException e) {
logger.warn("send connot write messge error.", e);
}
}
}
```

- ç¬¬ 22 è¡Œï¼šè°ƒç”¨

/#oClose()
æ–¹æ³•ï¼Œå…³é—­å¿ƒè·³å®šæ—¶å™¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private void doClose(){
if (!closed.compareAndSet(false, true)) {
return;
}
stopHeartbeatTimer();
try {
scheduled.shutdown();
} catch (Throwable t) {
logger.warn(t.getMessage(), t);
}
}
```

- ç¬¬ 24 è¡Œï¼š**çœŸæ­£**å…³é—­æœåŠ¡å™¨ã€‚

## 4.2 ExchangeServerDelegate

[
com.alibaba.dubbo.remoting.exchange.support.ExchangeServerDelegate
](https://github.com/YunaiV/dubbo/blob/31b3f1e868ed2d62c97a26b5cd233a921ce2205a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ExchangeServerDelegate.java) ï¼Œå®ç° ExchangeServer æ¥å£ï¼Œä¿¡æ¯äº¤æ¢æœåŠ¡å™¨è£…é¥°è€…ã€‚åœ¨æ¯ä¸ªå®ç°çš„æ–¹æ³•é‡Œï¼Œç›´æ¥è°ƒç”¨è¢«è£…é¥°çš„ [
server
](https://github.com/YunaiV/dubbo/blob/31b3f1e868ed2d62c97a26b5cd233a921ce2205a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ExchangeServerDelegate.java#L34) å±æ€§çš„æ–¹æ³•ã€‚

ç›®å‰

dubbo-remoting-p2p
æ¨¡å—ä¸­ï¼ŒExchangeServerPeer ä¼šç»§æ‰¿è¯¥ç±»ï¼Œåç»­å†çœ‹ã€‚

# 5. è¯·æ±‚/å“åº”æ¨¡å‹

## 5.1 Request

com.alibaba.dubbo.remoting.exchange.Request
ï¼Œè¯·æ±‚ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
//*/*
/* äº‹ä»¶ - å¿ƒè·³
/*/
public static final String HEARTBEAT_EVENT = null;
//*/*
/* äº‹ä»¶ - åªè¯»
/*/
public static final String READONLY_EVENT = "R";
//*/*
/* è¯·æ±‚ç¼–å·è‡ªå¢åºåˆ—
/*/
private static final AtomicLong INVOKE_ID = new AtomicLong(0);
//*/*
/* è¯·æ±‚ç¼–å·
/*/
private final long mId;
//*/*
/* Dubbo ç‰ˆæœ¬
/*/
private String mVersion;
//*/*
/* æ˜¯å¦éœ€è¦å“åº”
/*
/* true-éœ€è¦
/* false-ä¸éœ€è¦
/*/
private boolean mTwoWay = true;
//*/*
/* æ˜¯å¦æ˜¯äº‹ä»¶ã€‚ä¾‹å¦‚ï¼Œå¿ƒè·³äº‹ä»¶ã€‚
/*/
private boolean mEvent = false;
//*/*
/* æ˜¯å¦å¼‚å¸¸çš„è¯·æ±‚ã€‚
/*
/* åœ¨æ¶ˆæ¯è§£æçš„æ—¶å€™ï¼Œä¼šå‡ºç°ã€‚
/*/
private boolean mBroken = false;
//*/*
/* æ•°æ®
/*/
private Object mData;
```

- å†…ç½®ä¸¤ç§äº‹ä»¶ï¼š

- HEARTBEAT_EVENT
  ï¼šå¿ƒè·³ã€‚å› ä¸ºå¿ƒè·³æ¯”è¾ƒå¸¸ç”¨ï¼Œæ‰€ä»¥åœ¨äº‹ä»¶ä¸Šæ—¶å€™äº†

null
ã€‚

- READONLY_EVENT
  ï¼šåªè¯»ã€‚ä¸Šæ–‡å·²ç»è§£é‡Šã€‚
- mId
  å±æ€§ï¼šç¼–å·ã€‚ä½¿ç”¨

INVOKE_ID
å±æ€§ç”Ÿæˆï¼ŒJVM è¿›ç¨‹å†…å”¯ä¸€ã€‚ç”Ÿæˆä»£ç å¦‚ä¸‹ï¼š

```
private static long newId(){
// getAndIncrement() When it grows to MAX_VALUE, it will grow to MIN_VALUE, and the negative can be used as ID
return INVOKE_ID.getAndIncrement();
}
```

- version
  å±æ€§ï¼Œç‰ˆæœ¬å·ã€‚ç›®å‰ä½¿ç”¨ Dubbo å¤§ç‰ˆæœ¬ï¼Œ

"2.0.0"
ã€‚

- mTwoWay
  å±æ€§ï¼Œæ ‡è®°è¯·æ±‚æ˜¯å¦å“åº”( Response )ï¼Œé»˜è®¤**éœ€è¦**ã€‚
- mBroken
  å±æ€§ï¼Œæ˜¯å¦å¼‚å¸¸çš„è¯·æ±‚ã€‚åœ¨æ¶ˆæ¯è§£æçš„æ—¶å€™ï¼Œä¼šå‡ºç°ã€‚
- mData
  å±æ€§ï¼Œè¯·æ±‚å…·ä½“æ•°æ®ã€‚

## 5.2 Response

com.alibaba.dubbo.remoting.exchange.Response
ï¼Œå“åº”ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
//*/*
/* å“åº”ç¼–å·
/*
/* ä¸€ä¸ª {@link Request/#mId} å’Œ {@link Response/#mId} ä¸€ä¸€å¯¹åº”ã€‚
/*/
private long mId = 0;
//*/*
/* ç‰ˆæœ¬
/*/
private String mVersion;
//*/*
/* çŠ¶æ€
/*/
private byte mStatus = OK;
//*/*
/* æ˜¯å¦äº‹ä»¶
/*/
private boolean mEvent = false;
//*/*
/* é”™è¯¯æ¶ˆæ¯
/*/
private String mErrorMsg;
//*/*
/* ç»“æœ
/*/
private Object mResult;
```

- mId
  å±æ€§ï¼Œå“åº”ç¼–å·ï¼Œå’Œè¯·æ±‚ç¼–å·ä¸€è‡´ã€‚
- mStatus
  å±æ€§ï¼ŒçŠ¶æ€ã€‚æœ‰å¤šç§çŠ¶æ€ï¼š[çŠ¶æ€ç ]([https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Response.java)ã€‚](https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Response.java)%E3%80%82)
- mEvent
  å±æ€§ï¼Œæ˜¯å¦äº‹ä»¶ã€‚å’Œ Request å†…ç½®äº†**ä¸€æ ·**çš„äº‹ä»¶ï¼Œä½†æ˜¯

READONLY_EVENT
å¹¶æœªä½¿ç”¨ã€‚å› ä¸ºç›®å‰ï¼Œåªè¯»äº‹ä»¶ï¼Œæ— éœ€å“åº”ã€‚

- mErrorMsg
  å±æ€§ï¼Œé”™è¯¯æ¶ˆæ¯ã€‚
- mResult
  å±æ€§ï¼Œç»“æœã€‚

## 5.3 ResponseFuture

com.alibaba.dubbo.remoting.exchange.ResponseFuture
ï¼Œå“åº” Future **æ¥å£**ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š

```
// è·å¾—å€¼
Object get() throws RemotingException;
Object get(int timeoutInMillis) throws RemotingException;
// è®¾ç½®å›è°ƒ
void setCallback(ResponseCallback callback);
// æ˜¯å¦å®Œæˆ
boolean isDone();
```

å’Œ [
java.util.concurrent.Future
](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html) å¾ˆç±»ä¼¼ã€‚

### 5.3.1 ResponseCallback

com.alibaba.dubbo.remoting.exchange.ResponseCallback
ï¼Œå“åº”å›è°ƒ**æ¥å£**ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š

```
// å¤„ç†æ‰§è¡Œå®Œæˆ
void done(Object response);
// å¤„ç†å‘ç”Ÿå¼‚å¸¸
void caught(Throwable exception);
```

ResponseCallback åœ¨

com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter
ä¸­æœ‰ä½¿ç”¨ï¼Œåé¢æˆ‘ä»¬ä¼šæœ‰æ–‡ç« æ¥åˆ†äº« FutureFilter ã€‚

### 5.3.2 DefaultFuture

com.alibaba.dubbo.remoting.exchange.support.DefaultFuture
ï¼Œå®ç° ResponseFuture æ¥å£ï¼Œ**é»˜è®¤**å“åº” Future å®ç°ç±»ã€‚åŒæ—¶ï¼Œå®ƒä¹Ÿæ˜¯æ‰€æœ‰ DefaultFuture çš„ç®¡ç†å®¹å™¨ã€‚

**æ„é€ æ–¹æ³•**

```
//*/*
/* é€šé“é›†åˆ
/*
/* keyï¼šè¯·æ±‚ç¼–å·
/*/
private static final Map<Long, Channel> CHANNELS = new ConcurrentHashMap<Long, Channel>();
//*/*
/* Future é›†åˆ
/*
/* keyï¼šè¯·æ±‚ç¼–å·
/*/
private static final Map<Long, DefaultFuture> FUTURES = new ConcurrentHashMap<Long, DefaultFuture>();
//*/*
/* è¯·æ±‚ç¼–å·
/*/
// invoke id.
private final long id;
//*/*
/* é€šé“
/*/
private final Channel channel;
//*/*
/* è¯·æ±‚
/*/
private final Request request;
//*/*
/* è¶…æ—¶
/*/
private final int timeout;
//*/*
/* åˆ›å»ºå¼€å§‹æ—¶é—´
/*/
private final long start = System.currentTimeMillis();
//*/*
/* å‘é€è¯·æ±‚æ—¶é—´
/*/
private volatile long sent;
//*/*
/* å“åº”
/*/
private volatile Response response;
//*/*
/* å›è°ƒ
/*/
private volatile ResponseCallback callback;
public DefaultFuture(Channel channel, Request request, int timeout){
this.channel = channel;
this.request = request;
this.id = request.getId();
this.timeout = timeout > 0 ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
// put into waiting map.
FUTURES.put(id, this);
CHANNELS.put(id, channel);
}
```

- CHANNELS
  **é™æ€**å±æ€§ï¼Œé€šé“é›†åˆã€‚é€šè¿‡

/#hasFuture(channel)
æ–¹æ³•ï¼Œåˆ¤æ–­é€šé“æ˜¯å¦æœ‰æœªç»“æŸçš„è¯·æ±‚ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public static boolean hasFuture(Channel channel){
return CHANNELS.containsValue(channel);
}
```

- FUTURES
  **é™æ€**å±æ€§ï¼ŒFuture é›†åˆã€‚
- sent
  å±æ€§ï¼Œå‘é€è¯·æ±‚æ—¶é—´ã€‚å› ä¸ºåœ¨ç›®å‰ Netty Mina ç­‰é€šä¿¡æ¡†æ¶ä¸­ï¼Œå‘é€è¯·æ±‚ä¸€èˆ¬æ˜¯å¼‚æ­¥çš„ï¼Œå› æ­¤åœ¨

ChannelHandler/#sent(channel, message)
æ–¹æ³•ä¸­ï¼Œè°ƒç”¨

DefaultFuture/#sent(channel, request)
**é™æ€æ–¹æ³•**ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
public static void sent(Channel channel, Request request){
DefaultFuture future = FUTURES.get(request.getId());
if (future != null) {
future.doSent();
}
}
private void doSent(){
sent = System.currentTimeMillis();
}
```

- callback
  å±æ€§ï¼Œå›è°ƒï¼Œé€‚ç”¨äºå¼‚æ­¥è¯·æ±‚ã€‚é€šè¿‡

/#setCallback(callback)
æ–¹æ³•è®¾ç½®ã€‚

**è·å¾—å€¼**

```
//*/*
/* é”
/*/
private final Lock lock = new ReentrantLock();
//*/*
/* å®Œæˆ Condition
/*/
private final Condition done = lock.newCondition();
1: @Override
2: public Object get(int timeout) throws RemotingException{
3: if (timeout <= 0) {
4: timeout = Constants.DEFAULT_TIMEOUT;
5: }
6: // è‹¥æœªå®Œæˆï¼Œç­‰å¾…
7: if (!isDone()) {
8: long start = System.currentTimeMillis();
9: lock.lock();
10: try {
11: // ç­‰å¾…å®Œæˆæˆ–è¶…æ—¶
12: while (!isDone()) {
13: done.await(timeout, TimeUnit.MILLISECONDS);
14: if (isDone() || System.currentTimeMillis() - start > timeout) {
15: break;
16: }
17: }
18: } catch (InterruptedException e) {
19: throw new RuntimeException(e);
20: } finally {
21: lock.unlock();
22: }
23: // æœªå®Œæˆï¼ŒæŠ›å‡ºè¶…æ—¶å¼‚å¸¸ TimeoutException
24: if (!isDone()) {
25: throw new TimeoutException(sent > 0, channel, getTimeoutMessage(false));
26: }
27: }
28: // è¿”å›å“åº”
29: return returnFromResponse();
30: }
```

- ç¬¬ 7 è¡Œï¼šè°ƒç”¨

/#isDone()
æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å®Œæˆã€‚è‹¥æœªå®Œæˆï¼ŒåŸºäº Lock + Condition çš„æ–¹å¼ï¼Œå®ç°ç­‰å¾…ã€‚è€Œç­‰å¾…çš„å”¤é†’ï¼Œé€šè¿‡

ChannelHandler/#received(channel, message)
æ–¹æ³•ï¼Œæ¥æ”¶åˆ°è¯·æ±‚æ—¶æ‰§è¡Œ

DefaultFuture/#received(channel, response)
æ–¹æ³•ã€‚ğŸ™‚ ä¸‹æ–‡è¯¦ç»†è§£æã€‚

- [ã€Š Java çº¿ç¨‹(ä¹)ï¼šCondition-çº¿ç¨‹é€šä¿¡æ›´é«˜æ•ˆçš„æ–¹å¼ã€‹](https://blog.csdn.net/ghsau/article/details/7481142)
- [ã€Šæ€ä¹ˆç†è§£ Conditionã€‹](http://www.importnew.com/9281.html)
- ç¬¬ 8 è¡Œï¼šè·å¾—å¼€å§‹æ—¶é—´ã€‚**æ³¨æ„**ï¼Œæ­¤å¤„ä½¿ç”¨çš„ä¸æ˜¯

start
å±æ€§ã€‚åé¢æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œ

/#get(...)
æ–¹æ³•ä¸­ï¼Œä½¿ç”¨çš„æ˜¯**é‡æ–°**è·å–å¼€å§‹æ—¶é—´ï¼›**åå°æ‰«æè°ƒç”¨è¶…æ—¶ä»»åŠ¡**ï¼Œä½¿ç”¨çš„æ˜¯

start
å±æ€§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ

/#get(timeout)
æ–¹æ³•çš„

timeout
å‚æ•°ï¼ŒæŒ‡çš„æ˜¯ä»å½“å‰æ—¶åˆ»å¼€å§‹çš„**ç­‰å¾…è¶…æ—¶**æ—¶é—´ã€‚å½“ç„¶ï¼Œè¿™ä¸å½±å“æœ€ç»ˆçš„ç»“æœï¼Œæœ€ç»ˆ Response æ˜¯ä»€ä¹ˆï¼Œç”±æ˜¯

ChannelHandler/#received(channel, message)
è¿˜æ˜¯**åå°æ‰«æè°ƒç”¨è¶…æ—¶ä»»åŠ¡**ï¼Œè°**å…ˆè°ƒç”¨**

DefaultFuture/#received(channel, response)
æ–¹æ³•å†³å®šã€‚ğŸ™‚ æœ‰ç‚¹ç»•ï¼Œèƒ–å‹ç»†çœ‹ä¸‹ã€‚

- ç¬¬ 9 è¡Œï¼šè·å¾—é”ã€‚
- ç¬¬ 11 è‡³ 17 è¡Œï¼šç­‰å¾…**å®Œæˆ**æˆ–**è¶…æ—¶**ã€‚
- ç¬¬ 21 è¡Œï¼šé‡Šæ”¾é”ã€‚
- ç¬¬ 24 è‡³ 26 è¡Œï¼šè‹¥æœªå®Œæˆï¼ŒæŠ›å‡ºè¶…æ—¶å¼‚å¸¸ TimeoutException ã€‚

- TimeoutException.phase
  çš„é˜¶æ®µï¼Œç”±

sent > 0
æ¥å†³å®šï¼Œå³ Client æ˜¯å¦å‘é€ç»™ Server ã€‚

- [
  /#getTimeoutMessage(scan)
  ](https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/DefaultFuture.java#L264-L275) æ–¹æ³•ï¼Œè·å¾—è¶…æ—¶å¼‚å¸¸æç¤ºä¿¡æ¯ã€‚ğŸ™‚ èƒ–å‹è‡ªå·±çœ‹å“ˆã€‚
- ç¬¬ 29 è¡Œï¼šè°ƒç”¨

/#returnFromResponse()
æ–¹æ³•ï¼Œè¿”å›å“åº”( Response )ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private Object returnFromResponse() throws RemotingException{
Response res = response;
if (res == null) {
throw new IllegalStateException("response cannot be null");
}
// æ­£å¸¸ï¼Œè¿”å›ç»“æœ
if (res.getStatus() == Response.OK) {
return res.getResult();
}
// è¶…æ—¶ï¼ŒæŠ›å‡º TimeoutException å¼‚å¸¸
if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
throw new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());
}
// å…¶ä»–ï¼ŒæŠ›å‡º RemotingException å¼‚å¸¸
throw new RemotingException(channel, res.getErrorMessage());
}
```

**å“åº”ç»“æœ**

```
1: public static void received(Channel channel, Response response){
2: try {
3: // ç§»é™¤ FUTURES
4: DefaultFuture future = FUTURES.remove(response.getId());
5: // æ¥æ”¶ç»“æœ
6: if (future != null) {
7: future.doReceived(response);
8: } else {
9: logger.warn("The timeout response finally returned at "
10: + (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date()))
11: + ", response " + response
12: + (channel == null ? "" : ", channel: " + channel.getLocalAddress()
13: + " -> " + channel.getRemoteAddress()));
14: }
15: // ç§»é™¤ CHANNELS
16: } finally {
17: CHANNELS.remove(response.getId());
18: }
19: }
```

- è¯¥æ–¹æ³•æœ‰ä¸¤å¤„è¢«è°ƒç”¨ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![è°ƒç”¨](http://static2.iocoder.cn/images/Dubbo/2018_12_10/05.png)
- ç¬¬ 4 è¡Œï¼šç§»é™¤

FUTURES
ã€‚

- ç¬¬ 6 è‡³ 7 è¡Œï¼šè°ƒç”¨

DefaultFuture/#doReceived(response)
æ–¹æ³•ï¼Œå“åº”ç»“æœã€‚ä»£ç å¦‚ä¸‹ï¼š

```
1: private void doReceived(Response res){
2: // é”å®š
3: lock.lock();
4: try {
5: // è®¾ç½®ç»“æœ
6: response = res;
7: // é€šçŸ¥ï¼Œå”¤é†’ç­‰å¾…
8: if (done != null) {
9: done.signal();
10: }
11: } finally {
12: // é‡Šæ”¾é”å®š
13: lock.unlock();
14: }
15: // è°ƒç”¨å›è°ƒ
16: if (callback != null) {
17: invokeCallback(callback);
18: }
19: }
```

- ç¬¬ 3 è¡Œï¼šè·å¾—é”ã€‚
- ç¬¬ 6 è¡Œï¼šè®¾ç½®å“åº”

response
ã€‚

- ç¬¬ 8 è‡³ 10 è¡Œï¼šè°ƒç”¨

Condition/#signal()
æ–¹æ³•ï¼Œé€šçŸ¥ï¼Œ**å”¤é†’**

DefaultFuture/#get(..)
æ–¹æ³•çš„ç­‰å¾…ã€‚

- ç¬¬ 13 è¡Œï¼šé‡Šæ”¾é”ã€‚
- ç¬¬ 16 è‡³ 18 è¡Œï¼šè°ƒç”¨

/#invokeCallback(callback)
æ–¹æ³•ï¼Œæ‰§è¡Œå›è°ƒæ–¹æ³•ã€‚

- ç¬¬ 8 è‡³ 14 è¡Œï¼šè¶…æ—¶æƒ…å†µï¼Œæ‰“å°**å‘Šè­¦**æ—¥å¿—ã€‚
- ç¬¬ 15 è‡³ 18 è¡Œï¼šç§»é™¤

CHANNELS
ã€‚

**è®¾ç½®å›è°ƒ**

```
1: @Override
2: public void setCallback(ResponseCallback callback){
3: // å·²å®Œæˆï¼Œè°ƒç”¨å›è°ƒ
4: if (isDone()) {
5: invokeCallback(callback);
6: } else {
7: boolean isdone = false;
8: // è·å¾—é”
9: lock.lock();
10: try {
11: // æœªå®Œæˆï¼Œè®¾ç½®å›è°ƒ
12: if (!isDone()) {
13: this.callback = callback;
14: } else {
15: isdone = true;
16: }
17: // é‡Šæ”¾é”
18: } finally {
19: lock.unlock();
20: }
21: // å·²å®Œæˆï¼Œè°ƒç”¨å›è°ƒ
22: if (isdone) {
23: invokeCallback(callback);
24: }
25: }
26: }
```

- ç¬¬ 3 è‡³ 5 è¡Œï¼šè‹¥**å·²å®Œæˆ**ï¼Œè°ƒç”¨

/#invokeCallback(callback)
æ–¹æ³•ï¼Œæ‰§è¡Œå›è°ƒæ–¹æ³•ã€‚

- ç¬¬ 9 è¡Œï¼šè·å¾—é”ã€‚
- ç¬¬ 12 è‡³ 13 è¡Œï¼šè‹¥**æœªå®Œæˆ**ï¼Œè®¾ç½®å›è°ƒ

callback
å±æ€§ï¼Œç­‰åœ¨

/#doReceived(response)
æ–¹æ³•ä¸­**å†å›è°ƒ**ã€‚

- ç¬¬ 14 è‡³ 16 è¡Œï¼šæ ‡è®°å·²å®Œæˆã€‚åœ¨ã€ç¬¬ 22 è‡³ 24 è¡Œã€‘ï¼Œè°ƒç”¨

/#invokeCallback(callback)
æ–¹æ³•ï¼Œæ‰§è¡Œå›è°ƒæ–¹æ³•ã€‚

- ç¬¬ 18 è‡³ 20 è¡Œï¼šé‡Šæ”¾é”ã€‚

**è°ƒç”¨å›è°ƒ**

```
1: private void invokeCallback(ResponseCallback c){
2: ResponseCallback callbackCopy = c;
3: if (callbackCopy == null) {
4: throw new NullPointerException("callback cannot be null.");
5: }
6: Response res = response;
7: if (res == null) {
8: throw new IllegalStateException("response cannot be null. url:" + channel.getUrl());
9: }
10:
11: // æ­£å¸¸ï¼Œå¤„ç†ç»“æœ
12: if (res.getStatus() == Response.OK) {
13: try {
14: callbackCopy.done(res.getResult());
15: } catch (Exception e) {
16: logger.error("callback invoke error .reasult:" + res.getResult() + ",url:" + channel.getUrl(), e);
17: }
18: // è¶…æ—¶ï¼Œå¤„ç† TimeoutException å¼‚å¸¸
19: } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
20: try {
21: TimeoutException te = new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());
22: callbackCopy.caught(te);
23: } catch (Exception e) {
24: logger.error("callback invoke error ,url:" + channel.getUrl(), e);
25: }
26: // å…¶ä»–ï¼Œå¤„ç† RemotingException å¼‚å¸¸
27: } else {
28: try {
29: RuntimeException re = new RuntimeException(res.getErrorMessage());
30: callbackCopy.caught(re);
31: } catch (Exception e) {
32: logger.error("callback invoke error ,url:" + channel.getUrl(), e);
33: }
34: }
35: }
```

- å’Œ

/#returnFromResponse()
æ–¹æ³•ï¼Œæƒ…å†µä¸€è‡´ã€‚

- ç¬¬ 11 è‡³ 17 è¡Œï¼šæ­£å¸¸è¿”å›ï¼Œè°ƒç”¨

ResponseCallback/#done(result)
æ–¹æ³•ï¼Œå¤„ç†ç»“æœã€‚

- ç¬¬ 18 è‡³ 25 è¡Œï¼šè¶…æ—¶å¼‚å¸¸ï¼Œè°ƒç”¨

ResponseCallback/#caught(e)
æ–¹æ³•ï¼Œå¤„ç† TimeoutException å¼‚å¸¸ã€‚

- ç¬¬ 26 è‡³ 34 è¡Œï¼šå…¶ä»–å¼‚å¸¸ï¼Œè°ƒç”¨ ResponseCallback/#caught(e)` æ–¹æ³•ï¼Œå¤„ç† RuntimeException å¼‚å¸¸ã€‚

**åå°æ‰«æè°ƒç”¨è¶…æ—¶ä»»åŠ¡**

```
static {
Thread th = new Thread(new RemotingInvocationTimeoutScan(), "DubboResponseTimeoutScanTimer");
th.setDaemon(true);
th.start();
}
private static class RemotingInvocationTimeoutScan implements Runnable{
public void run(){
while (true) {
try {
for (DefaultFuture future : FUTURES.values()) {
// å·²å®Œæˆï¼Œè·³è¿‡
if (future == null || future.isDone()) {
continue;
}
// è¶…æ—¶
if (System.currentTimeMillis() - future.getStartTimestamp() > future.getTimeout()) {
// åˆ›å»ºè¶…æ—¶ Response
// create exception response.
Response timeoutResponse = new Response(future.getId());
// set timeout status.
timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);
timeoutResponse.setErrorMessage(future.getTimeoutMessage(true));
// å“åº”ç»“æœ
// handle response.
DefaultFuture.received(future.getChannel(), timeoutResponse);
}
}
// 30 ms
Thread.sleep(30);
} catch (Throwable e) {
logger.error("Exception when scan the timeout invocation of remoting.", e);
}
}
}
}
```

- ğŸ™‚ ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±çœ‹ä¸‹ä»£ç å’Œæ³¨é‡Šå˜¿ã€‚

ä»£ç ç•¥å¤šï¼Œèƒ–å‹è‡ªå·±åœ¨æ¢³ç†æ¢³ç†ï¼Œä¹Ÿå¯ä»¥å¤šå¤šè°ƒè¯•ã€‚

### 5.3.3 SimpleFuture

[
com.alibaba.dubbo.remoting.exchange.support.SimpleFuture
](https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/SimpleFuture.java) ï¼Œå®ç° ResponseFuture æ¥å£ï¼Œç®€å•çš„ Future å®ç°ã€‚

ç›®å‰æš‚æœªä½¿ç”¨ã€‚

## 5.4 MultiMessage

com.alibaba.dubbo.remoting.exchange.support.MultiMessage
ï¼Œå®ç° Iterable æ¥å£ï¼Œå¤šæ¶ˆæ¯çš„å°è£…ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public final class MultiMessage implements Iterable{
private final List messages = new ArrayList();
// ... çœç•¥æ–¹æ³•
}
```

# 6. Handler

åœ¨æ–‡åˆçš„ï¼Œæˆ‘ä»¬åœ¨ç±»å›¾å¯ä»¥çœ‹åˆ°ï¼Œæœ‰å¤šç§å¤„ç†å™¨ï¼Œç»Ÿä¸€åœ¨æœ¬å°èŠ‚åˆ†äº«ã€‚

## 6.1 HeartbeatHandler

[
com.alibaba.dubbo.remoting.exchange.support.header.HeartbeatHandler
](https://github.com/YunaiV/dubbo/blob/619cbe46350c8d0b97b84631c6518e4603a89aee/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeartbeatHandler.java) ï¼Œå®ç° AbstractChannelHandlerDelegate æŠ½è±¡ç±»ï¼Œ**å¿ƒè·³å¤„ç†å™¨**ï¼Œå¤„ç†å¿ƒè·³äº‹ä»¶ã€‚
æ—ç™½å›ï¼Œæ³¨æ„ï¼Œå®ƒæ˜¯ä¸€ä¸ª AbstractChannelHandlerDelegate ï¼ï¼ï¼

ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±æŸ¥çœ‹ã€‚

### 6.1.1 HeartBeatTask

com.alibaba.dubbo.remoting.exchange.support.header.HeartBeatTask
ï¼Œå®ç° Runnable æ¥å£ï¼Œå¿ƒè·³ä»»åŠ¡ã€‚

**æ„é€ æ–¹æ³•**

```
private ChannelProvider channelProvider;
//*/*
/* å¿ƒè·³é—´éš”ï¼Œå•ä½ï¼šæ¯«ç§’
/*/
private int heartbeat;
//*/*
/* å¿ƒè·³è¶…æ—¶æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’
/*/
private int heartbeatTimeout;
```

- channelProvider
  å±æ€§ï¼Œç”¨äºæŸ¥è¯¢è·å¾—éœ€è¦å¿ƒè·³çš„é€šé“æ•°ç»„ã€‚ChannelProvider æ¥å£ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
interface ChannelProvider{
Collection<Channel> getChannels();
}
```

**æ‰§è¡Œä»»åŠ¡**

```
1: @Override
2: public void run(){
3: try {
4: long now = System.currentTimeMillis();
5: for (Channel channel : channelProvider.getChannels()) {
6: if (channel.isClosed()) {
7: continue;
8: }
9: try {
10: Long lastRead = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_READ_TIMESTAMP);
11: Long lastWrite = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);
12: // æœ€åè¯»å†™çš„æ—¶é—´ï¼Œä»»ä¸€è¶…è¿‡å¿ƒè·³é—´éš”ï¼Œå‘é€å¿ƒè·³
13: if ((lastRead != null && now - lastRead > heartbeat)
14: || (lastWrite != null && now - lastWrite > heartbeat)) {
15: Request req = new Request();
16: req.setVersion("2.0.0");
17: req.setTwoWay(true); // éœ€è¦å“åº”
18: req.setEvent(Request.HEARTBEAT_EVENT);
19: channel.send(req);
20: if (logger.isDebugEnabled()) {
21: logger.debug("Send heartbeat to remote channel " + channel.getRemoteAddress()
22: + ", cause: The channel has no data-transmission exceeds a heartbeat period: " + heartbeat + "ms");
23: }
24: }
25: // æœ€åè¯»çš„æ—¶é—´ï¼Œè¶…è¿‡å¿ƒè·³è¶…æ—¶æ—¶é—´
26: if (lastRead != null && now - lastRead > heartbeatTimeout) {
27: logger.warn("Close channel " + channel
28: + ", because heartbeat read idle time out: " + heartbeatTimeout + "ms");
29: // å®¢æˆ·ç«¯ä¾§ï¼Œé‡æ–°è¿æ¥æœåŠ¡ç«¯
30: if (channel instanceof Client) {
31: try {
32: ((Client) channel).reconnect();
33: } catch (Exception e) {
34: //do nothing
35: }
36: // æœåŠ¡ç«¯ä¾§ï¼Œå…³é—­å®¢æˆ·ç«¯è¿æ¥
37: } else {
38: channel.close();
39: }
40: }
41: } catch (Throwable t) {
42: logger.warn("Exception when heartbeat to remote channel " + channel.getRemoteAddress(), t);
43: }
44: }
45: } catch (Throwable t) {
46: logger.warn("Unhandled exception when heartbeat, cause: " + t.getMessage(), t);
47: }
48: }
```

- ã€ä»»åŠ¡ä¸€ã€‘ç¬¬ 13 è‡³ 24 è¡Œï¼šæœ€åè¯»æˆ–å†™çš„æ—¶é—´ï¼Œ**ä»»ä¸€**è¶…è¿‡å¿ƒè·³é—´éš”

heartbeat
ï¼Œ**å‘é€å¿ƒè·³**ã€‚

- ã€ä»»åŠ¡äºŒã€‘ç¬¬ 25 è‡³ 40 è¡Œï¼šæœ€åè¯»çš„æ—¶é—´ï¼Œè¶…è¿‡å¿ƒè·³è¶…æ—¶æ—¶é—´

heartbeatTimeout
ï¼Œåˆ†æˆä¸¤ç§æƒ…å†µï¼š

- ç¬¬ 29 è‡³ 35 è¡Œï¼š**å®¢æˆ·ç«¯ä¾§**ï¼Œé‡è¿è¿æ¥æœåŠ¡ç«¯ã€‚
- ç¬¬ 36 è‡³ 39 è¡Œï¼š**æœåŠ¡ç«¯ä¾§**ï¼Œå…³é—­å®¢æˆ·ç«¯è¿æ¥ã€‚

## 6.2 HeaderExchangeHandler

[
com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler
](https://github.com/YunaiV/dubbo/blob/e24730a1dcfe8d5f1329377e80b1577724a85aac/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java)ï¼Œå®ç° ChannelHandlerDelegate æ¥å£ï¼Œ**åŸºäºæ¶ˆæ¯å¤´éƒ¨( Header )**çš„ä¿¡æ¯äº¤æ¢å¤„ç†å™¨å®ç°ç±»ã€‚
æ—ç™½å›ï¼Œæ³¨æ„ï¼Œå®ƒæ˜¯ä¸€ä¸ª ChannelHandlerDelegate ï¼ï¼ï¼

ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±æŸ¥çœ‹ï¼Œæˆ‘ä»¬æŒ‘å‡ ä¸ªæ¯”è¾ƒé‡è¦çš„æ¥è®²è®²ã€‚

**æ¥æ”¶æ¶ˆæ¯**

```
1: @Override
2: public void received(Channel channel, Object message) throws RemotingException{
3: // è®¾ç½®æœ€åçš„è¯»æ—¶é—´
4: channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
5: // åˆ›å»º ExchangeChannel å¯¹è±¡
6: ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
7: try {
8: // å¤„ç†è¯·æ±‚( Request )
9: if (message instanceof Request) {
10: // handle request.
11: Request request = (Request) message;
12: // å¤„ç†äº‹ä»¶è¯·æ±‚
13: if (request.isEvent()) {
14: handlerEvent(channel, request);
15: } else {
16: // å¤„ç†æ™®é€šè¯·æ±‚
17: if (request.isTwoWay()) {
18: Response response = handleRequest(exchangeChannel, request);
19: channel.send(response);
20: // æäº¤ç»™è£…é¥°çš„ `handler`ï¼Œç»§ç»­å¤„ç†
21: } else {
22: handler.received(exchangeChannel, request.getData());
23: }
24: }
25: // å¤„ç†å“åº”( Response )
26: } else if (message instanceof Response) {
27: handleResponse(channel, (Response) message);
28: // å¤„ç† String
29: } else if (message instanceof String) {
30: // å®¢æˆ·ç«¯ä¾§ï¼Œä¸æ”¯æŒ String
31: if (isClientSide(channel)) {
32: Exception e = new Exception("Dubbo client can not supported string message: " + message + " in channel: " + channel + ", url: " + channel.getUrl());
33: logger.error(e.getMessage(), e);
34: // æœåŠ¡ç«¯ä¾§ï¼Œç›®å‰æ˜¯ telnet å‘½ä»¤
35: } else {
36: String echo = handler.telnet(channel, (String) message);
37: if (echo != null && echo.length() > 0) {
38: channel.send(echo);
39: }
40: }
41: // æäº¤ç»™è£…é¥°çš„ `handler`ï¼Œç»§ç»­å¤„ç†
42: } else {
43: handler.received(exchangeChannel, message);
44: }
45: } finally {
46: // ç§»é™¤ ExchangeChannel å¯¹è±¡ï¼Œè‹¥å·²æ–­å¼€
47: HeaderExchangeChannel.removeChannelIfDisconnected(channel);
48: }
49: }
```

- ç¬¬ 4 è¡Œï¼šè®¾ç½®æœ€åçš„**è¯»æ—¶é—´**ã€‚
- ç¬¬ 6 è¡Œï¼šåˆ›å»º ExchangeChannel å¯¹è±¡ã€‚
- ç¬¬ 8 è‡³ 24 è¡Œï¼šå¤„ç†è¯·æ±‚( Request)

- ç¬¬ 13 è‡³ 14 è¡Œï¼šè°ƒç”¨

/#handlerEvent(channel, request)
æ–¹æ³•ï¼Œå¤„ç†äº‹ä»¶è¯·æ±‚ã€‚

- ç¬¬ 17 è‡³ 19 è¡Œï¼šè°ƒç”¨

/#handleRequest(channel, request)
æ–¹æ³•ï¼Œå¤„ç†æ™®é€šè¯·æ±‚ï¼ˆéœ€è¦å“åº”ï¼‰ï¼Œå¹¶å°†å“åº”å†™å›è¯·æ±‚æ–¹ã€‚

- ç¬¬ 21 è‡³ 23 è¡Œï¼šè°ƒç”¨

ChannelHandler/#received(channel, message)
æ–¹æ³•ï¼Œå¤„ç†æ™®é€šè¯·æ±‚ï¼ˆæ— éœ€å“åº”ï¼‰ã€‚

- ç¬¬ 25 è‡³ 27 è¡Œï¼šè°ƒç”¨

/#handleResponse(channel, message)
æ–¹æ³•ï¼Œå¤„ç†å“åº”ã€‚

- ç¬¬ 29 è‡³ 41 è¡Œï¼šå¤„ç† String çš„æƒ…å†µ

- ç¬¬ 30 è‡³ 33 è¡Œï¼šå®¢æˆ·ç«¯ä¾§ï¼Œä¸æ”¯æŒ String çš„æƒ…å†µã€‚
- ç¬¬ 34 è‡³ 40 è¡Œï¼šæœåŠ¡ç«¯ä¾§ï¼Œç›®å‰ä»…æœ‰ telnet å‘½ä»¤çš„æƒ…å†µï¼Œè°ƒç”¨

TelnetHandler/#telnet(channel, message)
æ–¹æ³•ï¼Œè·å¾— telnet å‘½ä»¤çš„ç»“æœï¼Œå¹¶å“åº”ç»™ telnet å®¢æˆ·ç«¯ã€‚åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ï¼ˆä¸‰ï¼‰ä¹‹ Telnet å±‚ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-telnet/?self) æœ‰è¯¦ç»†åˆ†äº«ã€‚

- ç¬¬ 42 è‡³ 44 è¡Œï¼šå‰©ä½™çš„æƒ…å†µï¼Œè°ƒç”¨

ChannelHandler/#received(channel, message)
æ–¹æ³•ï¼Œå¤„ç†ã€‚

- ç¬¬ 45 è‡³ 48 è¡Œï¼šç§»é™¤ ExchangeChannel å¯¹è±¡ï¼Œè‹¥å·²æ–­å¼€ã€‚
- /#handlerEvent(channel, request)
  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
void handlerEvent(Channel channel, Request req){
if (req.getData() != null && req.getData().equals(Request.READONLY_EVENT)) {
channel.setAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY, Boolean.TRUE);
}
}
```

- å®¢æˆ·ç«¯æ¥æ”¶åˆ° READONLY_EVENT äº‹ä»¶è¯·æ±‚ï¼Œè¿›è¡Œè®°å½•åˆ°é€šé“ã€‚åç»­ï¼Œä¸å†å‘è¯¥æœåŠ¡å™¨ï¼Œ**å‘é€æ–°çš„è¯·æ±‚**ã€‚
- /#handleRequest(channel, request)
  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
1: Response handleRequest(ExchangeChannel channel, Request req){
2: Response res = new Response(req.getId(), req.getVersion());
3: // è¯·æ±‚æ— æ³•è§£æï¼Œè¿”å› BAD_REQUEST å“åº”
4: if (req.isBroken()) {
5: Object data = req.getData();
6: String msg; // è¯·æ±‚æ•°æ®ï¼Œè½¬æˆ msg
7: if (data == null) {
8: msg = null;
9: } else if (data instanceof Throwable) {
10: msg = StringUtils.toString((Throwable) data);
11: } else {
12: msg = data.toString();
13: }
14: res.setErrorMessage("Fail to decode request due to: " + msg);
15: res.setStatus(Response.BAD_REQUEST);
16: return res;
17: }
18: // ä½¿ç”¨ ExchangeHandler å¤„ç†ï¼Œå¹¶è¿”å›å“åº”
19: // find handler by message class.
20: Object msg = req.getData();
21: try {
22: // handle data.
23: Object result = handler.reply(channel, msg);
24: res.setStatus(Response.OK);
25: res.setResult(result);
26: } catch (Throwable e) {
27: res.setStatus(Response.SERVICE_ERROR);
28: res.setErrorMessage(StringUtils.toString(e));
29: }
30: return res;
31: }
```

- ç¬¬ 3 è‡³ 17 è¡Œï¼šè¯·æ±‚**æ— æ³•è§£æ**ï¼Œè¿”å› BAD_REQUEST å“åº”ã€‚ä¸‹é¢ ExchangeCodec ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å…·ä½“å‘ç”Ÿçš„ä»£ç ã€‚
- ç¬¬ 18 è‡³ 30 è¡Œï¼šè°ƒç”¨

ExchangeHandler/#reply(channel, message)
æ–¹æ³•ï¼Œè¿”å›ç»“æœï¼Œå¹¶è®¾ç½®åˆ°å“åº”( Response) æœ€ç»ˆè¿”å›ã€‚

- /#handleResponse(channel, response)
  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
static void handleResponse(Channel channel, Response response){
if (response != null && !response.isHeartbeat()) {
DefaultFuture.received(channel, response);
}
}
```

- éå¿ƒè·³äº‹ä»¶å“åº”ï¼Œè°ƒç”¨

DefaultFuture/#received(channel, response)
æ–¹æ³•ï¼Œå”¤é†’ç­‰å¾…è¯·æ±‚ç»“æœçš„çº¿ç¨‹ã€‚

ğŸ™‚ æ¯”è¾ƒç¹æ‚ï¼Œèƒ–å‹è€å¿ƒçš„çœ‹ä¸€çœ‹å“Ÿã€‚

**å‘ç”Ÿå¼‚å¸¸**

```
1: @Override
2: public void caught(Channel channel, Throwable exception) throws RemotingException{
3: // å½“å‘ç”Ÿ ExecutionException å¼‚å¸¸ï¼Œè¿”å›å¼‚å¸¸å“åº”( Response )
4: if (exception instanceof ExecutionException) {
5: ExecutionException e = (ExecutionException) exception;
6: Object msg = e.getRequest();
7: if (msg instanceof Request) {
8: Request req = (Request) msg;
9: if (req.isTwoWay() && !req.isHeartbeat()) { // éœ€è¦å“åº”ï¼Œå¹¶ä¸”éå¿ƒè·³æ—¶é—´
10: Response res = new Response(req.getId(), req.getVersion());
11: res.setStatus(Response.SERVER_ERROR);
12: res.setErrorMessage(StringUtils.toString(e));
13: channel.send(res);
14: return;
15: }
16: }
17: }
18: // åˆ›å»º ExchangeChannel å¯¹è±¡
19: ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
20: try {
21: // æäº¤ç»™è£…é¥°çš„ `handler`ï¼Œç»§ç»­å¤„ç†
22: handler.caught(exchangeChannel, exception);
23: } finally {
24: // ç§»é™¤ ExchangeChannel å¯¹è±¡ï¼Œè‹¥å·²æ–­å¼€
25: HeaderExchangeChannel.removeChannelIfDisconnected(channel);
26: }
27: }
```

- ç¬¬ 3 è‡³ 17 è¡Œï¼šå½“å‘ç”Ÿ ExecutionException å¼‚å¸¸ï¼Œè¿”å›å¼‚å¸¸å“åº”( Response )ã€‚ç›®å‰ä¼šå‘ç”Ÿ ExecutionException çš„æƒ…å†µï¼Œå¹¶ä¸”ç¬¦åˆæäº¤ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![ExecutionException](http://static2.iocoder.cn/images/Dubbo/2018_12_10/06.png)
- ç¬¬ 18 è‡³ 26 è¡Œï¼šè§æ³¨é‡Šã€‚

## 6.3 ExchangeHandler

com.alibaba.dubbo.remoting.exchange.ExchangeHandler
ï¼Œç»§æ‰¿ ChannelHandler å’Œ TelnetHandler æ¥å£ï¼Œä¿¡æ¯äº¤æ¢å¤„ç†å™¨**æ¥å£**ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š

```
// å›å¤è¯·æ±‚ç»“æœ
Object reply(ExchangeChannel channel, Object request) throws RemotingException;
```

- **æ³¨æ„**ï¼Œè¿”å›çš„æ˜¯**è¯·æ±‚ç»“æœ**ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨ä¸Šæ–‡çœ‹åˆ°çš„ï¼Œå°†è¯·æ±‚ç»“æœï¼Œè®¾ç½®åˆ°

Response.mResult
å±æ€§ä¸­ã€‚

ExchangeHandler æ˜¯ä¸€ä¸ªéå¸¸å…³é”®çš„æ¥å£ã€‚ä¸ºä»€ä¹ˆè¿™ä¹ˆè¯´å‘¢ï¼Œç‚¹å‡» [
DubboProtocol. requestHandler
](https://github.com/YunaiV/dubbo/blob/619cbe46350c8d0b97b84631c6518e4603a89aee/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java#L82-L112) ï¼èƒ–å‹ï¼Œé¢†æ‚Ÿåˆ°äº†ä¹ˆï¼Ÿå¦‚æœæ²¡æœ‰ï¼Œæ·¡å®šï¼Œåé¢æˆ‘ä»¬ä¼šæœ‰æ–‡ç« åˆ†äº«ã€‚

### 6.3.1 ExchangeHandlerAdapter

com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerAdapter
ï¼Œå®ç° ExchangeHandler æ¥å£ï¼Œç»§æ‰¿ TelnetHandlerAdapter æŠ½è±¡ç±»ï¼Œä¿¡æ¯äº¤æ¢å¤„ç†å™¨é€‚é…å™¨**æŠ½è±¡ç±»**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
@Override
public Object reply(ExchangeChannel channel, Object msg) throws RemotingException{
return null;
}
```

åœ¨ DubboProtocol ã€ThirftProtocol ä¸­ï¼Œéƒ½ä¼šåŸºäº ExchangeHandlerAdapter **å®ç°è‡ªå·±çš„å¤„ç†å™¨**ï¼Œå¤„ç†è¯·æ±‚ï¼Œè¿”å›ç»“æœã€‚

## 6.4 Replier

å‹æƒ…æç¤ºï¼šè¿™ä¸ªå°èŠ‚ï¼Œèƒ–å‹å¯ä»¥é€‰æ‹©æ€§æ¥çœ‹ï¼Œç›®å‰ä»…ç”¨äº

dubbo-remoting-p2p
æ¨¡å—ä¸­ã€‚

åœ¨ ExchangeHandler ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„æ˜¯ï¼ŒRequest å¯¹åº”ç»Ÿä¸€çš„ ExchangeHandler å®ç°çš„å¯¹è±¡ã€‚ä½†æ˜¯åœ¨ä¸€äº›åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›å®ç°ï¼Œä¸åŒçš„æ•°æ®ç±»å‹ï¼Œå¯¹åº”ä¸åŒçš„å¤„ç†å™¨ã€‚Replier å°±æ˜¯æ¥å¤„ç†è¿™ç§æƒ…å†µçš„ã€‚ä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œå¯¹åº”ä¸€ä¸ª Replier å¯¹è±¡ã€‚

com.alibaba.dubbo.remoting.exchange.support.Replier
ï¼Œå›å¤è€…æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public interface Replier<T>{
// å›å¤è¯·æ±‚ç»“æœ
Object reply(ExchangeChannel channel, T request) throws RemotingException;
}
```

- å’Œ ExchangeHandler æœ€å¤§çš„ä¸åŒæ˜¯ï¼Œä½¿ç”¨çš„æ˜¯**æ³›å‹ T**ï¼Œè€Œä¸æ˜¯å›ºå®šçš„ Request ã€‚

### 6.4.1 ReplierDispatcher

com.alibaba.dubbo.remoting.exchange.support.ReplierDispatcher
ï¼Œå®ç° Replier æ¥å£ï¼Œå›å¤è€…**è°ƒåº¦å™¨**å®ç°ç±»ã€‚

**æ„é€ æ–¹æ³•**

```
//*/*
/* é»˜è®¤å›å¤è€…
/*/
private final Replier<?> defaultReplier;
//*/*
/* å›å¤è€…é›†åˆ
/*
/* keyï¼šç±»
/*/
private final Map<Class<?>, Replier<?>> repliers = new ConcurrentHashMap<Class<?>, Replier<?>>();
public ReplierDispatcher(){
this(null, null);
}
public ReplierDispatcher(Replier<?> defaultReplier){
this(defaultReplier, null);
}
public ReplierDispatcher(Replier<?> defaultReplier, Map<Class<?>, Replier<?>> repliers){
// ... çœç•¥
}
```

- repliers
  å±æ€§ï¼Œå›å¤è€…é›†åˆã€‚å¯é€šè¿‡ [
  /#addReplier(Class<T> type, Replier<T> replier)
  ](https://github.com/YunaiV/dubbo/blob/c63ec335b776a386a215fa3662b575ece7d32c5e/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ReplierDispatcher.java#L49-L52) æˆ– [
  /#removeReplier(Class<T> type)
  ](https://github.com/YunaiV/dubbo/blob/c63ec335b776a386a215fa3662b575ece7d32c5e/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ReplierDispatcher.java#L54-L57) æ–¹æ³•ï¼Œæ·»åŠ æˆ–ç§»é™¤å›å¤è€…ã€‚

**å›å¤è¯·æ±‚ç»“æœ**

```
@Override
@SuppressWarnings({"unchecked", "rawtypes"})
public Object reply(ExchangeChannel channel, Object request) throws RemotingException{
return ((Replier) getReplier(request.getClass())).reply(channel, request);
}
```

- è°ƒç”¨ [
  /#getReplier(Class<?> type)
  ](https://github.com/YunaiV/dubbo/blob/c63ec335b776a386a215fa3662b575ece7d32c5e/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ReplierDispatcher.java#L59-L69) æ–¹æ³•ï¼Œè·å¾—å›å¤è€…å¯¹è±¡ã€‚
- è°ƒç”¨

Repiler/#reply(channel, request)
æ–¹æ³•ï¼Œå›å¤è¯·æ±‚ç»“æœã€‚

### 6.4.2 ExchangeHandlerDispatcher

com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerDispatcher
ï¼Œå®ç° ExchangeHandler æ¥å£ï¼Œä¿¡æ¯äº¤æ¢å¤„ç†å™¨**è°ƒåº¦å™¨**å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
//*/*
/* å›å¤è€…è°ƒåº¦å™¨
/*/
private final ReplierDispatcher replierDispatcher;
//*/*
/* é€šé“å¤„ç†å™¨é›†åˆ
/*/
private final ChannelHandlerDispatcher handlerDispatcher;
//*/*
/* Telnet å‘½ä»¤å¤„ç†å™¨
/*/
private final TelnetHandler telnetHandler;
// ... çœç•¥æ–¹æ³•
```

- é€šè¿‡ ExchangeHandlerDispatcher ï¼Œå°† ReplierDispatcher + ChannelHandlerDispatcher + TelnetHandler ä¸‰è€…ç»“åˆåœ¨ä¸€èµ·ï¼Œå°†å¯¹åº”çš„äº‹ä»¶ï¼Œè°ƒåº¦åˆ°**åˆé€‚çš„**å¤„ç†å™¨ã€‚ä»¥

/#reply(...)

/#received(...)

/#telnet(...)
æ–¹æ³•ï¼Œä¸¾ä¾‹å­ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
@Override
@SuppressWarnings({"unchecked", "rawtypes"})
public Object reply(ExchangeChannel channel, Object request) throws RemotingException{
return replierDispatcher.reply(channel, request);
}
@Override
public void received(Channel channel, Object message){
handlerDispatcher.received(channel, message);
}
@Override
public String telnet(Channel channel, String message) throws RemotingException{
return telnetHandler.telnet(channel, message);
}
```

# 7. Exchanger

com.alibaba.dubbo.remoting.exchange.Exchanger
ï¼Œ**æ•°æ®äº¤æ¢è€…**æ¥å£ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š
Exchanger å’Œ Transporter ç±»ä¼¼ã€‚

```
@SPI(HeaderExchanger.NAME)
public interface Exchanger{
//*/*
/* bind.
/*
/* ç»‘å®šä¸€ä¸ªæœåŠ¡å™¨
/*
/* @param url server url
/* @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨
/* @return message server æœåŠ¡å™¨
/*/
@Adaptive({Constants.EXCHANGER_KEY})
ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException;
//*/*
/* connect.
/*
/* è¿æ¥ä¸€ä¸ªæœåŠ¡å™¨ï¼Œå³åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯
/*
/* @param url server url æœåŠ¡å™¨åœ°å€
/* @param handler æ•°æ®äº¤æ¢å¤„ç†å™¨
/* @return message channel å®¢æˆ·ç«¯
/*/
@Adaptive({Constants.EXCHANGER_KEY})
ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;
}
```

- @SPI(HeaderExchanger.NAME)
  æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œé»˜è®¤ä¸º

"header"
ï¼Œå³ HeaderExchanger ã€‚

- @Adaptive({Constants.EXCHANGER_KEY})
  æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Server å®ç°ï¼Œä½¿ç”¨

URL.exchanger
å±æ€§ã€‚

- @Adaptive({Constants.EXCHANGER_KEY})
  æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Client å®ç°ï¼Œä½¿ç”¨

URL.exchanger
å±æ€§ã€‚

## 7.1 HeaderExchanger

com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger
ï¼Œå®ç° Exchanger æ¥å£ï¼ŒåŸºäºæ¶ˆæ¯å¤´éƒ¨( Header )çš„**ä¿¡æ¯äº¤æ¢è€…**å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class HeaderExchanger implements Exchanger{
public static final String NAME = "header";
@Override
public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException{
return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);
}
@Override
public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException{
return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
}
}
```

- ä»¥

/#connect(...)
æ–¹æ³•ä¸¾ä¾‹å­ã€‚

- é€šè¿‡

Transporters/#connect(url, handler)
æ–¹æ³•ï¼Œåˆ›å»ºé€šä¿¡ Client ï¼Œå†…åµŒåˆ° HeaderExchangeClient ä¸­ã€‚

- ä¼ å…¥çš„

handler
å¤„ç†å™¨ï¼Œå†…åµŒåˆ° HeaderExchangeHandler ï¼Œå†è¿›ä¸€æ­¥å†…åµŒåˆ° DecodeHandler ä¸­ã€‚æ‰€ä»¥ï¼Œå¤„ç†å™¨çš„é¡ºåºæ˜¯ï¼šDecodeHandler => HeaderExchangeHandler => ExchangeHandler(

handler
) ã€‚

## 7.2 Exchangers

Exchangers å’Œ Transporters ç±»ä¼¼ã€‚

[
com.alibaba.dubbo.remoting.Transporters
](https://github.com/YunaiV/dubbo/blob/e24730a1dcfe8d5f1329377e80b1577724a85aac/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Exchangers.java) ï¼Œæ•°æ®äº¤æ¢è€…é—¨é¢ç±»ï¼Œå‚è§ Facade è®¾è®¡æ¨¡å¼ã€‚

ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±æŸ¥çœ‹åˆ—ã€‚

# 8. ExchangeCodec

èƒ–å‹ï¼Œæ‰“èµ·ç²¾ç¥ï¼ŒExchangeCodec éå¸¸é‡è¦ã€‚

com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec
ï¼Œç»§æ‰¿ TelnetCodec ç±»ï¼Œä¿¡æ¯äº¤æ¢ç¼–è§£ç å™¨ã€‚

åœ¨çœ‹å…·ä½“çš„ç¼–è§£ç æ–¹æ³•çš„ä»£ç æ—¶ï¼Œæˆ‘ä»¬æ¥å…ˆçœ‹ä¸€å¹…å›¾ï¼š![åè®®](http://static2.iocoder.cn/images/Dubbo/2018_12_10/07.png)

- åŸºäº**æ¶ˆæ¯é•¿åº¦**çš„æ–¹å¼ï¼Œåšæ¯æ¡æ¶ˆæ¯çš„**ç²˜åŒ…æ‹†åŒ…**å¤„ç†ã€‚å’Œæˆ‘ä»¬åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ï¼ˆäºŒï¼‰ä¹‹ Transport å±‚ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-transport/?self) ä¸­ï¼Œçœ‹åˆ° Telnet åè®®ï¼ŒåŸºäº**ç‰¹å®šå­—ç¬¦**çš„æ–¹å¼ï¼Œåšæ¯æ¡å‘½ä»¤çš„**ç²˜åŒ…æ‹†åŒ…**å¤„ç†**ä¸åŒ**ã€‚
- Header éƒ¨åˆ†ï¼Œåè®®å¤´ï¼Œé€šè¿‡ Codec ç¼–è§£ç ã€‚Bits ä½å¦‚ä¸‹ï¼š

- [0, 15]
  ï¼šMagic Number
- [16, 20]
  ï¼šSerialization ç¼–å·ã€‚
- [21]
  ï¼š

event
æ˜¯å¦ä¸ºäº‹ä»¶ã€‚

- [22]
  ï¼š

twoWay
æ˜¯å¦éœ€è¦å“åº”ã€‚

- [23]
  ï¼šæ˜¯è¯·æ±‚è¿˜æ˜¯å“åº”ã€‚
- [24 - 31]
  ï¼š

status
çŠ¶æ€ã€‚

- [32 - 95]
  ï¼š

id
ç¼–å·ï¼ŒLong å‹ã€‚

- [96 - 127]
  ï¼šBody çš„**é•¿åº¦**ã€‚é€šè¿‡è¯¥é•¿åº¦ï¼Œè¯»å– Body ã€‚
- Body éƒ¨åˆ†ï¼Œåè®®ä½“ï¼Œé€šè¿‡ Serialization åºåˆ—åŒ–/ååºåˆ—åŒ–ã€‚

**å±æ€§**

```
// header length.
protected static final int HEADER_LENGTH = 16;
// magic header.
protected static final short MAGIC = (short) 0xdabb;
protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0];
protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1];
// message flag.
protected static final byte FLAG_REQUEST = (byte) 0x80; // 128
protected static final byte FLAG_TWOWAY = (byte) 0x40; // 64
protected static final byte FLAG_EVENT = (byte) 0x20; // 32
protected static final int SERIALIZATION_MASK = 0x1f; // 31
```

- HEADER_LENGTH
  **é™æ€**å±æ€§ï¼ŒHeader æ€»é•¿åº¦ï¼Œ16 Bytes = 128 Bits ã€‚
- å…¶å®ƒ**é™æ€**å±æ€§ï¼Œèƒ–å‹å¯¹ç…§ä¸Šé¢çš„ Bits ä½ã€‚

**ç¼–ç **

```
1: @Override
2: public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException{
3: if (msg instanceof Request) { // è¯·æ±‚
4: encodeRequest(channel, buffer, (Request) msg);
5: } else if (msg instanceof Response) { // å“åº”
6: encodeResponse(channel, buffer, (Response) msg);
7: } else { // æäº¤ç»™çˆ¶ç±»( Telnet ) å¤„ç†ï¼Œç›®å‰æ˜¯ Telnet å‘½ä»¤çš„ç»“æœã€‚
8: super.encode(channel, buffer, msg);
9: }
10: }
```

- ç¬¬ 3 è‡³ 4 è¡Œï¼šè°ƒç”¨

/#encodeRequest(channel, buffer, request)
æ–¹æ³•ï¼Œç¼–ç è¯·æ±‚ã€‚

- ç¬¬ 5 è‡³ 6 è¡Œï¼šè°ƒç”¨

/#encodeResponse(channel, buffer, response)
æ–¹æ³•ï¼Œç¼–ç å“åº”ã€‚

- ç¬¬ 7 è‡³ 9 è¡Œï¼šè°ƒç”¨

TelnetCodec/#encode(channel, buffer, msg)
æ–¹æ³•ï¼Œç¼–ç  Telnet å‘½ä»¤çš„ç»“æœã€‚

- /#encodeRequest(channel, buffer, request)
  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
1: protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException{
2: Serialization serialization = getSerialization(channel);
3: // `[0, 15]`ï¼šMagic Number
4: // header.
5: byte[] header = new byte[HEADER_LENGTH];
6: // set magic number.
7: Bytes.short2bytes(MAGIC, header);
8:
9: // `[16, 20]`ï¼šSerialization ç¼–å· && `[23]`ï¼šè¯·æ±‚ã€‚
10: // set request and serialization flag.
11: header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());
12:
13: // `[21]`ï¼š`event` æ˜¯å¦ä¸ºäº‹ä»¶ã€‚
14: if (req.isTwoWay()) header[2] |= FLAG_TWOWAY;
15: // `[22]`ï¼š`twoWay` æ˜¯å¦éœ€è¦å“åº”ã€‚
16: if (req.isEvent()) header[2] |= FLAG_EVENT;
17:
18: // `[32 - 95]`ï¼š`id` ç¼–å·ï¼ŒLong å‹ã€‚
19: // set request id.
20: Bytes.long2bytes(req.getId(), header, 4);
21:
22: // ç¼–ç  `Request.data` åˆ° Body ï¼Œå¹¶å†™å…¥åˆ° Buffer
23: // encode request data.
24: int savedWriteIndex = buffer.writerIndex();
25: buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
26: ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);
27: ObjectOutput out = serialization.serialize(channel.getUrl(), bos); // åºåˆ—åŒ– Output
28: if (req.isEvent()) {
29: encodeEventData(channel, out, req.getData());
30: } else {
31: encodeRequestData(channel, out, req.getData());
32: }
33: // é‡Šæ”¾èµ„æº
34: out.flushBuffer();
35: if (out instanceof Cleanable) {
36: ((Cleanable) out).cleanup();
37: }
38: bos.flush();
39: bos.close();
40: // æ£€æŸ¥ Body é•¿åº¦ï¼Œæ˜¯å¦è¶…è¿‡æ¶ˆæ¯ä¸Šé™ã€‚
41: int len = bos.writtenBytes();
42: checkPayload(channel, len);
43: // `[96 - 127]`ï¼šBody çš„/*/*é•¿åº¦/*/*ã€‚
44: Bytes.int2bytes(len, header, 12);
45:
46: // å†™å…¥ Header åˆ° Buffer
47: // write
48: buffer.writerIndex(savedWriteIndex);
49: buffer.writeBytes(header); // write header.
50: buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
51: }
```

- Header éƒ¨åˆ†ï¼Œå…ˆå†™å…¥

header
æ•°ç»„ï¼Œå†å†™å…¥ Buffer ä¸­ã€‚

- Body éƒ¨åˆ†ï¼Œä½¿ç”¨ Serialization åºåˆ—åŒ–

Request.data
ï¼Œå†™å…¥åˆ° Buffer ä¸­ã€‚

- /#encodeEventData(Channel channel, ObjectOutput out, Object data)
  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
private void encodeEventData(Channel channel, ObjectOutput out, Object data) throws IOException{
encodeEventData(out, data);
}
private void encodeEventData(ObjectOutput out, Object data) throws IOException{
out.writeObject(data);
}
```

- x
- /#encodeRequestData(Channel channel, ObjectOutput out, Object data)
  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException{
encodeRequestData(out, data);
}
protected void encodeRequestData(ObjectOutput out, Object data) throws IOException{
out.writeObject(data);
}
```

- /#encodeEventData(...)
  å’Œ

/#encodeRequestData(...)
ä¸¤ä¸ªæ–¹æ³•æ˜¯ä¸€è‡´çš„ã€‚

- ç¬¬ 42 è¡Œï¼šä¼šè°ƒç”¨

/#checkPayload(channel, len)
æ–¹æ³•ï¼Œæ ¡éªŒ Body å†…å®¹çš„é•¿åº¦ã€‚ç¬”è€…åœ¨è¿™å—çº ç»“äº†å¾ˆä¹…ï¼Œå¦‚æœè¿‡é•¿è€ŒæŠ›å‡º ExceedPayloadLimitException å¼‚å¸¸ï¼Œé‚£ä¹ˆ ChannelBuffer æ˜¯å¦é‡ç½®ä¸‹å†™å…¥ä½ç½®ã€‚åæ¥å‘ç°è‡ªå·±ç…ç¬”äº†ï¼Œæ¯æ¬¡ ChannelBuffer éƒ½æ˜¯æ–°åˆ›å»ºçš„ï¼Œæ‰€ä»¥æ— éœ€é‡ç½®ã€‚

- ä¸ºä»€ä¹ˆ Buffer å…ˆå†™å…¥äº† Body ï¼Œå†å†™å…¥ Header å‘¢ï¼Ÿå› ä¸º Header ä¸­ï¼Œé‡Œé¢

[96 - 127]
çš„ Body é•¿åº¦ï¼Œéœ€è¦åºåˆ—åŒ–åæ‰å¾—åˆ°ã€‚

- [
  /#encodeResponse(channel, buffer, response)
  ](https://github.com/YunaiV/dubbo/blob/a89a569e608ee1282d1bce3fc2540860873629db/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java#L292-L404) æ–¹æ³•ï¼Œå’Œ

/#encodeRequest(chanel, buffer, request)
æ–¹æ³•ï¼ŒåŸºæœ¬ä¸€è‡´ï¼Œèƒ–å‹è‡ªå·±ç…ç…åˆ—ã€‚ä¸»è¦å·®å¼‚ç‚¹å¦‚ä¸‹ï¼š

- [24 - 31]
  ï¼š

status
çŠ¶æ€ã€‚è¿™æ˜¯ Request æ²¡æœ‰ï¼Œè€Œ Response æœ‰çš„éƒ¨åˆ†ã€‚

- å½“å“åº”çš„å†…å®¹è¿‡é•¿è€ŒæŠ›å‡º ExceedPayloadLimitException å¼‚å¸¸ï¼Œæ ¹æ®æ¡ä»¶ï¼Œå‘é€ä¸€æ¡ Response (

status = BAD_RESPONSE
) ç»™è¯·æ±‚æ–¹ã€‚

**è§£ç **

```
1: @Override
2: public Object decode(Channel channel, ChannelBuffer buffer) throws IOException{
3: // è¯»å– Header æ•°ç»„
4: int readable = buffer.readableBytes();
5: byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];
6: buffer.readBytes(header);
7: // è§£ç 
8: return decode(channel, buffer, readable, header);
9: }
10:
11: @Override
12: protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException{
13: // é Dubbo åè®®ï¼Œç›®å‰æ˜¯ Telnet å‘½ä»¤ã€‚
14: // check magic number.
15: if (readable > 0 && header[0] != MAGIC_HIGH || readable > 1 && header[1] != MAGIC_LOW) {
16: // å°† buffer å®Œå…¨å¤åˆ¶åˆ° `header` æ•°ç»„ä¸­ã€‚å› ä¸ºï¼Œä¸Šé¢çš„ `/#decode(channel, buffer)` æ–¹æ³•ï¼Œå¯èƒ½æœªè¯»å…¨
17: int length = header.length;
18: if (header.length < readable) {
19: header = Bytes.copyOf(header, readable);
20: buffer.readBytes(header, length, readable - length);
21: }
22: // ã€TODO 8026 ã€‘header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW ï¼Ÿ
23: for (int i = 1; i < header.length - 1; i++) {
24: if (header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW) {
25: buffer.readerIndex(buffer.readerIndex() - header.length + i);
26: header = Bytes.copyOf(header, i);
27: break;
28: }
29: }
30: // æäº¤ç»™çˆ¶ç±»( Telnet ) å¤„ç†ï¼Œç›®å‰æ˜¯ Telnet å‘½ä»¤ã€‚
31: return super.decode(channel, buffer, readable, header);
32: }
33: // Header é•¿åº¦ä¸å¤Ÿï¼Œè¿”å›éœ€è¦æ›´å¤šçš„è¾“å…¥
34: // check length.
35: if (readable < HEADER_LENGTH) {
36: return DecodeResult.NEED_MORE_INPUT;
37: }
38:
39: // `[96 - 127]`ï¼šBody çš„/*/*é•¿åº¦/*/*ã€‚é€šè¿‡è¯¥é•¿åº¦ï¼Œè¯»å– Body ã€‚
40: // get data length.
41: int len = Bytes.bytes2int(header, 12);
42: checkPayload(channel, len);
43:
44: // æ€»é•¿åº¦ä¸å¤Ÿï¼Œè¿”å›éœ€è¦æ›´å¤šçš„è¾“å…¥
45: int tt = len + HEADER_LENGTH;
46: if (readable < tt) {
47: return DecodeResult.NEED_MORE_INPUT;
48: }
49:
50: // è§£æ Header + Body
51: // limit input stream.
52: ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);
53: try {
54: return decodeBody(channel, is, header);
55: } finally {
56: // skip æœªè¯»å®Œçš„æµï¼Œå¹¶æ‰“å°é”™è¯¯æ—¥å¿—
57: if (is.available() > 0) {
58: try {
59: if (logger.isWarnEnabled()) {
60: logger.warn("Skip input stream " + is.available());
61: }
62: StreamUtils.skipUnusedStream(is);
63: } catch (IOException e) {
64: logger.warn(e.getMessage(), e);
65: }
66: }
67: }
68: }
```

- ç¬¬ 3 è‡³ 6 è¡Œï¼šè¯»å–

header
æ•°ç»„ã€‚**æ³¨æ„**ï¼Œè¿™é‡Œçš„

Math.min(readable, HEADER_LENGTH)
ï¼Œä¼˜å…ˆè€ƒè™‘è§£æ Dubbo åè®®ã€‚

- ç¬¬ 8 è¡Œï¼šè°ƒç”¨

/#decode(channel, buffer, readable, header)
æ–¹æ³•ï¼Œè§£ç ã€‚

- ========== åˆ†éš”çº¿ ==========
- ç¬¬ 13 è‡³ 32 è¡Œï¼šé Dubbo åè®®ï¼Œç›®å‰æ˜¯ Telnet åè®®ã€‚

- ç¬¬ 17 è‡³ 21 è¡Œï¼šå°† Buffer å®Œå…¨å¤åˆ¶åˆ°

header
æ•°ç»„ä¸­ã€‚å› ä¸ºï¼Œä¸Šé¢çš„

/#decode(channel, buffer)
æ–¹æ³•ï¼Œå¯èƒ½æœªè¯»å…¨ã€‚å› ä¸ºï¼Œã€ç¬¬ 3 è‡³ 6 è¡Œã€‘ï¼Œæ˜¯ä»¥ **Dubbo åè®®** ä¸ºä¼˜å…ˆè€ƒè™‘è§£ç çš„ã€‚

- ç¬¬ 22 è‡³ 29 è¡Œï¼šã€TODO 8026 ã€‘header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW ï¼Ÿæä¸æ‡‚ï¼Ÿ
- ç¬¬ 31 è¡Œï¼šè°ƒç”¨

Telnet/#decode(channel, buffer, readable, header)
æ–¹æ³•ï¼Œè§£ç  Telnet ã€‚åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” NIO æœåŠ¡å™¨ï¼ˆä¸‰ï¼‰ä¹‹ Telnet å±‚ã€‹](http://svip.iocoder.cn/Dubbo/remoting-api-telnet/?self) æœ‰è¯¦ç»†è§£æã€‚

- ç¬¬ 33 è‡³ 48 è¡Œï¼šåŸºäº**æ¶ˆæ¯é•¿åº¦**çš„æ–¹å¼ï¼Œæ‹†åŒ…ã€‚
- ç¬¬ 50 è‡³ 54 è¡Œï¼šè°ƒç”¨ [
  /#decodeBody(channel, is, header)
  ](https://github.com/YunaiV/dubbo/blob/a89a569e608ee1282d1bce3fc2540860873629db/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java#L148-L218) æ–¹æ³•ï¼Œè§£æ Header + Body ï¼Œæ ¹æ®æƒ…å†µï¼Œè¿”å› Request æˆ– Reponse ã€‚ğŸ™‚ é€»è¾‘ä¸Šï¼Œæ˜¯

/#encodeRequest(...)
å’Œ

/#encodeResponse(...)
æ–¹æ³•çš„åå‘ï¼Œæ‰€ä»¥ï¼Œèƒ–å‹å°±è‡ªå·±çœ‹å•¦ã€‚

- ç¬¬ 55 è‡³ 67 è¡Œï¼šskip **æœªè¯»å®Œçš„æµ**ï¼Œå¹¶æ‰“å°å‘Šè­¦æ—¥å¿—ã€‚
