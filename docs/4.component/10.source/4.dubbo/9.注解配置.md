# æ³¨è§£é…ç½®

æœ¬æ–‡åŸºäº Dubbo 2.7.1-SNAPSHOT ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

åœ¨ Dubbo æä¾›çš„å‡ ç§æ–¹å¼ä¸­ï¼Œ**æ³¨è§£é…ç½®**æ…¢æ…¢å˜æˆå¤§å®¶æœ€å¸¸ç”¨çš„æ–¹å¼ã€‚

å¦‚æœèƒ–å‹ä¸ç†Ÿæ‚‰ï¼Œå¯ä»¥æŸ¥çœ‹å¦‚ä¸‹æ–‡æ¡£ï¼š

- [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æ³¨è§£é…ç½®ã€‹](http://dubbo.apache.org/zh-cn/docs/user/configuration/annotation.html)
- [ã€Šåœ¨ Dubbo ä¸­ä½¿ç”¨æ³¨è§£ã€‹](http://dubbo.apache.org/zh-cn/blog/dubbo-annotation.html)
- [ã€ŠDubbo æ³¨è§£é©±åŠ¨ï¼ˆAnnotation-Drivenï¼‰ã€‹](https://dubbo.apache.org/zh-cn/blog/dubbo-annotation-driven.html)

# 2. ä½¿ç”¨ç¤ºä¾‹

æˆ‘ä»¬æ¥çœ‹çœ‹

dubbo-demo-annotation
é¡¹ç›®ä¸‹çš„

dubbo-demo-annotation-provider
å­é¡¹ç›®æä¾›çš„ Dubbo Provider ç¤ºä¾‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// Application.java
public class Application{
//*/*
/* In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
/* launch the application
/*/
public static void main(String[] args) throws Exception{
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class);
context.start();
System.in.read();
}
@Configuration
@EnableDubbo(scanBasePackages = "org.apache.dubbo.demo.provider") // <1>
@PropertySource("classpath:/spring/dubbo-provider.properties") // <2>
static class ProviderConfiguration{
@Bean // <3>
public RegistryConfig registryConfig(){
RegistryConfig registryConfig = new RegistryConfig();
registryConfig.setAddress("multicast://224.5.6.7:1234");
return registryConfig;
}
}
}
```

- <1>
  å¤„ï¼Œä½¿ç”¨

@EnableDubbo
æ³¨è§£ï¼Œé…ç½®æ‰«æ

"org.apache.dubbo.demo.provider"
ç›®å½•ä¸‹çš„

@Service
å’Œ

@Reference
Bean å¯¹è±¡ã€‚

- <2>
  å¤„ï¼Œä½¿ç”¨

@PropertySource
æ³¨è§£ï¼Œå¯¼å…¥

"classpath:/spring/dubbo-provider.properties"
é…ç½®æ–‡ä»¶ã€‚

- <3>
  å¤„ï¼Œé€šè¿‡

@Bean
æ³¨è§£æ–¹æ³•ï¼Œåˆ›å»º RegistryConfig Bean å¯¹è±¡ï¼Œå³æ³¨å†Œä¸­å¿ƒã€‚

- é€šè¿‡ä½¿ç”¨ Java Config + æ³¨è§£çš„æ–¹å¼ï¼Œç›¸æ¯” XML æ¥è¯´ï¼Œä¼šæ›´åŠ ç†Ÿæ‚‰ä¸€äº›~

ä¸‹é¢ï¼Œæˆ‘ä»¬å°±æ¥çœ‹çœ‹å…·ä½“çš„æºç è½ã€‚æœ¬æ–‡æ¶‰åŠçš„ç±»ï¼Œä¸»è¦å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![ç±»](http://static2.iocoder.cn/images/Dubbo/2018_01_22/01.jpg)

# 3. @EnableDubbo

org.apache.dubbo.config.spring.context.annotation.@EnableDubbo
æ³¨è§£ï¼Œæ˜¯

@EnableDubboConfig
å’Œ

@DubboComponentScan
çš„ç»„åˆæ³¨è§£ï¼Œä½¿ç”¨æ—¶æ›´åŠ ä¾¿åˆ©ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// EnableDubbo.java
//*/*
/* Enables Dubbo components as Spring Beans, equals
/* {@link DubboComponentScan} and {@link EnableDubboConfig} combination.
/* <p>
/* Note : {@link EnableDubbo} must base on Spring Framework 4.2 and above
/*
/* @see DubboComponentScan
/* @see EnableDubboConfig
/* @since 2.5.8
/*/
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@EnableDubboConfig // å¼€å¯ Dubbo Config
@DubboComponentScan // æ‰«æ Dubbo @Service å’Œ @Reference Bean
public @interface EnableDubbo {
//*/*
/* é…ç½® @DubboComponentScan æ³¨è§£ï¼Œæ‰«æçš„åŒ…
/*
/* Base packages to scan for annotated @Service classes.
/* <p>
/* Use {@link /#scanBasePackageClasses()} for a type-safe alternative to String-based
/* package names.
/*
/* @return the base packages to scan
/* @see DubboComponentScan/#basePackages()
/*/
@AliasFor(annotation = DubboComponentScan.class, attribute = "basePackages")
String[] scanBasePackages() default {};
//*/*
/* é…ç½® @DubboComponentScan æ³¨è§£ï¼Œæ‰«æçš„ç±»
/*
/* Type-safe alternative to {@link /#scanBasePackages()} for specifying the packages to
/* scan for annotated @Service classes. The package of each class specified will be
/* scanned.
/*
/* @return classes from the base packages to scan
/* @see DubboComponentScan/#basePackageClasses
/*/
@AliasFor(annotation = DubboComponentScan.class, attribute = "basePackageClasses")
Class<?>[] scanBasePackageClasses() default {};
//*/*
/* é…ç½® @EnableDubboConfig æ³¨è§£ï¼Œé…ç½®æ˜¯å¦ç»‘å®šåˆ°å¤šä¸ª Spring Bean ä¸Š
/*
/* It indicates whether {@link AbstractConfig} binding to multiple Spring Beans.
/*
/* @return the default value is <code>false</code>
/* @see EnableDubboConfig/#multiple()
/*/
@AliasFor(annotation = EnableDubboConfig.class, attribute = "multiple")
boolean multipleConfig() default false;
}
```

- æ³¨æ„çœ‹ä¸‹å…·ä½“çš„æ³¨é‡Šã€‚
  é€šè¿‡

@EnableDubbo
å¯ä»¥åœ¨æŒ‡å®šçš„åŒ…åä¸‹ï¼ˆé€šè¿‡

scanBasePackages
å±æ€§ï¼‰ï¼Œæˆ–è€…æŒ‡å®šçš„ç±»ä¸­ï¼ˆé€šè¿‡

scanBasePackageClasses
å±æ€§ï¼‰æ‰«æ Dubbo çš„æœåŠ¡æä¾›è€…ï¼ˆä»¥

@Service
æ³¨è§£ï¼‰ä»¥åŠ Dubbo çš„æœåŠ¡æ¶ˆè´¹è€…ï¼ˆä»¥

@Reference
æ³¨è§£ï¼‰ã€‚

æ‰«æåˆ° Dubbo çš„æœåŠ¡æä¾›æ–¹å’Œæ¶ˆè´¹è€…ä¹‹åï¼Œå¯¹å…¶åšç›¸åº”çš„ç»„è£…å¹¶åˆå§‹åŒ–ï¼Œå¹¶æœ€ç»ˆå®ŒæˆæœåŠ¡æš´éœ²æˆ–è€…å¼•ç”¨çš„å·¥ä½œã€‚

# 4. @EnableDubboConfig

org.apache.dubbo.config.spring.context.annotation.@EnableDubboConfig
æ³¨è§£ï¼Œå¼€å¯ Dubbo é…ç½®ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// EnableDubboConfig.java
//*/*
/* As a convenient and multiple {@link EnableDubboConfigBinding}
/* in default behavior , is equal to single bean bindings with below convention prefixes of properties:
/* <ul>
/* <li>{@link ApplicationConfig} binding to property : "dubbo.application"</li>
/* <li>{@link ModuleConfig} binding to property : "dubbo.module"</li>
/* <li>{@link RegistryConfig} binding to property : "dubbo.registry"</li>
/* <li>{@link ProtocolConfig} binding to property : "dubbo.protocol"</li>
/* <li>{@link MonitorConfig} binding to property : "dubbo.monitor"</li>
/* <li>{@link ProviderConfig} binding to property : "dubbo.provider"</li>
/* <li>{@link ConsumerConfig} binding to property : "dubbo.consumer"</li>
/* </ul>
/* <p>
/* In contrast, on multiple bean bindings that requires to set {@link /#multiple()} to be <code>true</code> :
/* <ul>
/* <li>{@link ApplicationConfig} binding to property : "dubbo.applications"</li>
/* <li>{@link ModuleConfig} binding to property : "dubbo.modules"</li>
/* <li>{@link RegistryConfig} binding to property : "dubbo.registries"</li>
/* <li>{@link ProtocolConfig} binding to property : "dubbo.protocols"</li>
/* <li>{@link MonitorConfig} binding to property : "dubbo.monitors"</li>
/* <li>{@link ProviderConfig} binding to property : "dubbo.providers"</li>
/* <li>{@link ConsumerConfig} binding to property : "dubbo.consumers"</li>
/* </ul>
/*
/* @see EnableDubboConfigBinding
/* @see DubboConfigConfiguration
/* @see DubboConfigConfigurationSelector
/* @since 2.5.8
/*/
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Import(DubboConfigConfigurationRegistrar.class)
public @interface EnableDubboConfig {
//*/*
/* It indicates whether binding to multiple Spring Beans.
/*
/* é…ç½®æ˜¯å¦ç»‘å®šåˆ°å¤šä¸ª Spring Bean ä¸Š
/*
/* @return the default value is <code>false</code>
/* @revised 2.5.9
/*/
boolean multiple() default false;
}
```

- å…³äº

multiple
å±æ€§ï¼Œå¯èƒ½ç¬¬ä¸€çœ¼ä¼šæœ‰ç‚¹æ‡µé€¼ï¼Œé‚£å’‹æ•´å‘¢ï¼Ÿ

- ç¬¬ä¸€æ­¥ï¼Œå¯ä»¥çœ‹çœ‹ [ã€ŠDubbo æ–°ç¼–ç¨‹æ¨¡å‹ä¹‹å¤–éƒ¨åŒ–é…ç½® â€”â€”

@EnableDubboConfig
ã€‹](https://segmentfault.com/a/1190000012661402#articleHeader4) å¯¹

@EnableDubboConfig
æ³¨è§£çš„ä»‹ç»ã€‚

- ç¬¬äºŒæ­¥ï¼Œæˆ‘ä»¬åœ¨æ¥ä¸‹æ¥ä¼šçœ‹å…·ä½“çš„æºç ï¼Œä¼šæ›´æ˜“æ‡‚ä¸€äº›ã€‚
- @Import(DubboConfigConfigurationRegistrar.class)
  æ³¨è§£ï¼Œè¡¨æ˜ä½¿ç”¨ DubboConfigConfigurationRegistrar ç±»è¿›è¡Œå¯¼å…¥ã€‚è¯¦ç»†çš„ï¼Œæˆ‘ä»¬ç»§ç»­æ¥çœ‹ [ã€Œ4.1 DubboConfigConfigurationRegistrarã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ã€‚

## 4.1 DubboConfigConfigurationRegistrar

org.apache.dubbo.config.spring.context.annotation.DubboConfigConfigurationRegistrar
ï¼Œå®ç° ImportBeanDefinitionRegistrar æ¥å£ï¼Œå¤„ç†

@EnableDubboConfig
æ³¨è§£ï¼Œæ³¨å†Œç›¸åº”çš„ DubboConfigConfiguration åˆ° Spring å®¹å™¨ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigConfigurationRegistrar.java
//*/*
/* Dubbo {@link AbstractConfig Config} {@link ImportBeanDefinitionRegistrar register}, which order can be configured
/*
/* @see EnableDubboConfig
/* @see DubboConfigConfiguration
/* @see Ordered
/* @since 2.5.8
/*/
public class DubboConfigConfigurationRegistrar implements ImportBeanDefinitionRegistrar{
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){
// è·å¾— @EnableDubboConfig æ³¨è§£çš„å±æ€§
AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName()));
// è·å¾— multiple å±æ€§
boolean multiple = attributes.getBoolean("multiple");
// å¦‚æœä¸º true ï¼Œåˆ™æ³¨å†Œ DubboConfigConfiguration.Multiple Bean å¯¹è±¡
if (multiple) {
AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, DubboConfigConfiguration.Multiple.class);
// å¦‚æœä¸º false ï¼Œåˆ™æ³¨å†Œ DubboConfigConfiguration.Single Bean å¯¹è±¡
} else {
AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, DubboConfigConfiguration.Single.class);
}
}
}
// AnnotatedBeanDefinitionRegistryUtils.java
public static void registerBeans(BeanDefinitionRegistry registry, Class<?>... annotatedClasses){
if (ObjectUtils.isEmpty(annotatedClasses)) {
return;
}
boolean debugEnabled = logger.isDebugEnabled();
// åˆ›å»º AnnotatedBeanDefinitionReader å¯¹è±¡
AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(registry);
if (debugEnabled) {
logger.debug(registry.getClass().getSimpleName() + " will register annotated classes : " + Arrays.asList(annotatedClasses) + " .");
}
// æ³¨å†Œ
reader.register(annotatedClasses);
}
```

- æ ¹æ®

@EnableDubboConfig
æ³¨è§£ä¸Šçš„

multiple
å±æ€§çš„ä¸åŒï¼Œåˆ›å»º DubboConfigConfiguration.Multiple æˆ– DubboConfigConfiguration.Single å¯¹è±¡ï¼Œæ³¨å†Œåˆ° Spring å®¹å™¨ä¸­ã€‚

## 4.2 DubboConfigConfiguration

org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigConfiguration
ï¼ŒDubbo AbstractConfig é…ç½®ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigConfiguration.java
//*/*
/* Dubbo {@link AbstractConfig Config} {@link Configuration}
/*
/* @see Configuration
/* @see EnableDubboConfigBindings
/* @see EnableDubboConfigBinding
/* @see ApplicationConfig
/* @see ModuleConfig
/* @see RegistryConfig
/* @see ProtocolConfig
/* @see MonitorConfig
/* @see ProviderConfig
/* @see ConsumerConfig
/* @see org.apache.dubbo.config.ConfigCenterConfig
/* @since 2.5.8
/*/
public class DubboConfigConfiguration{
//*/*
/* Single Dubbo {@link AbstractConfig Config} Bean Binding
/*/
@EnableDubboConfigBindings({
@EnableDubboConfigBinding(prefix = "dubbo.application", type = ApplicationConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.module", type = ModuleConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.registry", type = RegistryConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.protocol", type = ProtocolConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.monitor", type = MonitorConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.provider", type = ProviderConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.consumer", type = ConsumerConfig.class),
@EnableDubboConfigBinding(prefix = "dubbo.config-center", type = ConfigCenterBean.class),
@EnableDubboConfigBinding(prefix = "dubbo.metadata-report", type = MetadataReportConfig.class)
})
public static class Single{
}
//*/*
/* Multiple Dubbo {@link AbstractConfig Config} Bean Binding
/*/
@EnableDubboConfigBindings({
@EnableDubboConfigBinding(prefix = "dubbo.applications", type = ApplicationConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.modules", type = ModuleConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.registries", type = RegistryConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.protocols", type = ProtocolConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.monitors", type = MonitorConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.providers", type = ProviderConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.consumers", type = ConsumerConfig.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.config-centers", type = ConfigCenterBean.class, multiple = true),
@EnableDubboConfigBinding(prefix = "dubbo.metadata-reports", type = MetadataReportConfig.class, multiple = true)
})
public static class Multiple{
}
}
```

- ä¹çœ¼ä¸€çœ‹ï¼Œå°±æ˜¯ Single å’Œ Multiple å†…éƒ¨ç±»ã€‚å…¶ä¸Šéƒ½æœ‰

@@EnableDubboConfigBindings
å’Œ

@EnableDubboConfigBinding
æ³¨è§£ã€‚

- å‰è€… Single ï¼Œå…¶ä¸Šçš„æ³¨è§£ï¼Œ

prefix
éƒ½æ˜¯å•æ•°ã€‚

- åè€… Multiple ï¼Œå…¶ä¸Šçš„æ³¨è§£ï¼Œ

prefix
éƒ½æ˜¯å¤æ•°ï¼Œä¸”æœ‰

multiple = true
ã€‚

- é‚£ä¹ˆä¼šæœ‰ä»€ä¹ˆæ•ˆæœå‘¢ï¼Ÿæˆ‘ä»¬ç»§ç»­å¾€ [ã€Œ4.3 @@EnableDubboConfigBindingsã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) å’Œ [ã€Œ4.4 @@EnableDubboConfigBindingã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) çœ‹ã€‚

## 4.3 @EnableDubboConfigBindings

org.apache.dubbo.config.spring.context.annotation.@EnableDubboConfigBindings
æ³¨è§£ï¼Œæ˜¯

@EnableDubboConfigBinding
æ³¨è§£çš„æ•°ç»„ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// EnableDubboConfigBindings.java
//*/*
/* Multiple {@link EnableDubboConfigBinding} {@link Annotation}
/*
/* @since 2.5.8
/* @see EnableDubboConfigBinding
/*/
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(DubboConfigBindingsRegistrar.class)
public @interface EnableDubboConfigBindings {
//*/*
/* The value of {@link EnableDubboConfigBindings}
/*
/* @return non-null
/*/
EnableDubboConfigBinding[] value();
}
```

- @Import(DubboConfigBindingsRegistrar.class)
  æ³¨è§£ï¼Œè¡¨æ˜ä½¿ç”¨ DubboConfigBindingsRegistrar ç±»è¿›è¡Œå¯¼å…¥ã€‚è¯¦ç»†çš„ï¼Œæˆ‘ä»¬ç»§ç»­æ¥çœ‹ [ã€Œ4.3.1 DubboConfigBindingsRegistrarã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ã€‚

### 4.3.1 DubboConfigBindingsRegistrar

org.apache.dubbo.config.spring.context.annotation.DubboConfigBindingsRegistrar
ï¼Œå®ç° ImportBeanDefinitionRegistrarã€EnvironmentAware æ¥å£ï¼Œå¤„ç†

@EnableDubboConfigBindings
æ³¨è§£ï¼Œæ³¨å†Œç›¸åº”çš„ Dubbo AbstractConfig åˆ° Spring å®¹å™¨ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingsRegistrar.java
//*/*
/* {@link AbstractConfig Dubbo Config} binding Bean registrar for {@link EnableDubboConfigBindings}
/*
/* @see EnableDubboConfigBindings
/* @see DubboConfigBindingRegistrar
/* @since 2.5.8
/*/
public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware{
private ConfigurableEnvironment environment;
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){
// <1.1> è·å¾— @EnableDubboConfigBindings æ³¨è§£
AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));
// <1.2> è·å¾—å†…éƒ¨çš„ @EnableDubboConfigBinding æ³¨è§£çš„æ•°ç»„
AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray("value");
// <2> åˆ›å»º DubboConfigBindingRegistrar å¯¹è±¡ï¼Œå¹¶è®¾ç½® environment å±æ€§
DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();
registrar.setEnvironment(environment);
// <3> éå† annotationAttributes æ•°ç»„ï¼Œä½¿ç”¨ registrar è¿›è¡Œé€ä¸ª @EnableDubboConfigBinding æ³¨è§£çš„æ³¨å†Œå¯¹åº”çš„ Bean
for (AnnotationAttributes element : annotationAttributes) {
registrar.registerBeanDefinitions(element, registry);
}
}
@Override
public void setEnvironment(Environment environment){
Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
this.environment = (ConfigurableEnvironment) environment;
}
}
```

- <1.1>
  ã€

<1.2>
å¤„ï¼Œè·å¾—

@EnableDubboConfigBindings
æ³¨è§£ï¼Œä»è€Œåé¢è·å¾—å†…éƒ¨çš„

@EnableDubboConfigBinding
æ³¨è§£çš„æ•°ç»„ã€‚

- <2>
  å¤„ï¼Œåˆ›å»º DubboConfigBindingRegistrar å¯¹è±¡ï¼Œå¹¶è®¾ç½®

environment
å±æ€§ã€‚

- <3>
  å¤„ï¼Œéå†

annotationAttributes
æ•°ç»„ï¼Œä½¿ç”¨

registrar
ï¼Œè°ƒç”¨

DubboConfigBindingRegistrar/#registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œè¿›è¡Œé€ä¸ª

@EnableDubboConfigBinding
æ³¨è§£çš„æ³¨å†Œå¯¹åº”çš„ Bean ã€‚

- åœ¨ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ° DubboConfigBindingRegistrar æœ¬æ¥å°±æ˜¯ç”¨æ¥å¤„ç†

EnableDubboConfigBinding
æ³¨è§£ã€‚

## 4.4 @EnableDubboConfigBinding

org.apache.dubbo.config.spring.context.annotation.@EnableDubboConfigBinding
æ³¨è§£ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
// EnableDubboConfigBinding.java
@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(EnableDubboConfigBindings.class)
@Import(DubboConfigBindingRegistrar.class)
public @interface EnableDubboConfigBinding {
//*/*
/* The name prefix of the properties that are valid to bind to {@link AbstractConfig Dubbo Config}.
/*
/* é…ç½®å‰ç¼€
/*
/* @return the name prefix of the properties to bind
/*/
String prefix();
//*/*
/* é…ç½®ç±»
/*
/* @return The binding type of {@link AbstractConfig Dubbo Config}.
/* @see AbstractConfig
/* @see ApplicationConfig
/* @see ModuleConfig
/* @see RegistryConfig
/*/
Class<? extends AbstractConfig> type();
//*/*
/* æ˜¯å¦ multiple
/*
/* It indicates whether {@link /#prefix()} binding to multiple Spring Beans.
/*
/* @return the default value is <code>false</code>
/*/
boolean multiple() default false;
}
```

- æ¯ä¸ªå±æ€§ï¼Œçœ‹å…¶ä¸Šçš„ä»£ç æ³¨é‡Šã€‚
- - @Import(DubboConfigBindingRegistrar.class)
    æ³¨è§£ï¼Œè¡¨æ˜ä½¿ç”¨ DubboConfigBindingRegistrar ç±»è¿›è¡Œå¯¼å…¥ã€‚è¯¦ç»†çš„ï¼Œæˆ‘ä»¬ç»§ç»­æ¥çœ‹ [ã€Œ4.4.1 DubboConfigBindingRegistrarã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ã€‚

### 4.4.1 DubboConfigBindingRegistrar

org.apache.dubbo.config.spring.context.annotation.DubboConfigBindingRegistrar
ï¼Œå®ç° ImportBeanDefinitionRegistrarã€EnvironmentAware æ¥å£ï¼Œå¤„ç†

@EnableDubboConfigBinding
æ³¨è§£ï¼Œæ³¨å†Œç›¸åº”çš„ Dubbo AbstractConfig åˆ° Spring å®¹å™¨ä¸­ã€‚

### 4.4.1.1 registerBeanDefinitions

å®ç°

/#registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œå¤„ç†

@EnableDubboConfigBinding
æ³¨è§£ï¼Œæ³¨å†Œç›¸åº”çš„ Dubbo AbstractConfig åˆ° Spring å®¹å™¨ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingRegistrar.java
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){
// <1> è·å¾— @EnableDubboConfigBinding æ³¨è§£
AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName()));
// <2> æ³¨å†Œé…ç½®å¯¹åº”çš„ Bean Definition å¯¹è±¡
registerBeanDefinitions(attributes, registry);
}
protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry){
// <2.1> è·å¾— prefix å±æ€§
String prefix = environment.resolvePlaceholders(attributes.getString("prefix")); // å› ä¸ºï¼Œæœ‰å¯èƒ½æœ‰å ä½ç¬¦ï¼Œæ‰€ä»¥è¦è§£æã€‚
// <2.2> è·å¾— type å±æ€§ï¼Œå³ AbstractConfig çš„å®ç°ç±»
Class<? extends AbstractConfig> configClass = attributes.getClass("type");
// <2.3> è·å¾— multiple å±æ€§
boolean multiple = attributes.getBoolean("multiple");
// <2.4> æ³¨å†Œ Dubbo Config Bean å¯¹è±¡
registerDubboConfigBeans(prefix, configClass, multiple, registry);
}
```

- <1>
  å¤„ï¼Œè·å¾—

@EnableDubboConfigBinding
æ³¨è§£ã€‚

- <2>
  æ³¨å†Œé…ç½®å¯¹åº”çš„ Bean Definition å¯¹è±¡ã€‚ğŸ˜ˆ è¿™é‡Œæœ‰ä¸ªçŸ¥è¯†ç‚¹è¦è¡¥å……ä¸‹ï¼ŒSpring åœ¨åˆ›å»º Bean ä¹‹å‰ï¼Œä¼šå°† XML é…ç½®æˆ–è€…æ³¨è§£é…ç½®ï¼Œå…ˆè§£ææˆå¯¹åº”çš„ BeanDefinition å¯¹è±¡ï¼Œç„¶ååœ¨åˆ›å»º Bean å¯¹è±¡ã€‚

- <2.1>
  å¤„ï¼Œè·å¾—

prefix
å±æ€§ã€‚

- <2.2>
  å¤„ï¼Œè·å¾—

type
å±æ€§ï¼Œå³ AbstractConfig çš„å®ç°ç±»ã€‚

- <2.3>
  å¤„ï¼Œè·å¾—

multiple
å±æ€§ã€‚

- <2.4>
  å¤„ï¼Œè°ƒç”¨

/#registerDubboConfigBeans(String prefix, Class<? extends AbstractConfig> configClass, boolean multiple, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ³¨å†Œ Dubbo Config Bean å¯¹è±¡ã€‚

### 4.4.1.2 registerDubboConfigBeans

/#registerDubboConfigBeans(String prefix, Class<? extends AbstractConfig> configClass, boolean multiple, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ³¨å†Œ Dubbo Config Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingRegistrar.java
private void registerDubboConfigBeans(String prefix, Class<? extends AbstractConfig> configClass, boolean multiple,
BeanDefinitionRegistry registry){
// <1.1> è·å¾— prefix å¼€å¤´çš„é…ç½®å±æ€§
Map<String, Object> properties = PropertySourcesUtils.getSubProperties(environment.getPropertySources(), prefix);
// <1.2> å¦‚æœé…ç½®å±æ€§ä¸ºç©ºï¼Œåˆ™æ— éœ€åˆ›å»º
if (CollectionUtils.isEmpty(properties)) {
if (log.isDebugEnabled()) {
log.debug("There is no property for binding to dubbo config class [" + configClass.getName()
+ "] within prefix [" + prefix + "]");
}
return;
}
// <2> è·å¾—é…ç½®å±æ€§å¯¹åº”çš„ Bean åå­—çš„é›†åˆ
Set<String> beanNames = multiple ? resolveMultipleBeanNames(properties) :
Collections.singleton(resolveSingleBeanName(properties, configClass, registry));
// <3> éå† beanNames æ•°ç»„ï¼Œé€ä¸ªæ³¨å†Œ
for (String beanName : beanNames) {
// <3.1> æ³¨æ³¨å†Œ Dubbo Config Bean å¯¹è±¡
registerDubboConfigBean(beanName, configClass, registry);
// <3.2> æ³¨æ³¨å†Œ Dubbo Config å¯¹è±¡å¯¹åº”çš„ DubboConfigBindingBeanPostProcessor å¯¹è±¡
registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);
}
}
```

- <1.1>
  å¤„ï¼Œè°ƒç”¨

PropertySourcesUtils/#getSubProperties(Iterable<PropertySource<?>> propertySources, String prefix)
æ–¹æ³•ï¼Œè·å¾—

prefix
å¼€å¤´çš„é…ç½®å±æ€§ã€‚å› ä¸ºï¼Œåç»­ä¼šç”¨è¿™ä¸ªå±æ€§ï¼Œè®¾ç½®åˆ°åˆ›å»ºçš„ Bean å¯¹è±¡ä¸­ã€‚

- <1.2>
  å¤„ï¼Œå¦‚æœé…ç½®å±æ€§ä¸ºç©ºï¼Œåˆ™æ— éœ€åˆ›å»ºã€‚
- <2>
  å¤„ï¼Œæ ¹æ®

multiple
çš„å€¼ï¼Œè°ƒç”¨ä¸åŒçš„æ–¹æ³•ï¼Œè·å¾—é…ç½®å±æ€§å¯¹åº”çš„ Bean åå­—çš„é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingRegistrar.java
// ä¾‹å¦‚ï¼šdubbo.application.${beanName}.name=dubbo-demo-annotation-provider
private Set<String> resolveMultipleBeanNames(Map<String, Object> properties){
Set<String> beanNames = new LinkedHashSet<String>();
for (String propertyName : properties.keySet()) {
// è·å–ä¸Šè¿°ç¤ºä¾‹çš„ ${beanName} å­—ç¬¦ä¸²
int index = propertyName.indexOf(".");
if (index > 0) {
String beanName = propertyName.substring(0, index);
beanNames.add(beanName);
}
}
return beanNames;
}
// ä¾‹å¦‚ï¼šdubbo.application.name=dubbo-demo-annotation-provider
private String resolveSingleBeanName(Map<String, Object> properties, Class<? extends AbstractConfig> configClass,
BeanDefinitionRegistry registry){
// è·å¾— Bean çš„åå­—
String beanName = (String) properties.get("id");
// å¦‚æœå®šä¹‰ï¼ŒåŸºäº Spring æä¾›çš„æœºåˆ¶ï¼Œç”Ÿæˆå¯¹åº”çš„ Bean çš„åå­—ã€‚ä¾‹å¦‚è¯´ï¼šorg.apache.dubbo.config.ApplicationConfig/#0
if (!StringUtils.hasText(beanName)) {
BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(configClass);
beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry);
}
return beanName;
}
```

- è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œçœ‹çœ‹æˆ‘æä¾›çš„ç¤ºä¾‹ã€‚
- /#resolveMultipleBeanNames(Map<String, Object> properties)
  æ–¹æ³•ï¼Œå¯èƒ½æ¯”è¾ƒéš¾ç†è§£ä¸€ç‚¹ã€‚èƒ–å‹å¯ä»¥å¢åŠ å¦‚ä¸‹åˆ°é…ç½®æ–‡ä»¶ä¸­ï¼š

```
/# application.properties
dubbo.applications.x.name=biu
dubbo.applications.y.name=biubiubiu
```

- æ­¤æ—¶ï¼Œä½ éœ€è¦æŒ‡å®š

@Service
Bean ä½¿ç”¨å“ªä¸ªåº”ç”¨ã€‚

- <3>
  å¤„ï¼Œéå†

beanNames
æ•°ç»„ï¼Œé€ä¸ªæ³¨å†Œã€‚

- <3.1>
  å¤„ï¼Œè°ƒç”¨

/#registerDubboConfigBean(String beanName, Class<? extends AbstractConfig> configClass, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ³¨å†Œ Dubbo Config Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingRegistrar.java
private void registerDubboConfigBean(String beanName, Class<? extends AbstractConfig> configClass,
BeanDefinitionRegistry registry){
// åˆ›å»º BeanDefinitionBuilder å¯¹è±¡
BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(configClass);
// è·å¾— AbstractBeanDefinition å¯¹è±¡
AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
// æ³¨å†Œåˆ° registry ä¸­
registry.registerBeanDefinition(beanName, beanDefinition);
if (log.isInfoEnabled()) {
log.info("The dubbo config bean definition [name : " + beanName + ", class : " + configClass.getName() + "] has been registered.");
}
}
```

- æ­¤æ—¶ï¼Œä»…ä»…æ˜¯é€šè¿‡é…±ç´«çš„æ–¹å¼ï¼Œåˆ›å»ºäº†ä¸€ä¸ª Dubbo Config Bean å¯¹è±¡ï¼Œå¹¶æ²¡æœ‰å°†é…ç½®å±æ€§ï¼Œè®¾ç½®åˆ°è¯¥å¯¹è±¡ä¸­ã€‚ç­”æ¡ˆåœ¨

<3.2>
ä¸­ã€‚

- <3.2>
  å¤„ï¼Œè°ƒç”¨

/#registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ³¨å†Œ Dubbo Config å¯¹è±¡å¯¹è±¡çš„ DubboConfigBindingBeanPostProcessor å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingRegistrar.java
private void registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple,
BeanDefinitionRegistry registry){
// åˆ›å»º BeanDefinitionBuilder å¯¹è±¡
Class<?> processorClass = DubboConfigBindingBeanPostProcessor.class;
BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);
// æ·»åŠ æ„é€ æ–¹æ³•çš„å‚æ•°ä¸º actualPrefix å’Œ beanName ã€‚å³ï¼Œåˆ›å»º DubboConfigBindingBeanPostProcessor å¯¹è±¡ï¼Œéœ€è¦è¿™ä¸¤ä¸ªæ„é€ å‚æ•°
String actualPrefix = multiple ? PropertySourcesUtils.normalizePrefix(prefix) + beanName : prefix;
builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);
// è·å¾— AbstractBeanDefinition å¯¹è±¡
AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
// è®¾ç½® role å±æ€§
beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
// æ³¨å†Œåˆ° registry ä¸­
BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);
if (log.isInfoEnabled()) {
log.info("The BeanPostProcessor bean definition [" + processorClass.getName() + "] for dubbo config bean [name : " + beanName + "] has been registered.");
}
}
```

- å› ä¸ºæ­¤æ—¶ Dubbo Config Bean å¯¹è±¡è¿˜æœªåˆ›å»ºï¼Œæ‰€ä»¥éœ€è¦ç­‰åç»­å®ƒçœŸçš„åˆ›å»ºä¹‹åï¼Œä½¿ç”¨ DubboConfigBindingBeanPostProcessor ç±»ï¼Œå®ç°å¯¹å¯¹è±¡ï¼ˆBean å¯¹è±¡ï¼‰çš„é…ç½®è¾“å…¥çš„è®¾ç½®ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å‘ç°ï¼Œéœ€è¦ç»§ç»­æŒ–æ˜ï¼Œè®©æˆ‘ä»¬ç»§ç»­æ¥çœ‹ [ã€ŒDubboConfigBindingBeanPostProcessorã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ç±»ã€‚

## 4.5 DubboConfigBindingBeanPostProcessor

org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor
ï¼Œå®ç° BeanPostProcessorã€ApplicationContextAwareã€InitializingBean æ¥å£ï¼Œå¤„ç† Dubbo AbstractConfig Bean çš„é…ç½®å±æ€§æ³¨å…¥ã€‚

### 4.5.1 æ„é€ æ–¹æ³•

```
// DubboConfigBindingBeanPostProcessor.java
//*/*
/* The prefix of Configuration Properties
/*
/* é…ç½®å±æ€§çš„å‰ç¼€
/*/
private final String prefix;
//*/*
/* Binding Bean Name
/*
/* Bean çš„åå­—
/*/
private final String beanName;
private DubboConfigBinder dubboConfigBinder;
private ApplicationContext applicationContext;
//*/*
/* æ˜¯å¦å¿½ç•¥ä½ç½®çš„å±æ€§
/*/
private boolean ignoreUnknownFields = true;
//*/*
/* æ˜¯å¦å¿½ç•¥ç±»å‹ä¸å¯¹çš„å±æ€§
/*/
private boolean ignoreInvalidFields = true;
//*/*
/* @param prefix the prefix of Configuration Properties
/* @param beanName the binding Bean Name
/*/
public DubboConfigBindingBeanPostProcessor(String prefix, String beanName){
Assert.notNull(prefix, "The prefix of Configuration Properties must not be null");
Assert.notNull(beanName, "The name of bean must not be null");
this.prefix = prefix;
this.beanName = beanName;
}
```

- æ‰€ä»¥ï¼Œæˆ‘ä»¬åœ¨ä¸Šæ–‡ä¸­ä¼šçœ‹åˆ°ï¼Œåˆ›å»º DubboConfigBindingBeanPostProcessor Bean æ—¶ï¼Œä¼šæœ‰

builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);
ä¸€æ®µçš„ä»£ç ã€‚

### 4.5.2 afterPropertiesSet

/#afterPropertiesSet()
æ–¹æ³•ï¼Œè®¾ç½®

dubboConfigBinder
å±æ€§ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingBeanPostProcessor.java
@Override
public void afterPropertiesSet() throws Exception{
// è·å¾—ï¼ˆåˆ›å»ºï¼‰DubboConfigBinder å¯¹è±¡
if (dubboConfigBinder == null) {
try {
dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);
} catch (BeansException ignored) {
if (log.isDebugEnabled()) {
log.debug("DubboConfigBinder Bean can't be found in ApplicationContext.");
}
// Use Default implementation
dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());
}
}
// è®¾ç½® ignoreUnknownFieldsã€ignoreInvalidFields å±æ€§
dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);
dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);
}
//*/*
/* Create {@link DubboConfigBinder} instance.
/*
/* @param environment
/* @return {@link DefaultDubboConfigBinder}
/*/
protected DubboConfigBinder createDubboConfigBinder(Environment environment){
// åˆ›å»º DefaultDubboConfigBinder å¯¹è±¡
DefaultDubboConfigBinder defaultDubboConfigBinder = new DefaultDubboConfigBinder();
// è®¾ç½® environment å±æ€§
defaultDubboConfigBinder.setEnvironment(environment);
return defaultDubboConfigBinder;
}
```

- å…³äº DefaultDubboConfigBinder ç±»ï¼Œæˆ‘ä»¬åœ¨ä¸‹é¢çš„å°èŠ‚å…ˆæ¥ç…ç…ã€‚

### 4.5.2.1 DubboConfigBinder

org.apache.dubbo.config.spring.context.properties.DubboConfigBinder
ï¼Œç»§æ‰¿ EnvironmentAware æ¥å£ï¼ŒDubbo Config Binder æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBinder.java
//*/*
/* {@link AbstractConfig DubboConfig} Binder
/*
/* @see AbstractConfig
/* @see EnvironmentAware
/* @since 2.5.11
/*/
public interface DubboConfigBinder extends EnvironmentAware{
//*/*
/* Set whether to ignore unknown fields, that is, whether to ignore bind
/* parameters that do not have corresponding fields in the target object.
/* <p>Default is "true". Turn this off to enforce that all bind parameters
/* must have a matching field in the target object.
/*
/* @see /#bind
/*/
void setIgnoreUnknownFields(boolean ignoreUnknownFields);
//*/*
/* Set whether to ignore invalid fields, that is, whether to ignore bind
/* parameters that have corresponding fields in the target object which are
/* not accessible (for example because of null values in the nested path).
/* <p>Default is "false".
/*
/* @see /#bind
/*/
void setIgnoreInvalidFields(boolean ignoreInvalidFields);
//*/*
/* Bind the properties to Dubbo Config Object under specified prefix.
/*
/* @param prefix
/* @param dubboConfig
/*/
<C extends AbstractConfig> void bind(String prefix, C dubboConfig);
}
```

- åç»­çš„å®ç°ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°åŸºäº Spring DataBinder æ¥å®ç°ã€‚ä¸äº†è§£ DataBinder çš„èƒ–å‹ï¼Œå¯ä»¥çœ‹çœ‹ [ã€ŠSpring éªŒè¯ã€æ•°æ®ç»‘å®šå’Œç±»å‹è½¬æ¢ã€‹](https://my.oschina.net/u/2453016/blog/1512184) æ–‡ç« ã€‚

### 4.5.2.2 DubboConfigBinder

org.apache.dubbo.config.spring.context.properties.AbstractDubboConfigBinder
ï¼Œå®ç° DubboConfigBinder æ¥å£ï¼ŒDubboConfigBinder çš„æŠ½è±¡åŸºç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// AbstractDubboConfigBinder.java
public abstract class AbstractDubboConfigBinder implements DubboConfigBinder{
//*/*
/* PropertySource æ•°ç»„ï¼ˆè¿­ä»£ï¼‰
/*/
private Iterable<PropertySource<?>> propertySources;
private boolean ignoreUnknownFields = true;
private boolean ignoreInvalidFields = false;
//*/*
/* Get multiple {@link PropertySource propertySources}
/*
/* @return multiple {@link PropertySource propertySources}
/*/
protected Iterable<PropertySource<?>> getPropertySources() {
return propertySources;
}
public boolean isIgnoreUnknownFields(){
return ignoreUnknownFields;
}
@Override
public void setIgnoreUnknownFields(boolean ignoreUnknownFields){
this.ignoreUnknownFields = ignoreUnknownFields;
}
public boolean isIgnoreInvalidFields(){
return ignoreInvalidFields;
}
@Override
public void setIgnoreInvalidFields(boolean ignoreInvalidFields){
this.ignoreInvalidFields = ignoreInvalidFields;
}
@Override
public final void setEnvironment(Environment environment){
if (environment instanceof ConfigurableEnvironment) {
this.propertySources = ((ConfigurableEnvironment) environment).getPropertySources();
}
}
}
```

- æä¾›é»˜è®¤çš„å±æ€§ã€‚

### 4.5.2.3 DefaultDubboConfigBinder

org.apache.dubbo.config.spring.context.properties.DefaultDubboConfigBinder
ï¼Œç»§æ‰¿ AbstractDubboConfigBinder æŠ½è±¡ç±»ï¼Œä½¿ç”¨ Spring DataBinder ï¼Œå°†é…ç½®å±æ€§è®¾ç½®åˆ° Dubbo Config å¯¹è±¡ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DefaultDubboConfigBinder.java
//*/*
/* Default {@link DubboConfigBinder} implementation based on Spring {@link DataBinder}
/*/
public class DefaultDubboConfigBinder extends AbstractDubboConfigBinder{
@Override
public <C extends AbstractConfig> void bind(String prefix, C dubboConfig){
// å°† dubboConfig åŒ…è£…æˆ DataBinder å¯¹è±¡
DataBinder dataBinder = new DataBinder(dubboConfig);
// Set ignored/*
// è®¾ç½®å“åº”çš„ ignored/* å±æ€§
dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());
dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());
// Get properties under specified prefix from PropertySources
// è·å¾— prefix å¼€å¤´çš„é…ç½®å±æ€§
Map<String, Object> properties = PropertySourcesUtils.getSubProperties(getPropertySources(), prefix);
// Convert Map to MutablePropertyValues
// åˆ›å»º MutablePropertyValues å¯¹è±¡
MutablePropertyValues propertyValues = new MutablePropertyValues(properties);
// Bind
// ç»‘å®šé…ç½®å±æ€§åˆ° dubboConfig ä¸­
dataBinder.bind(propertyValues);
}
}
```

- æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±ç…ä¸€çœ¼ä»£ç å³å¯ã€‚

åœ¨ [ã€ŠDubbo æºç åˆ†æ â€”â€” é›†æˆ Spring Bootã€‹](http://www.iocoder.cn/Dubbo/spring-boot-integration/) ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¦å¤–ä¸€ä¸ª AbstractDubboConfigBinder çš„å®ç°ç±» RelaxedDubboConfigBinder ï¼Œå®ƒæ˜¯åŸºäº Spring Boot [Binder](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/bind/Binder.html) è¿›è¡Œå®ç°ã€‚ğŸ˜ˆ å› ä¸ºè‰¿è‰¿æ²¡æœ‰æ·±å…¥äº†è§£è¿‡ Spring Boot Binder ç›¸å…³ï¼Œæ‰€ä»¥è¿˜è¯´ä¸å‡ºå’Œ Spring DataBinder çš„åŒºåˆ«åœ¨å“ªã€‚orz

### 4.5.3 postProcessBeforeInitialization

å®ç°

/#postProcessBeforeInitialization(Object bean, String beanName)
æ–¹æ³•ï¼Œè®¾ç½®é…ç½®å±æ€§åˆ° Dubbo Config ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboConfigBindingBeanPostProcessor.java
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException{
// åˆ¤æ–­å¿…é¡»æ˜¯ beanName ï¼Œå¹¶ä¸”æ˜¯ AbstractConfig ç±»å‹
if (beanName.equals(this.beanName) && bean instanceof AbstractConfig) {
AbstractConfig dubboConfig = (AbstractConfig) bean;
// è®¾ç½®å±æ€§åˆ° dubboConfig ä¸­
dubboConfigBinder.bind(prefix, dubboConfig);
if (log.isInfoEnabled()) {
log.info("The properties of bean [name : " + beanName + "] have been binding by prefix of " + "configuration properties : " + prefix);
}
}
return bean;
}
```

è‡³æ­¤ï¼ŒDubbo Config å¯¹è±¡çš„åˆ›å»ºå’Œå±æ€§è®¾ç½®ï¼Œå·²ç»å®Œæˆã€‚å¦‚æœèƒ–å‹è¿˜æ˜¯æœ‰ç‚¹æ‡µé€¼ï¼Œå¯ä»¥è°ƒè¯•ä¸€æ¬¡ï¼Œæ²¡æœ‰ä»€ä¹ˆå¤æ‚é€»è¾‘å“Ÿã€‚

# 5. @DubboComponentScan

org.apache.dubbo.config.spring.context.annotation.@DubboComponentScan
æ³¨è§£ï¼Œé…ç½®è¦æ‰«æ

@Service
å’Œ

@Reference
æ³¨è§£çš„åŒ…æˆ–è€…ç±»ä»¬ï¼Œä»è€Œåˆ›å»ºå¯¹åº”çš„ Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboComponentScan.java
//*/*
/* Dubbo Component Scan {@link Annotation},scans the classpath for annotated components that will be auto-registered as
/* Spring beans. Dubbo-provided {@link Service} and {@link Reference}.
/*
/* @see Service
/* @see Reference
/* @since 2.5.7
/*/
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(DubboComponentScanRegistrar.class)
public @interface DubboComponentScan {
//*/*
/* å’Œ {@link /#basePackages()} ç­‰ä»·
/*
/* Alias for the {@link /#basePackages()} attribute. Allows for more concise annotation
/* declarations e.g.: {@code @DubboComponentScan("org.my.pkg")} instead of
/* {@code @DubboComponentScan(basePackages="org.my.pkg")}.
/*
/* @return the base packages to scan
/*/
String[] value() default {};
//*/*
/* è¦æ‰«æçš„åŒ…çš„æ•°ç»„
/*
/* Base packages to scan for annotated @Service classes. {@link /#value()} is an
/* alias for (and mutually exclusive with) this attribute.
/* <p>
/* Use {@link /#basePackageClasses()} for a type-safe alternative to String-based
/* package names.
/*
/* @return the base packages to scan
/*/
String[] basePackages() default {};
//*/*
/* è¦æ‰«æçš„ç±»çš„æ•°ç»„
/*
/* Type-safe alternative to {@link /#basePackages()} for specifying the packages to
/* scan for annotated @Service classes. The package of each class specified will be
/* scanned.
/*
/* @return classes from the base packages to scan
/*/
Class<?>[] basePackageClasses() default {};
}
```

- @Import(DubboComponentScanRegistrar.class)
  æ³¨è§£ï¼Œè¡¨æ˜ä½¿ç”¨ DubboComponentScanRegistrar ç±»è¿›è¡Œå¯¼å…¥ã€‚è¯¦ç»†çš„ï¼Œæˆ‘ä»¬ç»§ç»­æ¥çœ‹ [ã€Œ5.1 DubboComponentScanRegistrarã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ã€‚

## 5.1 DubboComponentScanRegistrar

org.apache.dubbo.config.spring.context.annotation.DubboComponentScanRegistrar
ï¼Œå®ç° ImportBeanDefinitionRegistrar æ¥å£ï¼Œå¤„ç†

@DubboComponentScan
æ³¨è§£ï¼Œæ³¨å†Œç›¸åº”çš„ ServiceAnnotationBeanPostProcessor å’Œ ReferenceAnnotationBeanPostProcessor åˆ° Spring å®¹å™¨ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboComponentScanRegistrar.java
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){
// <1> è·å¾—è¦æ‰«æçš„åŒ…
Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);
// <2> åˆ›å»º ServiceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ `@Service` æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Service Bean å¯¹è±¡
registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);
// <3> åˆ›å»º ReferenceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ `@Reference` æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Reference Bean å¯¹è±¡
registerReferenceAnnotationBeanPostProcessor(registry);
}
// ... çœç•¥ç¨åè°ƒç”¨çš„æ–¹æ³•ã€‚
```

- <1>
  å¤„ï¼Œè°ƒç”¨

/#getPackagesToScan(AnnotationMetadata metadata)
æ–¹æ³•ï¼Œè·å¾—è¦æ‰«æçš„åŒ…ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboComponentScanRegistrar.java
private Set<String> getPackagesToScan(AnnotationMetadata metadata){
// è·å¾— @DubboComponentScan æ³¨è§£
AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(DubboComponentScan.class.getName()));
// è·å¾—å…¶ä¸Šçš„å±æ€§
String[] basePackages = attributes.getStringArray("basePackages");
Class<?>[] basePackageClasses = attributes.getClassArray("basePackageClasses");
String[] value = attributes.getStringArray("value");
// Appends value array attributes
// æƒ…å†µä¸€ï¼Œå°†å±æ€§æ·»åŠ åˆ° packagesToScan é›†åˆä¸­
Set<String> packagesToScan = new LinkedHashSet<String>(Arrays.asList(value));
packagesToScan.addAll(Arrays.asList(basePackages));
for (Class<?> basePackageClass : basePackageClasses) {
packagesToScan.add(ClassUtils.getPackageName(basePackageClass));
}
// æƒ…å†µäºŒï¼Œå¦‚æœ packagesToScan ä¸ºç©ºï¼Œåˆ™é»˜è®¤ä½¿ç”¨æ³¨è§£ç±»æ‰€åœ¨çš„åŒ…
if (packagesToScan.isEmpty()) {
return Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));
}
return packagesToScan;
}
```

- æœ‰ä¸¤ç§æƒ…å†µï¼Œèƒ–å‹çœ‹çš„æ—¶å€™ï¼Œè¦æ³¨æ„ä¸‹ã€‚
- <2>
  å¤„ï¼Œè°ƒç”¨

/#registerServiceAnnotationBeanPostProcessor(Set<String> packagesToScan, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œåˆ›å»º ServiceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ

@Service
æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Service Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboComponentScanRegistrar.java
private void registerServiceAnnotationBeanPostProcessor(Set<String> packagesToScan, BeanDefinitionRegistry registry){
// åˆ›å»º BeanDefinitionBuilder å¯¹è±¡
BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);
// è®¾ç½®æ„é€ æ–¹æ³•å‚æ•°ä¸º packagesToScan ï¼Œå³ BeanDefinitionBuilder æ‰«æè¯¥åŒ…
builder.addConstructorArgValue(packagesToScan);
// è®¾ç½® role å±æ€§
builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
// è·å¾— AbstractBeanDefinition å¯¹è±¡
AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
// æ³¨å†Œåˆ° registry ä¸­
BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);
}
```

- å…³äº ServiceAnnotationBeanPostProcessor ç±»ï¼Œæˆ‘ä»¬åœ¨ [ã€Œ5.2 ServiceAnnotationBeanPostProcessorã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ä¸­ï¼Œè¯¦ç»†è§£æã€‚
- <3>
  å¤„ï¼Œè°ƒç”¨

/#registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œåˆ›å»º ReferenceAnnotationBeanPostProcessor Bean å¯¹è±¡ï¼Œåç»­æ‰«æ

@Reference
æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Reference Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DubboComponentScanRegistrar.java
private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry){
// Register @Reference Annotation Bean Processor
BeanRegistrar.registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
}
// BeanRegistrar.java
public static void registerInfrastructureBean(BeanDefinitionRegistry beanDefinitionRegistry,
String beanName, Class<?> beanType){
// ä¸å­˜åœ¨ beanName å¯¹åº”çš„ BeanDefinition å¯¹è±¡
if (!beanDefinitionRegistry.containsBeanDefinition(beanName)) {
// åˆ›å»º RootBeanDefinition å¯¹è±¡
RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
// è®¾ç½® role
beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
// æ³¨å†Œåˆ° beanDefinitionRegistry ä¸­
beanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition);
}
}
```

- å…³äº ReferenceAnnotationBeanPostProcessor ç±»ï¼Œæˆ‘ä»¬åœ¨ [ã€Œ5.3 ReferenceAnnotationBeanPostProcessorã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/)ä¸­ï¼Œè¯¦ç»†è§£æã€‚

## 5.2 ServiceAnnotationBeanPostProcessor

org.apache.dubbo.config.spring.beans.factory.annotation.ServiceAnnotationBeanPostProcessor
ï¼Œå®ç° BeanDefinitionRegistryPostProcessorã€EnvironmentAwareã€ResourceLoaderAwareã€BeanClassLoaderAware æ¥å£ï¼Œæ‰«æ

@Service
æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Service Bean å¯¹è±¡ã€‚

### 5.2.1 æ„é€ æ–¹æ³•

```
// ServiceAnnotationBeanPostProcessor.java
//*/*
/* è¦æ‰«æçš„åŒ…çš„é›†åˆ
/*/
private final Set<String> packagesToScan;
private Environment environment;
private ResourceLoader resourceLoader;
private ClassLoader classLoader;
public ServiceAnnotationBeanPostProcessor(String... packagesToScan){ // ä¸Šè¿°æ–‡ç« ä½¿ç”¨åˆ°çš„æ„é€ æ–¹æ³•
this(Arrays.asList(packagesToScan));
}
public ServiceAnnotationBeanPostProcessor(Collection<String> packagesToScan){
this(new LinkedHashSet<String>(packagesToScan));
}
public ServiceAnnotationBeanPostProcessor(Set<String> packagesToScan){
this.packagesToScan = packagesToScan;
}
```

### 5.2.2 postProcessBeanDefinitionRegistry

å®ç°

/#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ‰«æ

@Service
æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Service Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException{
// <1> è§£æ packagesToScan é›†åˆã€‚å› ä¸ºï¼Œå¯èƒ½å­˜åœ¨å ä½ç¬¦
Set<String> resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);
// <2> æ‰«æ packagesToScan åŒ…ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Service Bean å¯¹è±¡ã€‚
if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) {
registerServiceBeans(resolvedPackagesToScan, registry);
} else {
if (logger.isWarnEnabled()) {
logger.warn("packagesToScan is empty , ServiceBean registry will be ignored!");
}
}
}
```

- <1>
  å¤„ï¼Œè°ƒç”¨

/#resolvePackagesToScan(Set<String> packagesToScan)
æ–¹æ³•ï¼Œè§£æ

packagesToScan
é›†åˆã€‚å› ä¸ºï¼Œå¯èƒ½å­˜åœ¨å ä½ç¬¦ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
private Set<String> resolvePackagesToScan(Set<String> packagesToScan){
Set<String> resolvedPackagesToScan = new LinkedHashSet<String>(packagesToScan.size());
// éå† packagesToScan æ•°ç»„
for (String packageToScan : packagesToScan) {
if (StringUtils.hasText(packageToScan)) {
// è§£æå¯èƒ½å­˜åœ¨çš„å ä½ç¬¦
String resolvedPackageToScan = environment.resolvePlaceholders(packageToScan.trim());
// æ·»åŠ åˆ° resolvedPackagesToScan ä¸­
resolvedPackagesToScan.add(resolvedPackageToScan);
}
}
return resolvedPackagesToScan;
}
```

- <2>
  å¤„ï¼Œè°ƒç”¨

/#registerServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ‰«æ

packagesToScan
åŒ…ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Service Bean å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5.2.3 resolvePackagesToScanã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ä¸­ã€‚

### 5.2.3 resolvePackagesToScan

/#registerServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œæ‰«æ

packagesToScan
åŒ…ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Service Bean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
private void registerServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry){
// <1.1> åˆ›å»º DubboClassPathBeanDefinitionScanner å¯¹è±¡
DubboClassPathBeanDefinitionScanner scanner = new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);
// <1.2> è·å¾— BeanNameGenerator å¯¹è±¡ï¼Œå¹¶è®¾ç½® beanNameGenerator åˆ° scanner ä¸­
BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);
scanner.setBeanNameGenerator(beanNameGenerator);
// <1.3> è®¾ç½®è¿‡æ»¤è·å¾—å¸¦æœ‰ @Service æ³¨è§£çš„ç±»
scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class));
// <2> éå† packagesToScan æ•°ç»„
for (String packageToScan : packagesToScan) {
// Registers @Service Bean first
// <2.1> æ‰§è¡Œæ‰«æ
scanner.scan(packageToScan);
// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.
// <2.2> åˆ›å»ºæ¯ä¸ªåœ¨ packageToScan æ‰«æåˆ°çš„ç±»ï¼Œå¯¹åº”çš„ BeanDefinitionHolder å¯¹è±¡ï¼Œè¿”å› BeanDefinitionHolder é›†åˆ
Set<BeanDefinitionHolder> beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);
// <2.3> æ³¨å†Œåˆ° registry ä¸­
if (!CollectionUtils.isEmpty(beanDefinitionHolders)) {
for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {
registerServiceBean(beanDefinitionHolder, registry, scanner);
}
if (logger.isInfoEnabled()) {
logger.info(beanDefinitionHolders.size() + " annotated Dubbo's @Service Components { " + beanDefinitionHolders + " } were scanned under package[" + packageToScan + "]");
}
} else {
if (logger.isWarnEnabled()) {
logger.warn("No Spring Bean annotating Dubbo's @Service was found under package[" + packageToScan + "]");
}
}
}
}
```

- <1.1>
  å¤„ï¼Œåˆ›å»º DubboClassPathBeanDefinitionScanner å¯¹è±¡ã€‚å®ƒæ˜¯ç”¨äºæ‰«ææŒ‡å®šåŒ…ä¸‹ç¬¦åˆæ¡ä»¶çš„ç±»ï¼Œç”¨äºå°†æ¯ä¸ªç¬¦åˆæ¡ä»¶çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Bean ã€‚å…³äº DubboClassPathBeanDefinitionScanner ç±»ï¼Œèƒ–å‹ç‚¹å‡» [é“¾æ¥](https://github.com/apache/incubator-dubbo/blob/master/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessor.java) ç…ä¸€çœ¼å³å¯ã€‚
- <1.2>
  å¤„ï¼Œè°ƒç”¨

/#resolveBeanNameGenerator(BeanDefinitionRegistry registry)
æ–¹æ³•ï¼Œè·å¾— BeanNameGenerator å¯¹è±¡ï¼Œå¹¶è®¾ç½®

beanNameGenerator
åˆ°

scanner
ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
//*/*
/* It'd better to use BeanNameGenerator instance that should reference
/* {@link ConfigurationClassPostProcessor/#componentScanBeanNameGenerator},
/* thus it maybe a potential problem on bean name generation.
/*
/* @param registry {@link BeanDefinitionRegistry}
/* @return {@link BeanNameGenerator} instance
/* @see SingletonBeanRegistry
/* @see AnnotationConfigUtils/#CONFIGURATION_BEAN_NAME_GENERATOR
/* @see ConfigurationClassPostProcessor/#processConfigBeanDefinitions
/* @since 2.5.8
/*/
@SuppressWarnings("Duplicates")
private BeanNameGenerator resolveBeanNameGenerator(BeanDefinitionRegistry registry){
BeanNameGenerator beanNameGenerator = null;
// å¦‚æœæ˜¯ SingletonBeanRegistry ç±»å‹ï¼Œä»ä¸­è·å¾—å¯¹åº”çš„ BeanNameGenerator Bean å¯¹è±¡
if (registry instanceof SingletonBeanRegistry) {
SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry.class.cast(registry);
beanNameGenerator = (BeanNameGenerator) singletonBeanRegistry.getSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
}
// å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»º AnnotationBeanNameGenerator å¯¹è±¡
if (beanNameGenerator == null) {
if (logger.isInfoEnabled()) {
logger.info("BeanNameGenerator bean can't be found in BeanFactory with name [" + CONFIGURATION_BEAN_NAME_GENERATOR + "]");
logger.info("BeanNameGenerator will be a instance of " + AnnotationBeanNameGenerator.class.getName() + " , it maybe a potential problem on bean name generation.");
}
beanNameGenerator = new AnnotationBeanNameGenerator();
}
return beanNameGenerator;
}
```

- <1.3>
  å¤„ï¼Œè®¾ç½®è¿‡æ»¤è·å¾—å¸¦æœ‰

@Service
æ³¨è§£çš„ç±»ã€‚å…³äº

@Service
æ³¨è§£çš„å…·ä½“çš„å±æ€§ï¼Œæœ¬æ–‡å°±ä¸è¿‡åˆ†ä»‹ç»ï¼Œèƒ–å‹è‡ªå·±ç…ç…ã€‚

- <2>
  å¤„ï¼Œéå†

packagesToScan
æ•°ç»„ã€‚

- <2.1>
  å¤„ï¼Œè°ƒç”¨

DubboClassPathBeanDefinitionScanner/#scan(String... basePackages)
æ–¹æ³•ï¼Œæ‰§è¡Œæ‰«æã€‚

- <2.2>
  å¤„ï¼Œè°ƒç”¨

/#findServiceBeanDefinitionHolders(ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry, BeanNameGenerator beanNameGenerator)
æ–¹æ³•ï¼Œåˆ›å»ºæ¯ä¸ªåœ¨

packageToScan
æ‰«æåˆ°çš„ç±»ï¼Œå¯¹åº”çš„ BeanDefinitionHolder å¯¹è±¡ï¼Œè¿”å› BeanDefinitionHolder é›†åˆã€‚è¯¦ç»†è§£æ ï¼Œè§ [ã€Œ5.2.4 findServiceBeanDefinitionHoldersã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ä¸­ã€‚

- <2.3>
  å¤„ï¼Œè°ƒç”¨

/#registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner)
æ–¹æ³•ï¼Œæ³¨å†Œåˆ°

registry
ä¸­ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5.2.5 registerServiceBeanã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ä¸­ã€‚

### 5.2.4 findServiceBeanDefinitionHolders

/#findServiceBeanDefinitionHolders(ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry, BeanNameGenerator beanNameGenerator)
æ–¹æ³•ï¼Œåˆ›å»ºæ¯ä¸ªåœ¨

packageToScan
æ‰«æåˆ°çš„ç±»ï¼Œå¯¹åº”çš„ BeanDefinitionHolder å¯¹è±¡ï¼Œè¿”å› BeanDefinitionHolder é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
//*/*
/* Finds a {@link Set} of {@link BeanDefinitionHolder BeanDefinitionHolders} whose bean type annotated
/* {@link Service} Annotation.
/*
/* @param scanner {@link ClassPathBeanDefinitionScanner}
/* @param packageToScan pachage to scan
/* @param registry {@link BeanDefinitionRegistry}
/* @return non-null
/* @since 2.5.8
/*/
@SuppressWarnings("Duplicates")
private Set<BeanDefinitionHolder> findServiceBeanDefinitionHolders(
ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry,
BeanNameGenerator beanNameGenerator){
// è·å¾— packageToScan åŒ…ä¸‹ç¬¦åˆæ¡ä»¶çš„ BeanDefinition é›†åˆ
Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(packageToScan);
// åˆ›å»º BeanDefinitionHolder é›†åˆ
Set<BeanDefinitionHolder> beanDefinitionHolders = new LinkedHashSet<BeanDefinitionHolder>(beanDefinitions.size());
// éå† beanDefinitions æ•°ç»„
for (BeanDefinition beanDefinition : beanDefinitions) {
// è·å¾— Bean çš„åå­—
String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);
// åˆ›å»º BeanDefinitionHolder å¯¹è±¡
BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(beanDefinition, beanName);
// æ·»åŠ åˆ° beanDefinitions ä¸­
beanDefinitionHolders.add(beanDefinitionHolder);
}
return beanDefinitionHolders;
}
```

### 5.2.5 registerServiceBean

/#registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner)
æ–¹æ³•ï¼Œæ³¨å†Œåˆ°

registry
ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
//*/*
/* Registers {@link ServiceBean} from new annotated {@link Service} {@link BeanDefinition}
/*
/* @param beanDefinitionHolder
/* @param registry
/* @param scanner
/* @see ServiceBean
/* @see BeanDefinition
/*/
@SuppressWarnings("Duplicates")
private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,
DubboClassPathBeanDefinitionScanner scanner){
// <1.1> è§£æ Bean çš„ç±»
Class<?> beanClass = resolveClass(beanDefinitionHolder);
// <1.2> è·å¾— @Service æ³¨è§£
Service service = AnnotationUtils.findAnnotation(beanClass, Service.class);
// <1.3> è·å¾— Service æ¥å£
Class<?> interfaceClass = resolveServiceInterfaceClass(beanClass, service);
// <1.4> è·å¾— Bean çš„åå­—
String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();
// <1.5> åˆ›å»º AbstractBeanDefinition å¯¹è±¡
AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);
// ServiceBean Bean name
// <2> é‡æ–°ç”Ÿæˆ Bean çš„åå­—
String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);
// <3> æ ¡éªŒåœ¨ scanner ä¸­ï¼Œå·²ç»å­˜åœ¨ beanName ã€‚è‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œæ³¨å†Œã€‚
if (scanner.checkCandidate(beanName, serviceBeanDefinition)) { // check duplicated candidate bean
registry.registerBeanDefinition(beanName, serviceBeanDefinition);
if (logger.isInfoEnabled()) {
logger.info("The BeanDefinition[" + serviceBeanDefinition + "] of ServiceBean has been registered with name : " + beanName);
}
} else {
if (logger.isWarnEnabled()) {
logger.warn("The Duplicated BeanDefinition[" + serviceBeanDefinition + "] of ServiceBean[ bean name : " + beanName + "] was be found , Did @DubboComponentScan scan to same package in many times?");
}
}
}
```

- <1.1>
  å¤„ï¼Œè°ƒç”¨

/#resolveClass(BeanDefinitionHolder beanDefinitionHolder)
æ–¹æ³•ï¼Œè§£æè¿”å› Bean çš„ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
private Class<?> resolveClass(BeanDefinitionHolder beanDefinitionHolder) {
BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();
return resolveClass(beanDefinition);
}
private Class<?> resolveClass(BeanDefinition beanDefinition) {
String beanClassName = beanDefinition.getBeanClassName();
return ClassUtils.resolveClassName(beanClassName, classLoader);
}
```

- å› ä¸º BeanDefinition çš„

beanClassName
æ˜¯ String ç±»å‹ï¼Œæ‰€ä»¥å¾—è½¬æ¢æˆ Class ç±»å‹ã€‚

- <1.2>
  å¤„ï¼Œè·å¾—

@Service
æ³¨è§£ã€‚

- <1.3>
  å¤„ï¼Œè°ƒç”¨

/#resolveServiceInterfaceClass(Class<?> annotatedServiceBeanClass, Service service)
æ–¹æ³•ï¼Œè·å¾— Service æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
@SuppressWarnings("Duplicates")
private Class<?> resolveServiceInterfaceClass(Class<?> annotatedServiceBeanClass, Service service) {
// é¦–å…ˆï¼Œä»æ³¨è§£æœ¬èº«ä¸Šè·å¾—
Class<?> interfaceClass = service.interfaceClass();
if (void.class.equals(interfaceClass)) { // ä¸€èˆ¬æ˜¯æ»¡è¶³çš„
interfaceClass = null;
// è·å¾— @Service æ³¨è§£çš„ interfaceName å±æ€§ã€‚
String interfaceClassName = service.interfaceName();
// å¦‚æœå­˜åœ¨ï¼Œè·å¾—å…¶å¯¹åº”çš„ç±»
if (StringUtils.hasText(interfaceClassName)) {
if (ClassUtils.isPresent(interfaceClassName, classLoader)) {
interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);
}
}
}
// <X>ã€ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä½¿ç”¨è¿™ä¸ªã€‘è·å¾—ä¸åˆ°ï¼Œåˆ™ä»è¢«æ³¨è§£çš„ç±»ä¸Šè·å¾—å…¶å®ç°çš„é¦–ä¸ªæ¥å£
if (interfaceClass == null) {
Class<?>[] allInterfaces = annotatedServiceBeanClass.getInterfaces();
if (allInterfaces.length > 0) {
interfaceClass = allInterfaces[0];
}
}
Assert.notNull(interfaceClass, "@Service interfaceClass() or interfaceName() or interface class must be present!");
Assert.isTrue(interfaceClass.isInterface(), "The type that was annotated @Service is not an interface!");
return interfaceClass;
}
```

- è™½ç„¶ä»£ç æ¯”è¾ƒé•¿ï¼Œä½†æ˜¯é‡ç‚¹çœ‹

<X>
å¤„ï¼Œä»è¢«æ³¨è§£çš„ç±»ä¸Šè·å¾—å…¶å®ç°çš„é¦–ä¸ªæ¥å£ã€‚
* <1.4>
å¤„ï¼Œè·å¾— Bean çš„åå­—ã€‚
* <1.5>
å¤„ï¼Œè°ƒç”¨

/#buildServiceBeanDefinition(Service service, Class<?> interfaceClass, String annotatedServiceBeanName)
æ–¹æ³•ï¼Œåˆ›å»º AbstractBeanDefinition å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
@SuppressWarnings("Duplicates")
private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class<?> interfaceClass, String annotatedServiceBeanName){
// åˆ›å»º BeanDefinitionBuilder å¯¹è±¡
BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceBean.class);
// è·å¾— AbstractBeanDefinition å¯¹è±¡
AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
// è·å¾— MutablePropertyValues å±æ€§ã€‚åç»­ ï¼Œé€šè¿‡å‘å®ƒæ·»åŠ å±æ€§ï¼Œè®¾ç½®åˆ° BeanDefinition ä¸­ï¼Œå³ Service Bean ä¸­ã€‚
MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();
// <X> åˆ›å»º AnnotationPropertyValuesAdapter å¯¹è±¡ï¼Œæ·»åŠ åˆ° propertyValues ä¸­ã€‚
// æ­¤å¤„ï¼Œæ˜¯å°†æ³¨è§£ä¸Šçš„å±æ€§ï¼Œè®¾ç½®åˆ° propertyValues ä¸­
String[] ignoreAttributeNames = of("provider", "monitor", "application", "module", "registry", "protocol", "interface", "interfaceName"); // å¿½ç•¥çš„å±æ€§ï¼Œä¸‹é¢è¿›è¡Œå•ç‹¬è®¾ç½®ã€‚
propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));
// References "ref" property to annotated-@Service Bean
// è®¾ç½® ref å±æ€§æŒ‡å‘çš„ Service Bean åå­—
addPropertyReference(builder, "ref", annotatedServiceBeanName);
// Set interface è®¾ç½® Service æ¥å£ç±»å…¨ç±»å
builder.addPropertyValue("interface", interfaceClass.getName());
//*/*
/* Add {@link org.apache.dubbo.config.ProviderConfig} Bean reference
/*
/* æ·»åŠ  provider å±æ€§å¯¹åº”çš„ ProviderConfig Bean å¯¹è±¡
/*/
String providerConfigBeanName = service.provider();
if (StringUtils.hasText(providerConfigBeanName)) {
addPropertyReference(builder, "provider", providerConfigBeanName);
}
//*/*
/* Add {@link org.apache.dubbo.config.MonitorConfig} Bean reference
/*
/* æ·»åŠ  monitor å±æ€§å¯¹åº”çš„ MonitorConfig Bean å¯¹è±¡
/*/
String monitorConfigBeanName = service.monitor();
if (StringUtils.hasText(monitorConfigBeanName)) {
addPropertyReference(builder, "monitor", monitorConfigBeanName);
}
//*/*
/* Add {@link org.apache.dubbo.config.ApplicationConfig} Bean reference
/*
/* æ·»åŠ  application å±æ€§å¯¹åº”çš„ ApplicationConfig Bean å¯¹è±¡
/*/
String applicationConfigBeanName = service.application();
if (StringUtils.hasText(applicationConfigBeanName)) {
addPropertyReference(builder, "application", applicationConfigBeanName);
}
//*/*
/* Add {@link org.apache.dubbo.config.ModuleConfig} Bean reference
/*
/* æ·»åŠ  module å±æ€§å¯¹åº”çš„ ModuleConfig Bean å¯¹è±¡
/*/
String moduleConfigBeanName = service.module();
if (StringUtils.hasText(moduleConfigBeanName)) {
addPropertyReference(builder, "module", moduleConfigBeanName);
}
//*/*
/* Add {@link org.apache.dubbo.config.RegistryConfig} Bean reference
/*
/* æ·»åŠ  registries å±æ€§å¯¹åº”çš„ RegistryConfig Bean æ•°ç»„ï¼ˆä¸€ä¸ªæˆ–å¤šä¸ªï¼‰
/*/
String[] registryConfigBeanNames = service.registry();
List<RuntimeBeanReference> registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);
if (!registryRuntimeBeanReferences.isEmpty()) {
builder.addPropertyValue("registries", registryRuntimeBeanReferences);
}
//*/*
/* Add {@link org.apache.dubbo.config.ProtocolConfig} Bean reference
/*
/* æ·»åŠ  protocols å±æ€§å¯¹åº”çš„ ProtocolConfig Bean æ•°ç»„ï¼ˆä¸€ä¸ªæˆ–å¤šä¸ªï¼‰
/*/
String[] protocolConfigBeanNames = service.protocol();
List<RuntimeBeanReference> protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);
if (!protocolRuntimeBeanReferences.isEmpty()) {
builder.addPropertyValue("protocols", protocolRuntimeBeanReferences);
}
return builder.getBeanDefinition();
}
// RuntimeBeanReference ï¼Œåœ¨è§£æåˆ°ä¾èµ–çš„Beançš„æ—¶ä¾¯ï¼Œè§£æå™¨ä¼šä¾æ®ä¾èµ–beançš„nameåˆ›å»ºä¸€ä¸ªRuntimeBeanReferenceå¯¹åƒï¼Œå°†è¿™ä¸ªå¯¹åƒæ”¾å…¥BeanDefinitionçš„MutablePropertyValuesä¸­ã€‚
// æ­¤å¤„ï¼Œå’Œä¸Šé¢ä¸å¤ªä¸€æ ·çš„åŸå› ï¼Œå› ä¸ºæ˜¯å¤šä¸ª
@SuppressWarnings("Duplicates")
private ManagedList<RuntimeBeanReference> toRuntimeBeanReferences(String... beanNames){
ManagedList<RuntimeBeanReference> runtimeBeanReferences = new ManagedList<RuntimeBeanReference>();
if (!ObjectUtils.isEmpty(beanNames)) {
for (String beanName : beanNames) {
// è§£æçœŸæ­£çš„ Bean åå­—ï¼Œå¦‚æœæœ‰å ä½ç¬¦çš„è¯
String resolvedBeanName = environment.resolvePlaceholders(beanName);
runtimeBeanReferences.add(new RuntimeBeanReference(resolvedBeanName));
}
}
return runtimeBeanReferences;
}
// æ·»åŠ å±æ€§å€¼æ˜¯å¼•ç”¨ç±»å‹
private void addPropertyReference(BeanDefinitionBuilder builder, String propertyName, String beanName){
String resolvedBeanName = environment.resolvePlaceholders(beanName);
builder.addPropertyReference(propertyName, resolvedBeanName);
}
```

- æ¯”è¾ƒå†—é•¿ï¼Œé¡ºç€å¾€ä¸‹çœ‹å³å¯ã€‚
- <X>
  å¤„ï¼Œåˆ›å»º AnnotationPropertyValuesAdapter å¯¹è±¡ï¼Œæ·»åŠ åˆ°

propertyValues
ä¸­ã€‚æ­¤å¤„ï¼Œæ˜¯å°†æ³¨è§£ä¸Šçš„å±æ€§ï¼Œè®¾ç½®åˆ°

propertyValues
ä¸­ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ³¨è§£ä¸Šçš„å±æ€§ï¼Œè‡ªç„¶çš„èƒ½å¤Ÿè®¾ç½®åˆ°åç»­åˆ›å»ºçš„ Service Bean çš„å¯¹è±¡ä¸­ã€‚

- ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœè¯´

@Service(version="1.0.0")
ï¼Œé‚£ä¹ˆè¿™ä¸ªç‰ˆæœ¬å·ï¼ˆ

version
ï¼‰ï¼Œå°±å¯ä»¥è®¾ç½®åˆ° Dubbo Service Bean ä¸­å»äº†ã€‚

- å…³äº

org.apache.dubbo.config.spring.beans.factory.annotation.AnnotationPropertyValuesAdapter
ç±»ï¼Œå°±æ˜¯ä¸Šè¿°çš„ç”¨é€”ï¼Œæ¯”è¾ƒç®€å•ï¼Œèƒ–å‹ç‚¹å‡» [é“¾æ¥](https://github.com/apache/incubator-dubbo/blob/ff0ce37c46523e9d0dfa13748fca339e68edc027/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapter.java) æŸ¥çœ‹å³å¯ã€‚

- <2>
  å¤„ï¼Œè°ƒç”¨

/#generateServiceBeanName(Service service, Class<?> interfaceClass, String annotatedServiceBeanName)
æ–¹æ³•ï¼Œé‡æ–°ç”Ÿæˆ Bean çš„åå­—ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceAnnotationBeanPostProcessor.java
private String generateServiceBeanName(Service service, Class<?> interfaceClass, String annotatedServiceBeanName){
ServiceBeanNameBuilder builder = ServiceBeanNameBuilder.create(service, interfaceClass, environment);
return builder.build();
}
// ServiceBeanNameBuilder.java
private static final String SEPARATOR = ":";
private final String interfaceClassName;
private final Environment environment;
// Optional
private String version;
private String group;
// ServiceBean:${interfaceClassName}:${version}:${group}
public String build(){
StringBuilder beanNameBuilder = new StringBuilder("ServiceBean");
// Required
append(beanNameBuilder, interfaceClassName);
// Optional
append(beanNameBuilder, version);
append(beanNameBuilder, group);
// Build
String rawBeanName = beanNameBuilder.toString();
// Resolve placeholders
return environment.resolvePlaceholders(rawBeanName);
}
private static void append(StringBuilder builder, String value){
if (StringUtils.hasText(value)) {
builder.append(SEPARATOR).append(value);
}
}
```

- ç»“æœç¤ºä¾‹å¦‚ä¸‹ï¼š![`beanName`](http://static2.iocoder.cn/images/Dubbo/2018_01_22/02.jpg)
- <3>
  å¤„ï¼Œæ ¡éªŒåœ¨

scanner
ä¸­ï¼Œæ˜¯å¦å·²ç»å­˜åœ¨

beanName
ã€‚è‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œæ³¨å†Œã€‚

ğŸ˜ˆ æ•´ä¸ªé€»è¾‘ï¼Œæœ‰ç‚¹é•¿é•¿æ»´ã€‚èƒ–å‹è¾›è‹¦ä¸Šä¸‹æ»‘åŠ¨ï¼Œåœ¨ç…ç…ã€‚

## 5.3 ReferenceAnnotationBeanPostProcessor

org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor
ï¼Œç»§æ‰¿ AnnotationInjectedBeanPostProcessor æŠ½è±¡ç±»ï¼Œå®ç° ApplicationContextAwareã€ApplicationListener æ¥å£ï¼Œæ‰«æ

@Reference
æ³¨è§£çš„ç±»ï¼Œåˆ›å»ºå¯¹åº”çš„ Spring BeanDefinition å¯¹è±¡ï¼Œä»è€Œåˆ›å»º Dubbo Reference Bean å¯¹è±¡ã€‚
è™½ç„¶

org.apache.dubbo.config.spring.beans.factory.annotation.AnnotationInjectedBeanPostProcessor
æ”¾åœ¨ Dubbo é¡¹ç›®ä¸­ï¼Œä½†æ˜¯æ˜¯ clone è‡ª [https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java](https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java)ç±»ã€‚æ‰€ä»¥å‘¢ï¼Œæˆ‘ä»¬å…ˆä¸æ·±ç©¶è¿™ä¸ªç±»ï¼Œåªè¦çŸ¥é“å¦‚ä¸‹ï¼š

- è‹±æ–‡ï¼šAbstract generic {@link BeanPostProcessor} implementation for customized annotation that annotated injected-object.
- ä¸­æ–‡ï¼šBeanPostProcessor çš„æŠ½è±¡å®ç°ç±»ï¼Œç”¨äºæ”¯æŒä½¿ç”¨è‡ªå®šä¹‰æ³¨è§£ï¼Œæ³¨å…¥å¯¹è±¡çš„å±æ€§ã€‚

- æ­¤æ—¶ï¼ŒReferenceAnnotationBeanPostProcessor å®ç°çš„å°±æ˜¯ æ”¯æŒ

@Reference
æ³¨è§£çš„å±æ€§æ³¨å…¥ã€‚
ç›¸å¯¹æ¥è¯´ï¼Œæœ¬èŠ‚çš„ ReferenceAnnotationBeanPostProcessor ï¼Œä¼šæ¯”ä¸Šä¸€èŠ‚çš„ ServiceAnnotationBeanPostProcessor å¤æ‚è›®å¤š~ SO ï¼Œä¿æŒè€å¿ƒå“ˆã€‚

### 5.3.1 æ„é€ æ–¹æ³•

```
// ReferenceAnnotationBeanPostProcessor.java
//*/*
/* The bean name of {@link ReferenceAnnotationBeanPostProcessor}
/*/
public static final String BEAN_NAME = "referenceAnnotationBeanPostProcessor";
//*/*
/* Cache size
/*/
private static final int CACHE_SIZE = Integer.getInteger(BEAN_NAME + ".cache.size", 32);
//*/*
/* ReferenceBean ç¼“å­˜ Map
/*
/* KEYï¼šReference Bean çš„åå­—
/*/
private final ConcurrentMap<String, ReferenceBean<?>> referenceBeanCache = new ConcurrentHashMap<String, ReferenceBean<?>>(CACHE_SIZE);
//*/*
/* ReferenceBeanInvocationHandler ç¼“å­˜ Map
/*
/* KEYï¼šReference Bean çš„åå­—
/*/
private final ConcurrentHashMap<String, ReferenceBeanInvocationHandler> localReferenceBeanInvocationHandlerCache = new ConcurrentHashMap<String, ReferenceBeanInvocationHandler>(CACHE_SIZE);
//*/*
/* ä½¿ç”¨å±æ€§è¿›è¡Œæ³¨å…¥çš„ @Reference Bean çš„ç¼“å­˜ Map
/*
/* ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä½¿ç”¨è¿™ä¸ª
/*/
private final ConcurrentMap<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedFieldReferenceBeanCache = new ConcurrentHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>(CACHE_SIZE);
//*/*
/* ä½¿ç”¨æ–¹æ³•è¿›è¡Œæ³¨å…¥çš„ @Reference Bean çš„ç¼“å­˜ Map
/*/
private final ConcurrentMap<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedMethodReferenceBeanCache = new ConcurrentHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>(CACHE_SIZE);
private ApplicationContext applicationContext;
```

- å…·ä½“çš„æ¯ä¸ªå˜é‡çš„æ—¶å€™ï¼Œç»“åˆä¸‹é¢æ¥çœ‹ã€‚

### 5.3.2 doGetInjectedBean

å®ç°

/#doGetInjectedBean(Reference reference, Object bean, String beanName, Class<?> injectedType, InjectionMetadata.InjectedElement injectedElement)
æ–¹æ³•ï¼Œè·å¾—è¦æ³¨å…¥çš„

@Reference
Bean ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
@Override
protected Object doGetInjectedBean(Reference reference, Object bean, String beanName, Class<?> injectedType,
InjectionMetadata.InjectedElement injectedElement) throws Exception{
// <1> è·å¾— Reference Bean çš„åå­—
String referencedBeanName = buildReferencedBeanName(reference, injectedType);
// <2> åˆ›å»º ReferenceBean å¯¹è±¡
ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader());
// <3> ç¼“å­˜åˆ° injectedFieldReferenceBeanCache or injectedMethodReferenceBeanCache ä¸­
cacheInjectedReferenceBean(referenceBean, injectedElement);
// <4> åˆ›å»º Proxy ä»£ç†å¯¹è±¡
return buildProxy(referencedBeanName, referenceBean, injectedType);
}
```

- <1>
  å¤„ï¼Œè°ƒç”¨

/#buildReferencedBeanName(Reference reference, Class<?> injectedType)
æ–¹æ³•ï¼Œè·å¾— Reference Bean çš„åå­—ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
private String buildReferencedBeanName(Reference reference, Class<?> injectedType){
// åˆ›å»º Service Bean çš„åå­—
ServiceBeanNameBuilder builder = ServiceBeanNameBuilder.create(reference, injectedType, getEnvironment());
return getEnvironment().resolvePlaceholders(builder.build()); // è¿™é‡Œï¼Œè²Œä¼¼é‡å¤è§£æå ä½ç¬¦äº†ã€‚ä¸è¿‡æ²¡å•¥å½±å“~
}
```

- å®é™…ä¸Šï¼Œä½¿ç”¨çš„å°±æ˜¯ ServiceBeanNameBuilder çš„é€»è¾‘ï¼Œå³å’Œ Dubbo Service Bean çš„åå­—ï¼Œæ˜¯ åŒä¸€å¥—ã€‚å½“ç„¶ï¼Œè¿™ä¸ªä¹Ÿéå¸¸åˆç†~
- <2>
  å¤„ï¼Œè°ƒç”¨

/#buildReferenceBeanIfAbsent(String referencedBeanName, Reference reference, Class<?> referencedType, ClassLoader classLoader)
æ–¹æ³•ï¼Œåˆ›å»ºï¼ˆè·å¾—ï¼‰ ReferenceBean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
private ReferenceBean buildReferenceBeanIfAbsent(String referencedBeanName, Reference reference, Class<?> referencedType, ClassLoader classLoader)
throws Exception{
// é¦–å…ˆï¼Œä» referenceBeanCache ç¼“å­˜ä¸­ï¼Œè·å¾— referencedBeanName å¯¹åº”çš„ ReferenceBean å¯¹è±¡
ReferenceBean<?> referenceBean = referenceBeanCache.get(referencedBeanName);
// ç„¶åï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»ºã€‚ç„¶åï¼Œæ·»åŠ åˆ° referenceBeanCache ç¼“å­˜ä¸­ã€‚
if (referenceBean == null) {
ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder
.create(reference, classLoader, applicationContext)
.interfaceClass(referencedType);
referenceBean = beanBuilder.build();
referenceBeanCache.put(referencedBeanName, referenceBean);
}
return referenceBean;
}
```

- å…¶ä¸­ï¼Œä¼šä½¿ç”¨ ReferenceBeanBuilder ç±»ï¼Œæ„å»º ReferenceBean å¯¹è±¡ã€‚å…³äºå®ƒï¼Œæˆ‘ä»¬ç¨ååœ¨ [ã€Œ5.3.4 ReferenceBeanBuilderã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) æ¥ç…ç…ã€‚å®é™…ä¸Šï¼Œå’Œä¸Šé¢ ServiceBean çš„æ„å»ºï¼Œä¹Ÿå·®ä¸äº†å¤ªå¤šã€‚
- <3>
  å¤„ï¼Œè°ƒç”¨

/#cacheInjectedReferenceBean(String referencedBeanName, Reference reference, Class<?> referencedType, ClassLoader classLoader)
æ–¹æ³•ï¼Œç¼“å­˜åˆ°

injectedFieldReferenceBeanCache
or

injectedMethodReferenceBeanCache
ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
private void cacheInjectedReferenceBean(ReferenceBean referenceBean, InjectionMetadata.InjectedElement injectedElement){
if (injectedElement.getMember() instanceof Field) {
injectedFieldReferenceBeanCache.put(injectedElement, referenceBean);
} else if (injectedElement.getMember() instanceof Method) {
injectedMethodReferenceBeanCache.put(injectedElement, referenceBean);
}
}
```

- <4>
  å¤„ï¼Œè°ƒç”¨

/#buildProxy(String referencedBeanName, ReferenceBean referenceBean, Class<?> injectedType)
æ–¹æ³•ï¼Œåˆ›å»º Proxy ä»£ç†å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
private Object buildProxy(String referencedBeanName, ReferenceBean referenceBean, Class<?> injectedType){
InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean);
return Proxy.newProxyInstance(getClassLoader(), new Class[]{injectedType}, handler);
}
private InvocationHandler buildInvocationHandler(String referencedBeanName, ReferenceBean referenceBean){
// é¦–å…ˆï¼Œä» localReferenceBeanInvocationHandlerCache ç¼“å­˜ä¸­ï¼Œè·å¾— ReferenceBeanInvocationHandler å¯¹è±¡
ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName);
// ç„¶åï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»º ReferenceBeanInvocationHandler å¯¹è±¡
if (handler == null) {
handler = new ReferenceBeanInvocationHandler(referenceBean);
}
// <X> ä¹‹åï¼Œæ ¹æ®å¼•ç”¨çš„ Dubbo æœåŠ¡æ˜¯è¿œç¨‹çš„è¿˜æ˜¯æœ¬åœ°çš„ï¼Œåšä¸åŒçš„å¤„ç†ã€‚
// ã€æœ¬åœ°ã€‘åˆ¤æ–­å¦‚æœ applicationContext ä¸­å·²ç»åˆå§‹åŒ–ï¼Œè¯´æ˜æ˜¯æœ¬åœ°çš„ @Service Bean ï¼Œåˆ™æ·»åŠ åˆ° localReferenceBeanInvocationHandlerCache ç¼“å­˜ä¸­ã€‚
// ç­‰åˆ°æœ¬åœ°çš„ @Service Bean æš´éœ²åï¼Œå†è¿›è¡Œåˆå§‹åŒ–ã€‚
if (applicationContext.containsBean(referencedBeanName)) { // Is local @Service Bean or not ?
// ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported.
localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler);
// ã€è¿œç¨‹ã€‘åˆ¤æ–­è‹¥æœ applicationContext ä¸­æœªåˆå§‹åŒ–ï¼Œè¯´æ˜æ˜¯è¿œç¨‹çš„ @Service Bean å¯¹è±¡ï¼Œåˆ™ç«‹å³è¿›è¡Œåˆå§‹åŒ–
} else {
// Remote Reference Bean should initialize immediately
handler.init();
}
return handler;
}
```

- æ¯”è¾ƒå¤æ‚çš„æ˜¯ï¼Œ

<X>
å¤„ï¼Œæ ¹æ®å¼•ç”¨çš„ Dubbo æœåŠ¡æ˜¯è¿œç¨‹çš„è¿˜æ˜¯æœ¬åœ°çš„ï¼Œåšä¸åŒçš„å¤„ç†ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

- è¿œç¨‹çš„ Dubbo æœåŠ¡ï¼Œç†è®ºæ¥è¯´ï¼ˆä¸è€ƒè™‘å¯¹æ–¹æŒ‚æ‰çš„æƒ…å†µï¼‰ï¼Œæ˜¯å·²ç»å­˜åœ¨ï¼Œæ­¤æ—¶å¯ä»¥è¿›è¡ŒåŠ è½½å¼•ç”¨ã€‚
- æœ¬åœ°çš„ Dubbo æœåŠ¡ï¼Œæ­¤æ—¶å¹¶æœªæš´éœ²ï¼Œåˆ™å…ˆæ·»åŠ åˆ°

localReferenceBeanInvocationHandlerCache
ä¸­è¿›è¡Œç¼“å­˜ã€‚ç­‰åç»­çš„ï¼Œé€šè¿‡ Spring äº‹ä»¶ç›‘å¬çš„åŠŸèƒ½ï¼Œè¿›è¡Œå®ç°ã€‚è¯¦ç»†çš„ï¼Œæˆ‘ä»¬åœ¨ [ã€Œ5.3.3 onApplicationEventã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/)ä¸­ä¼šçœ‹åˆ°ã€‚

- ReferenceBeanInvocationHandler ï¼Œæ˜¯ ReferenceAnnotationBeanPostProcessor çš„å†…éƒ¨é™æ€ç±»ï¼Œå®ç° Dubbo InvocationHandler æ¥å£ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor/#ReferenceBeanInvocationHandler.java
private static class ReferenceBeanInvocationHandler implements InvocationHandler{
//*/*
/* ReferenceBean å¯¹è±¡
/*/
private final ReferenceBean referenceBean;
//*/*
/* Bean å¯¹è±¡
/*/
private Object bean;
private ReferenceBeanInvocationHandler(ReferenceBean referenceBean){
this.referenceBean = referenceBean;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
// è°ƒç”¨ bean çš„å¯¹åº”çš„æ–¹æ³•
return method.invoke(bean, args);
}
// é€šè¿‡åˆå§‹åŒ–æ–¹æ³•ï¼Œå¯ä»¥è·å¾— `ReferenceBean.ref`
private void init(){
this.bean = referenceBean.get();
}
}
```

- é‡å¿ƒåœ¨äº

/#init()
æ–¹æ³•ï¼Œå¯ä»¥è°ƒç”¨

ReferenceBean/#get()
æ–¹æ³•ï¼Œè¿›è¡Œå¼•ç”¨çš„ Bean çš„åˆå§‹åŒ–ï¼Œæœ€åè¿”å›å¼•ç”¨

ref
ã€‚

### 5.3.3 onApplicationEvent

å®ç°

/#onApplicationEvent(ApplicationEvent event)
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
@Override
public void onApplicationEvent(ApplicationEvent event){
if (event instanceof ServiceBeanExportedEvent) {
onServiceBeanExportEvent((ServiceBeanExportedEvent) event);
} else if (event instanceof ContextRefreshedEvent) {
onContextRefreshedEvent((ContextRefreshedEvent) event);
}
}
private void onServiceBeanExportEvent(ServiceBeanExportedEvent event){
// è·å¾— ServiceBean å¯¹è±¡
ServiceBean serviceBean = event.getServiceBean();
// åˆå§‹åŒ–å¯¹åº”çš„ ReferenceBeanInvocationHandler
initReferenceBeanInvocationHandler(serviceBean);
}
private void initReferenceBeanInvocationHandler(ServiceBean serviceBean){
String serviceBeanName = serviceBean.getBeanName();
// Remove ServiceBean when it's exported
// ä» localReferenceBeanInvocationHandlerCache ç¼“å­˜ä¸­ï¼Œç§»é™¤
ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.remove(serviceBeanName);
// Initialize
// æ‰§è¡Œåˆå§‹åŒ–
if (handler != null) {
handler.init();
}
}
private void onContextRefreshedEvent(ContextRefreshedEvent event){
}
```

- é‡ç‚¹åœ¨äºå¤„ç† ServiceBeanExportedEvent äº‹ä»¶ã€‚å¤„ç†æ—¶ï¼Œå¦‚æœåˆ¤æ–­

localReferenceBeanInvocationHandlerCache
ä¸­å­˜åœ¨ ReferenceBeanInvocationHandler å¯¹è±¡ï¼Œè¯´æ˜æœ‰å®ƒæœªåˆå§‹åŒ–ã€‚åç»­ï¼Œè°ƒç”¨

ReferenceBeanInvocationHandler/#init()
æ–¹æ³•ï¼Œä»è€Œå®Œæˆã€‚è¿™å—ï¼Œèƒ–å‹ç»“åˆ [ã€Œ5.2.2 doGetInjectedBeanã€](http://svip.iocoder.cn/Dubbo/configuration-annotation/) ä¸€èµ·ï¼Œæ˜¯ä¸æ˜¯å°±æ˜ç™½äº†ã€‚

- åœ¨ ServiceBean æš´éœ²æœåŠ¡å®Œæˆåï¼Œä¼šå‘å¸ƒ ServiceBeanExportedEvent äº‹ä»¶ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ServiceBean.java
private ApplicationEventPublisher applicationEventPublisher;
//*/*
/* @since 2.6.5
/*/
@Override
public void export(){
// æš´éœ²æœåŠ¡
super.export();
// Publish ServiceBeanExportedEvent
// å‘å¸ƒäº‹ä»¶
publishExportEvent();
}
//*/*
/* @since 2.6.5
/*/
private void publishExportEvent(){
// åˆ›å»º ServiceBeanExportedEvent å¯¹è±¡
ServiceBeanExportedEvent exportEvent = new ServiceBeanExportedEvent(this);
// å‘å¸ƒäº‹ä»¶
applicationEventPublisher.publishEvent(exportEvent);
}
```

- org.apache.dubbo.config.spring.context.event.ServiceBeanExportedEvent
  ï¼ŒService Bean æš´éœ²å®Œæˆäº‹ä»¶ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// BeanExportedEvent.java
//*/*
/* A {@link ApplicationEvent} after {@link ServiceBean} {@link ServiceBean/#export() export} invocation
/*
/* @see ApplicationEvent
/* @see ApplicationListener
/* @see ServiceBean
/* @since 2.6.5
/*/
public class ServiceBeanExportedEvent extends ApplicationEvent{
//*/*
/* Create a new ApplicationEvent.
/*
/* @param serviceBean {@link ServiceBean} bean
/*/
public ServiceBeanExportedEvent(ServiceBean serviceBean){
super(serviceBean);
}
//*/*
/* Get {@link ServiceBean} instance
/*
/* @return non-null
/*/
public ServiceBean getServiceBean(){
return (ServiceBean) super.getSource();
}
}
```

### 5.3.4 ReferenceBeanBuilder

org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceBeanBuilder
ï¼Œç»§æ‰¿ AbstractAnnotationConfigBeanBuilder æŠ½è±¡ç±»ï¼ŒReferenceBean çš„æ„å»ºå™¨ã€‚
è€ƒè™‘åˆ° ReferenceBeanBuilder ç±»ï¼Œå°±æ˜¯

/#build()
æ–¹æ³•ï¼Œæˆ‘ä»¬å°±ç›´æ¥ç»“åˆ AbstractAnnotationConfigBeanBuilder æŠ½è±¡ç±»ï¼Œä¸€èµ·å†™äº†ã€‚

### 5.3.4.1 æ„é€ æ–¹æ³•

```
// AbstractAnnotationConfigBeanBuilder.java
abstract class AbstractAnnotationConfigBeanBuilder<A extends Annotation, B extends AbstractInterfaceConfig>{
//*/*
/* æ³¨è§£
/*/
protected final A annotation;
protected final ApplicationContext applicationContext;
protected final ClassLoader classLoader;
//*/*
/* Bean å¯¹è±¡
/*/
protected Object bean;
//*/*
/* æ¥å£
/*/
protected Class<?> interfaceClass;
protected AbstractAnnotationConfigBeanBuilder(A annotation, ClassLoader classLoader,
ApplicationContext applicationContext){
Assert.notNull(annotation, "The Annotation must not be null!");
Assert.notNull(classLoader, "The ClassLoader must not be null!");
Assert.notNull(applicationContext, "The ApplicationContext must not be null!");
this.annotation = annotation;
this.applicationContext = applicationContext;
this.classLoader = classLoader;
}
}
// ReferenceBeanBuilder.java
class ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder<Reference, ReferenceBean>{
private ReferenceBeanBuilder(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext){
super(annotation, classLoader, applicationContext);
}
public static ReferenceBeanBuilder create(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext){
return new ReferenceBeanBuilder(annotation, classLoader, applicationContext);
}
}
```

- å…¶ä¸­ï¼Œæ³›å‹

A
å¯¹åº”

@Reference
æ³¨è§£ï¼Œæ³›å‹

B
å¯¹åº” ReferenceBean ç±»ã€‚

### 5.3.4.2 build

/#build()
æ–¹æ³•ï¼Œæ„é€ æ³›å‹

B
å¯¹è±¡ã€‚æ­¤å¤„ï¼Œå°±æ˜¯æ„é€  ReferenceBean å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// AbstractAnnotationConfigBeanBuilder.java
public final B build() throws Exception{
// æ ¡éªŒä¾èµ–
checkDependencies();
// æ‰§è¡Œæ„é€  Bean å¯¹è±¡
B bean = doBuild();
// é…ç½® Bean å¯¹è±¡
configureBean(bean);
if (logger.isInfoEnabled()) {
logger.info("The bean[type:" + bean.getClass().getSimpleName() + "] has been built.");
}
return bean;
}
private void checkDependencies(){
}
//*/*
/* Builds {@link B Bean}
/*
/* @return {@link B Bean}
/*/
protected abstract B doBuild();
protected void configureBean(B bean) throws Exception{
// å‰ç½®é…ç½®
preConfigureBean(annotation, bean);
// é…ç½® RegistryConfig å±æ€§
configureRegistryConfigs(bean);
// é…ç½® MonitorConfig å±æ€§
configureMonitorConfig(bean);
// é…ç½® ApplicationConfig å±æ€§
configureApplicationConfig(bean);
// é…ç½® ModuleConfig å±æ€§
configureModuleConfig(bean);
// åç½®é…ç½®
postConfigureBean(annotation, bean);
}
protected abstract void preConfigureBean(A annotation, B bean) throws Exception; // æŠ½è±¡æ–¹æ³•
private void configureRegistryConfigs(B bean){
String[] registryConfigBeanIds = resolveRegistryConfigBeanNames(annotation);
List<RegistryConfig> registryConfigs = BeanFactoryUtils.getBeans(applicationContext, registryConfigBeanIds, RegistryConfig.class);
bean.setRegistries(registryConfigs);
}
private void configureMonitorConfig(B bean){
String monitorBeanName = resolveMonitorConfigBeanName(annotation);
MonitorConfig monitorConfig = BeanFactoryUtils.getOptionalBean(applicationContext, monitorBeanName, MonitorConfig.class);
bean.setMonitor(monitorConfig);
}
private void configureApplicationConfig(B bean){
String applicationConfigBeanName = resolveApplicationConfigBeanName(annotation);
ApplicationConfig applicationConfig = BeanFactoryUtils.getOptionalBean(applicationContext, applicationConfigBeanName, ApplicationConfig.class);
bean.setApplication(applicationConfig);
}
private void configureModuleConfig(B bean){
String moduleConfigBeanName = resolveModuleConfigBeanName(annotation);
ModuleConfig moduleConfig = BeanFactoryUtils.getOptionalBean(applicationContext, moduleConfigBeanName, ModuleConfig.class);
bean.setModule(moduleConfig);
}
protected abstract String resolveModuleConfigBeanName(A annotation); // æŠ½è±¡æ–¹æ³•
protected abstract String resolveApplicationConfigBeanName(A annotation); // æŠ½è±¡æ–¹æ³•
protected abstract String[] resolveRegistryConfigBeanNames(A annotation); // æŠ½è±¡æ–¹æ³•
protected abstract String resolveMonitorConfigBeanName(A annotation); // æŠ½è±¡æ–¹æ³•
protected abstract void postConfigureBean(A annotation, B bean) throws Exception; // æŠ½è±¡æ–¹æ³•
```

- ReferenceBeanBuilder ä¸»è¦å¯¹ä¸Šé¢çš„æŠ½è±¡æ–¹æ³•ï¼Œè¿›è¡Œå…·ä½“å®ç°ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceBeanBuilder.java
static final String[] IGNORE_FIELD_NAMES = of("application", "module", "consumer", "monitor", "registry")
@Override
protected ReferenceBean doBuild(){
// åˆ›å»º ReferenceBean å¯¹è±¡
return new ReferenceBean<>();
}
@SuppressWarnings("Duplicates")
@Override
protected void preConfigureBean(Reference reference, ReferenceBean referenceBean){
Assert.notNull(interfaceClass, "The interface class must set first!");
// åˆ›å»º DataBinder å¯¹è±¡
DataBinder dataBinder = new DataBinder(referenceBean);
// Register CustomEditors for special fields
// æ³¨å†ŒæŒ‡å®šå±æ€§çš„è‡ªå®šä¹‰ Editor
dataBinder.registerCustomEditor(String.class, "filter", new StringTrimmerEditor(true));
dataBinder.registerCustomEditor(String.class, "listener", new StringTrimmerEditor(true));
dataBinder.registerCustomEditor(Map.class, "parameters", new PropertyEditorSupport() {
@Override
public void setAsText(String text) throws java.lang.IllegalArgumentException{
// Trim all whitespace
String content = StringUtils.trimAllWhitespace(text);
if (!StringUtils.hasText(content)) { // No content , ignore directly
return;
}
// replace "=" to ","
content = StringUtils.replace(content, "=", ",");
// replace ":" to ","
content = StringUtils.replace(content, ":", ",");
// String[] to Map
Map<String, String> parameters = CollectionUtils.toStringMap(commaDelimitedListToStringArray(content));
setValue(parameters);
}
});
// Bind annotation attributes
// å°†æ³¨è§£çš„å±æ€§ï¼Œè®¾ç½®åˆ° reference ä¸­
dataBinder.bind(new AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), IGNORE_FIELD_NAMES));
}
@Override
protected String resolveModuleConfigBeanName(Reference annotation){
return annotation.module();
}
@Override
protected String resolveApplicationConfigBeanName(Reference annotation){
return annotation.application();
}
@Override
protected String[] resolveRegistryConfigBeanNames(Reference annotation) {
return annotation.registry();
}
@Override
protected String resolveMonitorConfigBeanName(Reference annotation){
return annotation.monitor();
}
@Override
protected void postConfigureBean(Reference annotation, ReferenceBean bean) throws Exception{
// è®¾ç½® applicationContext
bean.setApplicationContext(applicationContext);
// é…ç½® interfaceClass
configureInterface(annotation, bean);
// é…ç½® ConsumerConfig
configureConsumerConfig(annotation, bean);
// æ‰§è¡Œ Bean åç½®å±æ€§åˆå§‹åŒ–
bean.afterPropertiesSet();
}
@SuppressWarnings("Duplicates")
private void configureInterface(Reference reference, ReferenceBean referenceBean){
// é¦–å…ˆï¼Œä» @Reference è·å¾— interfaceName å±æ€§ï¼Œä»è€Œè·å¾— interfaceClass ç±»
Class<?> interfaceClass = reference.interfaceClass();
if (void.class.equals(interfaceClass)) {
interfaceClass = null;
String interfaceClassName = reference.interfaceName();
if (StringUtils.hasText(interfaceClassName)) {
if (ClassUtils.isPresent(interfaceClassName, classLoader)) {
interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);
}
}
}
// å¦‚æœè·å¾—ä¸åˆ°ï¼Œåˆ™ä½¿ç”¨ interfaceClass å³å¯
if (interfaceClass == null) {
interfaceClass = this.interfaceClass;
}
Assert.isTrue(interfaceClass.isInterface(), "The class of field or method that was annotated @Reference is not an interface!");
referenceBean.setInterface(interfaceClass);
}
private void configureConsumerConfig(Reference reference, ReferenceBean<?> referenceBean){
// è·å¾— ConsumerConfig å¯¹è±¡
String consumerBeanName = reference.consumer();
ConsumerConfig consumerConfig = getOptionalBean(applicationContext, consumerBeanName, ConsumerConfig.class);
// è®¾ç½®åˆ° referenceBean ä¸­
referenceBean.setConsumer(consumerConfig);
}
```

- ~

ğŸ˜ˆ å†™çš„ç›¸å¯¹ç®€ç•¥ã€‚èƒ–å‹æ³¨æ„çœ‹æ¯ä¸€ä¸ªçš„æ³¨é‡Šå“ˆ~

### 5.3.5 destroy

å®ç°

/#destroy()
æ–¹æ³•ï¼Œæ‰§è¡Œé”€æ¯é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ReferenceAnnotationBeanPostProcessor.java
@Override
public void destroy() throws Exception{
// çˆ¶ç±»é”€æ¯
super.destroy();
// æ¸…ç©ºç¼“å­˜
this.referenceBeanCache.clear();
this.localReferenceBeanInvocationHandlerCache.clear();
this.injectedFieldReferenceBeanCache.clear();
this.injectedMethodReferenceBeanCache.clear();
}
```
