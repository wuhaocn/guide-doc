<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— EventLoop（八）之 EventLoop 优雅关闭
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>笔者先把 Netty 主要的内容写完，所以关于 EventLoop 的优雅关闭的分享，先放在后续的计划里。</p>
<p>当然，良心如我，还是为对这块感兴趣的胖友，先准备好了两篇不错的文章：</p>
<ul>
<li>Hypercube <a href="https://www.jianshu.com/p/088c5017acd6" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析 Netty（四）–优雅退出机制》</a></li>
<li>tomas家的小拨浪鼓 <a href="https://www.jianshu.com/p/e0ba9050aaef" rel="external nofollow noopener noreferrer" target="_blank">《Netty 源码解析 ——— Netty 优雅关闭流程》</a></li>
</ul>
<p>为避免可能 <a href="https://www.jianshu.com/p/088c5017acd6" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析 Netty（四）–优雅退出机制》</a> 被作者删除，笔者这里先复制一份作为备份。</p>
<h1 id="666-Netty优雅退出机制"><a href="#666-Netty优雅退出机制" class="headerlink" title="666. Netty优雅退出机制"></a>666. Netty优雅退出机制</h1><p>你也许已经习惯了使用下面的代码，使一个线程池退出：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">bossGroup.shutdownGracefully();</span><br></pre></td></tr></tbody></table></figure>
<p>那么它是如何工作的呢？由于bossGroup是一个线程池，线程池的关闭要求其中的每一个线程关闭。而线程的实现是在SingleThreadEventExecutor类，所以我们将再次回到这个类，首先看其中的shutdownGracefully()方法，其中的参数quietPeriod为静默时间，timeout为截止时间，此外还有一个相关参数gracefulShutdownStartTime即优雅关闭开始时间，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully(<span class="keyword">long</span> quietPeriod, <span class="keyword">long</span> timeout, TimeUnit unit) {</span><br><span class="line">    <span class="keyword">if</span> (isShuttingDown()) {</span><br><span class="line">        <span class="keyword">return</span> terminationFuture(); <span class="comment">// 正在关闭阻止其他线程</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="keyword">boolean</span> wakeup;</span><br><span class="line">    <span class="keyword">int</span> oldState;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (isShuttingDown()) {</span><br><span class="line">            <span class="keyword">return</span> terminationFuture(); <span class="comment">// 正在关闭阻止其他线程</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> newState;</span><br><span class="line">        wakeup = <span class="keyword">true</span>;</span><br><span class="line">        oldState = STATE_UPDATER.get(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (inEventLoop) {</span><br><span class="line">            newState = ST_SHUTTING_DOWN;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">switch</span> (oldState) {</span><br><span class="line">                <span class="keyword">case</span> ST_NOT_STARTED:</span><br><span class="line">                <span class="keyword">case</span> ST_STARTED:</span><br><span class="line">                    newState = ST_SHUTTING_DOWN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="comment">// 一个线程已修改好线程状态，此时这个线程才执行16行代码</span></span><br><span class="line">                    newState = oldState;</span><br><span class="line">                    wakeup = <span class="keyword">false</span>; <span class="comment">// 已经有线程唤醒，所以不用再唤醒</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, newState)) {</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 保证只有一个线程将oldState修改为newState</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 隐含STATE_UPDATER已被修改，则在下一次循环返回</span></span><br><span class="line">    }</span><br><span class="line">     <span class="comment">// 在default情况下会更新这两个值</span></span><br><span class="line">    gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);</span><br><span class="line">    gracefulShutdownTimeout = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldState == ST_NOT_STARTED) {</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (wakeup) {</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> terminationFuture();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码真是为多线程同时调用关闭的情况操碎了心，我们抓住其中的关键点：该方法只是将线程状态修改为ST_SHUTTING_DOWN并不执行具体的关闭操作（类似的shutdown方法将线程状态修改为ST_SHUTDOWN）。for()循环是为了保证修改state的线程（原生线程或者外部线程）有且只有一个。如果你还没有理解这句话，请查阅compareAndSet()方法的说明然后再看一遍。39-44行代码之所以这样处理，是因为子类的实现中run()方法是一个EventLoop即一个循环。40行代码启动线程可以完整走一遍正常流程并且可以处理添加到队列中的任务以及IO事件。43行唤醒阻塞在阻塞点上的线程，使其从阻塞状态退出。要从一个EventLoop循环中退出，有什么好方法吗？可能你会想到这样处理：设置一个标记，每次循环都检测这个标记，如果标记为真就退出。Netty正是使用这种方法，NioEventLoop的run()方法的循环部分有这样一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isShuttingDown()) { <span class="comment">// 检测线程状态</span></span><br><span class="line">    closeAll(); <span class="comment">// 关闭注册的channel</span></span><br><span class="line">    <span class="keyword">if</span> (confirmShutdown()) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>查询线程状态的方法有三个，实现简单，一并列出：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShuttingDown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> STATE_UPDATER.get(<span class="keyword">this</span>) &gt;= ST_SHUTTING_DOWN;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> STATE_UPDATER.get(<span class="keyword">this</span>) &gt;= ST_SHUTDOWN;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> STATE_UPDATER.get(<span class="keyword">this</span>) == ST_TERMINATED;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是调用shutdownGracefully()方法后线程状态为ST_SHUTTING_DOWN，调用shutdown()方法后线程状态为ST_SHUTDOWN。isShuttingDown()可以一并判断这两种调用方法。closeAll()方法关闭注册到NioEventLoop的所有Channel，代码不再列出。confirmShutdown()方法在SingleThreadEventExecutor类，确定是否可以关闭或者说是否可以从EventLoop循环中跳出。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">confirmShutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isShuttingDown()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// 没有调用shutdown相关的方法直接返回</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop()) {   <span class="comment">// 必须是原生线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"must be invoked from an event loop"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cancelScheduledTasks(); <span class="comment">// 取消调度任务</span></span><br><span class="line">    <span class="keyword">if</span> (gracefulShutdownStartTime == <span class="number">0</span>) {   <span class="comment">// 优雅关闭开始时间，这也是一个标记</span></span><br><span class="line">        gracefulShutdownStartTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行完普通任务或者没有普通任务时执行完shutdownHook任务</span></span><br><span class="line">    <span class="keyword">if</span> (runAllTasks() || runShutdownHooks()) {</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">// 调用shutdown()方法直接退出</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (gracefulShutdownQuietPeriod == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">// 优雅关闭静默时间为0也直接退出</span></span><br><span class="line">        }</span><br><span class="line">        wakeup(<span class="keyword">true</span>);   <span class="comment">// 优雅关闭但有未执行任务，唤醒线程执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nanoTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    <span class="comment">// shutdown()方法调用直接返回，优雅关闭截止时间到也返回</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown() || nanoTime - gracefulShutdownStartTime &gt; gracefulShutdownTimeout) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在静默期间每100ms唤醒线程执行期间提交的任务</span></span><br><span class="line">    <span class="keyword">if</span> (nanoTime - lastExecutionTime &lt;= gracefulShutdownQuietPeriod) {</span><br><span class="line">        wakeup(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 静默时间内没有任务提交，可以优雅关闭，此时若用户又提交任务则不会被执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们总结一下，调用shutdown()方法从循环跳出的条件有：<br> (1).执行完普通任务<br> (2).没有普通任务，执行完shutdownHook任务<br> (3).既没有普通任务也没有shutdownHook任务<br> 调用shutdownGracefully()方法从循环跳出的条件有：<br> (1).执行完普通任务且静默时间为0<br> (2).没有普通任务，执行完shutdownHook任务且静默时间为0<br> (3).静默期间没有任务提交<br> (4).优雅关闭截止时间已到<br> 注意上面所列的条件之间是<strong>或</strong>的关系，也就是说满足任意一条就会从EventLoop循环中跳出。我们可以将静默时间看为一段观察期，在此期间如果没有任务执行，说明可以跳出循环；如果此期间有任务执行，执行完后立即进入下一个观察期继续观察；如果连续多个观察期一直有任务执行，那么截止时间到则跳出循环。我们看一下shutdownGracefully()的默认参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully() {</span><br><span class="line">    <span class="keyword">return</span> shutdownGracefully(<span class="number">2</span>, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可知，Netty默认的shutdownGracefully()机制为：在2秒的静默时间内如果没有任务，则关闭；否则15秒截止时间到达时关闭。换句话说，在15秒时间段内，如果有超过2秒的时间段没有任务则关闭。至此，我们明白了从EvnetLoop循环中跳出的机制，最后，我们抵达终点站：线程结束机制。这一部分的代码实现在线程工厂的生成方法中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">thread = threadFactory.newThread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();   <span class="comment">// 模板方法，EventLoop实现</span></span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">for</span> (;;) {</span><br><span class="line">                    <span class="keyword">int</span> oldState = STATE_UPDATER.get(SingleThreadEventExecutor.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">// 用户调用了关闭的方法或者抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                            SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) {</span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">// 抛出异常也将状态置为ST_SHUTTING_DOWN</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// time=0，说明confirmShutdown()方法没有调用，记录日志</span></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">for</span> (;;) {</span><br><span class="line">                        <span class="comment">// 抛出异常时，将普通任务和shutdownHook任务执行完毕</span></span><br><span class="line">                        <span class="comment">// 正常关闭时，结合前述的循环跳出条件</span></span><br><span class="line">                        <span class="keyword">if</span> (confirmShutdown()) {</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        cleanup();</span><br><span class="line">                    } <span class="keyword">finally</span> {</span><br><span class="line">                        <span class="comment">// 线程状态设置为ST_TERMINATED，线程终止</span></span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        <span class="keyword">if</span> (!taskQueue.isEmpty()) {</span><br><span class="line">                            <span class="comment">//  关闭时，任务队列中添加了任务，记录日志</span></span><br><span class="line">                        }</span><br><span class="line">                        terminationFuture.setSuccess(<span class="keyword">null</span>); <span class="comment">// 异步结果设置为成功</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure>
<p>20-22行代码说明子类在实现模板方法run()时，须调用confirmShutdown()方法，不调用的话会有错误日志。25-31行的for()循环主要是对异常情况的处理，但同时也兼顾了正常调用关闭方法的情况。可以将抛出异常的情况视为静默时间为0的shutdownGracefully()方法，这样便于理解循环跳出条件。34行代码cleanup()的默认实现什么也不做，NioEventLoop覆盖了基类，实现关闭NioEventLoop持有的selector：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        selector.close();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        logger.warn(<span class="string">"Failed to close a selector."</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>关于Netty优雅关闭的机制，还有最后一点细节，那就是runShutdownHooks()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">runShutdownHooks</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownHooks.isEmpty()) {</span><br><span class="line">        <span class="comment">// 使用copy是因为shutdwonHook任务中可以添加或删除shutdwonHook任务</span></span><br><span class="line">        List&lt;Runnable&gt; copy = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;(shutdownHooks);</span><br><span class="line">        shutdownHooks.clear();</span><br><span class="line">        <span class="keyword">for</span> (Runnable task: copy) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                task.run();</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                logger.warn(<span class="string">"Shutdown hook raised an exception."</span>, t);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ran) {</span><br><span class="line">        lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ran;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此外，还有threadLock.release()方法，如果你还记得字段定义，threadLock是一个初始值为0的信号量。一个初值为0的信号量，当线程请求锁时只会阻塞，这有什么用呢？awaitTermination()方法揭晓答案，用来使其他线程阻塞等待原生线程关闭 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 由于tryAcquire()永远不会成功，所以必定阻塞timeout时间</span></span><br><span class="line">    <span class="keyword">if</span> (threadLock.tryAcquire(timeout, unit)) {</span><br><span class="line">        threadLock.release();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isTerminated();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/EventLoop-8-EventLoop-shutdown/" data-id="ck4pl3fow00dgfgcffcub7jmt" class="article-share-link">分享</a>

</footer>
-->
</div>
