<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 ByteBuf（二）核心子类
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-1-ByteBuf-intro/">《精尽 Netty 源码解析 —— ByteBuf（一）之简介》</a> 中，我们对 ByteBuf 有了整体的认识，特别是核心 API 部分。同时，我们也看到，ByteBuf 有非常非常非常多的子类，那么怎么办呢？实际上，<strong>ByteBuf 有 8 个最最最核心的子类实现</strong>。如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_08_04/01.png" title="核心子类" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_04/01.png" alt="核心子类"></a><span class="caption">核心子类</span></p>
<p>一共可以按照三个维度来看这 8 个核心子类，刚好是 2 x 2 x 2 = 8 ：</p>
<ul>
<li>按照<strong>内存类型</strong>分类：<ul>
<li>① 堆内存字节缓冲区( <strong>Heap</strong>ByteBuf )：底层为 JVM 堆内的字节数组，其特点是申请和释放效率较高。但是如果要进行 Socket 的 I/O 读写，需要额外多做一次内存复制，需要将堆内存对应的缓冲区复制到内核 Channel 中，性能可能会有一定程度的损耗。</li>
<li>② 直接内存字节缓冲区( <strong>Direct</strong>ByteBuf )：堆外内存，为操作系统内核空间的字节数组，它由操作系统直接管理和操作，其申请和释放的效率会慢于堆缓冲区。但是将它写入或者从 SocketChannel 中读取时，会少一次内存复制，这样可以大大提高 I/O 效率，实现零拷贝。</li>
<li>关于这两者的对比，感兴趣的胖友，可以再看看 <a href="https://www.zhihu.com/question/60892134" rel="external nofollow noopener noreferrer" target="_blank">《Java NIO direct buffer 的优势在哪儿？》</a> 和 <a href="http://eyesmore.iteye.com/blog/1133335" rel="external nofollow noopener noreferrer" target="_blank">《JAVA NIO 之 Direct Buffer 与 Heap Buffer的区别？》</a></li>
</ul>
</li>
<li>按照 <strong>对象池</strong> 分类：<ul>
<li>① 基于对象池( <strong>Pooled</strong>ByteBuf )：基于对象池的 ByteBuf 可以重用 ByteBuf ，也就是说它自己内部维护着一个对象池，当对象释放后会归还给对象池，这样就可以循环地利用创建的 ByteBuf，提升内存的使用率，降低由于高负载导致的频繁 GC。当需要大量且频繁创建缓冲区时，推荐使用该类缓冲区。 </li>
<li>② 不使用对象池( <strong>Unpooled</strong>ByteBuf )：对象池的管理和维护会比较困难，所以在不需要创建大量缓冲区对象时，推荐使用此类缓冲区。</li>
</ul>
</li>
<li>按照 <strong>Unsafe</strong> 分类：<ul>
<li>① 使用 Unsafe ：基于 Java <code>sun.misc.Unsafe.Unsafe</code> 的 API ，直接访问内存中的数据。</li>
<li>② 不使用 Unsafe ： 基于 <strong>Heap</strong>ByteBuf 和 <strong>Direct</strong>ByteBuf 的标准 API ，进行访问对应的数据。</li>
<li>关于 Unsafe ，JVM 大佬 R 大在知乎上有个回答：<a href="https://www.zhihu.com/question/29266773" rel="external nofollow noopener noreferrer" target="_blank">《为什么 JUC 中大量使用了 sun.misc.Unsafe 这个类，但官方却不建议开发者使用？》</a> 。关于为什么 Unsafe 的性能会更好：”其中一种是嫌 Java 性能不够好，例如说数组访问的边界检查语义，嫌这个开销太大，觉得用 Unsafe 会更快；”。</li>
</ul>
</li>
</ul>
<p>默认情况下，使用 PooledUnsafeDirectByteBuf 类型。所以，重点重点重点，看 <a href="#">「2.4 PooledUnsafeDirectByteBuf」</a> 。</p>
<h1 id="2-PooledByteBuf"><a href="#2-PooledByteBuf" class="headerlink" title="2. PooledByteBuf"></a>2. PooledByteBuf</h1><p><code>io.netty.buffer.PooledByteBuf</code> ，继承 AbstractReferenceCountedByteBuf 抽象类，<strong>对象池化</strong>的 ByteBuf 抽象基类，为基于<strong>对象池</strong>的 ByteBuf 实现类，提供公用的方法。</p>
<p>关于 <code>io.netty.util.AbstractReferenceCountedByteBuf</code> 抽象类，对象引用计数器抽象类。本文暂时不解析，我们会在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector/">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》</a> 详细解析。</p>
<h2 id="2-1-内部方法"><a href="#2-1-内部方法" class="headerlink" title="2.1 内部方法"></a>2.1 内部方法</h2><h3 id="2-1-1-构造方法"><a href="#2-1-1-构造方法" class="headerlink" title="2.1.1 构造方法"></a>2.1.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycler 处理器，用于回收对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Recycler.Handle&lt;PooledByteBuf&lt;T&gt;&gt; recyclerHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chunk 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> PoolChunk&lt;T&gt; chunk;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 Chunk 对象中分配的内存块所处的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> handle;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存空间。具体什么样的数据，通过子类设置泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> T memory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #memory} 开始位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #idx(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #capacity()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 占用 {<span class="doctag">@link</span> #memory} 的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> maxLength;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 1013 Chunk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PoolThreadCache cache;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 临时 ByteBuff 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #internalNioBuffer()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuf 分配器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ByteBufAllocator allocator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PooledByteBuf</span><span class="params">(Recycler.Handle&lt;? extends PooledByteBuf&lt;T&gt;&gt; recyclerHandle, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">    <span class="keyword">this</span>.recyclerHandle = (Handle&lt;PooledByteBuf&lt;T&gt;&gt;) recyclerHandle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>recyclerHandle</code> 属性，Recycler 处理器，用于回收<strong>当前</strong>对象。</li>
<li><code>chunk</code> 属性，PoolChunk 对象。在 Netty 中，使用 Jemalloc 算法管理内存，而 Chunk 是里面的一种<strong>内存块</strong>。在这里，我们可以理解 <code>memory</code> 所属的 PoolChunk 对象。<ul>
<li><code>handle</code> 属性，从 Chunk 对象中分配的内存块所处的位置。具体的，胖友后面仔细看看 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk/">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》</a> 和 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-3-Jemalloc-subpage/">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（三）PoolSubpage》</a> 。</li>
<li><code>memory</code> 属性，内存空间。具体什么样的数据，通过子类设置泛型( <code>T</code> )。例如：1) PooledDirectByteBuf 和 PooledUnsafeDirectByteBuf 为 <strong>ByteBuffer</strong> ；2) PooledHeapByteBuf 和 PooledUnsafeHeapByteBuf 为 <code>byte[]</code> 。<ul>
<li><code>offset</code> 属性，使用 <code>memory</code> 的开始位置。</li>
<li><code>maxLength</code> 属性，<strong>最大</strong>使用 <code>memory</code> 的长度( 大小 )。</li>
<li><code>length</code> 属性，<strong>目前</strong>使用 <code>memory</code> 的长度( 大小 )。</li>
<li>😈 因为 <code>memory</code> 属性，可以被<strong>多个</strong> ByteBuf 使用。<strong>每个</strong> ByteBuf 使用范围为 <code>[offset, maxLength)</code> 。</li>
</ul>
</li>
</ul>
</li>
<li><code>cache</code> 属性，TODO 1013 Chunk</li>
<li><code>tmpNioBuf</code> 属性，临时 ByteBuff 对象，通过 <code>#tmpNioBuf()</code> 方法生成。详细解析，见 <a href="#">「2.1.9 internalNioBuffer」</a> 。 </li>
<li><code>allocator</code> 属性，ByteBuf 分配器。</li>
</ul>
<h3 id="2-1-2-init0"><a href="#2-1-2-init0" class="headerlink" title="2.1.2 init0"></a>2.1.2 init0</h3><p><code>#init0(PoolChunk&lt;T&gt; chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache)</code> 方法，初始化 PooledByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init0</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assert</span> chunk != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From PoolChunk 对象</span></span><br><span class="line">    <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">    memory = chunk.memory;</span><br><span class="line">    allocator = chunk.arena.parent;</span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.maxLength = maxLength;</span><br><span class="line">    tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>仔细的胖友，可能会发现，这是一个 <code>private</code> 私有方法。目前它被两个方法调用：</p>
<ul>
<li><p>① <code>#init(PoolChunk&lt;T&gt; chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache)</code> 方法，一般是基于 <strong>pooled</strong> 的 PoolChunk 对象，初始化 PooledByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>{</span><br><span class="line">    init0(chunk, handle, offset, length, maxLength, cache);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>② <code>#initUnpooled(PoolChunk&lt;T&gt; chunk, int length)</code> 方法，基于 <strong>unPoolooled</strong> 的 PoolChunk 对象，初始化 PooledByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initUnpooled</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    init0(chunk, <span class="number">0</span>, chunk.offset, length, length, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>例如说 <strong>Huge</strong> 大小的 PoolChunk 对象。</li>
<li>注意，传入的给 <code>#init0(...)</code> 方法的 <code>length</code> 和 <code>maxLength</code> 方法参数，<strong>都是</strong> <code>length</code> 。</li>
</ul>
</li>
</ul>
<p>可能胖友读到此处会一脸懵逼。其实，这是很正常的。可以在看完 <a href="http://svip.iocoder.cn/Netty/ByteBuf-3-2-Jemalloc-chunk/">《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（二）PoolChunk》</a> 后，在回过头来，理解理解。</p>
<h3 id="2-1-3-reuse"><a href="#2-1-3-reuse" class="headerlink" title="2.1.3 reuse"></a>2.1.3 reuse</h3><p><code>#reuse(int maxCapacity)</code> 方法，每次在重用 PooledByteBuf 对象时，需要调用该方法，重置属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method must be called before reuse this {<span class="doctag">@link</span> PooledByteBufAllocator}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reuse</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    maxCapacity(maxCapacity);</span><br><span class="line">    <span class="comment">// 设置引用数量为 0</span></span><br><span class="line">    setRefCnt(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 重置读写索引为 0</span></span><br><span class="line">    setIndex0(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 重置读写标记位为 0</span></span><br><span class="line">    discardMarks();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，该方法在 <a href="#">「2.1.2 init9」</a> <strong>之前</strong>就调用了。在下文中，我们会看到，该方法的调用。</p>
<h3 id="2-1-4-capacity"><a href="#2-1-4-capacity" class="headerlink" title="2.1.4 capacity"></a>2.1.4 capacity</h3><p><code>#capacity()</code> 方法，获得容量。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>当前</strong>容量的值为 <code>length</code> 属性。<br>但是，要注意的是，<code>maxLength</code> 属性，<strong>不是表示最大容量</strong>。<code>maxCapacity</code> 属性，才是真正表示最大容量。<br>那么，<code>maxLength</code> 属性有什么用？表示<strong>占用</strong> <code>memory</code> 的最大容量( 而不是 PooledByteBuf 对象的最大容量 )。在写入数据超过 <code>maxLength</code> 容量时，会进行扩容，但是容量的上限，为 <code>maxCapacity</code> 。</p>
<hr>
<p><code>#capacity(int newCapacity)</code> 方法，调整容量大小。在这个过程中，根据情况，可能对 <code>memory</code> 扩容或缩容。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 校验新的容量，不能超过最大容量</span></span><br><span class="line"> <span class="number">4</span>:     checkNewCapacity(newCapacity);</span><br><span class="line"> <span class="number">5</span>: </span><br><span class="line"> <span class="number">6</span>:     <span class="comment">// Chunk 内存，非池化</span></span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// If the request capacity does not require reallocation, just update the length of the memory.</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (chunk.unpooled) {</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (newCapacity == length) { <span class="comment">// 相等，无需扩容 / 缩容</span></span><br><span class="line"><span class="number">10</span>:             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">11</span>:         }</span><br><span class="line"><span class="number">12</span>:     <span class="comment">// Chunk 内存，是池化</span></span><br><span class="line"><span class="number">13</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">14</span>:         <span class="comment">// 扩容</span></span><br><span class="line"><span class="number">15</span>:         <span class="keyword">if</span> (newCapacity &gt; length) {</span><br><span class="line"><span class="number">16</span>:             <span class="keyword">if</span> (newCapacity &lt;= maxLength) {</span><br><span class="line"><span class="number">17</span>:                 length = newCapacity;</span><br><span class="line"><span class="number">18</span>:                 <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">19</span>:             }</span><br><span class="line"><span class="number">20</span>:         <span class="comment">// 缩容</span></span><br><span class="line"><span class="number">21</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (newCapacity &lt; length) {</span><br><span class="line"><span class="number">22</span>:             <span class="comment">// 大于 maxLength 的一半</span></span><br><span class="line"><span class="number">23</span>:             <span class="keyword">if</span> (newCapacity &gt; maxLength &gt;&gt;&gt; <span class="number">1</span>) {</span><br><span class="line"><span class="number">24</span>:                 <span class="keyword">if</span> (maxLength &lt;= <span class="number">512</span>) {</span><br><span class="line"><span class="number">25</span>:                     <span class="comment">// 因为 Netty SubPage 最小是 16 ，如果小于等 16 ，无法缩容。</span></span><br><span class="line"><span class="number">26</span>:                     <span class="keyword">if</span> (newCapacity &gt; maxLength - <span class="number">16</span>) {</span><br><span class="line"><span class="number">27</span>:                         length = newCapacity;</span><br><span class="line"><span class="number">28</span>:                         <span class="comment">// 设置读写索引，避免超过最大容量</span></span><br><span class="line"><span class="number">29</span>:                         setIndex(Math.min(readerIndex(), newCapacity), Math.min(writerIndex(), newCapacity));</span><br><span class="line"><span class="number">30</span>:                         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">31</span>:                     }</span><br><span class="line"><span class="number">32</span>:                 } <span class="keyword">else</span> { <span class="comment">// &gt; 512 (i.e. &gt;= 1024)</span></span><br><span class="line"><span class="number">33</span>:                     length = newCapacity;</span><br><span class="line"><span class="number">34</span>:                     <span class="comment">// 设置读写索引，避免超过最大容量</span></span><br><span class="line"><span class="number">35</span>:                     setIndex(Math.min(readerIndex(), newCapacity), Math.min(writerIndex(), newCapacity));</span><br><span class="line"><span class="number">36</span>:                     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">37</span>:                 }</span><br><span class="line"><span class="number">38</span>:             }</span><br><span class="line"><span class="number">39</span>:         <span class="comment">// 相等，无需扩容 / 缩容</span></span><br><span class="line"><span class="number">40</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">41</span>:             <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">42</span>:         }</span><br><span class="line"><span class="number">43</span>:     }</span><br><span class="line"><span class="number">44</span>: </span><br><span class="line"><span class="number">45</span>:     <span class="comment">// 重新分配新的内存空间，并将数据复制到其中。并且，释放老的内存空间。</span></span><br><span class="line"><span class="number">46</span>:     <span class="comment">// Reallocation required.</span></span><br><span class="line"><span class="number">47</span>:     chunk.arena.reallocate(<span class="keyword">this</span>, newCapacity, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">48</span>:     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">49</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 4 行：调用 <code>AbstractByteBuf#checkNewCapacity(int newCapacity)</code> 方法，校验新的容量，不能超过最大容量。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkNewCapacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span> || newCapacity &gt; maxCapacity()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"newCapacity: "</span> + newCapacity + <span class="string">" (expected: 0-"</span> + maxCapacity() + <span class="string">')'</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 6 至 11 行：对于基于 <strong>unPoolooled</strong> 的 PoolChunk 对象，除非容量不变，否则会扩容或缩容，即【第 47 行】的代码。为什么呢？在 <code>#initUnpooled(PoolChunk&lt;T&gt; chunk, int length)</code> 方法中，我们可以看到，<code>maxLength</code> 和 <code>length</code> 是相等的，所以大于或小于时，需要进行扩容或缩容。</p>
</li>
<li>第 13 行：对于基于 <strong>poolooled</strong> 的 PoolChunk 对象，需要根据情况：<ul>
<li>第 39 至 42 行：容量未变，不进行扩容。类似【第 9 至 11 行】的代码。</li>
<li>第 14 至 19 行：新容量<strong>大于</strong>当前容量，但是小于 <code>memory</code> 最大容量，仅仅修改当前容量，无需进行扩容。否则，第【第 47 行】的代码，进行<strong>扩容</strong>。</li>
<li>第 20 至 38 行：新容量<strong>小于</strong>当前容量，但是不到 <code>memory</code> 最大容量的<strong>一半</strong>，因为缩容<strong>相对</strong>释放不多，无需进行缩容。否则，第【第 47 行】的代码，进行<strong>缩容</strong>。<ul>
<li>比较神奇的是【第 26 行】的 <code>newCapacity &gt; maxLength - 16</code> 代码块。 笔者的理解是，Netty SubPage <strong>最小</strong>是 16 B ，如果小于等 16 ，无法缩容。</li>
</ul>
</li>
</ul>
</li>
<li>第 47 行：调用 <code>PoolArena#reallocate(PooledByteBuf&lt;T&gt; buf, int newCapacity, boolean freeOldMemory)</code> 方法，<strong>重新分配</strong>新的内存空间，并将数据<strong>复制</strong>到其中。并且，<strong>释放</strong>老的内存空间。详细解析，见 <a href="#">《TODO 1013 Chunk》</a> 中。</li>
</ul>
<h3 id="2-1-5-order"><a href="#2-1-5-order" class="headerlink" title="2.1.5 order"></a>2.1.5 order</h3><p><code>#order()</code> 方法，返回字节序为 <code>ByteOrder.BIG_ENDIAN</code> 大端。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ByteOrder.BIG_ENDIAN;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>统一<strong>大端</strong>模式。</p>
<blockquote>
<p>FROM <a href="https://www.bysocket.com/?p=615" rel="external nofollow noopener noreferrer" target="_blank">《深入浅出： 大小端模式》</a></p>
<p>在网络上传输数据时，由于数据传输的两端对应不同的硬件平台，采用的存储字节顺序可能不一致。所以在 TCP/IP 协议规定了在网络上必须采用网络字节顺序，也就是大端模式。</p>
</blockquote>
<h3 id="2-1-6-unwrap"><a href="#2-1-6-unwrap" class="headerlink" title="2.1.6 unwrap"></a>2.1.6 unwrap</h3><p><code>#unwrap()</code> 方法，返回空，因为没有被装饰的 ByteBuffer 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuf <span class="title">unwrap</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-1-7-retainedSlice"><a href="#2-1-7-retainedSlice" class="headerlink" title="2.1.7 retainedSlice"></a>2.1.7 retainedSlice</h3><p><code>#retainedSlice()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuf <span class="title">retainedSlice</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = readerIndex();</span><br><span class="line">    <span class="keyword">return</span> retainedSlice(index, writerIndex() - index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuf <span class="title">retainedSlice</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> PooledSlicedByteBuf.newInstance(<span class="keyword">this</span>, <span class="keyword">this</span>, index, length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>PooledSlicedByteBuf#newInstance(AbstractByteBuf unwrapped, ByteBuf wrapped, int index, int length)</code> 方法，创建<strong>池化的</strong> PooledSlicedByteBuf 对象。</li>
<li>TODO 1016 派生类</li>
</ul>
<h3 id="2-1-8-retainedDuplicate"><a href="#2-1-8-retainedDuplicate" class="headerlink" title="2.1.8 retainedDuplicate"></a>2.1.8 retainedDuplicate</h3><p><code>#retainedDuplicate()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuf <span class="title">retainedDuplicate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> PooledDuplicatedByteBuf.newInstance(<span class="keyword">this</span>, <span class="keyword">this</span>, readerIndex(), writerIndex());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>PooledSlicedByteBuf#newInstance(AbstractByteBuf unwrapped, ByteBuf wrapped, int readerIndex, int writerIndex)</code> 方法，创建<strong>池化的</strong> PooledDuplicatedByteBuf.newInstance 对象。</li>
<li>TODO 1016 派生类</li>
</ul>
<h3 id="2-1-9-internalNioBuffer"><a href="#2-1-9-internalNioBuffer" class="headerlink" title="2.1.9 internalNioBuffer"></a>2.1.9 internalNioBuffer</h3><p><code>#internalNioBuffer()</code> 方法，获得临时 ByteBuf 对象( <code>tmpNioBuf</code> ) 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ByteBuffer <span class="title">internalNioBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    ByteBuffer tmpNioBuf = <span class="keyword">this</span>.tmpNioBuf;</span><br><span class="line">    <span class="comment">// 为空，创建临时 ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">if</span> (tmpNioBuf == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.tmpNioBuf = tmpNioBuf = newInternalNioBuffer(memory);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tmpNioBuf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>当 <code>tmpNioBuf</code> 属性为空时，调用 <code>#newInternalNioBuffer(T memory)</code> 方法，创建 ByteBuffer 对象。因为 <code>memory</code> 的类型不确定，所以该方法定义成<strong>抽象方法</strong>，由子类实现。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">newInternalNioBuffer</span><span class="params">(T memory)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<hr>
<p>为什么要有 <code>tmpNioBuf</code> 这个属性呢？以 PooledDirectByteBuf 举例子，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, FileChannel in, <span class="keyword">long</span> position, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="comment">// 获得临时 ByteBuf 对象</span></span><br><span class="line">    ByteBuffer tmpBuf = internalNioBuffer();</span><br><span class="line">    index = idx(index);</span><br><span class="line">    tmpBuf.clear().position(index).limit(index + length);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 写入临时 ByteBuf 对象</span></span><br><span class="line">        <span class="keyword">return</span> in.read(tmpBuf, position);</span><br><span class="line">    } <span class="keyword">catch</span> (ClosedChannelException ignored) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, FileChannel out, <span class="keyword">long</span> position, <span class="keyword">int</span> length, <span class="keyword">boolean</span> internal)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得临时 ByteBuf 对象</span></span><br><span class="line">    ByteBuffer tmpBuf = internal ? internalNioBuffer() : memory.duplicate();</span><br><span class="line">    index = idx(index);</span><br><span class="line">    tmpBuf.clear().position(index).limit(index + length);</span><br><span class="line">    <span class="comment">// 写入到 FileChannel 中</span></span><br><span class="line">    <span class="keyword">return</span> out.write(tmpBuf, position);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-1-10-deallocate"><a href="#2-1-10-deallocate" class="headerlink" title="2.1.10 deallocate"></a>2.1.10 deallocate</h3><p><code>#deallocate()</code> 方法，当引用计数为 0 时，调用该方法，进行内存回收。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 重置属性</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">        <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">        memory = <span class="keyword">null</span>;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 释放内存回 Arena 中</span></span><br><span class="line">        chunk.arena.free(chunk, handle, maxLength, cache);</span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 回收对象</span></span><br><span class="line">        recycle();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>{</span><br><span class="line">    recyclerHandle.recycle(<span class="keyword">this</span>); <span class="comment">// 回收对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-1-11-idx"><a href="#2-1-11-idx" class="headerlink" title="2.1.11 idx"></a>2.1.11 idx</h3><p><code>#idx(int index)</code> 方法，获得指定位置在 <code>memory</code> 变量中的位置。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> offset + index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-2-PooledDirectByteBuf"><a href="#2-2-PooledDirectByteBuf" class="headerlink" title="2.2 PooledDirectByteBuf"></a>2.2 PooledDirectByteBuf</h2><p><code>io.netty.buffer.PooledDirectByteBuf</code> ，实现 PooledByteBuf 抽象类，基于 <strong>ByteBuffer</strong> 的<strong>可重用</strong> ByteBuf 实现类。所以，泛型 <code>T</code> 为 ByteBuffer ，即：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">final class PooledDirectByteBuf extends PooledByteBuf&lt;ByteBuffer&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-1-构造方法"><a href="#2-2-1-构造方法" class="headerlink" title="2.2.1 构造方法"></a>2.2.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PooledDirectByteBuf</span><span class="params">(Recycler.Handle&lt;PooledDirectByteBuf&gt; recyclerHandle, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(recyclerHandle, maxCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-2-newInstance"><a href="#2-2-2-newInstance" class="headerlink" title="2.2.2 newInstance"></a>2.2.2 newInstance</h3><p><code>#newInstance(int maxCapacity)</code> <strong>静态</strong>方法，“创建” PooledDirectByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycler 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;PooledDirectByteBuf&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;PooledDirectByteBuf&gt;() {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PooledDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PooledDirectByteBuf(handle, <span class="number">0</span>); <span class="comment">// 真正创建 PooledDirectByteBuf 对象</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 从 Recycler 的对象池中获得 PooledDirectByteBuf 对象</span></span><br><span class="line">    PooledDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    <span class="comment">// 重置 PooledDirectByteBuf 的属性</span></span><br><span class="line">    buf.reuse(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-3-newInternalNioBuffer"><a href="#2-2-3-newInternalNioBuffer" class="headerlink" title="2.2.3 newInternalNioBuffer"></a>2.2.3 newInternalNioBuffer</h3><p><code>#newInternalNioBuffer(ByteBuffer memory)</code> 方法，获得临时 ByteBuf 对象( <code>tmpNioBuf</code> ) 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">newInternalNioBuffer</span><span class="params">(ByteBuffer memory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> memory.duplicate();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>ByteBuffer#duplicate()</code> 方法，复制一个 ByteBuffer 对象，<strong>共享</strong>里面的数据。</li>
</ul>
<h3 id="2-2-4-isDirect"><a href="#2-2-4-isDirect" class="headerlink" title="2.2.4 isDirect"></a>2.2.4 isDirect</h3><p><code>#isDirect()</code> 方法，获得内部类型是否为 Direct ，返回 <code>true</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-5-读取-写入操作"><a href="#2-2-5-读取-写入操作" class="headerlink" title="2.2.5 读取 / 写入操作"></a>2.2.5 读取 / 写入操作</h3><p>老样子，我们以 Int 类型为例子，来看看它的读取和写入操作的实现代码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">_getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> memory.getInt(idx(index));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">_setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    memory.putInt(idx(index), value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-6-copy"><a href="#2-2-6-copy" class="headerlink" title="2.2.6 copy"></a>2.2.6 copy</h3><p><code>#copy(int index, int length)</code> 方法，复制指定范围的数据到新创建的 Direct ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">copy</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验索引</span></span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="comment">// 创建一个 Direct ByteBuf 对象</span></span><br><span class="line">    ByteBuf copy = alloc().directBuffer(length, maxCapacity());</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    copy.writeBytes(<span class="keyword">this</span>, index, length);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-7-转换-NIO-ByteBuffer-操作"><a href="#2-2-7-转换-NIO-ByteBuffer-操作" class="headerlink" title="2.2.7 转换 NIO ByteBuffer 操作"></a>2.2.7 转换 NIO ByteBuffer 操作</h3><h4 id="2-2-7-1-nioBufferCount"><a href="#2-2-7-1-nioBufferCount" class="headerlink" title="2.2.7.1 nioBufferCount"></a>2.2.7.1 nioBufferCount</h4><p><code>#nioBufferCount()</code> 方法，返回 ByteBuf 包含 ByteBuffer 数量为 <strong>1</strong> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nioBufferCount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-7-2-nioBuffer"><a href="#2-2-7-2-nioBuffer" class="headerlink" title="2.2.7.2 nioBuffer"></a>2.2.7.2 nioBuffer</h4><p><code>#nioBuffer(int index, int length)</code> 方法，返回 ByteBuf <strong>指定范围</strong>包含的 ByteBuffer 对象( <strong>共享</strong> )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">nioBuffer</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="comment">// memory 中的开始位置</span></span><br><span class="line">    index = idx(index);</span><br><span class="line">    <span class="comment">// duplicate 复制一个 ByteBuffer 对象，共享数据</span></span><br><span class="line">    <span class="comment">// position + limit 设置位置和大小限制</span></span><br><span class="line">    <span class="comment">// slice 创建 [position, limit] 子缓冲区，共享数据</span></span><br><span class="line">    <span class="keyword">return</span> ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，看具体注释。</li>
</ul>
<h4 id="2-2-7-3-nioBuffers"><a href="#2-2-7-3-nioBuffers" class="headerlink" title="2.2.7.3 nioBuffers"></a>2.2.7.3 nioBuffers</h4><p><code>#nioBuffers(int index, int length)</code> 方法，返回 ByteBuf <strong>指定范围</strong>内包含的 ByteBuffer 数组( <strong>共享</strong> )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer[] nioBuffers(<span class="keyword">int</span> index, <span class="keyword">int</span> length) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteBuffer[] { nioBuffer(index, length) };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <code>#nioBuffer(int index, int length)</code> 方法的基础上，创建大小为 1 的 ByteBuffer 数组。</li>
</ul>
<h4 id="2-2-7-4-internalNioBuffer"><a href="#2-2-7-4-internalNioBuffer" class="headerlink" title="2.2.7.4 internalNioBuffer"></a>2.2.7.4 internalNioBuffer</h4><p><code>#internalNioBuffer(int index, int length)</code> 方法，返回 ByteBuf <strong>指定范围</strong>内的 ByteBuffer 对象( <strong>共享</strong> )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">internalNioBuffer</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="comment">// memory 中的开始位置</span></span><br><span class="line">    index = idx(index);</span><br><span class="line">    <span class="comment">// clear 标记清空（不会清理数据）</span></span><br><span class="line">    <span class="comment">// position + limit 设置位置和大小限制</span></span><br><span class="line">    <span class="keyword">return</span> (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，看具体注释。</li>
<li>因为是基于 <code>tmpNioBuf</code> 属性实现，所以方法在命名上，以 <code>"internal"</code> 打头。</li>
</ul>
<h3 id="2-2-8-Heap-相关方法"><a href="#2-2-8-Heap-相关方法" class="headerlink" title="2.2.8 Heap 相关方法"></a>2.2.8 Heap 相关方法</h3><p>不支持 Heap 相关方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] array() {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"direct buffer"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"direct buffer"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-9-Unsafe-相关方法"><a href="#2-2-9-Unsafe-相关方法" class="headerlink" title="2.2.9 Unsafe 相关方法"></a>2.2.9 Unsafe 相关方法</h3><p>不支持 Unsafe 相关方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMemoryAddress</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">memoryAddress</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-3-PooledHeapByteBuf"><a href="#2-3-PooledHeapByteBuf" class="headerlink" title="2.3 PooledHeapByteBuf"></a>2.3 PooledHeapByteBuf</h2><p><code>io.netty.buffer.PooledHeapByteBuf</code> ，实现 PooledByteBuf 抽象类，基于 <strong>ByteBuffer</strong> 的<strong>可重用</strong> ByteBuf 实现类。所以，泛型 <code>T</code> 为 <code>byte[]</code> ，即：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class PooledHeapByteBuf extends PooledByteBuf&lt;byte[]&gt; {</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-1-构造方法"><a href="#2-3-1-构造方法" class="headerlink" title="2.3.1 构造方法"></a>2.3.1 构造方法</h3><p>和 <a href="#">「2.2.1 构造方法」</a> 相同。</p>
<h3 id="2-3-2-newInstance"><a href="#2-3-2-newInstance" class="headerlink" title="2.3.2 newInstance"></a>2.3.2 newInstance</h3><p>和 <a href="#">「2.2.2 newInstance」</a> 相同。</p>
<h3 id="2-3-3-newInternalNioBuffer"><a href="#2-3-3-newInternalNioBuffer" class="headerlink" title="2.3.3 newInternalNioBuffer"></a>2.3.3 newInternalNioBuffer</h3><p><code>#newInternalNioBuffer(byte[] memory)</code> 方法，获得临时 ByteBuf 对象( <code>tmpNioBuf</code> ) 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ByteBuffer <span class="title">newInternalNioBuffer</span><span class="params">(<span class="keyword">byte</span>[] memory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(memory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>ByteBuffer#wrap(byte[] array)</code> 方法，创建 ByteBuffer 对象。注意，返回的是 HeapByteBuffer 对象。</li>
</ul>
<h3 id="2-3-4-isDirect"><a href="#2-3-4-isDirect" class="headerlink" title="2.3.4 isDirect"></a>2.3.4 isDirect</h3><p><code>#isDirect()</code> 方法，获得内部类型是否为 Direct ，返回 <code>false</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-5-读取-写入操作"><a href="#2-3-5-读取-写入操作" class="headerlink" title="2.3.5 读取 / 写入操作"></a>2.3.5 读取 / 写入操作</h3><p>老样子，我们以 Int 类型为例子，来看看它的读取和写入操作的实现代码。</p>
<p>① <strong>读取</strong>操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">_getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> HeapByteBufUtil.getInt(memory, idx(index));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeapByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">byte</span>[] memory, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span>  (memory[index]     &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span> |</span><br><span class="line">            (memory[index + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span> |</span><br><span class="line">            (memory[index + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span> |</span><br><span class="line">            memory[index + <span class="number">3</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>② <strong>写入</strong>操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">_setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>   value)</span> </span>{</span><br><span class="line">    HeapByteBufUtil.setInt(memory, idx(index), value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeapByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">byte</span>[] memory, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    memory[index]     = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    memory[index + <span class="number">1</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    memory[index + <span class="number">2</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    memory[index + <span class="number">3</span>] = (<span class="keyword">byte</span>) value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-6-copy"><a href="#2-3-6-copy" class="headerlink" title="2.3.6 copy"></a>2.3.6 copy</h3><p><code>#copy(int index, int length)</code> 方法，复制指定范围的数据到新创建的 Heap ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">copy</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验索引</span></span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="comment">// 创建一个 Heap ByteBuf 对象</span></span><br><span class="line">    ByteBuf copy = alloc().heapBuffer(length, maxCapacity());</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    copy.writeBytes(<span class="keyword">this</span>, index, length);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>和 PooledDirectByteBuf <a href="#">「2.2.6 copy」</a> 的差异在于，创建的是 <strong>Heap</strong> ByteBuf 对象。</p>
<h3 id="2-3-7-转换-NIO-ByteBuffer-操作"><a href="#2-3-7-转换-NIO-ByteBuffer-操作" class="headerlink" title="2.3.7 转换 NIO ByteBuffer 操作"></a>2.3.7 转换 NIO ByteBuffer 操作</h3><h4 id="2-3-7-1-nioBufferCount"><a href="#2-3-7-1-nioBufferCount" class="headerlink" title="2.3.7.1 nioBufferCount"></a>2.3.7.1 nioBufferCount</h4><p>和 <a href="#">「2.2.7.1 nioBufferCount」</a> 一致。</p>
<h4 id="2-3-7-2-nioBuffer"><a href="#2-3-7-2-nioBuffer" class="headerlink" title="2.3.7.2 nioBuffer"></a>2.3.7.2 nioBuffer</h4><p><code>#nioBuffer(int index, int length)</code> 方法，返回 ByteBuf <strong>指定范围</strong>包含的 ByteBuffer 对象( <strong>共享</strong> )。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">nioBuffer</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    checkIndex(index, length);</span><br><span class="line">    <span class="comment">// memory 中的开始位置</span></span><br><span class="line">    index = idx(index);</span><br><span class="line">    <span class="comment">// 创建 ByteBuffer 对象</span></span><br><span class="line">    ByteBuffer buf =  ByteBuffer.wrap(memory, index, length);</span><br><span class="line">    <span class="comment">// slice 创建 [position, limit] 子缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> buf.slice();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，看具体注释。</li>
</ul>
<h4 id="2-3-7-3-nioBuffers"><a href="#2-3-7-3-nioBuffers" class="headerlink" title="2.3.7.3 nioBuffers"></a>2.3.7.3 nioBuffers</h4><p>和 <a href="#">「2.2.7.3 nioBuffers」</a> 一致。</p>
<h4 id="2-3-7-4-internalNioBuffer"><a href="#2-3-7-4-internalNioBuffer" class="headerlink" title="2.3.7.4 internalNioBuffer"></a>2.3.7.4 internalNioBuffer</h4><p>和 <a href="#">「2.2.7.4 nioBuffers」</a> 一致。</p>
<h3 id="2-3-8-Heap-相关方法"><a href="#2-3-8-Heap-相关方法" class="headerlink" title="2.3.8 Heap 相关方法"></a>2.3.8 Heap 相关方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() {</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">return</span> memory;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-8-Unsafe-相关方法"><a href="#2-3-8-Unsafe-相关方法" class="headerlink" title="2.3.8 Unsafe 相关方法"></a>2.3.8 Unsafe 相关方法</h3><p>和 <a href="#">「2.2.9 Unsafe 相关方法」</a> 一致。</p>
<h2 id="2-4-PooledUnsafeDirectByteBuf"><a href="#2-4-PooledUnsafeDirectByteBuf" class="headerlink" title="2.4 PooledUnsafeDirectByteBuf"></a>2.4 PooledUnsafeDirectByteBuf</h2><blockquote>
<p>老艿艿：它是 <a href="#">「2.2 PooledDirectByteBuf」</a> 对应的基于 Unsafe 版本的实现类。</p>
</blockquote>
<p><code>io.netty.buffer.PooledUnsafeDirectByteBuf</code> ，实现 PooledByteBuf 抽象类，基于 <strong>ByteBuffer</strong> + <strong>Unsafe</strong> 的<strong>可重用</strong> ByteBuf 实现类。所以，泛型 <code>T</code> 为 <code>ByteBuffer</code> ，即：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">final class PooledUnsafeDirectByteBuf extends PooledByteBuf&lt;ByteBuffer&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-1-构造方法"><a href="#2-4-1-构造方法" class="headerlink" title="2.4.1 构造方法"></a>2.4.1 构造方法</h3><p>和 <a href="#">「2.2.1 构造方法」</a> 相同。</p>
<h3 id="2-4-2-newInstance"><a href="#2-4-2-newInstance" class="headerlink" title="2.4.2 newInstance"></a>2.4.2 newInstance</h3><p>和 <a href="#">「2.2.2 newInstance」</a> 相同。</p>
<h3 id="2-4-3-初始化"><a href="#2-4-3-初始化" class="headerlink" title="2.4.3 初始化"></a>2.4.3 初始化</h3><p>PooledUnsafeDirectByteBuf 重写了初始化相关的方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolChunk&lt;ByteBuffer&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> maxLength,</span></span></span><br><span class="line"><span class="function"><span class="params">          PoolThreadCache cache)</span> </span>{</span><br><span class="line">    <span class="comment">// 调用父初始化方法</span></span><br><span class="line">    <span class="keyword">super</span>.init(chunk, handle, offset, length, maxLength, cache);</span><br><span class="line">    <span class="comment">// 初始化内存地址</span></span><br><span class="line">    initMemoryAddress(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initUnpooled</span><span class="params">(PoolChunk&lt;ByteBuffer&gt; chunk, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="comment">// 调用父初始化方法</span></span><br><span class="line">    <span class="keyword">super</span>.initUnpooled(chunk, length);</span><br><span class="line">    <span class="comment">// 初始化内存地址</span></span><br><span class="line">    initMemoryAddress(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>在 <code>&lt;1&gt;</code> 处，增加调用 <code>#initMemoryAddress()</code> 方法，初始化内存地址。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> memoryAddress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMemoryAddress</span><span class="params">()</span> </span>{</span><br><span class="line">    memoryAddress = PlatformDependent.directBufferAddress(memory) + offset; <span class="comment">// &lt;2&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>PlatformDependent#directBufferAddress(ByteBuffer buffer)</code> 方法，获得 ByteBuffer 对象的起始内存地址。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">directBufferAddress</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent0.directBufferAddress(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent0.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">directBufferAddress</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getLong(buffer, ADDRESS_FIELD_OFFSET);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object object, <span class="keyword">long</span> fieldOffset)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getLong(object, fieldOffset);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 Unsafe 类不熟悉的胖友，可以看看 <a href="https://blog.csdn.net/zhxdick/article/details/52003123" rel="external nofollow noopener noreferrer" target="_blank">《Java Unsafe 类》</a></li>
</ul>
</li>
<li><p>注意，<code>&lt;2&gt;</code> 处的代码，已经将 <code>offset</code> 添加到 <code>memoryAddress</code> 中。所以在 <code>#addr(int index)</code> 方法中，求指定位置( <code>index</code> ) 在内存地址的顺序，不用再添加。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">addr</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> memoryAddress + index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-4-newInternalNioBuffer"><a href="#2-4-4-newInternalNioBuffer" class="headerlink" title="2.4.4 newInternalNioBuffer"></a>2.4.4 newInternalNioBuffer</h3><p>和 <a href="#">「2.2.3 newInternalNioBuffer」</a> 相同。</p>
<h3 id="2-4-5-isDirect"><a href="#2-4-5-isDirect" class="headerlink" title="2.4.5 isDirect"></a>2.4.5 isDirect</h3><p>和 <a href="#">「2.2.4 isDirect」</a> 相同。</p>
<h3 id="2-4-6-读取-写入操作"><a href="#2-4-6-读取-写入操作" class="headerlink" title="2.4.6 读取 / 写入操作"></a>2.4.6 读取 / 写入操作</h3><p>老样子，我们以 Int 类型为例子，来看看它的读取和写入操作的实现代码。</p>
<p>① <strong>读取</strong>操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">_getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UnsafeByteBufUtil.getInt(addr(index));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnsafeByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">long</span> address)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (UNALIGNED) {</span><br><span class="line">        <span class="keyword">int</span> v = PlatformDependent.getInt(address);</span><br><span class="line">        <span class="keyword">return</span> BIG_ENDIAN_NATIVE_ORDER ? v : Integer.reverseBytes(v);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.getByte(address) &lt;&lt; <span class="number">24</span> |</span><br><span class="line">           (PlatformDependent.getByte(address + <span class="number">1</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span> |</span><br><span class="line">           (PlatformDependent.getByte(address + <span class="number">2</span>) &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span> |</span><br><span class="line">           PlatformDependent.getByte(address + <span class="number">3</span>)  &amp; <span class="number">0xff</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">long</span> address)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent0.getInt(address);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent0.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">long</span> address)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(address);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>② <strong>写入</strong>操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">_setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    UnsafeByteBufUtil.setInt(addr(index), value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnsafeByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (UNALIGNED) {</span><br><span class="line">        PlatformDependent.putInt(address, BIG_ENDIAN_NATIVE_ORDER ? value : Integer.reverseBytes(value));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        PlatformDependent.putByte(address, (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">24</span>));</span><br><span class="line">        PlatformDependent.putByte(address + <span class="number">1</span>, (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">        PlatformDependent.putByte(address + <span class="number">2</span>, (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">8</span>));</span><br><span class="line">        PlatformDependent.putByte(address + <span class="number">3</span>, (<span class="keyword">byte</span>) value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    PlatformDependent0.putInt(address, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent0.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    UNSAFE.putInt(address, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-7-copy"><a href="#2-4-7-copy" class="headerlink" title="2.4.7 copy"></a>2.4.7 copy</h3><p><code>#copy(int index, int length)</code> 方法，复制指定范围的数据到新创建的 Direct ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">copy</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UnsafeByteBufUtil.copy(<span class="keyword">this</span>, addr(index), index, length);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnsafeByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ByteBuf <span class="title">copy</span><span class="params">(AbstractByteBuf buf, <span class="keyword">long</span> addr, <span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    buf.checkIndex(index, length);</span><br><span class="line">    <span class="comment">// 创建 Direct ByteBuffer 对象</span></span><br><span class="line">    ByteBuf copy = buf.alloc().directBuffer(length, buf.maxCapacity());</span><br><span class="line">    <span class="keyword">if</span> (length != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (copy.hasMemoryAddress()) {</span><br><span class="line">            <span class="comment">// 使用 Unsafe 操作来复制</span></span><br><span class="line">            PlatformDependent.copyMemory(addr, copy.memoryAddress(), length);</span><br><span class="line">            copy.setIndex(<span class="number">0</span>, length);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            copy.writeBytes(buf, index, length);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(<span class="keyword">long</span> srcAddr, <span class="keyword">long</span> dstAddr, <span class="keyword">long</span> length)</span> </span>{</span><br><span class="line">    PlatformDependent0.copyMemory(srcAddr, dstAddr, length);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent0.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(<span class="keyword">long</span> srcAddr, <span class="keyword">long</span> dstAddr, <span class="keyword">long</span> length)</span> </span>{</span><br><span class="line">    <span class="comment">//UNSAFE.copyMemory(srcAddr, dstAddr, length);</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">long</span> size = Math.min(length, UNSAFE_COPY_THRESHOLD);</span><br><span class="line">        UNSAFE.copyMemory(srcAddr, dstAddr, size);</span><br><span class="line">        length -= size;</span><br><span class="line">        srcAddr += size;</span><br><span class="line">        dstAddr += size;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-8-转换-NIO-ByteBuffer-操作"><a href="#2-4-8-转换-NIO-ByteBuffer-操作" class="headerlink" title="2.4.8 转换 NIO ByteBuffer 操作"></a>2.4.8 转换 NIO ByteBuffer 操作</h3><h4 id="2-4-8-1-nioBufferCount"><a href="#2-4-8-1-nioBufferCount" class="headerlink" title="2.4.8.1 nioBufferCount"></a>2.4.8.1 nioBufferCount</h4><p>和 <a href="#">「2.2.7.1 nioBufferCount」</a> 一致。</p>
<h4 id="2-4-8-2-nioBuffer"><a href="#2-4-8-2-nioBuffer" class="headerlink" title="2.4.8.2 nioBuffer"></a>2.4.8.2 nioBuffer</h4><p>和 <a href="#">「2.2.7.2 nioBuffer」</a> 一致。</p>
<h4 id="2-4-8-3-nioBuffers"><a href="#2-4-8-3-nioBuffers" class="headerlink" title="2.4.8.3 nioBuffers"></a>2.4.8.3 nioBuffers</h4><p>和 <a href="#">「2.2.7.3 nioBuffers」</a> 一致。</p>
<h4 id="2-4-8-4-internalNioBuffer"><a href="#2-4-8-4-internalNioBuffer" class="headerlink" title="2.4.8.4 internalNioBuffer"></a>2.4.8.4 internalNioBuffer</h4><p>和 <a href="#">「2.2.7.4 internalNioBuffer」</a> 一致。</p>
<h3 id="2-4-9-Heap-相关方法"><a href="#2-4-9-Heap-相关方法" class="headerlink" title="2.4.9 Heap 相关方法"></a>2.4.9 Heap 相关方法</h3><p>不支持 Heap 相关方法。</p>
<h3 id="2-4-10-Unsafe-相关方法。"><a href="#2-4-10-Unsafe-相关方法。" class="headerlink" title="2.4.10 Unsafe 相关方法。"></a>2.4.10 Unsafe 相关方法。</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMemoryAddress</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">memoryAddress</span><span class="params">()</span> </span>{</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">return</span> memoryAddress;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-11-newSwappedByteBuf"><a href="#2-4-11-newSwappedByteBuf" class="headerlink" title="2.4.11 newSwappedByteBuf"></a>2.4.11 newSwappedByteBuf</h3><blockquote>
<p><code>#newSwappedByteBuf()</code> 方法的<strong>重写</strong>，是 Unsafe 类型独有的。</p>
</blockquote>
<p><code>#newSwappedByteBuf()</code> 方法，创建 SwappedByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SwappedByteBuf <span class="title">newSwappedByteBuf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.isUnaligned()) { <span class="comment">// 支持</span></span><br><span class="line">        <span class="comment">// Only use if unaligned access is supported otherwise there is no gain.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnsafeDirectSwappedByteBuf(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.newSwappedByteBuf();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 Linux 环境下，一般是支持 unaligned access( 对齐访问 )，所以返回的是 UnsafeDirectSwappedByteBuf 对象。详细解析，见 <a href="#">《TODO 1016 派生类》</a> 。</li>
<li>为什么要对齐访问呢？可看 <a href="https://www.zhihu.com/question/23791224" rel="external nofollow noopener noreferrer" target="_blank">《什么是字节对齐，为什么要对齐?》</a> 。有趣。</li>
</ul>
<h2 id="2-5-PooledUnsafeHeapByteBuf"><a href="#2-5-PooledUnsafeHeapByteBuf" class="headerlink" title="2.5 PooledUnsafeHeapByteBuf"></a>2.5 PooledUnsafeHeapByteBuf</h2><p><code>io.netty.buffer.PooledUnsafeHeapByteBuf</code> ，实现 PooledHeapByteBuf 类，在 <a href="#">「2.3 PooledHeapByteBuf」</a> 的基础上，基于 <strong>Unsafe</strong> 的<strong>可重用</strong> ByteBuf 实现类。所以，泛型 <code>T</code> 为 <code>byte[]</code> ，即：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">final class PooledUnsafeHeapByteBuf extends PooledHeapByteBuf</span><br></pre></td></tr></tbody></table></figure>
<p>也因此，PooledUnsafeHeapByteBuf 需要实现的方法，灰常少。</p>
<h3 id="2-5-1-构造方法"><a href="#2-5-1-构造方法" class="headerlink" title="2.5.1 构造方法"></a>2.5.1 构造方法</h3><p>和 <a href="#">「2.2.1 构造方法」</a> 相同。</p>
<h3 id="2-5-2-newInstance"><a href="#2-5-2-newInstance" class="headerlink" title="2.5.2 newInstance"></a>2.5.2 newInstance</h3><p>和 <a href="#">「2.2.2 newInstance」</a> 相同。</p>
<h3 id="2-5-3-读取-写入操作"><a href="#2-5-3-读取-写入操作" class="headerlink" title="2.5.3 读取 / 写入操作"></a>2.5.3 读取 / 写入操作</h3><p>老样子，我们以 Int 类型为例子，来看看它的读取和写入操作的实现代码。</p>
<p>① <strong>读取</strong>操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">_getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UnsafeByteBufUtil.getInt(memory, idx(index));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnsafeByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (UNALIGNED) {</span><br><span class="line">        <span class="keyword">int</span> v = PlatformDependent.getInt(array, index);</span><br><span class="line">        <span class="keyword">return</span> BIG_ENDIAN_NATIVE_ORDER ? v : Integer.reverseBytes(v);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.getByte(array, index) &lt;&lt; <span class="number">24</span> |</span><br><span class="line">           (PlatformDependent.getByte(array, index + <span class="number">1</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span> |</span><br><span class="line">           (PlatformDependent.getByte(array, index + <span class="number">2</span>) &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span> |</span><br><span class="line">           PlatformDependent.getByte(array, index + <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent0.getInt(data, index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent0.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(data, BYTE_ARRAY_BASE_OFFSET + index);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>基于 Unsafe 操作 <code>byte[]</code> 数组。</li>
</ul>
<p>② <strong>写入</strong>操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">_setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    UnsafeByteBufUtil.setInt(memory, idx(index), value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnsafeByteBufUtil.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (UNALIGNED) {</span><br><span class="line">        PlatformDependent.putInt(array, index, BIG_ENDIAN_NATIVE_ORDER ? value : Integer.reverseBytes(value));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        PlatformDependent.putByte(array, index, (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">24</span>));</span><br><span class="line">        PlatformDependent.putByte(array, index + <span class="number">1</span>, (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">        PlatformDependent.putByte(array, index + <span class="number">2</span>, (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">8</span>));</span><br><span class="line">        PlatformDependent.putByte(array, index + <span class="number">3</span>, (<span class="keyword">byte</span>) value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    PlatformDependent0.putInt(data, index, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent0.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    UNSAFE.putInt(data, BYTE_ARRAY_BASE_OFFSET + index, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-4-newSwappedByteBuf"><a href="#2-5-4-newSwappedByteBuf" class="headerlink" title="2.5.4 newSwappedByteBuf"></a>2.5.4 newSwappedByteBuf</h3><blockquote>
<p><code>#newSwappedByteBuf()</code> 方法的<strong>重写</strong>，是 Unsafe 类型独有的。</p>
</blockquote>
<p><code>#newSwappedByteBuf()</code> 方法，创建 SwappedByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SwappedByteBuf <span class="title">newSwappedByteBuf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.isUnaligned()) {</span><br><span class="line">        <span class="comment">// Only use if unaligned access is supported otherwise there is no gain.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnsafeHeapSwappedByteBuf(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.newSwappedByteBuf();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 Linux 环境下，一般是支持 unaligned access( 对齐访问 )，所以返回的是 UnsafeHeapSwappedByteBuf 对象。详细解析，见 <a href="#">《TODO 1016 派生类》</a> 。</li>
</ul>
<h1 id="3-UnpooledByteBuf"><a href="#3-UnpooledByteBuf" class="headerlink" title="3. UnpooledByteBuf"></a>3. UnpooledByteBuf</h1><p>😈 不存在 UnpooledByteBuf 这样一个类，主要是为了<strong>聚合</strong>所有 Unpooled 类型的 ByteBuf 实现类。</p>
<h2 id="3-1-UnpooledDirectByteBuf"><a href="#3-1-UnpooledDirectByteBuf" class="headerlink" title="3.1 UnpooledDirectByteBuf"></a>3.1 UnpooledDirectByteBuf</h2><p><code>io.netty.buffer.UnpooledDirectByteBuf</code> ，实现 AbstractReferenceCountedByteBuf 抽象类，对应 <a href="#">「2.2 PooledDirectByteBuf」</a> 的<strong>非池化</strong> ByteBuf 实现类。</p>
<h3 id="3-1-1-构造方法"><a href="#3-1-1-构造方法" class="headerlink" title="3.1.1 构造方法"></a>3.1.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuf 分配器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据 ByteBuffer 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ByteBuffer buffer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 临时 ByteBuffer 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要释放 &lt;1&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 {<span class="doctag">@link</span> #buffer} 从外部传入，则需要进行释放，即 {<span class="doctag">@link</span> #UnpooledDirectByteBuf(ByteBufAllocator, ByteBuffer, int)} 构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> doNotFree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">    <span class="keyword">if</span> (alloc == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"alloc"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"initialCapacity: "</span> + initialCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (maxCapacity &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxCapacity: "</span> + maxCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Direct ByteBuffer 对象</span></span><br><span class="line">    <span class="comment">// 设置数据 ByteBuffer 对象</span></span><br><span class="line">    setByteBuffer(ByteBuffer.allocateDirect(initialCapacity));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, ByteBuffer initialBuffer, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">    <span class="keyword">if</span> (alloc == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"alloc"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (initialBuffer == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"initialBuffer"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!initialBuffer.isDirect()) { <span class="comment">// 必须是 Direct</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"initialBuffer is not a direct buffer."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (initialBuffer.isReadOnly()) { <span class="comment">// 必须可写</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"initialBuffer is a read-only buffer."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得剩余可读字节数，作为初始容量大小 &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">int</span> initialCapacity = initialBuffer.remaining();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记为 true 。因为 initialBuffer 是从外部传递进来，释放的工作，不交给当前 UnpooledDirectByteBuf 对象。</span></span><br><span class="line">    doNotFree = <span class="keyword">true</span>; &lt;<span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slice 切片</span></span><br><span class="line">    <span class="comment">// 设置数据 ByteBuffer 对象</span></span><br><span class="line">    setByteBuffer(initialBuffer.slice().order(ByteOrder.BIG_ENDIAN));</span><br><span class="line">    <span class="comment">// 设置写索引 &lt;2&gt;</span></span><br><span class="line">    writerIndex(initialCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，主要要理解下 <code>&lt;1&gt;</code> 和 <code>&lt;2&gt;</code> 两处。</li>
<li><p>调用 <code>#allocateDirect(int initialCapacity)</code> 方法，创建 Direct ByteBuffer 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.allocateDirect(initialCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>调用 <code>#setByteBuffer(ByteBuffer buffer)</code> 方法，设置数据 ByteBuffer 对象。如果有老的<strong>自己的</strong>( 指的是自己创建的 ) <code>buffer</code> 对象，需要进行释放。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setByteBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">    ByteBuffer oldBuffer = <span class="keyword">this</span>.buffer;</span><br><span class="line">    <span class="keyword">if</span> (oldBuffer != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 标记为 false 。因为设置的 ByteBuffer 对象，是 UnpooledDirectByteBuf 自己创建的</span></span><br><span class="line">        <span class="keyword">if</span> (doNotFree) {</span><br><span class="line">            doNotFree = <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 释放老的 buffer 对象</span></span><br><span class="line">            freeDirect(oldBuffer); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 buffer</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">    <span class="comment">// 重置 tmpNioBuf 为 null</span></span><br><span class="line">    tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    capacity = buffer.remaining();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;3&gt;</code> 处，调用 <code>#freeDirect(ByteBuffer buffer)</code> 方法，释放<strong>老的</strong> <code>buffer</code> 对象。详细解析，见 <a href="#">「3.1.3 deallocate」</a> 。</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-capacity"><a href="#3-1-2-capacity" class="headerlink" title="3.1.2 capacity"></a>3.1.2 capacity</h3><p><code>#capacity()</code> 方法，获得容量。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> capacity;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>#capacity(int newCapacity)</code> 方法，调整容量大小。在这个过程中，根据情况，可能对 <code>buffer</code> 扩容或缩容。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验新的容量，不能超过最大容量</span></span><br><span class="line">    checkNewCapacity(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> readerIndex = readerIndex();</span><br><span class="line">    <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = capacity;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) {</span><br><span class="line">        ByteBuffer oldBuffer = buffer;</span><br><span class="line">        <span class="comment">// 创建新的 Direct ByteBuffer 对象</span></span><br><span class="line">        ByteBuffer newBuffer = allocateDirect(newCapacity);</span><br><span class="line">        <span class="comment">// 复制数据到新的 buffer 对象</span></span><br><span class="line">        oldBuffer.position(<span class="number">0</span>).limit(oldBuffer.capacity());</span><br><span class="line">        newBuffer.position(<span class="number">0</span>).limit(oldBuffer.capacity());</span><br><span class="line">        newBuffer.put(oldBuffer);</span><br><span class="line">        newBuffer.clear(); <span class="comment">// 因为读取和写入，使用 readerIndex 和 writerIndex ，所以没关系。</span></span><br><span class="line">        <span class="comment">// 设置新的 buffer 对象，并根据条件释放老的 buffer 对象</span></span><br><span class="line">        setByteBuffer(newBuffer);</span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (newCapacity &lt; oldCapacity) {</span><br><span class="line">        ByteBuffer oldBuffer = buffer;</span><br><span class="line">        <span class="comment">// 创建新的 Direct ByteBuffer 对象</span></span><br><span class="line">        ByteBuffer newBuffer = allocateDirect(newCapacity);</span><br><span class="line">        <span class="keyword">if</span> (readerIndex &lt; newCapacity) {</span><br><span class="line">            <span class="comment">// 如果写索引超过新容量，需要重置下，设置为最大容量。否则就越界了。</span></span><br><span class="line">            <span class="keyword">if</span> (writerIndex &gt; newCapacity) {</span><br><span class="line">                writerIndex(writerIndex = newCapacity);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 复制数据到新的 buffer 对象</span></span><br><span class="line">            oldBuffer.position(readerIndex).limit(writerIndex);</span><br><span class="line">            newBuffer.position(readerIndex).limit(writerIndex);</span><br><span class="line">            newBuffer.put(oldBuffer);</span><br><span class="line">            newBuffer.clear(); <span class="comment">// 因为读取和写入，使用 readerIndex 和 writerIndex ，所以没关系。</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 因为读索引超过新容量，所以写索引超过新容量</span></span><br><span class="line">            <span class="comment">// 如果读写索引都超过新容量，需要重置下，都设置为最大容量。否则就越界了。</span></span><br><span class="line">            setIndex(newCapacity, newCapacity);</span><br><span class="line">            <span class="comment">// 这里要注意下，老的数据，相当于不进行复制，因为已经读取完了。</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 设置新的 buffer 对象，并根据条件释放老的 buffer 对象</span></span><br><span class="line">        setByteBuffer(newBuffer);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然代码比较长，实际很简单。胖友自己耐心看下注释进行理解下噢。</li>
</ul>
<h3 id="3-1-3-deallocate"><a href="#3-1-3-deallocate" class="headerlink" title="3.1.3 deallocate"></a>3.1.3 deallocate</h3><p><code>#deallocate()</code> 方法，当引用计数为 0 时，调用该方法，进行内存回收。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>{</span><br><span class="line">    ByteBuffer buffer = <span class="keyword">this</span>.buffer;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 置空 buffer 属性</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 buffer 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!doNotFree) {</span><br><span class="line">        freeDirect(buffer);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>#freeDirect(ByteBuffer buffer)</code> 方法，释放 <code>buffer</code> 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeArray</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>{</span><br><span class="line">    PlatformDependent.freeDirectBuffer(buffer);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PlatformDependent.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cleaner NOOP = <span class="keyword">new</span> Cleaner() { ... }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">    CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过调用 <code>io.netty.util.internal.Cleaner#freeDirectBuffer(ByteBuffer buffer)</code> 方法，释放 Direct ByteBuffer 对象。因为 Java 的版本不同，调用的方法，所以 Cleaner 有两个 实现类：</li>
<li><code>io.netty.util.internal.CleanerJava9</code> ，适用于 Java9+ 的版本，通过反射调用 DirectByteBuffer 对象的 <code>#invokeCleaner()</code> 方法，进行释放。</li>
<li><code>io.netty.util.internal.CleanerJava6</code> ，适用于 Java6+ 的版本，通过反射获得 DirectByteBuffer 对象的 <code>#cleaner()</code> 方法，从而调用 <code>sun.misc.Cleaner#clean()</code> 方法，进行释放。</li>
<li>虽然实现略有不同，但是原理是一致的。感兴趣的胖友，自己看下 CleanerJava9 和 CleanerJava6 的实现代码。</li>
</ul>
</li>
</ul>
<h3 id="3-1-4-其它方法"><a href="#3-1-4-其它方法" class="headerlink" title="3.1.4 其它方法"></a>3.1.4 其它方法</h3><p>其他方法，和 <a href="#">「2.2 PooledDirectByteBuf」</a> 基本一致。</p>
<h2 id="3-2-UnpooledHeapByteBuf"><a href="#3-2-UnpooledHeapByteBuf" class="headerlink" title="3.2 UnpooledHeapByteBuf"></a>3.2 UnpooledHeapByteBuf</h2><p><code>io.netty.buffer.UnpooledHeapByteBuf</code> ，实现 AbstractReferenceCountedByteBuf 抽象类，对应 <a href="#">「2.3 PooledHeapByteBuf」</a> 的<strong>非池化</strong> ByteBuf 实现类。</p>
<h3 id="3-2-1-构造方法"><a href="#3-2-1-构造方法" class="headerlink" title="3.2.1 构造方法"></a>3.2.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuf 分配器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] array;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 临时 ByteBuff 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">    checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并设置字节数组</span></span><br><span class="line">    setArray(allocateArray(initialCapacity));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置读写索引</span></span><br><span class="line">    setIndex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">byte</span>[] initialArray, <span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">    checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line">    checkNotNull(initialArray, <span class="string">"initialArray"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialArray.length &gt; maxCapacity) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialArray.length, maxCapacity));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字节数组</span></span><br><span class="line">    setArray(initialArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置读写索引</span></span><br><span class="line">    setIndex(<span class="number">0</span>, initialArray.length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第一、二个构造方法的区别，后者字节数组是否从方法参数( <code>initialArray</code> )传递进来。</li>
<li><p>调用 <code>#allocateArray(int initialCapacity)</code> 方法，创建字节数组。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>调用 <code>#setArray(byte[] initialArray)</code> 方法，设置 <code>array</code> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">byte</span>[] initialArray)</span> </span>{</span><br><span class="line">        array = initialArray;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ```    </span><br><span class="line"></span><br><span class="line">### 3.2.2 capacity</span><br><span class="line"></span><br><span class="line">`#capacity()` 方法，获得容量。代码如下：</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> array.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用字节数组的大小，作为当前容量上限。</p>
</li>
</ul>
<hr>
<p><code>#capacity(int newCapacity)</code> 方法，调整容量大小。在这个过程中，根据情况，可能对 <code>array</code> 扩容或缩容。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// // 校验新的容量，不能超过最大容量</span></span><br><span class="line">    checkNewCapacity(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = array.length;</span><br><span class="line">    <span class="keyword">byte</span>[] oldArray = array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) {</span><br><span class="line">        <span class="comment">// 创建新数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] newArray = allocateArray(newCapacity);</span><br><span class="line">        <span class="comment">// 复制【全部】数据到新数组</span></span><br><span class="line">        System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, oldArray.length);</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newArray);</span><br><span class="line">        <span class="comment">// 释放老数组</span></span><br><span class="line">        freeArray(oldArray);</span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (newCapacity &lt; oldCapacity) {</span><br><span class="line">        <span class="comment">// 创建新数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] newArray = allocateArray(newCapacity);</span><br><span class="line">        <span class="keyword">int</span> readerIndex = readerIndex();</span><br><span class="line">        <span class="keyword">if</span> (readerIndex &lt; newCapacity) {</span><br><span class="line">            <span class="comment">// 如果写索引超过新容量，需要重置下，设置为最大容量。否则就越界了。</span></span><br><span class="line">            <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">            <span class="keyword">if</span> (writerIndex &gt; newCapacity) {</span><br><span class="line">                writerIndex(writerIndex = newCapacity);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 只复制【读取段】数据到新数组</span></span><br><span class="line">            System.arraycopy(oldArray, readerIndex, newArray, readerIndex, writerIndex - readerIndex);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 因为读索引超过新容量，所以写索引超过新容量</span></span><br><span class="line">            <span class="comment">// 如果读写索引都超过新容量，需要重置下，都设置为最大容量。否则就越界了。</span></span><br><span class="line">            setIndex(newCapacity, newCapacity);</span><br><span class="line">            <span class="comment">// 这里要注意下，老的数据，相当于不进行复制，因为已经读取完了。</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newArray);</span><br><span class="line">        <span class="comment">// 释放老数组</span></span><br><span class="line">        freeArray(oldArray);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然代码比较长，实际很简单。胖友自己耐心看下注释进行理解下噢。😈 和 <a href="#">「3.1.2 capacity」</a> 基本一直的。</li>
</ul>
<h3 id="3-2-3-deallocate"><a href="#3-2-3-deallocate" class="headerlink" title="3.2.3 deallocate"></a>3.2.3 deallocate</h3><p><code>#deallocate()</code> 方法，当引用计数为 0 时，调用该方法，进行内存回收。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 释放老数组</span></span><br><span class="line">    freeArray(array);</span><br><span class="line">    <span class="comment">// 设置为空字节数组</span></span><br><span class="line">    array = EmptyArrays.EMPTY_BYTES;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>#freeArray(byte[] array)</code> 方法，释放数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeArray</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>{</span><br><span class="line">    <span class="comment">// NOOP</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>字节数组，无引用后，自然就会被 GC 回收。</li>
</ul>
</li>
</ul>
<h3 id="3-2-4-其它方法"><a href="#3-2-4-其它方法" class="headerlink" title="3.2.4 其它方法"></a>3.2.4 其它方法</h3><p>其它方法，和 <a href="#">「2.3 PooledHeapByteBuf」</a> 基本一致。</p>
<h2 id="3-3-UnpooledUnsafeDirectByteBuf"><a href="#3-3-UnpooledUnsafeDirectByteBuf" class="headerlink" title="3.3 UnpooledUnsafeDirectByteBuf"></a>3.3 UnpooledUnsafeDirectByteBuf</h2><p><code>io.netty.buffer.UnpooledUnsafeDirectByteBuf</code> ，实现 AbstractReferenceCountedByteBuf 抽象类，对应 <code>「2.4 PooledUnsafeDirectByteBuf」</code> 的<strong>非池化</strong> ByteBuf 实现类。</p>
<ul>
<li>构造方法、<code>#capacity(...)</code> 方法、<code>#deallocate()</code> 方法，和 <a href="#">「3.1  PooledDirectByteBuf」</a> 基本一致。</li>
<li>其它方法，和 <a href="#">「2.4 PooledUnsafeDirectByteBuf」</a> 基本一致。</li>
</ul>
<p>另外，UnpooledUnsafeDirectByteBuf 有一个子类 UnpooledUnsafeNoCleanerDirectByteBuf ，用于 <code>netty-microbench</code> 模块，进行基准测试。感兴趣的胖友，可以自己看看。</p>
<h2 id="3-4-UnpooledUnsafeHeapByteBuf"><a href="#3-4-UnpooledUnsafeHeapByteBuf" class="headerlink" title="3.4 UnpooledUnsafeHeapByteBuf"></a>3.4 UnpooledUnsafeHeapByteBuf</h2><p><code>io.netty.buffer.UnpooledUnsafeHeapByteBuf</code> ，实现 AbstractReferenceCountedByteBuf 抽象类，对应 <code>「2.5 PooledUnsafeHeapByteBuf」</code> 的<strong>非池化</strong> ByteBuf 实现类。</p>
<ul>
<li>构造方法、<code>#capacity(...)</code> 方法、<code>#deallocate()</code> 方法，和 <a href="#">「3.2  PooledHeapByteBuf」</a> 基本一致。</li>
<li>其它方法，和 <a href="#">「2.5 PooledUnsafeHeapByteBuf」</a> 基本一致。</li>
</ul>
<h2 id="3-5-ThreadLocal-ByteBuf"><a href="#3-5-ThreadLocal-ByteBuf" class="headerlink" title="3.5 ThreadLocal ByteBuf"></a>3.5 ThreadLocal ByteBuf</h2><blockquote>
<p>老艿艿：这是本文的拓展内容。</p>
</blockquote>
<p>虽然 UnpooledByteBuf 不基于<strong>对象池</strong>实现，但是考虑到 NIO Direct ByteBuffer 申请的成本是比较高的，所以基于 ThreadLocal + Recycler 实现重用。</p>
<p><code>ByteBufUtil#threadLocalDirectBuffer()</code> 方法，创建 ThreadLocal ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_LOCAL_BUFFER_SIZE;</span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="string">"io.netty.threadLocalDirectBufferSize"</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a cached thread-local direct buffer, if available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a cached thread-local direct buffer, if available.  {<span class="doctag">@code</span> null} otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">threadLocalDirectBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (THREAD_LOCAL_BUFFER_SIZE &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) {</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalUnsafeDirectByteBuf.newInstance();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalDirectByteBuf.newInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>THREAD_LOCAL_BUFFER_SIZE</code> <strong>静态</strong>属性，通过 <code>"io.netty.threadLocalDirectBufferSize"</code> 配置，默认为 0 。也就是说，实际 <code>#threadLocalDirectBuffer()</code> 方法，返回 <code>null</code> ，不开启 ThreadLocal ByteBuf 的功能。</li>
<li>根据是否支持 Unsafe 操作，创建 ThreadLocalUnsafeDirectByteBuf 或 ThreadLocalDirectByteBuf 对象。</li>
</ul>
<h3 id="3-5-1-ThreadLocalUnsafeDirectByteBuf"><a href="#3-5-1-ThreadLocalUnsafeDirectByteBuf" class="headerlink" title="3.5.1 ThreadLocalUnsafeDirectByteBuf"></a>3.5.1 ThreadLocalUnsafeDirectByteBuf</h3><p>ThreadLocalUnsafeDirectByteBuf ，在 ByteBufUtil 的<strong>内部静态类</strong>，继承 UnpooledUnsafeDirectByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recycler 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;ThreadLocalUnsafeDirectByteBuf&gt; RECYCLER =</span><br><span class="line">            <span class="keyword">new</span> Recycler&lt;ThreadLocalUnsafeDirectByteBuf&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> ThreadLocalUnsafeDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;ThreadLocalUnsafeDirectByteBuf&gt; handle)</span> </span>{</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalUnsafeDirectByteBuf(handle);</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 从 RECYCLER 中，获得 ThreadLocalUnsafeDirectByteBuf 对象</span></span><br><span class="line">        ThreadLocalUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">        <span class="comment">// 初始化 ref 为 1</span></span><br><span class="line">        buf.setRefCnt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recycler 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;ThreadLocalUnsafeDirectByteBuf&gt; handle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalUnsafeDirectByteBuf</span><span class="params">(Handle&lt;ThreadLocalUnsafeDirectByteBuf&gt; handle)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(UnpooledByteBufAllocator.DEFAULT, <span class="number">256</span>, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (capacity() &gt; THREAD_LOCAL_BUFFER_SIZE) { <span class="comment">// &lt;1&gt;</span></span><br><span class="line">            <span class="comment">// 释放</span></span><br><span class="line">            <span class="keyword">super</span>.deallocate();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空</span></span><br><span class="line">            clear();</span><br><span class="line">            <span class="comment">// 回收对象</span></span><br><span class="line">            handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <code>&lt;1&gt;</code> 处，我们可以看到，只有 ByteBuffer 容量小于 <code>THREAD_LOCAL_BUFFER_SIZE</code> 时，才会重用 ByteBuffer 对象。</li>
</ul>
<h3 id="3-5-2-ThreadLocalDirectByteBuf"><a href="#3-5-2-ThreadLocalDirectByteBuf" class="headerlink" title="3.5.2 ThreadLocalDirectByteBuf"></a>3.5.2 ThreadLocalDirectByteBuf</h3><p>ThreadLocalUnsafeDirectByteBuf ，在 ByteBufUtil 的<strong>内部静态类</strong>，继承 UnpooledDirectByteBuf 类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledDirectByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recycler 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;ThreadLocalDirectByteBuf&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;ThreadLocalDirectByteBuf&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> ThreadLocalDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;ThreadLocalDirectByteBuf&gt; handle)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalDirectByteBuf(handle);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalDirectByteBuf <span class="title">newInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 从 RECYCLER 中，获得 ThreadLocalUnsafeDirectByteBuf 对象</span></span><br><span class="line">        ThreadLocalDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">        <span class="comment">// 初始化 ref 为 1</span></span><br><span class="line">        buf.setRefCnt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recycler 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handle&lt;ThreadLocalDirectByteBuf&gt; handle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalDirectByteBuf</span><span class="params">(Handle&lt;ThreadLocalDirectByteBuf&gt; handle)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(UnpooledByteBufAllocator.DEFAULT, <span class="number">256</span>, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (capacity() &gt; THREAD_LOCAL_BUFFER_SIZE) {</span><br><span class="line">            <span class="comment">// 释放</span></span><br><span class="line">            <span class="keyword">super</span>.deallocate();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            clear();</span><br><span class="line">            <span class="comment">// 回收</span></span><br><span class="line">            handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-6-WrappedUnpooledUnsafeDirectByteBuf"><a href="#3-6-WrappedUnpooledUnsafeDirectByteBuf" class="headerlink" title="3.6 WrappedUnpooledUnsafeDirectByteBuf"></a>3.6 WrappedUnpooledUnsafeDirectByteBuf</h2><blockquote>
<p>老艿艿：这是本文的拓展内容。</p>
</blockquote>
<p><code>io.netty.buffer.WrappedUnpooledUnsafeDirectByteBuf</code> ，继承 UnpooledUnsafeDirectByteBuf 类，基于 <code>memoryAddress</code> 内存地址，创建 Direct ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedUnpooledUnsafeDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeDirectByteBuf</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于 memoryAddress 内存地址，创建 Direct ByteBuf 对象</span></span><br><span class="line">    WrappedUnpooledUnsafeDirectByteBuf(ByteBufAllocator alloc, <span class="keyword">long</span> memoryAddress, <span class="keyword">int</span> size, <span class="keyword">boolean</span> doFree) {</span><br><span class="line">        <span class="keyword">super</span>(alloc, PlatformDependent.directBuffer(memoryAddress, size) <span class="comment">/** 创建 Direct ByteBuf 对象 **/</span>, size, doFree);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">freeDirect</span><span class="params">(ByteBuffer buffer)</span> </span>{</span><br><span class="line">        PlatformDependent.freeMemory(memoryAddress);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>FROM <a href="https://www.jianshu.com/p/b833254908f7" rel="external nofollow noopener noreferrer" target="_blank">《Netty源码分析（一） ByteBuf》</a></p>
<p>创建一个指定内存地址的UnpooledUnsafeDirectByteBuf，该内存块可能已被写入数据以减少一步拷贝操作。</p>
</blockquote>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>每次这种 N 多实现类的源码解析，写到 60% 的时候，就特别头疼。不是因为难写，是因为基本是组合排列，不断在啰嗦啰嗦啰嗦的感觉。</p>
<p>嗯嗯，如果有地方写的错乱，烦请指出。默默再 review 几遍。</p>
<hr>
<p>推荐阅读文章：</p>
<ul>
<li>HryReal <a href="https://blog.csdn.net/qq_33394088/article/details/72763305" rel="external nofollow noopener noreferrer" target="_blank">《PooledByteBuf源码分析》</a></li>
<li>江南白衣 <a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" rel="external nofollow noopener noreferrer" target="_blank">《Netty之Java堆外内存扫盲贴》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-1-2-ByteBuf-core-impl/" data-id="ck4pl3fp400e0fgcfxmedsoke" class="article-share-link">分享</a>

</footer>
-->
</div>
