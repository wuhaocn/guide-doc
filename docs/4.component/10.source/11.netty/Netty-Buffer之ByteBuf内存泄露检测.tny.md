<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在本文，我们来分享 Netty 的<strong>内存泄露检测</strong>的实现机制。考虑到胖友更好的理解本文，请先阅读江南白衣大大的 <a href="http://calvin1978.blogcn.com/articles/netty-leak.html" rel="external nofollow noopener noreferrer" target="_blank">《Netty 之有效规避内存泄漏》</a> 。</p>
<p>因为江南白衣大大在文章中，已经很清晰的讲解了概念与原理，笔者就不班门弄斧，直接上手，撸源码。</p>
<h1 id="2-ReferenceCounted"><a href="#2-ReferenceCounted" class="headerlink" title="2. ReferenceCounted"></a>2. ReferenceCounted</h1><blockquote>
<p>FROM <a href="http://damacheng009.iteye.com/blog/2013657" rel="external nofollow noopener noreferrer" target="_blank">《【Netty官方文档翻译】引用计数对象（reference counted objects）》</a></p>
<p>自从 Netty 4 开始，对象的生命周期由它们的引用计数( reference counts )管理，而不是由垃圾收集器( garbage collector )管理了。<strong>ByteBuf 是最值得注意的，它使用了引用计数来改进分配内存和释放内存的性能</strong>。</p>
</blockquote>
<p>在 Netty 中，通过 <code>io.netty.util.ReferenceCounted</code> <strong>接口</strong>，定义了引用计数相关的一系列操作。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReferenceCounted</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得引用计数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns the reference count of this object.  If {<span class="doctag">@code</span> 0}, it means this object has been deallocated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">refCnt</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加引用计数 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Increases the reference count by {<span class="doctag">@code</span> 1}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReferenceCounted <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加引用计数 n</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Increases the reference count by the specified {<span class="doctag">@code</span> increment}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReferenceCounted <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等价于调用 `#touch(null)` 方法，即 hint 方法参数传递为 null 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Records the current access location of this object for debugging purposes.</span></span><br><span class="line"><span class="comment">     * If this object is determined to be leaked, the information recorded by this operation will be provided to you</span></span><br><span class="line"><span class="comment">     * via {<span class="doctag">@link</span> ResourceLeakDetector}.  This method is a shortcut to {<span class="doctag">@link</span> #touch(Object) touch(null)}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReferenceCounted <span class="title">touch</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出于调试目的,用一个额外的任意的(arbitrary)信息记录这个对象的当前访问地址. 如果这个对象被检测到泄露了, 这个操作记录的信息将通过ResourceLeakDetector 提供.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Records the current access location of this object with an additional arbitrary information for debugging</span></span><br><span class="line"><span class="comment">     * purposes.  If this object is determined to be leaked, the information recorded by this operation will be</span></span><br><span class="line"><span class="comment">     * provided to you via {<span class="doctag">@link</span> ResourceLeakDetector}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReferenceCounted <span class="title">touch</span><span class="params">(Object hint)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少引用计数 1 。</span></span><br><span class="line"><span class="comment">     * 当引用计数为 0 时，释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Decreases the reference count by {<span class="doctag">@code</span> 1} and deallocates this object if the reference count reaches at</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@code</span> 0}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if and only if the reference count became {<span class="doctag">@code</span> 0} and this object has been deallocated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少引用计数 n 。</span></span><br><span class="line"><span class="comment">     *  当引用计数为 0 时，释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Decreases the reference count by the specified {<span class="doctag">@code</span> decrement} and deallocates this object if the reference</span></span><br><span class="line"><span class="comment">     * count reaches at {<span class="doctag">@code</span> 0}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if and only if the reference count became {<span class="doctag">@code</span> 0} and this object has been deallocated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#refCnt()</code>、<code>#retain(...)</code>、<code>#release(...)</code> 三种方法比较好理解，对引用指数的获取与增减。</li>
<li><code>#touch(...)</code> 方法，主动记录一个 <code>hint</code> 给 ResourceLeakDetector ，方便我们在发现内存泄露有更多的信息进行排查。详细的，在下文 ResourceLeakDetector 相关的内容，具体来看。</li>
</ul>
<hr>
<p>ReferenceCounted 的直接子类 / 子接口有两个 ：</p>
<ul>
<li><code>io.netty.buffer.ByteBuf</code> 。所以，所有 ByteBuf 实现类，都支持引用计数的操作。</li>
<li><code>io.netty.util.AbstractReferenceCounted</code> ，ReferenceCounted 的抽象实现类。它的子类实现类，主要是除了 ByteBuf 之外，需要引用计数的操作的类。例如：AbstractHttpData、DefaultFileRegion 等等。<ul>
<li>AbstractReferenceCounted 不是本文的重点，就不多做介绍。</li>
<li>AbstractReferenceCounted 的具体代码实现，在下文中，我们会看到和 <code>io.netty.buffer.AbstractReferenceCountedByteBuf</code> 基本差不多。</li>
</ul>
</li>
</ul>
<h1 id="3-ByteBuf"><a href="#3-ByteBuf" class="headerlink" title="3. ByteBuf"></a>3. ByteBuf</h1><p>ByteBuf 虽然继承了 ReferenceCounted 接口，但是并未实现相应的方法。那么真正实现与相关的类，如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_08_07/01.png" title="类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_08_07/01.png" alt="类图"></a><span class="caption">类图</span></p>
<ul>
<li>黄框<ul>
<li>AbstractReferenceCountedByteBuf ，实现引用计数的获取与增减的操作。</li>
</ul>
</li>
<li>红框<ul>
<li>WrappedByteBuf ，实现对 ByteBuf 的装饰器实现类。</li>
<li>WrappedCompositeByteBuf ，实现对 CompositeByteBuf 的装饰器实现类。</li>
</ul>
</li>
<li>绿框<ul>
<li>SimpleLeakAwareByteBuf、SimpleLeakAwareCompositeByteBuf ，实现了 <code>SIMPLE</code> 级别的内存泄露检测。</li>
<li>AdvancedLeakAwareByteBuf、AdvancedLeakAwareCompositeByteBuf ，实现了 <code>ADVANCED</code> 和 <code>PARANOID</code> 级别的内存泄露检测。</li>
</ul>
</li>
<li>蓝筐<ul>
<li>UnreleasableByteBuf ，用于阻止他人对装饰的 ByteBuf 的销毁，避免被错误销毁掉。</li>
</ul>
</li>
</ul>
<p>因为带 <code>"Composite"</code> 类的代码实现，和不带的类( 例如 WrappedCompositeByteBuf 和 WrappedByteBuf )，实现代码基本一致，<strong>所以本文只分享不带 <code>"Composite"</code> 的类</strong>。</p>
<h2 id="3-1-创建-LeakAware-ByteBuf-对象"><a href="#3-1-创建-LeakAware-ByteBuf-对象" class="headerlink" title="3.1 创建 LeakAware ByteBuf 对象"></a>3.1 创建 LeakAware ByteBuf 对象</h2><p>在前面的文章中，我们已经提到，ByteBufAllocator 可用于创建 ByteBuf 对象。创建的过程中，它会调用 <code>#toLeakAwareBuffer(...)</code> 方法，将 ByteBuf <strong>装饰</strong>成 LeakAware ( 可检测内存泄露 )的 ByteBuf 对象，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractByteBufAllocator.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ByteBuf <span class="title">toLeakAwareBuffer</span><span class="params">(ByteBuf buf)</span> </span>{</span><br><span class="line">    ResourceLeakTracker&lt;ByteBuf&gt; leak;</span><br><span class="line">    <span class="keyword">switch</span> (ResourceLeakDetector.getLevel()) {</span><br><span class="line">        <span class="keyword">case</span> SIMPLE:</span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) {</span><br><span class="line">                buf = <span class="keyword">new</span> SimpleLeakAwareByteBuf(buf, leak);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADVANCED:</span><br><span class="line">        <span class="keyword">case</span> PARANOID:</span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) {</span><br><span class="line">                buf = <span class="keyword">new</span> AdvancedLeakAwareByteBuf(buf, leak);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> CompositeByteBuf <span class="title">toLeakAwareBuffer</span><span class="params">(CompositeByteBuf buf)</span> </span>{</span><br><span class="line">    ResourceLeakTracker&lt;ByteBuf&gt; leak;</span><br><span class="line">    <span class="keyword">switch</span> (ResourceLeakDetector.getLevel()) {</span><br><span class="line">        <span class="keyword">case</span> SIMPLE:</span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) {</span><br><span class="line">                buf = <span class="keyword">new</span> SimpleLeakAwareCompositeByteBuf(buf, leak);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADVANCED:</span><br><span class="line">        <span class="keyword">case</span> PARANOID:</span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) {</span><br><span class="line">                buf = <span class="keyword">new</span> AdvancedLeakAwareCompositeByteBuf(buf, leak);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>有两个 <code>#toLeakAwareBuffer(...)</code> 方法，分别对应带 <code>"Composite"</code> 的 组合 ByteBuf 类，和不带 <code>Composite</code> 普通 ByteBuf 类。因为这个不同，所以前者创建的是 SimpleLeakAwareCompositeByteBuf / AdvancedLeakAwareCompositeByteBuf 对象，后者创建的是 SimpleLeakAwareByteBuf / AdvancedLeakAwareByteBuf 对象。</li>
<li>当然，从总的逻辑来看，是<strong>一致</strong>的：<ul>
<li><code>SIMPLE</code> 级别，创建  SimpleLeakAwareByteBuf 或 SimpleLeakAwareCompositeByteBuf 对象。</li>
<li><code>ADVANCED</code> 和 <code>PARANOID</code> 级别，创建 AdvancedLeakAwareByteBuf 或者 AdvancedLeakAwareCompositeByteBuf 对象。</li>
</ul>
</li>
<li>是否需要创建 LeakAware ByteBuf 对象，有一个前提，调用  <code>ResourceLeakDetector#track(ByteBuf)</code> 方法，返回了 ResourceLeakTracker 对象。<ul>
<li>虽然说， <code>ADVANCED</code> 和 <code>PARANOID</code> 级别，都使用了 AdvancedLeakAwareByteBuf 或 AdvancedLeakAwareCompositeByteBuf 对象，但是它们的差异是：1) <code>PARANOID</code> 级别，一定返回 ResourceLeakTracker 对象；2) <code>ADVANCED</code> 级别，随机概率( 默认为 <code>1%</code> 左右 )返回 ResourceLeakTracker 对象。</li>
<li>关于 <code>ResourceLeakDetector#track(ByteBuf)</code> 方法的实现，下文也会详细解析。</li>
</ul>
</li>
</ul>
<h2 id="3-2-AbstractReferenceCountedByteBuf"><a href="#3-2-AbstractReferenceCountedByteBuf" class="headerlink" title="3.2 AbstractReferenceCountedByteBuf"></a>3.2 AbstractReferenceCountedByteBuf</h2><p><code>io.netty.buffer.AbstractReferenceCountedByteBuf</code> ，实现引用计数的获取与增减的操作。</p>
<h3 id="3-2-1-构造方法"><a href="#3-2-1-构造方法" class="headerlink" title="3.2.1 构造方法"></a>3.2.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #refCnt} 的更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">"refCnt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用计数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> refCnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractReferenceCountedByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">    <span class="comment">// 初始 refCnt 为 1</span></span><br><span class="line">    refCntUpdater.set(<span class="keyword">this</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>为什么 <code>refCnt</code> 不使用 AtomicInteger 呢？</li>
</ul>
<blockquote>
<p>计数器基于 AtomicIntegerFieldUpdater ，为什么不直接用 AtomicInteger ？因为 ByteBuf 对象很多，如果都把 <code>int</code> 包一层 AtomicInteger 花销较大，而AtomicIntegerFieldUpdater 只需要一个全局的静态变量。</p>
</blockquote>
<h3 id="3-2-2-refCnt"><a href="#3-2-2-refCnt" class="headerlink" title="3.2.2 refCnt"></a>3.2.2 refCnt</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">refCnt</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> refCnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-3-setRefCnt"><a href="#3-2-3-setRefCnt" class="headerlink" title="3.2.3 setRefCnt"></a>3.2.3 setRefCnt</h3><p><code>#setRefCnt(int refCnt)</code> 方法，直接修改 <code>refCnt</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRefCnt</span><span class="params">(<span class="keyword">int</span> refCnt)</span> </span>{</span><br><span class="line">    refCntUpdater.set(<span class="keyword">this</span>, refCnt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-4-retain"><a href="#3-2-4-retain" class="headerlink" title="3.2.4 retain"></a>3.2.4 retain</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> retain0(checkPositive(increment, <span class="string">"increment"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ByteBuf <span class="title">retain0</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> increment)</span> </span>{</span><br><span class="line">    <span class="comment">// 增加</span></span><br><span class="line">    <span class="keyword">int</span> oldRef = refCntUpdater.getAndAdd(<span class="keyword">this</span>, increment);</span><br><span class="line">    <span class="comment">// 原有 refCnt 就是 &lt;= 0 ；或者，increment 为负数</span></span><br><span class="line">    <span class="keyword">if</span> (oldRef &lt;= <span class="number">0</span> || oldRef + increment &lt; oldRef) {</span><br><span class="line">        <span class="comment">// Ensure we don't resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span></span><br><span class="line">        <span class="comment">// 加回去，负负得正。</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="keyword">this</span>, -increment);</span><br><span class="line">        <span class="comment">// 抛出 IllegalReferenceCountException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(oldRef, increment);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-5-release"><a href="#3-2-5-release" class="headerlink" title="3.2.5 release"></a>3.2.5 release</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> release0(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> release0(checkPositive(decrement, <span class="string">"decrement"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">release0</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>{</span><br><span class="line">    <span class="comment">// 减少</span></span><br><span class="line">    <span class="keyword">int</span> oldRef = refCntUpdater.getAndAdd(<span class="keyword">this</span>, -decrement);</span><br><span class="line">    <span class="comment">// 原有 oldRef 等于减少的值</span></span><br><span class="line">    <span class="keyword">if</span> (oldRef == decrement) {</span><br><span class="line">        <span class="comment">// 释放</span></span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 减少的值得大于 原有 oldRef ，说明“越界”；或者，increment 为负数</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (oldRef &lt; decrement || oldRef - decrement &gt; oldRef) {</span><br><span class="line">        <span class="comment">// Ensure we don't over-release, and avoid underflow.</span></span><br><span class="line">        <span class="comment">// 加回去，负负得正。</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="keyword">this</span>, decrement);</span><br><span class="line">        <span class="comment">// 抛出 IllegalReferenceCountException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(oldRef, -decrement);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>当释放完成，即 <code>refCnt</code> 等于 0 时，调用 <code>#deallocate()</code> 方法，进行<strong>真正的释放</strong>。这是个<strong>抽象方法</strong>，需要子类去实现。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called once {<span class="doctag">@link</span> #refCnt()} is equals 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <a href="http://svip.iocoder.cn/Netty/ByteBuf-1-2-ByteBuf-core-impl/">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（二）核心子类》</a> 中，可以看到各种 ByteBuf 对 <code>#deallocate()</code> 方法的实现。</li>
</ul>
</li>
</ul>
<h3 id="3-2-6-touch"><a href="#3-2-6-touch" class="headerlink" title="3.2.6 touch"></a>3.2.6 touch</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">(Object hint)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一脸懵逼？！实际 AbstractReferenceCountedByteBuf <strong>并未</strong>实现 <code>#touch(...)</code> 方法。而是在 AdvancedLeakAwareByteBuf 中才实现。</p>
<h2 id="3-3-SimpleLeakAwareByteBuf"><a href="#3-3-SimpleLeakAwareByteBuf" class="headerlink" title="3.3 SimpleLeakAwareByteBuf"></a>3.3 SimpleLeakAwareByteBuf</h2><p><code>io.netty.buffer.SimpleLeakAwareByteBuf</code> ，继承 WrappedByteBuf 类，<code>Simple</code> 级别的 LeakAware ByteBuf 实现类。</p>
<h3 id="3-3-1-构造方法"><a href="#3-3-1-构造方法" class="headerlink" title="3.3.1 构造方法"></a>3.3.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关联的 ByteBuf 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This object's is associated with the {<span class="doctag">@link</span> ResourceLeakTracker}. When {<span class="doctag">@link</span> ResourceLeakTracker#close(Object)}</span></span><br><span class="line"><span class="comment"> * is called this object will be used as the argument. It is also assumed that this object is used when</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ResourceLeakDetector#track(Object)} is called to create {<span class="doctag">@link</span> #leak}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuf trackedByteBuf;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResourceLeakTracker 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> ResourceLeakTracker&lt;ByteBuf&gt; leak;</span><br><span class="line"></span><br><span class="line">SimpleLeakAwareByteBuf(ByteBuf wrapped, ByteBuf trackedByteBuf, ResourceLeakTracker&lt;ByteBuf&gt; leak) { <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">super</span>(wrapped);</span><br><span class="line">    <span class="keyword">this</span>.trackedByteBuf = ObjectUtil.checkNotNull(trackedByteBuf, <span class="string">"trackedByteBuf"</span>);</span><br><span class="line">    <span class="keyword">this</span>.leak = ObjectUtil.checkNotNull(leak, <span class="string">"leak"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SimpleLeakAwareByteBuf(ByteBuf wrapped, ResourceLeakTracker&lt;ByteBuf&gt; leak) { <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    <span class="keyword">this</span>(wrapped, wrapped, leak);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>leak</code> 属性，ResourceLeakTracker 对象。</li>
<li><code>trackedByteBuf</code> 属性，<strong>真正</strong>关联 <code>leak</code> 的 ByteBuf 对象。<ul>
<li>对于构造方法 <code>&lt;1&gt;</code> ，<code>wrapped</code> 和 <code>trackedByteBuf</code> <strong>相同</strong>。</li>
<li>对于构造方法 <code>&lt;2&gt;</code> ，<code>wrapped</code> 和 <code>trackedByteBuf</code> <strong>一般不同</strong>。</li>
<li>有点难理解？继续往下看。</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-slice"><a href="#3-3-2-slice" class="headerlink" title="3.3.2 slice"></a>3.3.2 slice</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">slice</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newSharedLeakAwareByteBuf(<span class="keyword">super</span>.slice());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">slice</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newSharedLeakAwareByteBuf(<span class="keyword">super</span>.slice(index, length));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>首先，调用<strong>父</strong> <code>#slice(...)</code> 方法，获得 <strong>slice</strong> ByteBuf 对象。</li>
<li><p>之后，因为 <strong>slice</strong> ByteBuf 对象，并不是一个 LeakAware 的 ByteBuf 对象。所以调用 <code>#newSharedLeakAwareByteBuf(ByteBuf wrapped)</code> 方法，装饰成 LeakAware 的 ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SimpleLeakAwareByteBuf <span class="title">newSharedLeakAwareByteBuf</span><span class="params">(ByteBuf wrapped)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newLeakAwareByteBuf(wrapped, trackedByteBuf <span class="comment">/** &lt;1&gt; **/</span>, leak);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SimpleLeakAwareByteBuf <span class="title">newLeakAwareByteBuf</span><span class="params">(ByteBuf buf, ByteBuf trackedByteBuf, ResourceLeakTracker&lt;ByteBuf&gt; leakTracker)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleLeakAwareByteBuf(buf, trackedByteBuf <span class="comment">/** &lt;1&gt; **/</span>, leakTracker);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从 <code>&lt;1&gt;</code> 处，我们可以看到，<code>trackedByteBuf</code> 代表的是<strong>原始的</strong> ByteBuf 对象，它是跟 <code>leak</code> 真正进行关联的。而 <code>wrapped</code> 则不是。</li>
</ul>
</li>
</ul>
<hr>
<p>在 SimpleLeakAwareByteBuf 中，还有如下方法，和 <code>#slice(...)</code> 方法是<strong>类似</strong>的，在调用完<strong>父</strong>对应的方法后，再调用 <code>#newSharedLeakAwareByteBuf(ByteBuf wrapped)</code> 方法，装饰成 LeakAware 的 ByteBuf 对象。整理如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">duplicate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newSharedLeakAwareByteBuf(<span class="keyword">super</span>.duplicate());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readSlice</span><span class="params">(<span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newSharedLeakAwareByteBuf(<span class="keyword">super</span>.readSlice(length));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">asReadOnly</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newSharedLeakAwareByteBuf(<span class="keyword">super</span>.asReadOnly());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">order</span><span class="params">(ByteOrder endianness)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (order() == endianness) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> newSharedLeakAwareByteBuf(<span class="keyword">super</span>.order(endianness));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-3-3-retainedSlice"><a href="#3-3-3-retainedSlice" class="headerlink" title="3.3.3 retainedSlice"></a>3.3.3 retainedSlice</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retainedSlice</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unwrappedDerived(<span class="keyword">super</span>.retainedSlice());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retainedSlice</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unwrappedDerived(<span class="keyword">super</span>.retainedSlice(index, length));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>首先，调用<strong>父</strong> <code>#retainedSlice(...)</code> 方法，获得 <strong>slice</strong> ByteBuf 对象，引用计数加 1。</li>
<li><p>之后，因为 <strong>slice</strong> ByteBuf 对象，并不是一个 LeakAware 的 ByteBuf 对象。所以调用 <code>#unwrappedDerived(ByteBuf wrapped)</code> 方法，装饰成 LeakAware 的 ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 芋艿，看不懂 1017</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ByteBuf <span class="title">unwrappedDerived</span><span class="params">(ByteBuf derived)</span> </span>{</span><br><span class="line">    <span class="comment">// We only need to unwrap SwappedByteBuf implementations as these will be the only ones that may end up in</span></span><br><span class="line">    <span class="comment">// the AbstractLeakAwareByteBuf implementations beside slices / duplicates and "real" buffers.</span></span><br><span class="line">    ByteBuf unwrappedDerived = unwrapSwapped(derived);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unwrappedDerived <span class="keyword">instanceof</span> AbstractPooledDerivedByteBuf) {</span><br><span class="line">        <span class="comment">// Update the parent to point to this buffer so we correctly close the ResourceLeakTracker.</span></span><br><span class="line">        ((AbstractPooledDerivedByteBuf) unwrappedDerived).parent(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        ResourceLeakTracker&lt;ByteBuf&gt; newLeak = AbstractByteBuf.leakDetector.track(derived);</span><br><span class="line">        <span class="keyword">if</span> (newLeak == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// No leak detection, just return the derived buffer.</span></span><br><span class="line">            <span class="keyword">return</span> derived;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> newLeakAwareByteBuf(derived, newLeak);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newSharedLeakAwareByteBuf(derived);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuf <span class="title">unwrapSwapped</span><span class="params">(ByteBuf buf)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (buf <span class="keyword">instanceof</span> SwappedByteBuf) {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            buf = buf.unwrap();</span><br><span class="line">        } <span class="keyword">while</span> (buf <span class="keyword">instanceof</span> SwappedByteBuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SimpleLeakAwareByteBuf <span class="title">newLeakAwareByteBuf</span><span class="params">(ByteBuf wrapped, ResourceLeakTracker&lt;ByteBuf&gt; leakTracker)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> newLeakAwareByteBuf(wrapped, wrapped, leakTracker);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>TODO 1017</li>
</ul>
</li>
</ul>
<hr>
<p>在 SimpleLeakAwareByteBuf 中，还有如下方法，和 <code>#retainedSlice(...)</code> 方法是<strong>类似</strong>的，在调用完<strong>父</strong>对应的方法后，再调用 <code>#unwrappedDerived(ByteBuf derived)</code> 方法，装饰成 LeakAware 的 ByteBuf 对象。整理如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retainedDuplicate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unwrappedDerived(<span class="keyword">super</span>.retainedDuplicate());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readRetainedSlice</span><span class="params">(<span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unwrappedDerived(<span class="keyword">super</span>.readRetainedSlice(length));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-3-4-release"><a href="#3-3-4-release" class="headerlink" title="3.3.4 release"></a>3.3.4 release</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.release()) { <span class="comment">// 释放完成</span></span><br><span class="line">        closeLeak();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.release(decrement)) { <span class="comment">// 释放完成</span></span><br><span class="line">        closeLeak();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>在调用<strong>父</strong> <code>#release(...)</code> 方法，释放完成后，会调用 <code>#closeLeak()</code> 方法，关闭 ResourceLeakTracker 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeLeak</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Close the ResourceLeakTracker with the tracked ByteBuf as argument. This must be the same that was used when</span></span><br><span class="line">    <span class="comment">// calling DefaultResourceLeak.track(...).</span></span><br><span class="line">    <span class="keyword">boolean</span> closed = leak.close(trackedByteBuf);</span><br><span class="line">    <span class="keyword">assert</span> closed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<pre><code>* 进一步的详细解析，可以看看 [「5.1.5 close」](#) 。
</code></pre><h3 id="3-3-5-touch"><a href="#3-3-5-touch" class="headerlink" title="3.3.5 touch"></a>3.3.5 touch</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">(Object hint)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>又一脸懵逼？！实际 SimpleLeakAwareByteBuf <strong>也并未</strong>实现 <code>#touch(...)</code> 方法。而是在 AdvancedLeakAwareByteBuf 中才实现。</p>
<h2 id="3-4-AdvancedLeakAwareByteBuf"><a href="#3-4-AdvancedLeakAwareByteBuf" class="headerlink" title="3.4 AdvancedLeakAwareByteBuf"></a>3.4 AdvancedLeakAwareByteBuf</h2><p><code>io.netty.buffer.AdvancedLeakAwareByteBuf</code> ，继承 SimpleLeakAwareByteBuf 类，<code>ADVANCED</code> 和 <code>PARANOID</code> 级别的 LeakAware ByteBuf 实现类。</p>
<h3 id="3-4-1-构造方法"><a href="#3-4-1-构造方法" class="headerlink" title="3.4.1 构造方法"></a>3.4.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">AdvancedLeakAwareByteBuf(ByteBuf buf, ResourceLeakTracker&lt;ByteBuf&gt; leak) {</span><br><span class="line">    <span class="keyword">super</span>(buf, leak);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">AdvancedLeakAwareByteBuf(ByteBuf wrapped, ByteBuf trackedByteBuf, ResourceLeakTracker&lt;ByteBuf&gt; leak) {</span><br><span class="line">    <span class="keyword">super</span>(wrapped, trackedByteBuf, leak);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>就是调用父构造方法，没啥特点。</p>
<h3 id="3-4-2-retain"><a href="#3-4-2-retain" class="headerlink" title="3.4.2 retain"></a>3.4.2 retain</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">()</span> </span>{</span><br><span class="line">    leak.record();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.retain();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>{</span><br><span class="line">    leak.record();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.retain(increment);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>会调用 <code>ResourceLeakTracer#record()</code> 方法，记录信息。</li>
</ul>
<h3 id="3-4-3-release"><a href="#3-4-3-release" class="headerlink" title="3.4.3 release"></a>3.4.3 release</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span> </span>{</span><br><span class="line">    leak.record();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.release();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>{</span><br><span class="line">    leak.record();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.release(decrement);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>会调用 <code>ResourceLeakTracer#record()</code> 方法，记录信息。</li>
</ul>
<h3 id="3-4-4-touch"><a href="#3-4-4-touch" class="headerlink" title="3.4.4 touch"></a>3.4.4 touch</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">()</span> </span>{</span><br><span class="line">    leak.record();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">(Object hint)</span> </span>{</span><br><span class="line">    leak.record(hint);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>会调用 <code>ResourceLeakTracer#record(...)</code> 方法，记录信息。</li>
<li>😈 <code>#touch(...)</code> 方法，终于实现了，哈哈哈。</li>
</ul>
<h3 id="3-4-5-recordLeakNonRefCountingOperation"><a href="#3-4-5-recordLeakNonRefCountingOperation" class="headerlink" title="3.4.5 recordLeakNonRefCountingOperation"></a>3.4.5 recordLeakNonRefCountingOperation</h3><p><code>#recordLeakNonRefCountingOperation(ResourceLeakTracker&lt;ByteBuf&gt; leak)</code> <strong>静态</strong>方法，除了引用计数操作相关( 即 <code>#retain(...)</code>/<code>#release(...)</code>/<code>#touch(...)</code> 方法 )方法外，是否要调用记录信息。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROP_ACQUIRE_AND_RELEASE_ONLY = <span class="string">"io.netty.leakDetection.acquireAndReleaseOnly"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ACQUIRE_AND_RELEASE_ONLY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    ACQUIRE_AND_RELEASE_ONLY = SystemPropertyUtil.getBoolean(PROP_ACQUIRE_AND_RELEASE_ONLY, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordLeakNonRefCountingOperation</span><span class="params">(ResourceLeakTracker&lt;ByteBuf&gt; leak)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!ACQUIRE_AND_RELEASE_ONLY) {</span><br><span class="line">        leak.record();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>负负得正，所以会调用 <code>ResourceLeakTracer#record(...)</code> 方法，记录信息。</li>
<li><p>也就是说，ByteBuf 的所有方法，都会记录信息。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">order</span><span class="params">(ByteOrder endianness)</span> </span>{</span><br><span class="line">    recordLeakNonRefCountingOperation(leak);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.order(endianness);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readIntLE</span><span class="params">()</span> </span>{</span><br><span class="line">    recordLeakNonRefCountingOperation(leak);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.readIntLE();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法比较多，就不一一列举了。</li>
</ul>
</li>
</ul>
<h3 id="3-4-6-newLeakAwareByteBuf"><a href="#3-4-6-newLeakAwareByteBuf" class="headerlink" title="3.4.6 newLeakAwareByteBuf"></a>3.4.6 newLeakAwareByteBuf</h3><p><code>#newLeakAwareByteBuf(ByteBuf buf, ByteBuf trackedByteBuf, ResourceLeakTracker&lt;ByteBuf&gt; leakTracker)</code> 方法，覆写父类方法，将原先装饰成 SimpleLeakAwareByteBuf 改成 AdvancedLeakAwareByteBuf 对象。代码如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AdvancedLeakAwareByteBuf <span class="title">newLeakAwareByteBuf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ByteBuf buf, ByteBuf trackedByteBuf, ResourceLeakTracker&lt;ByteBuf&gt; leakTracker)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AdvancedLeakAwareByteBuf(buf, trackedByteBuf, leakTracker);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-5-UnreleasableByteBuf"><a href="#3-5-UnreleasableByteBuf" class="headerlink" title="3.5 UnreleasableByteBuf"></a>3.5 UnreleasableByteBuf</h2><p><code>io.netty.buffer.UnreleasableByteBuf</code> ，继承 WrappedByteBuf 类，用于阻止他人对装饰的 ByteBuf 的销毁，避免被错误销毁掉。</p>
<p>它的实现方法比较简单，主要是两大点：</p>
<ul>
<li><p>引用计数操作相关( 即 <code>#retain(...)</code>/<code>#release(...)</code>/<code>#touch(...)</code> 方法 )方法，不进行调用。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">touch</span><span class="params">(Object hint)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p>拷贝操作相关方法，都会在包一层 UnreleasableByteBuf 对象。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">slice</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnreleasableByteBuf(buf.slice());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h1 id="4-ResourceLeakDetector"><a href="#4-ResourceLeakDetector" class="headerlink" title="4. ResourceLeakDetector"></a>4. ResourceLeakDetector</h1><p><code>io.netty.util.ResourceLeakDetector</code> ，内存泄露检测器。</p>
<blockquote>
<p>老艿艿：Resource 翻译成“资源”更合理。考虑到标题叫做《内存泄露检测》，包括互联网其他作者在关于这块内容的命名，也是叫做“内存泄露检测”。所以，在下文，Resource 笔者还是继续翻译成“资源”。</p>
</blockquote>
<p>ResourceLeakDetector 为了检测内存是否泄漏，使用了 WeakReference( 弱引用 )和 ReferenceQueue( 引用队列 )，过程如下：</p>
<ol>
<li>根据检测级别和采样率的设置，在需要时为需要检测的 ByteBuf 创建WeakReference 引用。</li>
<li>当 JVM 回收掉 ByteBuf 对象时，JVM 会将 WeakReference 放入ReferenceQueue 队列中。</li>
<li>通过对 ReferenceQueue 中 WeakReference 的检查，判断在 GC 前是否有释放ByteBuf 的资源，就可以知道是否有资源释放。</li>
</ol>
<p>😈 看不太懂？继续往下看代码，在回过头来理解理解。</p>
<h2 id="4-1-静态属性"><a href="#4-1-静态属性" class="headerlink" title="4.1 静态属性"></a>4.1 静态属性</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROP_LEVEL_OLD = <span class="string">"io.netty.leakDetectionLevel"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROP_LEVEL = <span class="string">"io.netty.leakDetection.level"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认内存检测级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Level DEFAULT_LEVEL = Level.SIMPLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROP_TARGET_RECORDS = <span class="string">"io.netty.leakDetection.targetRecords"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TARGET_RECORDS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个 DefaultResourceLeak 记录的 Record 数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET_RECORDS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存检测级别枚举</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Represents the level of resource leak detection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Disables resource leak detection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DISABLED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables simplistic sampling resource leak detection which reports there is a leak or not,</span></span><br><span class="line"><span class="comment">     * at the cost of small overhead (default).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SIMPLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables advanced sampling resource leak detection which reports where the leaked object was accessed</span></span><br><span class="line"><span class="comment">     * recently at the cost of high overhead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADVANCED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables paranoid resource leak detection which reports where the leaked object was accessed recently,</span></span><br><span class="line"><span class="comment">     * at the cost of the highest possible overhead (for testing purposes only).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PARANOID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns level based on string value. Accepts also string that represents ordinal number of enum.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> levelStr - level string : DISABLED, SIMPLE, ADVANCED, PARANOID. Ignores case.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> corresponding level or SIMPLE level in case of no match.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Level <span class="title">parseLevel</span><span class="params">(String levelStr)</span> </span>{</span><br><span class="line">        String trimmedLevelStr = levelStr.trim();</span><br><span class="line">        <span class="keyword">for</span> (Level l : values()) {</span><br><span class="line">            <span class="keyword">if</span> (trimmedLevelStr.equalsIgnoreCase(l.name()) || trimmedLevelStr.equals(String.valueOf(l.ordinal()))) {</span><br><span class="line">                <span class="keyword">return</span> l;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_LEVEL;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存泄露检测等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Level level;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认采集频率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// There is a minor performance benefit in TLR if this is a power of 2.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SAMPLING_INTERVAL = <span class="number">128</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="number">1</span>: <span class="keyword">static</span> {</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// 获得是否禁用泄露检测</span></span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> disabled;</span><br><span class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (SystemPropertyUtil.get(<span class="string">"io.netty.noResourceLeakDetection"</span>) != <span class="keyword">null</span>) {</span><br><span class="line">  <span class="number">5</span>:         disabled = SystemPropertyUtil.getBoolean(<span class="string">"io.netty.noResourceLeakDetection"</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="number">6</span>:         logger.debug(<span class="string">"-Dio.netty.noResourceLeakDetection: {}"</span>, disabled);</span><br><span class="line">  <span class="number">7</span>:         logger.warn(<span class="string">"-Dio.netty.noResourceLeakDetection is deprecated. Use '-D{}={}' instead."</span>, PROP_LEVEL, DEFAULT_LEVEL.name().toLowerCase());</span><br><span class="line">  <span class="number">8</span>:     } <span class="keyword">else</span> {</span><br><span class="line">  <span class="number">9</span>:         disabled = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">10</span>:     }</span><br><span class="line"> <span class="number">11</span>: </span><br><span class="line"> <span class="number">12</span>:     <span class="comment">// 获得默认级别</span></span><br><span class="line"> <span class="number">13</span>:     Level defaultLevel = disabled? Level.DISABLED : DEFAULT_LEVEL;</span><br><span class="line"> <span class="number">14</span>:     <span class="comment">// 获得配置的级别字符串，从老版本的配置</span></span><br><span class="line"> <span class="number">15</span>:     <span class="comment">// First read old property name (兼容老版本）</span></span><br><span class="line"> <span class="number">16</span>:     String levelStr = SystemPropertyUtil.get(PROP_LEVEL_OLD, defaultLevel.name());</span><br><span class="line"> <span class="number">17</span>:     <span class="comment">// 获得配置的级别字符串，从新版本的配置</span></span><br><span class="line"> <span class="number">18</span>:     <span class="comment">// If new property name is present, use it</span></span><br><span class="line"> <span class="number">19</span>:     levelStr = SystemPropertyUtil.get(PROP_LEVEL, levelStr);</span><br><span class="line"> <span class="number">20</span>:     <span class="comment">// 获得最终的级别</span></span><br><span class="line"> <span class="number">21</span>:     Level level = Level.parseLevel(levelStr);</span><br><span class="line"> <span class="number">22</span>:     <span class="comment">// 设置最终的级别</span></span><br><span class="line"> <span class="number">23</span>:     ResourceLeakDetector.level = level;</span><br><span class="line"> <span class="number">24</span>: </span><br><span class="line"> <span class="number">25</span>:     <span class="comment">// 初始化 TARGET_RECORDS</span></span><br><span class="line"> <span class="number">26</span>:     TARGET_RECORDS = SystemPropertyUtil.getInt(PROP_TARGET_RECORDS, DEFAULT_TARGET_RECORDS);</span><br><span class="line"> <span class="number">27</span>: </span><br><span class="line"> <span class="number">28</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line"> <span class="number">29</span>:         logger.debug(<span class="string">"-D{}: {}"</span>, PROP_LEVEL, level.name().toLowerCase());</span><br><span class="line"> <span class="number">30</span>:         logger.debug(<span class="string">"-D{}: {}"</span>, PROP_TARGET_RECORDS, TARGET_RECORDS);</span><br><span class="line"> <span class="number">31</span>:     }</span><br><span class="line"> <span class="number">32</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>level</code> <strong>静态</strong>属性，内存泄露等级。😈 不是说好了，静态变量要统一大写么。</p>
<ul>
<li>默认级别为 <code>DEFAULT_LEVEL = Level.SIMPLE</code> 。</li>
<li><p>在 Level 中，枚举了四个级别。</p>
<blockquote>
<ul>
<li>禁用（DISABLED） - 完全禁止泄露检测，省点消耗。</li>
<li>简单（SIMPLE） - 默认等级，告诉我们取样的1%的ByteBuf是否发生了泄露，但总共一次只打印一次，看不到就没有了。</li>
<li>高级（ADVANCED） - 告诉我们取样的1%的ByteBuf发生泄露的地方。每种类型的泄漏（创建的地方与访问路径一致）只打印一次。对性能有影响。</li>
<li>偏执（PARANOID） - 跟高级选项类似，但此选项检测所有ByteBuf，而不仅仅是取样的那1%。对性能有绝大的影响。<ul>
<li>看着有点懵逼？下面继续看代码。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>在【第 2 至 23 行】的代码进行初始化。</li>
</ul>
</li>
<li><code>TARGET_RECORDS</code> 静态属性，每个 DefaultResourceLeak 记录的 Record 数量。<ul>
<li>默认大小为 <code>DEFAULT_TARGET_RECORDS = 4</code> 。</li>
<li>在【第 26 行】的代码进行初始化。</li>
</ul>
</li>
<li><code>DEFAULT_SAMPLING_INTERVAL</code> 静态属性，默认采集频率，128 。</li>
</ul>
<h2 id="4-2-构造方法"><a href="#4-2-构造方法" class="headerlink" title="4.2 构造方法"></a>4.2 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultResourceLeak 集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * the collection of active resources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;DefaultResourceLeak&lt;?&gt;, LeakEntry&gt; allLeaks = PlatformDependent.newConcurrentHashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已汇报的内存泄露的资源类型的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Boolean&gt; reportedLeaks = PlatformDependent.newConcurrentHashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String resourceType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采集评率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> samplingInterval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResourceLeakDetector</span><span class="params">(Class&lt;?&gt; resourceType, <span class="keyword">int</span> samplingInterval)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(simpleClassName(resourceType) <span class="comment">/** &lt;1&gt; **/</span>, samplingInterval, Long.MAX_VALUE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>allLeaks</code> 属性，DefaultResourceLeak 集合。因为 Java 没有自带的 ConcurrentSet ，所以只好使用使用 ConcurrentMap 。也就是说，value 属性实际没有任何用途。<ul>
<li>关于 LeakEntry ，可以看下 <a href="#">「6. LeakEntry」</a> 。</li>
</ul>
</li>
<li><code>refQueue</code> 属性，就是我们提到的<strong>引用队列</strong>( ReferenceQueue 队列 )。</li>
<li><code>reportedLeaks</code> 属性，已汇报的内存泄露的资源类型的集合。</li>
<li><code>resourceType</code> 属性，资源类型，使用资源类的类名简写，见 <code>&lt;1&gt;</code> 处。</li>
<li><code>samplingInterval</code> 属性，采集频率。</li>
</ul>
<hr>
<p>在 AbstractByteBuf 类中，我们可以看到创建了所有 ByteBuf 对象统一使用的 ResourceLeakDetector 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;ByteBuf&gt; leakDetector = ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>ResourceLeakDetector 的创建，通过 <code>io.netty.util.ResourceLeakDetectorFactory</code> ，基于工厂模式的方式来创建。<ul>
<li>关于 ResourceLeakDetectorFactory 的代码比较简单，笔者就不赘述了。</li>
<li>有一点要注意的是，可以通过 <code>"io.netty.customResourceLeakDetector"</code> 来<strong>自定义</strong> ResourceLeakDetector 的实现类。当然，绝大多数场景是完全不需要的。</li>
</ul>
</li>
</ul>
<h2 id="4-3-track"><a href="#4-3-track" class="headerlink" title="4.3 track"></a>4.3 track</h2><p><code>#track(...)</code> 方法，给指定资源( 例如 ByteBuf 对象 )创建一个检测它是否泄漏的 ResourceLeakTracker 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ResourceLeakTracker&lt;T&gt; <span class="title">track</span><span class="params">(T obj)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">return</span> track0(obj);</span><br><span class="line"> <span class="number">3</span>: }</span><br><span class="line"> <span class="number">4</span>: </span><br><span class="line"> <span class="number">5</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="number">6</span>: <span class="function"><span class="keyword">private</span> DefaultResourceLeak <span class="title">track0</span><span class="params">(T obj)</span> </span>{</span><br><span class="line"> <span class="number">7</span>:     Level level = ResourceLeakDetector.level;</span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// DISABLED 级别，不创建</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">if</span> (level == Level.DISABLED) {</span><br><span class="line"><span class="number">10</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">11</span>:     }</span><br><span class="line"><span class="number">12</span>: </span><br><span class="line"><span class="number">13</span>:     <span class="comment">// SIMPLE 和 ADVANCED</span></span><br><span class="line"><span class="number">14</span>:     <span class="keyword">if</span> (level.ordinal() &lt; Level.PARANOID.ordinal()) {</span><br><span class="line"><span class="number">15</span>:         <span class="comment">// 随机</span></span><br><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> ((PlatformDependent.threadLocalRandom().nextInt(samplingInterval)) == <span class="number">0</span>) {</span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 汇报内存是否泄漏</span></span><br><span class="line"><span class="number">18</span>:             reportLeak();</span><br><span class="line"><span class="number">19</span>:             <span class="comment">// 创建 DefaultResourceLeak 对象</span></span><br><span class="line"><span class="number">20</span>:             <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceLeak(obj, refQueue, allLeaks);</span><br><span class="line"><span class="number">21</span>:         }</span><br><span class="line"><span class="number">22</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">23</span>:     }</span><br><span class="line"><span class="number">24</span>: </span><br><span class="line"><span class="number">25</span>:     <span class="comment">// PARANOID 级别</span></span><br><span class="line"><span class="number">26</span>:     <span class="comment">// 汇报内存是否泄漏</span></span><br><span class="line"><span class="number">27</span>:     reportLeak();</span><br><span class="line"><span class="number">28</span>:     <span class="comment">// 创建 DefaultResourceLeak 对象</span></span><br><span class="line"><span class="number">29</span>:     <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceLeak(obj, refQueue, allLeaks);</span><br><span class="line"><span class="number">30</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 8 至 11 行：<code>DISABLED</code> 级别时，不创建，直接返回 <code>null</code> 。</li>
<li>第 13 至 23 行：<code>SIMPLE</code> 和 <code>ADVANCED</code> 级别时，随机，概率为 <code>1 / samplingInterval</code> ，创建 DefaultResourceLeak 对象。默认情况下 <code>samplingInterval = 128</code> ，约等于 <code>1%</code> ，这也是就为什么说“告诉我们取样的 1% 的ByteBuf发生泄露的地方”。</li>
<li>第 27 至 29 行：<code>PARANOID</code> 级别时，一定创建 DefaultResourceLeak 对象。这也是为什么说“对性能有绝大的影响”。</li>
<li>第 18 至 27 行：笔者原本以为，ResourceLeakDetector 会有一个定时任务，不断检测是否有内存泄露。从这里的代码来看，它是在每次一次创建 DefaultResourceLeak 对象时，调用 <code>#reportLeak()</code> 方法，汇报内存是否泄漏。详细解析，见 <a href="#">「4.4 reportLeak」</a> 。</li>
</ul>
<h2 id="4-4-reportLeak"><a href="#4-4-reportLeak" class="headerlink" title="4.4 reportLeak"></a>4.4 reportLeak</h2><p><code>#reportLeak()</code> 方法，检测是否有内存泄露。若有，则进行汇报。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportLeak</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 如果不允许打印错误日志，则无法汇报，清理队列，并直接结束。</span></span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (!logger.isErrorEnabled()) {</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 清理队列</span></span><br><span class="line"> <span class="number">5</span>:         clearRefQueue();</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>:     }</span><br><span class="line"> <span class="number">8</span>: </span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// 循环引用队列，直到为空</span></span><br><span class="line"><span class="number">10</span>:     <span class="comment">// Detect and report previous leaks.</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="number">12</span>:         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="number">13</span>:         DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll();</span><br><span class="line"><span class="number">14</span>:         <span class="keyword">if</span> (ref == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">15</span>:             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">16</span>:         }</span><br><span class="line"><span class="number">17</span>: </span><br><span class="line"><span class="number">18</span>:         <span class="comment">// 清理，并返回是否内存泄露</span></span><br><span class="line"><span class="number">19</span>:         <span class="keyword">if</span> (!ref.dispose()) {</span><br><span class="line"><span class="number">20</span>:             <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">21</span>:         }</span><br><span class="line"><span class="number">22</span>: </span><br><span class="line"><span class="number">23</span>:         <span class="comment">// 获得 Record 日志</span></span><br><span class="line"><span class="number">24</span>:         String records = ref.toString();</span><br><span class="line"><span class="number">25</span>:         <span class="comment">// 相同 Record 日志，只汇报一次</span></span><br><span class="line"><span class="number">26</span>:         <span class="keyword">if</span> (reportedLeaks.putIfAbsent(records, Boolean.TRUE) == <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">27</span>:             <span class="keyword">if</span> (records.isEmpty()) {</span><br><span class="line"><span class="number">28</span>:                 reportUntracedLeak(resourceType);</span><br><span class="line"><span class="number">29</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">30</span>:                 reportTracedLeak(resourceType, records);</span><br><span class="line"><span class="number">31</span>:             }</span><br><span class="line"><span class="number">32</span>:         }</span><br><span class="line"><span class="number">33</span>:     }</span><br><span class="line"><span class="number">34</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 2 至 7 行：如果不允许打印错误日志，则无法汇报，因此调用 <code>#clearRefQueue()</code> 方法，清理队列，并直接结束。详细解析，见 <a href="#">「4.5 clearRefQueue」</a> 。</li>
<li>第 9 至 16 行：循环引用队列 <code>refQueue</code> ，直到为空。</li>
<li>第 18 至 21 行：调用 <code>DefaultResourceLeak#dispose()</code> 方法，清理，并返回是否内存泄露。如果未泄露，就直接 <code>continue</code> 。详细解析，见 <a href="#">「5.1.3 dispose」</a> 。</li>
<li>第 24 行：调用 <code>DefaultResourceLeak#toString()</code> 方法，获得 Record 日志。详细解析，见 <a href="#">「5.1 DefaultResourceLeak」</a> 。</li>
<li><p>第 25 至 32 行：相同 Record 日志内容( 即“创建的地方与访问路径一致” )，<strong>只汇报一次</strong>。 代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is called when a traced leak is detected. It can be overridden for tracking how many times leaks</span></span><br><span class="line"><span class="comment"> * have been detected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reportTracedLeak</span><span class="params">(String resourceType, String records)</span> </span>{</span><br><span class="line">    logger.error(</span><br><span class="line">            <span class="string">"LEAK: {}.release() was not called before it's garbage-collected. "</span> +</span><br><span class="line">            <span class="string">"See http://netty.io/wiki/reference-counted-objects.html for more information.{}"</span>,</span><br><span class="line">            resourceType, records);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is called when an untraced leak is detected. It can be overridden for tracking how many times leaks</span></span><br><span class="line"><span class="comment"> * have been detected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reportUntracedLeak</span><span class="params">(String resourceType)</span> </span>{</span><br><span class="line">    logger.error(<span class="string">"LEAK: {}.release() was not called before it's garbage-collected. "</span> +</span><br><span class="line">            <span class="string">"Enable advanced leak reporting to find out where the leak occurred. "</span> +</span><br><span class="line">            <span class="string">"To enable advanced leak reporting, "</span> +</span><br><span class="line">            <span class="string">"specify the JVM option '-D{}={}' or call {}.setLevel() "</span> +</span><br><span class="line">            <span class="string">"See http://netty.io/wiki/reference-counted-objects.html for more information."</span>,</span><br><span class="line">            resourceType, PROP_LEVEL, Level.ADVANCED.name().toLowerCase(), simpleClassName(<span class="keyword">this</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>😈 这块逻辑的信息量，可能有点大，胖友可以看完 <a href="#">「5. ResourceLeakTracker」</a> ，再回过头理解下。</p>
<h2 id="4-5-clearRefQueue"><a href="#4-5-clearRefQueue" class="headerlink" title="4.5 clearRefQueue"></a>4.5 clearRefQueue</h2><p><code>#clearRefQueue()</code> 方法，清理队列。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearRefQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 清理，并返回是否内存泄露</span></span><br><span class="line">        ref.dispose();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>实际上，就是 <code>#reportLeak()</code> 方法的<strong>不汇报内存泄露</strong>的版本。</li>
</ul>
<h1 id="5-ResourceLeakTracker"><a href="#5-ResourceLeakTracker" class="headerlink" title="5. ResourceLeakTracker"></a>5. ResourceLeakTracker</h1><p><code>io.netty.util.ResourceLeakTracker</code> ，内存泄露追踪器接口。从 <a href="#">「4.3 track」</a> 中，我们已经看到，每个资源( 例如：ByteBuf 对象 )，会创建一个追踪它是否内存泄露的 ResourceLeakTracker 对象。</p>
<p>接口方法定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLeakTracker</span>&lt;<span class="title">T</span>&gt;  </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Records the caller's current stack trace so that the {<span class="doctag">@link</span> ResourceLeakDetector} can tell where the leaked</span></span><br><span class="line"><span class="comment">     * resource was accessed lastly. This method is a shortcut to {<span class="doctag">@link</span> #record(Object) record(null)}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Records the caller's current stack trace and the specified additional arbitrary information</span></span><br><span class="line"><span class="comment">     * so that the {<span class="doctag">@link</span> ResourceLeakDetector} can tell where the leaked resource was accessed lastly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">(Object hint)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Close the leak so that {<span class="doctag">@link</span> ResourceLeakTracker} does not warn about leaked resources.</span></span><br><span class="line"><span class="comment">     * After this method is called a leak associated with this ResourceLeakTracker should not be reported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if called first time, {<span class="doctag">@code</span> false} if called already</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">close</span><span class="params">(T trackedObject)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>#record(...)</code> 方法，出于调试目的，用一个额外的任意的( arbitrary )信息记录这个对象的当前访问地址。如果这个对象被检测到泄露了, 这个操作记录的信息将通过ResourceLeakDetector 提供。实际上，就是 <code>ReferenceCounted#touch(...)</code> 方法，会调用 <code>#record(...)</code> 方法。</li>
<li><code>#close(T trackedObject)</code> 方法，关闭 ResourceLeakTracker 。如果资源( 例如：ByteBuf 对象 )被正确释放，则会调用 <code>#close(T trackedObject)</code> 方法，关闭 ResourceLeakTracker ，从而结束追踪。这样，在 <code>ResourceLeakDetector#reportLeak()</code> 方法，就不会提示该资源泄露。</li>
</ul>
<h2 id="4-6-addExclusions"><a href="#4-6-addExclusions" class="headerlink" title="4.6 addExclusions"></a>4.6 addExclusions</h2><p><code>#addExclusions(Class clz, String ... methodNames)</code> 方法，添加忽略方法的集合。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 忽略的方法集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;String[]&gt; excludedMethods = <span class="keyword">new</span> AtomicReference&lt;String[]&gt;(EmptyArrays.EMPTY_STRINGS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addExclusions</span><span class="params">(Class clz, String ... methodNames)</span> </span>{</span><br><span class="line">    Set&lt;String&gt; nameSet = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methodNames));</span><br><span class="line">    <span class="comment">// Use loop rather than lookup. This avoids knowing the parameters, and doesn't have to handle</span></span><br><span class="line">    <span class="comment">// NoSuchMethodException.</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : clz.getDeclaredMethods()) {</span><br><span class="line">        <span class="keyword">if</span> (nameSet.remove(method.getName()) &amp;&amp; nameSet.isEmpty()) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!nameSet.isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't find '"</span> + nameSet + <span class="string">"' in "</span> + clz.getName());</span><br><span class="line">    }</span><br><span class="line">    String[] oldMethods;</span><br><span class="line">    String[] newMethods;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        oldMethods = excludedMethods.get();</span><br><span class="line">        newMethods = Arrays.copyOf(oldMethods, oldMethods.length + <span class="number">2</span> * methodNames.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodNames.length; i++) {</span><br><span class="line">            newMethods[oldMethods.length + i * <span class="number">2</span>] = clz.getName();</span><br><span class="line">            newMethods[oldMethods.length + i * <span class="number">2</span> + <span class="number">1</span>] = methodNames[i];</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span> (!excludedMethods.compareAndSet(oldMethods, newMethods));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己理解。</li>
<li>具体的用途，可参见 <a href="#">「7. Record」</a> 的 <code>#toString()</code> 方法。</li>
<li><p>目前调用该静态方法的有如下几处：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractByteBufAllocator.java</span></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, <span class="string">"toLeakAwareBuffer"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AdvancedLeakAwareByteBuf.java</span></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    ResourceLeakDetector.addExclusions(AdvancedLeakAwareByteBuf.class, <span class="string">"touch"</span>, <span class="string">"recordLeakNonRefCountingOperation"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceCountUtil.java</span></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    ResourceLeakDetector.addExclusions(ReferenceCountUtil.class, <span class="string">"touch"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="5-1-DefaultResourceLeak"><a href="#5-1-DefaultResourceLeak" class="headerlink" title="5.1 DefaultResourceLeak"></a>5.1 DefaultResourceLeak</h2><p>DefaultResourceLeak ，继承 <code>java.lang.ref.WeakReference</code> 类，实现 ResourceLeakTracker 接口，默认 ResourceLeakTracker 实现类。同时，它是 ResourceLeakDetector 内部静态类。即：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ... 简化无关代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceLeakDetector</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLeak</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">ResourceLeakTracker</span>&lt;<span class="title">T</span>&gt;, <span class="title">ResourceLeak</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>那么为什么要继承 <code>java.lang.ref.WeakReference</code> 类呢？在 <a href="#">「5.1.1 构造方法」</a> 见分晓。</p>
<h3 id="5-1-1-构造方法"><a href="#5-1-1-构造方法" class="headerlink" title="5.1.1 构造方法"></a>5.1.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #head} 的更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// generics and updaters do not mix.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;DefaultResourceLeak&lt;?&gt;, Record&gt; headUpdater =</span><br><span class="line">        (AtomicReferenceFieldUpdater)</span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(DefaultResourceLeak.class, Record.class, <span class="string">"head"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #droppedRecords} 的更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// generics and updaters do not mix.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;DefaultResourceLeak&lt;?&gt;&gt; droppedRecordsUpdater =</span><br><span class="line">        (AtomicIntegerFieldUpdater)</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(DefaultResourceLeak.class, <span class="string">"droppedRecords"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Record 链的头节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 看完 {<span class="doctag">@link</span> #record()} 方法后，实际上，head 是尾节点，即最后( 新 )的一条 Record 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Record head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 丢弃的 Record 计数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> droppedRecords;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultResourceLeak 集合。来自 {<span class="doctag">@link</span> ResourceLeakDetector#allLeaks}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;DefaultResourceLeak&lt;?&gt;, LeakEntry&gt; allLeaks;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 保证 {<span class="doctag">@link</span> #close(Object)} 传入的对象，就是 {<span class="doctag">@link</span> #referent} 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> trackedHash;</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>: DefaultResourceLeak(</span><br><span class="line">  <span class="number">2</span>:         Object referent,</span><br><span class="line">  <span class="number">3</span>:         ReferenceQueue&lt;Object&gt; refQueue,</span><br><span class="line">  <span class="number">4</span>:         ConcurrentMap&lt;DefaultResourceLeak&lt;?&gt;, LeakEntry&gt; allLeaks) {</span><br><span class="line">  <span class="number">5</span>:     <span class="comment">// 父构造方法 &lt;1&gt;</span></span><br><span class="line">  <span class="number">6</span>:     <span class="keyword">super</span>(referent, refQueue);</span><br><span class="line">  <span class="number">7</span>: </span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">assert</span> referent != <span class="keyword">null</span>;</span><br><span class="line">  <span class="number">9</span>: </span><br><span class="line"> <span class="number">10</span>:     <span class="comment">// Store the hash of the tracked object to later assert it in the close(...) method.</span></span><br><span class="line"> <span class="number">11</span>:     <span class="comment">// It's important that we not store a reference to the referent as this would disallow it from</span></span><br><span class="line"> <span class="number">12</span>:     <span class="comment">// be collected via the WeakReference.</span></span><br><span class="line"> <span class="number">13</span>:     trackedHash = System.identityHashCode(referent);</span><br><span class="line"> <span class="number">14</span>:     allLeaks.put(<span class="keyword">this</span>, LeakEntry.INSTANCE);</span><br><span class="line"> <span class="number">15</span>:     <span class="comment">// Create a new Record so we always have the creation stacktrace included.</span></span><br><span class="line"> <span class="number">16</span>:     headUpdater.set(<span class="keyword">this</span>, <span class="keyword">new</span> Record(Record.BOTTOM));</span><br><span class="line"> <span class="number">17</span>:     <span class="keyword">this</span>.allLeaks = allLeaks;</span><br><span class="line"> <span class="number">18</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>head</code> 属性，Record 链的头节点。<ul>
<li>为什么说它是链呢？详细解析，胖友可以先跳到 <a href="#">「7. Record」</a> 。 </li>
<li>实际上，<code>head</code> 是尾节点，即最后( 新 )的一条 Record 记录。详细解析，见 <a href="#">「5.1.2 record」</a> 。</li>
<li>在【第 16 行】代码，会默认创建尾节点 <code>Record.BOTTOM</code> 。</li>
</ul>
</li>
<li><code>droppedRecords</code> 属性，丢弃的 Record 计数。详细解析，见 <a href="#">「5.1.2 record」</a> 。</li>
<li><code>allLeaks</code> 属性，DefaultResourceLeak 集合。来自 <code>ResourceLeakDetector.allLeaks</code> 属性。<ul>
<li>在【第 14 行】代码，会将自己添加到 <code>allLeaks</code> 中。</li>
</ul>
</li>
<li><code>trackedHash</code> 属性，hash 值。保证在 <code>#close(T trackedObject)</code> 方法，传入的对象，就是 <code>referent</code> 属性，即就是 DefaultResourceLeak 指向的资源( 例如：ByteBuf 对象 )。详细解析，见 <a href="#">「5.1.4 close」</a> 。<ul>
<li>在【第 10 至 13 行】代码，计算并初始化 <code>trackedHash</code> 属性。</li>
</ul>
</li>
<li><p>【重要】在 <code>&lt;1&gt;</code> 处，会将 <code>referent</code>( 资源，例如：ByteBuf 对象 )和 <code>refQueue</code>( 引用队列 )传入父 WeakReference 构造方法。</p>
<blockquote>
<p>FROM <a href="https://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/index.html" rel="external nofollow noopener noreferrer" target="_blank">《译文：理解Java中的弱引用》</a></p>
<p><strong>引用队列(Reference Queue)</strong></p>
<p>一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。</p>
<p>引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。</p>
</blockquote>
<ul>
<li>也就是说，<code>referent</code> 被标记为垃圾的时候，它对应的 WeakReference 对象会被添加到 <code>refQueue</code> 队列中。<strong>在此处，即将 DefaultResourceLeak 添加到 <code>referent</code> 队列中</strong>。</li>
<li>那又咋样呢？假设 <code>referent</code> 为 ByteBuf 对象。如果它被正确的释放，即调用了 <a href="#">「3.3.4 release」</a> 方法，从而调用了 <code>AbstractReferenceCountedByteBuf#closeLeak()</code> 方法，最终调用到 <code>ResourceLeakTracker#close(trackedByteBuf)</code> 方法，那么该 ByteBuf 对象对应的 ResourceLeakTracker 对象，将从 <code>ResourceLeakDetector.allLeaks</code> 中移除。</li>
<li>那这又意味着什么呢？ 在 <code>ResourceLeakDetector#reportLeak()</code> 方法中，即使从 <code>refQueue</code> 队列中，获取到该 ByteBuf 对象对应 ResourceLeakTracker 对象，因为在 <code>ResourceLeakDetector.allLeaks</code> 中移除了，所以在 <code>ResourceLeakDetector#reportLeak()</code> 方法的【第 19 行】代码 <code>!ref.dispose() = true</code> ，直接 <code>continue</code> 。</li>
<li>😈 比较绕，胖友再好好理解下。胖友可以在思考下，如果 ByteBuf 对象，没有被正确的释放，是怎么样一个流程。</li>
</ul>
</li>
</ul>
<h3 id="5-1-2-record"><a href="#5-1-2-record" class="headerlink" title="5.1.2 record"></a>5.1.2 record</h3><p><code>#record(...)</code> 方法，创建 Record 对象，添加到 <code>head</code> 链中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>{</span><br><span class="line">    record0(<span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(Object hint)</span> </span>{</span><br><span class="line">    record0(hint);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method works by exponentially backing off as more records are present in the stack. Each record has a</span></span><br><span class="line"><span class="comment"> * 1 / 2^n chance of dropping the top most record and replacing it with itself. This has a number of convenient</span></span><br><span class="line"><span class="comment"> * properties:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;  The current record is always recorded. This is due to the compare and swap dropping the top most</span></span><br><span class="line"><span class="comment"> *       record, rather than the to-be-pushed record.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;  The very last access will always be recorded. This comes as a property of 1.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;  It is possible to retain more records than the target, based upon the probability distribution.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;  It is easy to keep a precise record of the number of elements in the stack, since each element has to</span></span><br><span class="line"><span class="comment"> *     know how tall the stack is.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In this particular implementation, there are also some advantages. A thread local random is used to decide</span></span><br><span class="line"><span class="comment"> * if something should be recorded. This means that if there is a deterministic access pattern, it is now</span></span><br><span class="line"><span class="comment"> * possible to see what other accesses occur, rather than always dropping them. Second, after</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #TARGET_RECORDS} accesses, backoff occurs. This matches typical access patterns,</span></span><br><span class="line"><span class="comment"> * where there are either a high number of accesses (i.e. a cached buffer), or low (an ephemeral buffer), but</span></span><br><span class="line"><span class="comment"> * not many in between.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The use of atomics avoids serializing a high number of accesses, when most of the records will be thrown</span></span><br><span class="line"><span class="comment"> * away. High contention only happens when there are very few existing records, which is only likely when the</span></span><br><span class="line"><span class="comment"> * object isn't shared! If this is a problem, the loop can be aborted and the record dropped, because another</span></span><br><span class="line"><span class="comment"> * thread won the race.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">record0</span><span class="params">(Object hint)</span> </span>{</span><br><span class="line">  <span class="number">2</span>:     <span class="comment">// Check TARGET_RECORDS &gt; 0 here to avoid similar check before remove from and add to lastRecords</span></span><br><span class="line">  <span class="number">3</span>:     <span class="keyword">if</span> (TARGET_RECORDS &gt; <span class="number">0</span>) {</span><br><span class="line">  <span class="number">4</span>:         Record oldHead;</span><br><span class="line">  <span class="number">5</span>:         Record prevHead;</span><br><span class="line">  <span class="number">6</span>:         Record newHead;</span><br><span class="line">  <span class="number">7</span>:         <span class="keyword">boolean</span> dropped;</span><br><span class="line">  <span class="number">8</span>:         <span class="keyword">do</span> {</span><br><span class="line">  <span class="number">9</span>:             <span class="comment">// 已经关闭，则返回</span></span><br><span class="line"> <span class="number">10</span>:             <span class="keyword">if</span> ((prevHead = oldHead = headUpdater.get(<span class="keyword">this</span>)) == <span class="keyword">null</span>) {</span><br><span class="line"> <span class="number">11</span>:                 <span class="comment">// already closed.</span></span><br><span class="line"> <span class="number">12</span>:                 <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">13</span>:             }</span><br><span class="line"> <span class="number">14</span>:             <span class="comment">// 当超过 TARGET_RECORDS 数量时，随机丢到头节点。</span></span><br><span class="line"> <span class="number">15</span>:             <span class="keyword">final</span> <span class="keyword">int</span> numElements = oldHead.pos + <span class="number">1</span>;</span><br><span class="line"> <span class="number">16</span>:             <span class="keyword">if</span> (numElements &gt;= TARGET_RECORDS) {</span><br><span class="line"> <span class="number">17</span>:                 <span class="keyword">final</span> <span class="keyword">int</span> backOffFactor = Math.min(numElements - TARGET_RECORDS, <span class="number">30</span>);</span><br><span class="line"> <span class="number">18</span>:                 <span class="keyword">if</span> (dropped = PlatformDependent.threadLocalRandom().nextInt(<span class="number">1</span> &lt;&lt; backOffFactor) != <span class="number">0</span>) {</span><br><span class="line"> <span class="number">19</span>:                     prevHead = oldHead.next;</span><br><span class="line"> <span class="number">20</span>:                 }</span><br><span class="line"> <span class="number">21</span>:             } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">22</span>:                 dropped = <span class="keyword">false</span>;</span><br><span class="line"> <span class="number">23</span>:             }</span><br><span class="line"> <span class="number">24</span>:             <span class="comment">// 创建新的头节点</span></span><br><span class="line"> <span class="number">25</span>:             newHead = hint != <span class="keyword">null</span> ? <span class="keyword">new</span> Record(prevHead, hint) : <span class="keyword">new</span> Record(prevHead);</span><br><span class="line"> <span class="number">26</span>:         } <span class="keyword">while</span> (!headUpdater.compareAndSet(<span class="keyword">this</span>, oldHead, newHead)); <span class="comment">// cas 修改头节点</span></span><br><span class="line"> <span class="number">27</span>:         <span class="comment">// 若丢弃，增加 droppedRecordsUpdater 计数</span></span><br><span class="line"> <span class="number">28</span>:         <span class="keyword">if</span> (dropped) {</span><br><span class="line"> <span class="number">29</span>:             droppedRecordsUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line"> <span class="number">30</span>:         }</span><br><span class="line"> <span class="number">31</span>:     }</span><br><span class="line"> <span class="number">32</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 9 至 13 行：通过 <code>headUpdater</code> 获得 <code>head</code> 属性，若为 <code>null</code> 时，说明  DefaultResourceLeak 已经关闭。为什么呢？详细可见 <a href="#">「5.1.4 close」</a> 和 <a href="#">5.1.5 toString</a> 。</li>
<li>第 14 至 23 行：当当前 DefaultResourceLeak 对象所拥有的 Record 数量超过 <code>TARGET_RECORDS</code> 时，随机丢弃当前 <code>head</code> 节点的数据。也就是说，尽量保留<strong>老</strong>的 Record 节点。这是为什么呢?越是<strong>老</strong>( 开始 )的 Record 节点，越有利于排查问题。另外，随机丢弃的的概率，按照 <code>1 - (1 / 2^n）</code> 几率，越来越<strong>大</strong>。</li>
<li>第 25 行：创建新 Record 对象，作为头节点，指向<strong>原头节点</strong>。这也是为什么说，“实际上，head 是尾节点，即最后( 新 )的一条 Record”。</li>
<li>第 26 行：通过 CAS 的方式，修改新创建的 Record 对象为头节点。</li>
<li>第 27 至 30 行：若丢弃，增加 <code>droppedRecordsUpdater</code> 计数。</li>
</ul>
<h3 id="5-1-3-dispose"><a href="#5-1-3-dispose" class="headerlink" title="5.1.3 dispose"></a>5.1.3 dispose</h3><p><code>#dispose()</code> 方法， 清理，并返回是否内存泄露。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 清理，并返回是否内存泄露</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispose</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 清理 referent 的引用</span></span><br><span class="line">    clear();</span><br><span class="line">    <span class="comment">// 移除出 allLeaks 。移除成功，意味着内存泄露。</span></span><br><span class="line">    <span class="keyword">return</span> allLeaks.remove(<span class="keyword">this</span>, LeakEntry.INSTANCE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-1-4-close"><a href="#5-1-4-close" class="headerlink" title="5.1.4 close"></a>5.1.4 close</h3><p><code>#close(T trackedObject)</code> 方法，关闭 DefaultResourceLeak 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">close</span><span class="params">(T trackedObject)</span> </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 校验一致</span></span><br><span class="line"> <span class="number">4</span>:     <span class="comment">// Ensure that the object that was tracked is the same as the one that was passed to close(...).</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">assert</span> trackedHash == System.identityHashCode(trackedObject);</span><br><span class="line"> <span class="number">6</span>: </span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 关闭</span></span><br><span class="line"> <span class="number">8</span>:     <span class="comment">// We need to actually do the null check of the trackedObject after we close the leak because otherwise</span></span><br><span class="line"> <span class="number">9</span>:     <span class="comment">// we may get false-positives reported by the ResourceLeakDetector. This can happen as the JIT / GC may</span></span><br><span class="line"><span class="number">10</span>:     <span class="comment">// be able to figure out that we do not need the trackedObject anymore and so already enqueue it for</span></span><br><span class="line"><span class="number">11</span>:     <span class="comment">// collection before we actually get a chance to close the enclosing ResourceLeak.</span></span><br><span class="line"><span class="number">12</span>:     <span class="keyword">return</span> close() &amp;&amp; trackedObject != <span class="keyword">null</span>;</span><br><span class="line"><span class="number">13</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 行：校验一致性。</li>
<li><p>第 12 行：调用 <code>#close()</code> 方法，关闭 DefaultResourceLeak 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 移除出 allLeaks</span></span><br><span class="line">    <span class="comment">// Use the ConcurrentMap remove method, which avoids allocating an iterator.</span></span><br><span class="line">    <span class="keyword">if</span> (allLeaks.remove(<span class="keyword">this</span>, LeakEntry.INSTANCE)) {</span><br><span class="line">        <span class="comment">// 清理 referent 的引用</span></span><br><span class="line">        <span class="comment">// Call clear so the reference is not even enqueued.</span></span><br><span class="line">        clear();</span><br><span class="line">        <span class="comment">// 置空 head</span></span><br><span class="line">        headUpdater.set(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回成功</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 返回失败</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关闭时，会将 DefaultResourceLeak 对象，从 <code>allLeaks</code> 中移除。</li>
</ul>
</li>
</ul>
<h3 id="5-1-5-toString"><a href="#5-1-5-toString" class="headerlink" title="5.1.5 toString"></a>5.1.5 toString</h3><p>当 DefaultResourceLeak 追踪到内存泄露，会在 <code>ResourceLeakDetector#reportLeak()</code> 方法中，调用 <code>DefaultResourceLeak#toString()</code> 方法，拼接提示信息。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获得 head 属性，并置空 &lt;1&gt;</span></span><br><span class="line">    Record oldHead = headUpdater.getAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 若为空，说明已经关闭。</span></span><br><span class="line">    <span class="keyword">if</span> (oldHead == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// Already closed</span></span><br><span class="line">        <span class="keyword">return</span> EMPTY_STRING;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dropped = droppedRecordsUpdater.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int</span> duped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> present = oldHead.pos + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Guess about 2 kilobytes per stack trace</span></span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(present * <span class="number">2048</span>).append(NEWLINE);</span><br><span class="line">    buf.append(<span class="string">"Recent access records: "</span>).append(NEWLINE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 Record 练</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;String&gt;(present);</span><br><span class="line">    <span class="keyword">for</span> (; oldHead != Record.BOTTOM; oldHead = oldHead.next) {</span><br><span class="line">        String s = oldHead.toString();</span><br><span class="line">        <span class="keyword">if</span> (seen.add(s)) { <span class="comment">// 是否重复</span></span><br><span class="line">            <span class="keyword">if</span> (oldHead.next == Record.BOTTOM) {</span><br><span class="line">                buf.append(<span class="string">"Created at:"</span>).append(NEWLINE).append(s);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                buf.append(<span class="string">'#'</span>).append(i++).append(<span class="string">':'</span>).append(NEWLINE).append(s);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            duped++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 duped ( 重复 ) 次数</span></span><br><span class="line">    <span class="keyword">if</span> (duped &gt; <span class="number">0</span>) {</span><br><span class="line">        buf.append(<span class="string">": "</span>)</span><br><span class="line">                .append(dropped)</span><br><span class="line">                .append(<span class="string">" leak records were discarded because they were duplicates"</span>)</span><br><span class="line">                .append(NEWLINE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 dropped (丢弃) 次数</span></span><br><span class="line">    <span class="keyword">if</span> (dropped &gt; <span class="number">0</span>) {</span><br><span class="line">        buf.append(<span class="string">": "</span>)</span><br><span class="line">           .append(dropped)</span><br><span class="line">           .append(<span class="string">" leak records were discarded because the leak record count is targeted to "</span>)</span><br><span class="line">           .append(TARGET_RECORDS)</span><br><span class="line">           .append(<span class="string">". Use system property "</span>)</span><br><span class="line">           .append(PROP_TARGET_RECORDS)</span><br><span class="line">           .append(<span class="string">" to increase the limit."</span>)</span><br><span class="line">           .append(NEWLINE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buf.setLength(buf.length() - NEWLINE.length());</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己看注释。</li>
<li><code>&lt;1&gt;</code> 处，真的是个神坑。如果胖友在 IDEA 调试时，因为默认会调用对应的 <code>#toString()</code> 方法，会导致 <code>head</code> 属性被错误的重置为 <code>null</code> 值。wtf！！！笔者在这里卡了好久好久。</li>
</ul>
<h1 id="6-LeakEntry"><a href="#6-LeakEntry" class="headerlink" title="6. LeakEntry"></a>6. LeakEntry</h1><p>LeakEntry ，用于 <code>ResourceLeakDetector.allLeaks</code> 属性的 value 值。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakEntry</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> LeakEntry INSTANCE = <span class="keyword">new</span> LeakEntry();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 值，避免重复计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH = System.identityHashCode(INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LeakEntry</span><span class="params">()</span> </span>{ <span class="comment">// 禁止创建，仅使用 INSTANCE 单例</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> HASH;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>😈 没有什么功能逻辑。</p>
<h1 id="7-Record"><a href="#7-Record" class="headerlink" title="7. Record"></a>7. Record</h1><p>Record ，记录。每次调用 <code>ResourceLeakTracker#touch(...)</code> 方法后，会产生响应的 Record 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6065153674892850720L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾节点的单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Record BOTTOM = <span class="keyword">new</span> Record();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hint 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hintString;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Record next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========== 构造方法 ===========</span></span><br><span class="line"></span><br><span class="line">    Record(Record next, Object hint) {</span><br><span class="line">        <span class="comment">// This needs to be generated even if toString() is never called as it may change later on.</span></span><br><span class="line">        hintString = hint <span class="keyword">instanceof</span> ResourceLeakHint ? ((ResourceLeakHint) hint).toHintString() : hint.toString(); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.pos = next.pos + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Record(Record next) {</span><br><span class="line">       hintString = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">this</span>.next = next;</span><br><span class="line">       <span class="keyword">this</span>.pos = next.pos + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to terminate the stack</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Record</span><span class="params">()</span> </span>{</span><br><span class="line">        hintString = <span class="keyword">null</span>;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">        pos = -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========== toString ===========</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">2048</span>);</span><br><span class="line">        <span class="keyword">if</span> (hintString != <span class="keyword">null</span>) {</span><br><span class="line">            buf.append(<span class="string">"\tHint: "</span>).append(hintString).append(NEWLINE);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Append the stack trace.</span></span><br><span class="line">        StackTraceElement[] array = getStackTrace();</span><br><span class="line">        <span class="comment">// Skip the first three elements.</span></span><br><span class="line">        out: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; array.length; i++) {</span><br><span class="line">            StackTraceElement element = array[i];</span><br><span class="line">            <span class="comment">// 跳过忽略的方法 &lt;2&gt;</span></span><br><span class="line">            <span class="comment">// Strip the noisy stack trace elements.</span></span><br><span class="line">            String[] exclusions = excludedMethods.get();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; exclusions.length; k += <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">if</span> (exclusions[k].equals(element.getClassName())</span><br><span class="line">                        &amp;&amp; exclusions[k + <span class="number">1</span>].equals(element.getMethodName())) {</span><br><span class="line">                    <span class="keyword">continue</span> out;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            buf.append(<span class="string">'\t'</span>);</span><br><span class="line">            buf.append(element.toString());</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 <code>next</code> 属性，我们可以得知，Record 是链式结构。</li>
<li><code>&lt;1&gt;</code> 处，如果传入的 <code>hint</code> 类型为 ResourceLeakHint 类型，会调用对应的 <code>#toHintString()</code> 方法，拼接更友好的字符串提示信息。</li>
<li><code>&lt;2&gt;</code> 处，如果调用栈的方法在 <code>ResourceLeakDetector.exclusions</code> 属性中，进行忽略。</li>
</ul>
<h1 id="8-ResourceLeakHint"><a href="#8-ResourceLeakHint" class="headerlink" title="8. ResourceLeakHint"></a>8. ResourceLeakHint</h1><p><code>io.netty.util.ResourceLeakHint</code> ，接口，提供人类可读( 易懂 )的提示信息，使用在 ResourceLeakDetector 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A hint object that provides human-readable message for easier resource leak tracking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLeakHint</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a human-readable message that potentially enables easier resource leak tracking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">toHintString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>目前它的实现类是 AbstractChannelHandlerContext 。对应的实现方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHintString</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\''</span> + name + <span class="string">"' will handle the message from this point."</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>比想象中长很多的文章，也比想象中花费了更多时间的文章。主要是 xxx 的 <a href="#">「5.1.5 toString」</a> 中卡了好久啊！！！！</p>
<p>推荐阅读文章：</p>
<ul>
<li><a href="https://skyao.gitbooks.io/learning-netty/content/buffer/reference_count.html" rel="external nofollow noopener noreferrer" target="_blank">《Netty 学习笔记 —— Reference Count》</a></li>
<li>唯有坚持不懈 <a href="https://blog.csdn.net/prestigeding/article/details/54233327" rel="external nofollow noopener noreferrer" target="_blank">《Netty学习之旅—-源码分析Netty内存泄漏检测》</a></li>
</ul>
<p>上述两篇文章，因为分析的 Netty 不是最新版本，所以代码会有一些差异，例如 <code>maxActive</code> 已经被去除。 </p>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector/" data-id="ck4pl3fp600e4fgcfnoi4uv9p" class="article-share-link">分享</a>

</footer>
-->
</div>
