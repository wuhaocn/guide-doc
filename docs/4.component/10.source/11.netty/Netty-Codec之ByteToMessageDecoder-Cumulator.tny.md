<div class="article-inner">

<header class="article-header">

<h1 class="article-title" itemprop="name">
精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（一）Cumulator
</h1>

</header>

<div class="article-entry" itemprop="articleBody">

<!-- Table of Contents -->

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Netty/ChannelHandler-1-intro">《精尽 Netty 源码解析 —— ChannelHandler（一）之简介》</a> 中，我们看了 ChannelHandler 的核心类图，如下：<a href="http://static2.iocoder.cn/images/Netty/2018_10_01/01.png" title="核心类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_10_01/01.png" alt="核心类图"></a><span class="caption">核心类图</span></p>
<ul>
<li><p><strong>绿框</strong>部分，我们可以看到，Netty 基于 ChannelHandler 实现了读写的数据( 消息 )的编解码。</p>
<blockquote>
<p>Codec( 编解码 ) = Encode( 编码 ) + Decode( 解码 )。</p>
</blockquote>
</li>
<li><p>图中有五个和 Codec 相关的类，整理如下：</p>
<ul>
<li>😈 ，实际应该是六个，漏画了 MessageToMessageDecoder 类。</li>
<li>ByteToMessageCodec ，ByteToMessageDecoder + MessageByteEncoder 的<strong>组合</strong>。<ul>
<li>ByteToMessageDecoder ，将字节<strong>解码</strong>成消息。</li>
<li>MessageByteEncoder ，将消息<strong>编码</strong>成字节。</li>
</ul>
</li>
<li>MessageToMessageCodec ，MessageToMessageDecoder + MessageToMessageEncoder 的<strong>组合</strong>。<ul>
<li>MessageToMessageDecoder ，将消息<strong>解码</strong>成另一种消息。</li>
<li>MessageToMessageEncoder ，将消息<strong>编码</strong>成另一种消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>而本文，我们来分享 ByteToMessageDecoder 部分的内容。</p>
<h1 id="2-ByteToMessageDecoder-核心类图"><a href="#2-ByteToMessageDecoder-核心类图" class="headerlink" title="2. ByteToMessageDecoder 核心类图"></a>2. ByteToMessageDecoder 核心类图</h1><p><a href="http://static2.iocoder.cn/images/Netty/2018_12_01/01.png" title="核心类图" class="fancybox" rel="article0"><img src="http://static2.iocoder.cn/images/Netty/2018_12_01/01.png" alt="核心类图"></a><span class="caption">核心类图</span></p>
<p>ByteToMessageDecoder 本身是个<strong>抽象</strong>类，其下有多个子类，笔者简单整理成三类，可能不全哈：</p>
<ul>
<li><strong>绿框</strong>部分 FrameDecoder ：消息帧( Frame )解码器。也就是说该类解码器，用于处理 TCP 的<strong>粘包</strong>现象，将网络发送的字节流解码为具有确定含义的消息帧。之后的解码器再将消息帧解码为实际的 POJO 对象。 如下图所示：<a href="http://static2.iocoder.cn/images/Netty/2018_12_01/02.png" rel="external nofollow noopener noreferrer" target="_blank">decode</a></li>
<li><strong>黄框</strong>部分，将字节流使用<strong>指定序列化方式</strong>反序列化成<strong>消息</strong>，例如：XML、JSON 等等。<ul>
<li>对于该类解码器，不处理 TCP 的<strong>粘包</strong>现象，所以需要搭配 FrameDecoder 一起使用。</li>
</ul>
</li>
<li><strong>蓝框</strong>部分，将字节流<strong>解压</strong>，主要涉及相关压缩算法，例如：GZip、BZip 等等。<ul>
<li>对于该类解码器，不处理 TCP 的<strong>粘包</strong>现象，所以需要搭配 FrameDecoder 一起使用。</li>
</ul>
</li>
</ul>
<h1 id="3-为什么要粘包拆包"><a href="#3-为什么要粘包拆包" class="headerlink" title="3. 为什么要粘包拆包"></a>3. 为什么要粘包拆包</h1><p>😈 因为有些朋友不了解粘包和拆包的概念和原理，这里引用笔者的基友【闪电侠】在 <a href="https://www.jianshu.com/p/dc26e944da95" rel="external nofollow noopener noreferrer" target="_blank">《netty 源码分析之拆包器的奥秘》</a> 对这块的描述。</p>
<h2 id="3-1-为什么要粘包"><a href="#3-1-为什么要粘包" class="headerlink" title="3.1 为什么要粘包"></a>3.1 为什么要粘包</h2><blockquote>
<p>首先你得了解一下 TCP/IP 协议，在用户数据量非常小的情况下，极端情况下，一个字节，该 TCP 数据包的有效载荷非常低，传递 100 字节的数据，需要 100 次TCP传送， 100 次ACK，在应用及时性要求不高的情况下，将这 100 个有效数据拼接成一个数据包，那会缩短到一个TCP数据包，以及一个 ack ，有效载荷提高了，带宽也节省了。</p>
<p>非极端情况，有可能<strong>两个</strong>数据包拼接成一个数据包，也有可能<strong>一个半</strong>的数据包拼接成一个数据包，也有可能<strong>两个半</strong>的数据包拼接成一个数据包。</p>
</blockquote>
<h2 id="3-2-为什么要拆包"><a href="#3-2-为什么要拆包" class="headerlink" title="3.2 为什么要拆包"></a>3.2 为什么要拆包</h2><blockquote>
<p>拆包和粘包是相对的，一端粘了包，另外一端就需要将粘过的包拆开。举个栗子，发送端将三个数据包粘成两个TCP数据包发送到接收端，接收端就需要根据应用协议将两个数据包重新组装成三个数据包。</p>
<p>还有一种情况就是用户数据包超过了 mss(最大报文长度)，那么这个数据包在发送的时候必须拆分成几个数据包，接收端收到之后需要将这些数据包粘合起来之后，再拆开。</p>
</blockquote>
<h2 id="3-3-拆包的原理"><a href="#3-3-拆包的原理" class="headerlink" title="3.3 拆包的原理"></a>3.3 拆包的原理</h2><blockquote>
<p>数据，每次读取完都需要判断是否是一个完整的数据包：</p>
<ol>
<li>如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从tcp缓冲区中读取，直到得到一个完整的数据包。</li>
<li>如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，够成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接。</li>
</ol>
</blockquote>
<h1 id="4-Cumulator"><a href="#4-Cumulator" class="headerlink" title="4. Cumulator"></a>4. Cumulator</h1><p>Cumulator ，是 ByteToMessageDecoder 的<strong>内部</strong>接口。中文翻译为“累加器”，用于将读取到的数据进行累加到一起，然后再尝试<strong>解码</strong>，从而实现<strong>拆包</strong>。</p>
<p>也是因为 Cumulator 的累加，所以能将不完整的包累加到一起，从而完整。当然，累加的过程，没准又进入了一个不完整的包。所以，这是一个不断累加，不断解码拆包的过程。</p>
<hr>
<p>Cumulator 接口，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuf 累积器接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cumulate {<span class="doctag">@link</span> ByteBuf}s.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cumulator</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cumulate the given {<span class="doctag">@link</span> ByteBuf}s and return the {<span class="doctag">@link</span> ByteBuf} that holds the cumulated bytes.</span></span><br><span class="line"><span class="comment">     * The implementation is responsible to correctly handle the life-cycle of the given {<span class="doctag">@link</span> ByteBuf}s and so</span></span><br><span class="line"><span class="comment">     * call {<span class="doctag">@link</span> ByteBuf#release()} if a {<span class="doctag">@link</span> ByteBuf} is fully consumed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alloc ByteBuf 分配器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cumulation ByteBuf 当前累积结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 当前读取( 输入 ) ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ByteBuf 新的累积结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对于 <code>Cumulator#cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</code> 方法，将<strong>原有</strong> <code>cumulation</code> 累加上<strong>新的</strong> <code>in</code> ，返回“新”的 ByteBuf 对象。</li>
<li>如果 <code>in</code> 过大，超过 <code>cumulation</code> 的空间上限，使用 <code>alloc</code> 进行扩容后再累加。</li>
</ul>
<hr>
<p>Cumulator 有两个实现类，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() {</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator COMPOSITE_CUMULATOR = <span class="keyword">new</span> Cumulator() {</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>两者的累加方式不同，我们来详细解析。</p>
<h2 id="4-1-MERGE-CUMULATOR"><a href="#4-1-MERGE-CUMULATOR" class="headerlink" title="4.1 MERGE_CUMULATOR"></a>4.1 MERGE_CUMULATOR</h2><p><code>MERGE_CUMULATOR</code> 思路是，不断使用<strong>老的</strong> ByteBuf 累积。如果空间不够，扩容出<strong>新的</strong> ByteBuf ，再继续进行累积。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ByteToMessageDecoder.java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cumulate {<span class="doctag">@link</span> ByteBuf}s by merge them into one {<span class="doctag">@link</span> ByteBuf}'s, using memory copies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() {</span><br><span class="line">  <span class="number">2</span>: </span><br><span class="line">  <span class="number">3</span>:     <span class="meta">@Override</span></span><br><span class="line">  <span class="number">4</span>:     <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>{</span><br><span class="line">  <span class="number">5</span>:         <span class="keyword">final</span> ByteBuf buffer;</span><br><span class="line">  <span class="number">6</span>:         <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes() <span class="comment">// 超过空间大小，需要扩容</span></span><br><span class="line">  <span class="number">7</span>:                 || cumulation.refCnt() &gt; <span class="number">1</span> <span class="comment">// 引用大于 1 ，说明用户使用了 slice().retain() 或 duplicate().retain() 使refCnt增加并且大于 1 ，</span></span><br><span class="line">  <span class="number">8</span>:                                            <span class="comment">// 此时扩容返回一个新的累积区ByteBuf，方便用户对老的累积区ByteBuf进行后续处理。</span></span><br><span class="line">  <span class="number">9</span>:                 || cumulation.isReadOnly()) { <span class="comment">// 只读，不可累加，所以需要改成可写</span></span><br><span class="line"> <span class="number">10</span>:             <span class="comment">// Expand cumulation (by replace it) when either there is not more room in the buffer</span></span><br><span class="line"> <span class="number">11</span>:             <span class="comment">// or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</span></span><br><span class="line"> <span class="number">12</span>:             <span class="comment">// duplicate().retain() or if its read-only.</span></span><br><span class="line"> <span class="number">13</span>:             <span class="comment">//</span></span><br><span class="line"> <span class="number">14</span>:             <span class="comment">// See:</span></span><br><span class="line"> <span class="number">15</span>:             <span class="comment">// - https://github.com/netty/netty/issues/2327</span></span><br><span class="line"> <span class="number">16</span>:             <span class="comment">// - https://github.com/netty/netty/issues/1764</span></span><br><span class="line"> <span class="number">17</span>:             <span class="comment">// 扩容，返回新的 buffer</span></span><br><span class="line"> <span class="number">18</span>:             buffer = expandCumulation(alloc, cumulation, in.readableBytes());</span><br><span class="line"> <span class="number">19</span>:         } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">20</span>:             <span class="comment">// 使用老的 buffer</span></span><br><span class="line"> <span class="number">21</span>:             buffer = cumulation;</span><br><span class="line"> <span class="number">22</span>:         }</span><br><span class="line"> <span class="number">23</span>:         <span class="comment">// 写入 in 到 buffer 中</span></span><br><span class="line"> <span class="number">24</span>:         buffer.writeBytes(in);</span><br><span class="line"> <span class="number">25</span>:         <span class="comment">// 释放输入 in</span></span><br><span class="line"> <span class="number">26</span>:         in.release();</span><br><span class="line"> <span class="number">27</span>:         <span class="comment">// 返回 buffer</span></span><br><span class="line"> <span class="number">28</span>:         <span class="keyword">return</span> buffer;</span><br><span class="line"> <span class="number">29</span>:     }</span><br><span class="line"> <span class="number">30</span>: </span><br><span class="line"> <span class="number">31</span>: };</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>获取 <code>buffer</code> 对象。</p>
<ul>
<li>第 6 至 9 行：如下三个条件，满足任意，需要进行扩容。<ul>
<li>① 第 6 行：<code>cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</code> ，超过空间大小，需要扩容。<ul>
<li>这个比较好理解。</li>
</ul>
</li>
<li>② 第 7 行：<code>cumulation.refCnt() &gt; 1</code> ，引用大于 1 ，说明用户使用了 <code>ByteBuf#slice()#retain()</code> 或 <code>ByteBuf#duplicate()#retain()</code> 方法，使 <code>refCnt</code> 增加并且大于 1 。<ul>
<li>关于这块，在【第 11 行】的英文注释，也相应的提到。</li>
</ul>
</li>
<li>③ 第 9 行：只读，不可累加，所以需要改成可写。<ul>
<li>这个比较好理解。</li>
</ul>
</li>
</ul>
</li>
<li><p>【需要扩容】第 18 行：调用 <code>ByteToMessageDecoder#expandCumulation(ByteBufAllocator alloc, ByteBuf cumulation, int readable)</code> <strong>静态</strong>方法，扩容，并返回新的，并赋值给 <code>buffer</code> 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuf <span class="title">expandCumulation</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, <span class="keyword">int</span> readable)</span> </span>{</span><br><span class="line">    <span class="comment">// 记录老的 ByteBuf 对象</span></span><br><span class="line">    ByteBuf oldCumulation = cumulation;</span><br><span class="line">    <span class="comment">// 分配新的 ByteBuf 对象</span></span><br><span class="line">    cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);</span><br><span class="line">    <span class="comment">// 将老的数据，写入到新的 ByteBuf 对象</span></span><br><span class="line">    cumulation.writeBytes(oldCumulation);</span><br><span class="line">    <span class="comment">// 释放老的 ByteBuf 对象</span></span><br><span class="line">    oldCumulation.release();</span><br><span class="line">    <span class="comment">// 返回新的 ByteBuf 对象</span></span><br><span class="line">    <span class="keyword">return</span> cumulation;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>标准的扩容，并复制老数据的过程。胖友自己看下注释噢。</li>
</ul>
</li>
<li>【无需扩容】第 21 行：<code>buffer</code> 直接使用的 <code>cumulation</code> 对象。</li>
</ul>
</li>
<li>第 24 行：写入 <code>in</code> 到 <code>buffer</code> 中，进行累积。<ul>
<li>第 26 行：释放 <code>in</code> 。</li>
</ul>
</li>
<li>第 28 行：返回 <code>buffer</code> 。 </li>
</ul>
<h2 id="4-2-COMPOSITE-CUMULATOR"><a href="#4-2-COMPOSITE-CUMULATOR" class="headerlink" title="4.2 COMPOSITE_CUMULATOR"></a>4.2 COMPOSITE_CUMULATOR</h2><p><code>COMPOSITE_CUMULATOR</code> 思路是，使用 CompositeByteBuf ，组合新输入的 ByteBuf 对象，从而避免内存拷贝。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ByteToMessageDecoder.java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cumulate {<span class="doctag">@link</span> ByteBuf}s by add them to a {<span class="doctag">@link</span> CompositeByteBuf} and so do no memory copy whenever possible.</span></span><br><span class="line"><span class="comment">     * Be aware that {<span class="doctag">@link</span> CompositeByteBuf} use a more complex indexing implementation so depending on your use-case</span></span><br><span class="line"><span class="comment">     * and the decoder implementation this may be slower then just use the {<span class="doctag">@link</span> #MERGE_CUMULATOR}.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 相比 MERGE_CUMULATOR 来说：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 好处是，内存零拷贝</span></span><br><span class="line"><span class="comment">     * 坏处是，因为维护复杂索引，所以某些使用场景下，慢于 MERGE_CUMULATOR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator COMPOSITE_CUMULATOR = <span class="keyword">new</span> Cumulator() {</span><br><span class="line">  <span class="number">2</span>: </span><br><span class="line">  <span class="number">3</span>:     <span class="meta">@Override</span></span><br><span class="line">  <span class="number">4</span>:     <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>{</span><br><span class="line">  <span class="number">5</span>:         ByteBuf buffer;</span><br><span class="line">  <span class="number">6</span>:         <span class="comment">// 和 MERGE_CUMULATOR 的情况类似</span></span><br><span class="line">  <span class="number">7</span>:         <span class="keyword">if</span> (cumulation.refCnt() &gt; <span class="number">1</span>) {</span><br><span class="line">  <span class="number">8</span>:             <span class="comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the user</span></span><br><span class="line">  <span class="number">9</span>:             <span class="comment">// use slice().retain() or duplicate().retain().</span></span><br><span class="line"> <span class="number">10</span>:             <span class="comment">//</span></span><br><span class="line"> <span class="number">11</span>:             <span class="comment">// See:</span></span><br><span class="line"> <span class="number">12</span>:             <span class="comment">// - https://github.com/netty/netty/issues/2327</span></span><br><span class="line"> <span class="number">13</span>:             <span class="comment">// - https://github.com/netty/netty/issues/1764</span></span><br><span class="line"> <span class="number">14</span>:             buffer = expandCumulation(alloc, cumulation, in.readableBytes());</span><br><span class="line"> <span class="number">15</span>:             buffer.writeBytes(in);</span><br><span class="line"> <span class="number">16</span>:             in.release();</span><br><span class="line"> <span class="number">17</span>:         } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">18</span>:             CompositeByteBuf composite;</span><br><span class="line"> <span class="number">19</span>:             <span class="comment">// 原来是 CompositeByteBuf 类型，直接使用</span></span><br><span class="line"> <span class="number">20</span>:             <span class="keyword">if</span> (cumulation <span class="keyword">instanceof</span> CompositeByteBuf) {</span><br><span class="line"> <span class="number">21</span>:                 composite = (CompositeByteBuf) cumulation;</span><br><span class="line"> <span class="number">22</span>:             <span class="comment">// 原来不是 CompositeByteBuf 类型，创建，并添加到其中</span></span><br><span class="line"> <span class="number">23</span>:             } <span class="keyword">else</span> {</span><br><span class="line"> <span class="number">24</span>:                 composite = alloc.compositeBuffer(Integer.MAX_VALUE);</span><br><span class="line"> <span class="number">25</span>:                 composite.addComponent(<span class="keyword">true</span>, cumulation);</span><br><span class="line"> <span class="number">26</span>:             }</span><br><span class="line"> <span class="number">27</span>:             <span class="comment">// 添加 in 到 composite 中</span></span><br><span class="line"> <span class="number">28</span>:             composite.addComponent(<span class="keyword">true</span>, in);</span><br><span class="line"> <span class="number">29</span>:             <span class="comment">// 赋值给 buffer</span></span><br><span class="line"> <span class="number">30</span>:             buffer = composite;</span><br><span class="line"> <span class="number">31</span>:         }</span><br><span class="line"> <span class="number">32</span>:         <span class="comment">// 返回 buffer</span></span><br><span class="line"> <span class="number">33</span>:         <span class="keyword">return</span> buffer;</span><br><span class="line"> <span class="number">34</span>:     }</span><br><span class="line"> <span class="number">35</span>: </span><br><span class="line"> <span class="number">36</span>: };</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 7 至 16 行：<code>cumulation.refCnt() &gt; 1</code> 成立，和 <code>MERGE_CUMULATOR</code> 的情况一致，创建一个新的 ByteBuf 对象。这样，再下一次 <code>#cumulate(...)</code> 时，就会走【第 22 至 26 行】的情况。</li>
<li>获得 <code>composite</code> 对象<ul>
<li>第 19 至 21 行：如果原来<strong>就是</strong> CompositeByteBuf 类型，直接使用。</li>
<li>第 22 至 26 行：如果原来<strong>不是</strong> CompositeByteBuf 类型，创建 CompositeByteBuf 对象，并添加 <code>cumulation</code> 到其中。</li>
</ul>
</li>
<li>第 28 行：添加 <code>in</code> 到 <code>composite</code> 中，避免内存拷贝。</li>
</ul>
<h2 id="4-3-对比"><a href="#4-3-对比" class="headerlink" title="4.3 对比"></a>4.3 对比</h2><p>关于 <code>MERGE_CUMULATOR</code> 和 <code>COMPOSITE_CUMULATOR</code> 的对比，已经写在 <code>COMPOSITE_CUMULATOR</code> 的<strong>头上</strong>的注释。</p>
<p>默认情况下，ByteToMessageDecoder 使用 <code>MERGE_CUMULATOR</code> 作为累加器。</p>
<h1 id="5-ByteToMessageDecoder"><a href="#5-ByteToMessageDecoder" class="headerlink" title="5. ByteToMessageDecoder"></a>5. ByteToMessageDecoder</h1><p><code>io.netty.handler.codec.ByteToMessageDecoder</code> ，继承 ChannelInboundHandlerAdapter 类，<strong>抽象基类</strong>，负责将 Byte 解码成 Message 。</p>
<blockquote>
<p>老艿艿：ByteToMessageDecoder 的细节比较多，建议胖友理解如下小节即可：</p>
<ul>
<li><a href="#">5.1 构造方法</a></li>
<li><a href="#">5.2 channelRead</a></li>
<li><a href="#">5.3 callDecode</a></li>
<li><a href="#">5.4 channelReadComplete</a></li>
</ul>
</blockquote>
<h2 id="5-1-构造方法"><a href="#5-1-构造方法" class="headerlink" title="5.1 构造方法"></a>5.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STATE_INIT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STATE_CALLING_CHILD_DECODE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STATE_HANDLER_REMOVED_PENDING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已累积的 ByteBuf 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuf cumulation;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 累计器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Cumulator cumulator = MERGE_CUMULATOR;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否每次只解码一条消息，默认为 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 部分解码器为 true ，例如：Socks4ClientDecoder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #callDecode(ChannelHandlerContext, ByteBuf, List)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> singleDecode;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否解码到消息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WasNull ，说明就是没解码到消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #channelReadComplete(ChannelHandlerContext)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> decodeWasNull;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否首次读取，即 {<span class="doctag">@link</span> #cumulation} 为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> first;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A bitmask where the bits are defined as</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;{<span class="doctag">@link</span> #STATE_INIT}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;{<span class="doctag">@link</span> #STATE_CALLING_CHILD_DECODE}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;{<span class="doctag">@link</span> #STATE_HANDLER_REMOVED_PENDING}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解码状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 - 初始化</span></span><br><span class="line"><span class="comment"> * 1 - 调用 {<span class="doctag">@link</span> #decode(ChannelHandlerContext, ByteBuf, List)} 方法中，正在进行解码</span></span><br><span class="line"><span class="comment"> * 2 - 准备移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> decodeState = STATE_INIT;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取释放阀值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> discardAfterReads = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已读取次数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 再读取 {<span class="doctag">@link</span> #discardAfterReads} 次数据后，如果无法全部解码完，则进行释放，避免 OOM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numReads;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ByteToMessageDecoder</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 校验，不可共享</span></span><br><span class="line">    ensureNotSharable();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>属性比较简单，胖友自己看注释。</p>
<h2 id="5-2-channelRead"><a href="#5-2-channelRead" class="headerlink" title="5.2 channelRead"></a>5.2 channelRead</h2><p><code>#channelRead(ChannelHandlerContext ctx, Object msg)</code> 方法，读取到新的数据，进行解码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) {</span><br><span class="line"> <span class="number">4</span>:         <span class="comment">// 创建 CodecOutputList 对象</span></span><br><span class="line"> <span class="number">5</span>:         CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">7</span>:             ByteBuf data = (ByteBuf) msg;</span><br><span class="line"> <span class="number">8</span>:             <span class="comment">// 判断是否首次</span></span><br><span class="line"> <span class="number">9</span>:             first = cumulation == <span class="keyword">null</span>;</span><br><span class="line"><span class="number">10</span>:             <span class="comment">// 若首次，直接使用读取的 data</span></span><br><span class="line"><span class="number">11</span>:             <span class="keyword">if</span> (first) {</span><br><span class="line"><span class="number">12</span>:                 cumulation = data;</span><br><span class="line"><span class="number">13</span>:             <span class="comment">// 若非首次，将读取的 data ，累积到 cumulation 中</span></span><br><span class="line"><span class="number">14</span>:             } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">15</span>:                 cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line"><span class="number">16</span>:             }</span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 执行解码</span></span><br><span class="line"><span class="number">18</span>:             callDecode(ctx, cumulation, out);</span><br><span class="line"><span class="number">19</span>:         } <span class="keyword">catch</span> (DecoderException e) {</span><br><span class="line"><span class="number">20</span>:             <span class="keyword">throw</span> e; <span class="comment">// 抛出异常</span></span><br><span class="line"><span class="number">21</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="number">22</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e); <span class="comment">// 封装成 DecoderException 异常，抛出</span></span><br><span class="line"><span class="number">23</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">24</span>:             <span class="comment">// cumulation 中所有数据被读取完，直接释放全部</span></span><br><span class="line"><span class="number">25</span>:             <span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) {</span><br><span class="line"><span class="number">26</span>:                 numReads = <span class="number">0</span>; <span class="comment">// 重置 numReads 次数</span></span><br><span class="line"><span class="number">27</span>:                 cumulation.release(); <span class="comment">// 释放 cumulation</span></span><br><span class="line"><span class="number">28</span>:                 cumulation = <span class="keyword">null</span>; <span class="comment">// 置空 cumulation</span></span><br><span class="line"><span class="number">29</span>:             <span class="comment">// 读取次数到达 discardAfterReads 上限，释放部分的已读</span></span><br><span class="line"><span class="number">30</span>:             } <span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) {</span><br><span class="line"><span class="number">31</span>:                 <span class="comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span></span><br><span class="line"><span class="number">32</span>:                 <span class="comment">// See https://github.com/netty/netty/issues/4275</span></span><br><span class="line"><span class="number">33</span>:                 numReads = <span class="number">0</span>; <span class="comment">// 重置 numReads 次数</span></span><br><span class="line"><span class="number">34</span>:                 discardSomeReadBytes(); <span class="comment">// 释放部分的已读</span></span><br><span class="line"><span class="number">35</span>:             }</span><br><span class="line"><span class="number">36</span>: </span><br><span class="line"><span class="number">37</span>:             <span class="comment">// 解码消息的数量</span></span><br><span class="line"><span class="number">38</span>:             <span class="keyword">int</span> size = out.size();</span><br><span class="line"><span class="number">39</span>:             <span class="comment">// 是否解码到消息</span></span><br><span class="line"><span class="number">40</span>:             decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line"><span class="number">41</span>: </span><br><span class="line"><span class="number">42</span>:             <span class="comment">// 触发 Channel Read 事件。可能是多条消息</span></span><br><span class="line"><span class="number">43</span>:             fireChannelRead(ctx, out, size);</span><br><span class="line"><span class="number">44</span>: </span><br><span class="line"><span class="number">45</span>:             <span class="comment">// 回收 CodecOutputList 对象</span></span><br><span class="line"><span class="number">46</span>:             out.recycle();</span><br><span class="line"><span class="number">47</span>:         }</span><br><span class="line"><span class="number">48</span>:     } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">49</span>:         <span class="comment">// 触发 Channel Read 事件到下一个节点</span></span><br><span class="line"><span class="number">50</span>:         ctx.fireChannelRead(msg);</span><br><span class="line"><span class="number">51</span>:     }</span><br><span class="line"><span class="number">52</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 48 至 51 行：消息的类型<strong>不是</strong> ByteBuf 类，直接触发 Channel Read 事件到下一个节点。也就说，不进行解码。</li>
<li>第 3 行：消息的类型<strong>是</strong> ByteBuf 类，开始解码。</li>
<li><p>第 5 行：创建 CodecOutputList 对象。CodecOutputList 的简化代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Special {<span class="doctag">@link</span> AbstractList} implementation which is used within our codec base classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecOutputList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>如下内容，引用自 <a href="https://www.jianshu.com/p/7c439cc7b01c" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（八）–CodecHandler》</a></p>
<blockquote>
<p>解码结果列表 CodecOutputList 是 Netty 定制的一个特殊列表，该列表在线程中被缓存，可循环使用来存储解码结果，减少不必要的列表实例创建，从而提升性能。由于解码结果需要频繁存储，普通的 ArrayList 难以满足该需求，故定制化了一个特殊列表，由此可见 Netty 对优化的极致追求。</p>
</blockquote>
</li>
</ul>
<ul>
<li>第 7 至 9 行：通过 <code>cumulation</code> 是否为 <code>null</code> 来判断，是否为首次 <code>first</code> 。<ul>
<li>若<strong>是</strong>首次，直接使用读取的 <code>data</code> ( <code>ByteBuf data = (ByteBuf) msg</code> )。</li>
<li>若<strong>非</strong>首次，将读取的 <code>data</code> ，累积到 <code>cumulation</code> 中。在 <a href="#">「4. Cumulator」</a> 中，我们已经详细解析。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 18 行：调用 <code>#callDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。而解码的结果，会添加到 <code>out</code> 数组中。详细解析，见 <a href="#">「5.3 callDecode」</a> 。</p>
</li>
<li>第 19 至 22 行：若发生异常，抛出 DecoderException 异常。</li>
<li><p>第 24 至 35 行：根据 <code>cumulation</code> 的情况，释放 <code>cumulation</code> 。</p>
<ul>
<li>第 24 至 28 行：<code>cumulation</code> 中所有数据被读取完，直接<strong>释放全部</strong>。</li>
<li><p>第 29 至 35 行：读取次数( <code>numReads</code> )到达 <code>discardAfterReads</code> 上限，重置计数，并调用 <code>#discardSomeReadBytes()</code> 方法，释放部分的已读。😈 如果一直不去释放，等到满足【第 24 至 28 行】的条件，很有可能会出现 OOM 的情况。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">discardSomeReadBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !first</span><br><span class="line">            &amp;&amp; cumulation.refCnt() == <span class="number">1</span>) { <span class="comment">// &lt;1&gt; 如果用户使用了 slice().retain() 和 duplicate().retain() 使 refCnt &gt; 1 ，表明该累积区还在被用户使用，丢弃数据可能导致用户的困惑，所以须确定用户不再使用该累积区的已读数据，此时才丢弃。</span></span><br><span class="line">        <span class="comment">// discard some bytes if possible to make more room in the</span></span><br><span class="line">        <span class="comment">// buffer but only if the refCnt == 1  as otherwise the user may have</span></span><br><span class="line">        <span class="comment">// used slice().retain() or duplicate().retain().</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See:</span></span><br><span class="line">        <span class="comment">// - https://github.com/netty/netty/issues/2327</span></span><br><span class="line">        <span class="comment">// - https://github.com/netty/netty/issues/1764</span></span><br><span class="line">        <span class="comment">// &lt;2&gt; 释放部分</span></span><br><span class="line">        cumulation.discardSomeReadBytes();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，原因见中文注释。</li>
<li><code>&lt;2&gt;</code> 处，释放<strong>部分</strong>已读字节区。注意，是“部分”，而不是“全部”，避免一次性释放全部，时间过长。并且，能够读取到这么“大”，往往字节数容量不小。如果直接释放掉“全部”，那么后续还需要再重复扩容，反倒不好。</li>
</ul>
</li>
</ul>
</li>
<li>第 38 行：获得解码消息的数量。<ul>
<li>第 40 行：是否解码到消息。为什么不直接使用 <code>size</code> 来判断呢？因为如果添加了消息，然后又移除该消息，此时 <code>size</code> 为 0 ，但是 <code>!out.insertSinceRecycled()</code> 为 <code>true</code> 。<ul>
<li>另外，我们在 <a href="#">「5.3 callDecode」</a> 中，将会看到一个 <code>out</code> 的清理操作，到时会更加明白。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 43 行：调用 <code>#fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements)</code> <strong>静态</strong>方法，触发 Channel Read 事件。可能是多条消息。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get {<span class="doctag">@code</span> numElements} out of the {<span class="doctag">@link</span> List} and forward these through the pipeline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, <span class="keyword">int</span> numElements)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msgs <span class="keyword">instanceof</span> CodecOutputList) { <span class="comment">// 如果是 CodecOutputList 类型，特殊优化</span></span><br><span class="line">        fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) {</span><br><span class="line">            ctx.fireChannelRead(msgs.get(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get {<span class="doctag">@code</span> numElements} out of the {<span class="doctag">@link</span> CodecOutputList} and forward these through the pipeline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="keyword">int</span> numElements)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i ++) {</span><br><span class="line">        ctx.fireChannelRead(msgs.getUnsafe(i)); <span class="comment">// getUnsafe 是自定义的方法，减少越界判断，效率更高</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>遍历 <code>msgs</code> 数组，每条消息触发一次 Channel Read 事件。</li>
</ul>
</li>
<li><p>第 46 行：回收 CodecOutputList 对象。</p>
</li>
</ul>
<h2 id="5-3-callDecode"><a href="#5-3-callDecode" class="headerlink" title="5.3 callDecode"></a>5.3 callDecode</h2><p><code>#callDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。而解码的结果，会添加到 <code>out</code> 数组中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">3</span>:         <span class="comment">// 循环读取，直到不可读</span></span><br><span class="line"> <span class="number">4</span>:         <span class="keyword">while</span> (in.isReadable()) {</span><br><span class="line"> <span class="number">5</span>:             <span class="comment">// 记录</span></span><br><span class="line"> <span class="number">6</span>:             <span class="keyword">int</span> outSize = out.size();</span><br><span class="line"> <span class="number">7</span>:             <span class="comment">// out 非空，说明上一次解码有解码到消息</span></span><br><span class="line"> <span class="number">8</span>:             <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) {</span><br><span class="line"> <span class="number">9</span>:                 <span class="comment">// 触发 Channel Read 事件。可能是多条消息</span></span><br><span class="line"><span class="number">10</span>:                 fireChannelRead(ctx, out, outSize);</span><br><span class="line"><span class="number">11</span>:                 <span class="comment">// 清空</span></span><br><span class="line"><span class="number">12</span>:                 out.clear();</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:                 <span class="comment">// 用户主动删除该 Handler ，继续操作 in 是不安全的</span></span><br><span class="line"><span class="number">15</span>:                 <span class="comment">// Check if this handler was removed before continuing with decoding.</span></span><br><span class="line"><span class="number">16</span>:                 <span class="comment">// If it was removed, it is not safe to continue to operate on the buffer.</span></span><br><span class="line"><span class="number">17</span>:                 <span class="comment">//</span></span><br><span class="line"><span class="number">18</span>:                 <span class="comment">// See:</span></span><br><span class="line"><span class="number">19</span>:                 <span class="comment">// - https://github.com/netty/netty/issues/4635</span></span><br><span class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (ctx.isRemoved()) {</span><br><span class="line"><span class="number">21</span>:                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">22</span>:                 }</span><br><span class="line"><span class="number">23</span>:                 outSize = <span class="number">0</span>;</span><br><span class="line"><span class="number">24</span>:             }</span><br><span class="line"><span class="number">25</span>: </span><br><span class="line"><span class="number">26</span>:             <span class="comment">// 记录当前可读字节数</span></span><br><span class="line"><span class="number">27</span>:             <span class="keyword">int</span> oldInputLength = in.readableBytes();</span><br><span class="line"><span class="number">28</span>: </span><br><span class="line"><span class="number">29</span>:             <span class="comment">// 执行解码。如果 Handler 准备移除，在解码完成后，进行移除。</span></span><br><span class="line"><span class="number">30</span>:             decodeRemovalReentryProtection(ctx, in, out);</span><br><span class="line"><span class="number">31</span>: </span><br><span class="line"><span class="number">32</span>:             <span class="comment">// 用户主动删除该 Handler ，继续操作 in 是不安全的</span></span><br><span class="line"><span class="number">33</span>:             <span class="comment">// Check if this handler was removed before continuing the loop.</span></span><br><span class="line"><span class="number">34</span>:             <span class="comment">// If it was removed, it is not safe to continue to operate on the buffer.</span></span><br><span class="line"><span class="number">35</span>:             <span class="comment">//</span></span><br><span class="line"><span class="number">36</span>:             <span class="comment">// See https://github.com/netty/netty/issues/1664</span></span><br><span class="line"><span class="number">37</span>:             <span class="keyword">if</span> (ctx.isRemoved()) {</span><br><span class="line"><span class="number">38</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">39</span>:             }</span><br><span class="line"><span class="number">40</span>: </span><br><span class="line"><span class="number">41</span>:             <span class="comment">// 整列判断 `out.size() == 0` 比较合适。因为，如果 `outSize &gt; 0` 那段，已经清理了 out 。</span></span><br><span class="line"><span class="number">42</span>:             <span class="keyword">if</span> (outSize == out.size()) {</span><br><span class="line"><span class="number">43</span>:                 <span class="comment">// 如果未读取任何字节，结束循环</span></span><br><span class="line"><span class="number">44</span>:                 <span class="keyword">if</span> (oldInputLength == in.readableBytes()) {</span><br><span class="line"><span class="number">45</span>:                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">46</span>:                 <span class="comment">// 如果可读字节发生变化，继续读取</span></span><br><span class="line"><span class="number">47</span>:                 } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">48</span>:                     <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">49</span>:                 }</span><br><span class="line"><span class="number">50</span>:             }</span><br><span class="line"><span class="number">51</span>: </span><br><span class="line"><span class="number">52</span>:             <span class="comment">// 如果解码了消息，但是可读字节数未变，抛出 DecoderException 异常。说明，有问题。</span></span><br><span class="line"><span class="number">53</span>:             <span class="keyword">if</span> (oldInputLength == in.readableBytes()) {</span><br><span class="line"><span class="number">54</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(StringUtil.simpleClassName(getClass()) + <span class="string">".decode() did not read anything but decoded a message."</span>);</span><br><span class="line"><span class="number">55</span>:             }</span><br><span class="line"><span class="number">56</span>: </span><br><span class="line"><span class="number">57</span>:             <span class="comment">// 如果开启 singleDecode ，表示只解析一次，结束循环</span></span><br><span class="line"><span class="number">58</span>:             <span class="keyword">if</span> (isSingleDecode()) {</span><br><span class="line"><span class="number">59</span>:                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">60</span>:             }</span><br><span class="line"><span class="number">61</span>:         }</span><br><span class="line"><span class="number">62</span>:     } <span class="keyword">catch</span> (DecoderException e) {</span><br><span class="line"><span class="number">63</span>:         <span class="keyword">throw</span> e;</span><br><span class="line"><span class="number">64</span>:     } <span class="keyword">catch</span> (Exception cause) {</span><br><span class="line"><span class="number">65</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(cause);</span><br><span class="line"><span class="number">66</span>:     }</span><br><span class="line"><span class="number">67</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：循环读取 <code>in</code> ，直到不可读。</li>
<li>第 5 行：记录 <code>out</code> 的大小。<ul>
<li>第 8 行：如果 <code>out</code> 非空，说明上一次解码有解码到消息。</li>
<li>第 10 行：调用 <code>#fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements)</code> <strong>静态</strong>方法，触发 Channel Read 事件。可能是多条消息。😈 关于该方法，上文已经详细解析。</li>
<li>第 12 行：清空 <code>out</code> 。所以，有可能会出现 <code>#channelRead(ChannelHandlerContext ctx, Object msg)</code> 方法的【第 40 行】的情况。</li>
<li>第 14 至 22 行：用户主动删除该 Handler ，继续操作 <code>in</code> 是不安全的，所以结束循环。</li>
<li>第 23 行：记录 <code>out</code> 的大小为<strong>零</strong>。所以，实际上，<code>outSize</code> 没有必要记录。因为，一定是为<strong>零</strong>。</li>
</ul>
</li>
<li>第 27 行：记录当前可读字节数。</li>
<li>第 30 行：调用 <code>#decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。如果 Handler 准备移除，在解码完成后，进行移除。详细解析，见 <a href="#">「5.3.1 decodeRemovalReentryProtection」</a> 中。</li>
<li>第 32 至 39 行：用户主动删除该 Handler ，继续操作 <code>in</code> 是不安全的，所以结束循环。</li>
<li>第 42 行：直接判断 <code>out.size() == 0</code> 比较合适。因为【第 8 至 24 行】的代码，能够保证 <code>outSize</code> 等于<strong>零</strong>。<ul>
<li>第 43 至 45 行：如果<strong>未读取</strong>任何字节，<code>break</code> 结束循环。</li>
<li>第 46 至 49 行：如果可读字节<strong>发生变化</strong>，<code>continue</code> 重新开始循环，即继续读取。</li>
</ul>
</li>
<li>第 52 至 55 行：如果解码了消息，但是可读字节数未变，抛出 DecoderException 异常。说明，有问题。</li>
<li>第 57 至 60 行：如果开启 <code>singleDecode</code> ，表示只解析一次，<code>break</code> 结束循环。</li>
<li>第 62 至 66 行：如果发生异常，抛出 DecoderException 异常。</li>
</ul>
<p>😈 代码有一些长，胖友保持耐心看完哈。其实，蛮简单的。</p>
<h3 id="5-3-1-decodeRemovalReentryProtection"><a href="#5-3-1-decodeRemovalReentryProtection" class="headerlink" title="5.3.1 decodeRemovalReentryProtection"></a>5.3.1 decodeRemovalReentryProtection</h3><p><code>#decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。如果 Handler 准备移除，在解码完成后，进行移除。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decodeRemovalReentryProtection</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 设置状态为 STATE_CALLING_CHILD_DECODE</span></span><br><span class="line"> <span class="number">3</span>:     decodeState = STATE_CALLING_CHILD_DECODE;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 执行解码</span></span><br><span class="line"> <span class="number">6</span>:         decode(ctx, in, out);</span><br><span class="line"> <span class="number">7</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"> <span class="number">8</span>:         <span class="comment">// 判断是否准备移除</span></span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">boolean</span> removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;</span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 设置状态为 STATE_INIT</span></span><br><span class="line"><span class="number">11</span>:         decodeState = STATE_INIT;</span><br><span class="line"><span class="number">12</span>:         <span class="comment">// 移除当前 Handler</span></span><br><span class="line"><span class="number">13</span>:         <span class="keyword">if</span> (removePending) {</span><br><span class="line"><span class="number">14</span>:             handlerRemoved(ctx);</span><br><span class="line"><span class="number">15</span>:         }</span><br><span class="line"><span class="number">16</span>:     }</span><br><span class="line"><span class="number">17</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 行：设置状态(<code>decodeState</code>) 为 <code>STATE_CALLING_CHILD_DECODE</code> 。</li>
<li><p>第 6 行：调用 <code>#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，执行解码。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decode the from one {<span class="doctag">@link</span> ByteBuf} to an other. This method will be called till either the input</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ByteBuf} has nothing to read when return from this method or till nothing was read from the input</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ByteBuf}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx           the {<span class="doctag">@link</span> ChannelHandlerContext} which this {<span class="doctag">@link</span> ByteToMessageDecoder} belongs to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in            the {<span class="doctag">@link</span> ByteBuf} from which to read data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out           the {<span class="doctag">@link</span> List} to which decoded messages should be added</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception    is thrown if an error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>子类实现该方法，就可以愉快的解码消息了，<strong>并且，也只需要实现该方法</strong>。其它的逻辑，ByteToMessageDecoder 已经全部帮忙实现了。</li>
</ul>
</li>
<li>第 9 行：判断是否准备移除。那么什么情况下，会出现 <code>decodeState == STATE_HANDLER_REMOVED_PENDING</code> 成立呢？详细解析，见 <a href="#">「5.7 handlerRemoved」</a> 。<ul>
<li>第 11 行：设置状态(<code>decodeState</code>) 为 <code>STATE_HANDLER_REMOVED_PENDING</code> 。</li>
<li>第 12 至 15 行：如果准备移除，则调用 <code>#handlerRemoved(ChannelHandlerContext ctx)</code> 方法，移除当前 Handler 。详细解析，见 <a href="#">「5.7 handlerRemoved」</a> 。</li>
</ul>
</li>
</ul>
<h2 id="5-4-channelReadComplete"><a href="#5-4-channelReadComplete" class="headerlink" title="5.4 channelReadComplete"></a>5.4 channelReadComplete</h2><p><code>#channelReadComplete(ChannelHandlerContext ctx)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 重置 numReads</span></span><br><span class="line"> <span class="number">4</span>:     numReads = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>:     <span class="comment">// 释放部分的已读</span></span><br><span class="line"> <span class="number">6</span>:     discardSomeReadBytes();</span><br><span class="line"> <span class="number">7</span>:     <span class="comment">// 未解码到消息，并且未开启自动读取，则再次发起读取，期望读取到更多数据，以便解码到消息</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (decodeWasNull) {</span><br><span class="line"> <span class="number">9</span>:         decodeWasNull = <span class="keyword">false</span>; <span class="comment">// 重置 decodeWasNull</span></span><br><span class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!ctx.channel().config().isAutoRead()) {</span><br><span class="line"><span class="number">11</span>:             ctx.read();</span><br><span class="line"><span class="number">12</span>:         }</span><br><span class="line"><span class="number">13</span>:     }</span><br><span class="line"><span class="number">14</span>:     <span class="comment">// 触发 Channel ReadComplete 事件到下一个节点</span></span><br><span class="line"><span class="number">15</span>:     ctx.fireChannelReadComplete();</span><br><span class="line"><span class="number">16</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 4 行：重置 <code>numReads</code> 。</li>
<li>第 6 行：调用 <code>#discardSomeReadBytes()</code> 方法，释放部分的已读。</li>
<li>第 7 至 13 行：未解码到消息( <code>decodeWasNull == true</code> )，并且未开启自动读取( <code>ctx.channel().config().isAutoRead() == false</code> )，则再次发起读取，期望读取到更多数据，以便解码到消息。</li>
<li>第 15 行：触发 Channel ReadComplete 事件到下一个节点。</li>
</ul>
<h2 id="5-5-channelInactive"><a href="#5-5-channelInactive" class="headerlink" title="5.5 channelInactive"></a>5.5 channelInactive</h2><p><code>#channelInactive(ChannelHandlerContext ctx)</code> 方法，通道处于未激活( Inactive )，解码完剩余的消息，并释放相关资源。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    channelInputClosed(ctx, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>调用 <code>#channelInputClosed(ChannelHandlerContext ctx, boolean callChannelInactive)</code> 方法，执行 Channel 读取关闭的逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">channelInputClosed</span><span class="params">(ChannelHandlerContext ctx, <span class="keyword">boolean</span> callChannelInactive)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">2</span>:     <span class="comment">// 创建 CodecOutputList 对象</span></span><br><span class="line"> <span class="number">3</span>:     CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">try</span> {</span><br><span class="line"> <span class="number">5</span>:         <span class="comment">// 当 Channel 读取关闭时，执行解码剩余消息的逻辑</span></span><br><span class="line"> <span class="number">6</span>:         channelInputClosed(ctx, out);</span><br><span class="line"> <span class="number">7</span>:     } <span class="keyword">catch</span> (DecoderException e) {</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">throw</span> e;</span><br><span class="line"> <span class="number">9</span>:     } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="number">10</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e);</span><br><span class="line"><span class="number">11</span>:     } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">12</span>:         <span class="keyword">try</span> {</span><br><span class="line"><span class="number">13</span>:             <span class="comment">// 释放 cumulation</span></span><br><span class="line"><span class="number">14</span>:             <span class="keyword">if</span> (cumulation != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">15</span>:                 cumulation.release();</span><br><span class="line"><span class="number">16</span>:                 cumulation = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">17</span>:             }</span><br><span class="line"><span class="number">18</span>:             <span class="keyword">int</span> size = out.size();</span><br><span class="line"><span class="number">19</span>:             <span class="comment">// 触发 Channel Read 事件到下一个节点。可能是多条消息</span></span><br><span class="line"><span class="number">20</span>:             fireChannelRead(ctx, out, size);</span><br><span class="line"><span class="number">21</span>:             <span class="comment">// 如果有解码到消息，则触发 Channel ReadComplete 事件到下一个节点。</span></span><br><span class="line"><span class="number">22</span>:             <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">23</span>:                 <span class="comment">// Something was read, call fireChannelReadComplete()</span></span><br><span class="line"><span class="number">24</span>:                 ctx.fireChannelReadComplete();</span><br><span class="line"><span class="number">25</span>:             }</span><br><span class="line"><span class="number">26</span>:             <span class="comment">// 如果方法调用来源是 `#channelInactive(...)` ，则触发 Channel Inactive 事件到下一个节点</span></span><br><span class="line"><span class="number">27</span>:             <span class="keyword">if</span> (callChannelInactive) {</span><br><span class="line"><span class="number">28</span>:                 ctx.fireChannelInactive();</span><br><span class="line"><span class="number">29</span>:             }</span><br><span class="line"><span class="number">30</span>:         } <span class="keyword">finally</span> {</span><br><span class="line"><span class="number">31</span>:             <span class="comment">// 回收 CodecOutputList 对象</span></span><br><span class="line"><span class="number">32</span>:             <span class="comment">// Recycle in all cases</span></span><br><span class="line"><span class="number">33</span>:             out.recycle();</span><br><span class="line"><span class="number">34</span>:         }</span><br><span class="line"><span class="number">35</span>:     }</span><br><span class="line"><span class="number">36</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>第 3 行：创建 CodecOutputList 对象。</p>
<ul>
<li><p>第 6 行：调用 <code>#channelInputClosed(ChannelHandlerContext ctx, List&lt;Object&gt; out)</code> 方法，当 Channel 读取关闭时，执行解码剩余消息的逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the input of the channel was closed which may be because it changed to inactive or because of</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ChannelInputShutdownEvent}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelInputClosed</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (cumulation != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 执行解码</span></span><br><span class="line">        callDecode(ctx, cumulation, out);</span><br><span class="line">        <span class="comment">// 最后一次，执行解码</span></span><br><span class="line">        decodeLast(ctx, cumulation, out);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 最后一次，执行解码</span></span><br><span class="line">        decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is called one last time when the {<span class="doctag">@link</span> ChannelHandlerContext} goes in-active. Which means the</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #channelInactive(ChannelHandlerContext)} was triggered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * By default this will just call {<span class="doctag">@link</span> #decode(ChannelHandlerContext, ByteBuf, List)} but sub-classes may</span></span><br><span class="line"><span class="comment"> * override this for some special cleanup operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (in.isReadable()) {</span><br><span class="line">        <span class="comment">// Only call decode() if there is something left in the buffer to decode.</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/4386</span></span><br><span class="line">        decodeRemovalReentryProtection(ctx, in, out);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>其中，<code>#decodeLast(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法，是可以被重写的。例如，HttpObjectDecoder 就重写了该方法。</li>
</ul>
</li>
<li>第 7 至 10 行：如果发生异常，就抛出 DecoderException 异常。</li>
</ul>
</li>
<li>第 13 至 17 行：释放 <code>cumulation</code> 。</li>
<li>第 20 行：调用 <code>#fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements)</code> <strong>静态</strong>方法，触发 Channel Read 事件。可能是多条消息。</li>
<li>第 21 至 25 行：如果有解码到消息( <code>size &gt; 0</code> )，则触发 Channel ReadComplete 事件到下一个节点。</li>
<li>第 26 至 29 行：如果方法调用来源是 <code>#channelInactive(...)</code> ，则触发 Channel Inactive 事件到下一个节点。</li>
<li>第 30 至 35 行：回收 CodecOutputList 对象。</li>
</ul>
</li>
</ul>
<p>😈 对于该方法的目的，笔者的理解是，尽可能在解码一次剩余的 <code>cumulation</code> ，在 Channel 变成未激活时。细节好多呀！！！</p>
<h2 id="5-6-userEventTriggered"><a href="#5-6-userEventTriggered" class="headerlink" title="5.6 userEventTriggered"></a>5.6 userEventTriggered</h2><p><code>#userEventTriggered(ChannelHandlerContext ctx, Object evt)</code> 方法，处理 ChannelInputShutdownEvent 事件，即 Channel 关闭读取。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> ChannelInputShutdownEvent) {</span><br><span class="line">        <span class="comment">// The decodeLast method is invoked when a channelInactive event is encountered.</span></span><br><span class="line">        <span class="comment">// This method is responsible for ending requests in some situations and must be called</span></span><br><span class="line">        <span class="comment">// when the input has been shutdown.</span></span><br><span class="line">        channelInputClosed(ctx, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 继续传播 evt 到下一个节点</span></span><br><span class="line">    <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>#channelInputClosed(ChannelHandlerContext ctx, boolean callChannelInactive)</code> 方法，执行 Channel 读取关闭的逻辑。</li>
<li>继续传播 <code>evt</code> 到下一个节点。</li>
</ul>
<p>😈 对于该方法的目的，笔者的理解是，尽可能在解码一次剩余的 <code>cumulation</code> ，在 Channel 关闭读取。细节好多呀！！！</p>
<h2 id="5-7-handlerRemoved"><a href="#5-7-handlerRemoved" class="headerlink" title="5.7 handlerRemoved"></a>5.7 handlerRemoved</h2><p><code>#handlerRemoved(ChannelHandlerContext ctx)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> <span class="number">3</span>:     <span class="comment">// 状态处于 STATE_CALLING_CHILD_DECODE 时，标记状态为 STATE_HANDLER_REMOVED_PENDING</span></span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (decodeState == STATE_CALLING_CHILD_DECODE) {</span><br><span class="line"> <span class="number">5</span>:         decodeState = STATE_HANDLER_REMOVED_PENDING;</span><br><span class="line"> <span class="number">6</span>:         <span class="keyword">return</span>; <span class="comment">// 返回！！！！结合 `#decodeRemovalReentryProtection(...)` 方法，一起看。</span></span><br><span class="line"> <span class="number">7</span>:     }</span><br><span class="line"> <span class="number">8</span>:     ByteBuf buf = cumulation;</span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">if</span> (buf != <span class="keyword">null</span>) {</span><br><span class="line"><span class="number">10</span>:         <span class="comment">// 置空 cumulation</span></span><br><span class="line"><span class="number">11</span>:         <span class="comment">// Directly set this to null so we are sure we not access it in any other method here anymore.</span></span><br><span class="line"><span class="number">12</span>:         cumulation = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">13</span>: </span><br><span class="line"><span class="number">14</span>:         <span class="keyword">int</span> readable = buf.readableBytes();</span><br><span class="line"><span class="number">15</span>:         <span class="comment">// 有可读字节</span></span><br><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> (readable &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="number">17</span>:             <span class="comment">// 读取剩余字节，并释放 buf</span></span><br><span class="line"><span class="number">18</span>:             ByteBuf bytes = buf.readBytes(readable);</span><br><span class="line"><span class="number">19</span>:             buf.release();</span><br><span class="line"><span class="number">20</span>:             <span class="comment">// 触发 Channel Read 到下一个节点</span></span><br><span class="line"><span class="number">21</span>:             ctx.fireChannelRead(bytes);</span><br><span class="line"><span class="number">22</span>:         <span class="comment">// 无可读字节</span></span><br><span class="line"><span class="number">23</span>:         } <span class="keyword">else</span> {</span><br><span class="line"><span class="number">24</span>:             <span class="comment">// 释放 buf</span></span><br><span class="line"><span class="number">25</span>:             buf.release();</span><br><span class="line"><span class="number">26</span>:         }</span><br><span class="line"><span class="number">27</span>: </span><br><span class="line"><span class="number">28</span>:         <span class="comment">// 置空 numReads</span></span><br><span class="line"><span class="number">29</span>:         numReads = <span class="number">0</span>;</span><br><span class="line"><span class="number">30</span>:         <span class="comment">// 触发 Channel ReadComplete 到下一个节点</span></span><br><span class="line"><span class="number">31</span>:         ctx.fireChannelReadComplete();</span><br><span class="line"><span class="number">32</span>:     }</span><br><span class="line"><span class="number">33</span>:     <span class="comment">// 执行移除逻辑</span></span><br><span class="line"><span class="number">34</span>:     handlerRemoved0(ctx);</span><br><span class="line"><span class="number">35</span>: }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 3 至 7 行：如果状态( <code>decodeState</code> )处于 <code>STATE_CALLING_CHILD_DECODE</code> 时，说明正在执行 <code>#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法中。如果此时，直接往下执行，<code>cumulation</code> 将被直接释放，而 <code>#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法可能正在解码中，很大可能性造成影响，导致错误。所以，此处仅仅标记状态( <code>decodeState</code> )为 <code>STATE_HANDLER_REMOVED_PENDING</code> 。等到 <code>#decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code> 方法执行完成后，在进行移除。胖友，此时可以再跳回 <a href="#">「5.3.1 decodeRemovalReentryProtection」</a> ，进行再次理解。</li>
<li>【有可读字节】第 15 至 21 行：读取剩余字节，并释放 <code>buf</code> 。然后，触发 Channel Read 到下一个节点。通过这样的方式，避免 <code>cumulation</code> 中，有字节被“丢失”，即使当前可能无法解码成一个数据包。</li>
<li>【无可读字节】第 22 至 26 行：直接释放 <code>buf</code> 。</li>
<li>第 29 行：置空 <code>numReads</code> 。</li>
<li><p>第 34 行：调用 <code>#handlerRemoved0(ChannelHandlerContext ctx)</code> 方法，执行移除逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets called after the {<span class="doctag">@link</span> ByteToMessageDecoder} was removed from the actual context and it doesn't handle</span></span><br><span class="line"><span class="comment"> * events anymore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handlerRemoved0</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{ }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认情况下，该方法实现为空。目前可重写该方法，实现自定义的资源释放。目前重写该方法的类，例如：Http2ConnectionHandler、SslHandler 等等。</li>
</ul>
</li>
</ul>
<h2 id="5-8-internalBuffer"><a href="#5-8-internalBuffer" class="headerlink" title="5.8 internalBuffer"></a>5.8 internalBuffer</h2><p><code>#internalBuffer()</code> 方法，获得 ByteBuf 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the internal cumulative buffer of this decoder. You usually</span></span><br><span class="line"><span class="comment"> * do not need to access the internal buffer directly to write a decoder.</span></span><br><span class="line"><span class="comment"> * Use it only when you must use it at your own risk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">internalBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cumulation != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cumulation;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> Unpooled.EMPTY_BUFFER;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-9-actualReadableBytes"><a href="#5-9-actualReadableBytes" class="headerlink" title="5.9 actualReadableBytes"></a>5.9 actualReadableBytes</h2><p><code>#actualReadableBytes()</code> 方法，获得可读字节数。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the actual number of readable bytes in the internal cumulative</span></span><br><span class="line"><span class="comment"> * buffer of this decoder. You usually do not need to rely on this value</span></span><br><span class="line"><span class="comment"> * to write a decoder. Use it only when you must use it at your own risk.</span></span><br><span class="line"><span class="comment"> * This method is a shortcut to {<span class="doctag">@link</span> #internalBuffer() internalBuffer().readableBytes()}.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">actualReadableBytes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> internalBuffer().readableBytes();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>细节有点多，可能对如下小节理解不够到位。如有错误，烦请胖友教育。</p>
<ul>
<li><a href="#">「5.5 channelInactive」</a></li>
<li><a href="#">「5.6 userEventTriggered」</a></li>
<li><a href="#">「5.7 handlerRemoved」</a></li>
</ul>
<hr>
<p>本文参考如下文章：</p>
<ul>
<li>简书闪电侠 <a href="https://www.jianshu.com/p/dc26e944da95" rel="external nofollow noopener noreferrer" target="_blank">《netty源码分析之拆包器的奥秘》</a></li>
<li>Hypercube <a href="https://www.jianshu.com/p/7c439cc7b01c" rel="external nofollow noopener noreferrer" target="_blank">《自顶向下深入分析Netty（八）–CodecHandler》</a></li>
</ul>

</div>
<!--
<footer class="article-footer">
<a data-url="http://svip.iocoder.cn/Netty/Codec-1-1-ByteToMessageDecoder-core-impl/" data-id="ck4pl3fpb00ekfgcfqsfar0b8" class="article-share-link">分享</a>

</footer>
-->
</div>
