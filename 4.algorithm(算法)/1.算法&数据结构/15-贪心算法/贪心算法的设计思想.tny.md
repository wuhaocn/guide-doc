<div class="clear">&nbsp;</div>
<div class="postBody">
<div id="cnblogs_post_body" class="blogpost-body">
<div id="article_content" class="article_content">
<h2>贪心算法的设计思想</h2>
<div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 贪心算法在解决这个问题的策略上目光短浅，仅仅依据当前已有的信息就做出选择，并且一旦做出了选择，无论将来有什么结果，这个选择都不会改变。换言之，贪心法并非从总体最优考虑，它所做出的选择仅仅是在某种意义上的局部最优。贪心算法对于大部分的优化问题都能产生最优解，但不能总获得总体最优解，通常能够获得近似最优解。</div>
<div>
<h4>引例 [找零钱]</h4>
<h4><span class="Apple-style-span">一个小孩买了价值少于1美元的糖，并将1美元的钱交给售货员。售货员希望用数目最少的硬币找给小孩。</span><span class="Apple-style-span">如果提供了数目不限的面值为2 5美分、1 0美分、5美分、及1美分的硬币。</span><span class="Apple-style-span">售货员分步骤组成要找的零钱数，每次增加一个硬币。选择硬币时所採用的贪婪准则例如以下：每一次选择应使零钱数尽量增大。为保证解法的可行性（即：所给的零钱等于要找的零钱数），所选择的硬币不应使零钱总数超过终于所需的数目</span></h4>
<h4><strong><span class="Apple-style-span">引例分析</span></strong></h4>
<h4><span class="Apple-style-span">为使找回的零钱的硬币数最小，不考虑找零钱的全部各种方案，而是从最大面值的币种開始，按递减的顺序考虑各币种，先尽量用大面值的币种，仅仅当不足大面值币种的金额才会去考虑下一种较小面值的币种。这就是在採用贪婪法。</span><span class="Apple-style-span">这样的方法在这里之所以总是最优，是由于银行对其发行的硬币种类和硬币面值的巧妙安排。</span><span class="Apple-style-span">假设仅仅有面值分别为1，5和11单位的硬币，而希望找回总额为15单位的硬币，按贪婪算法，应找1个11单位面值的硬币和4个1单位面值的硬币，共找回5个硬币。但最优的解答应是3个5单位面值的硬币。</span></h4>
<h2><strong>贪心法的求解过程&nbsp;</strong></h2>
<div>
<div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 用贪心法求解问题应该考虑例如以下几个方面：</div>
<div>（1）候选集合C：为了构造问题的解决方式，有一个候选集合C作为问题的可能解，即问题的终于解均取自于候选集合C。比如，在付款问题中，各种 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;面值的货币构成候选集合。</div>
<div>（2）解集合S：随着贪心选择的进行，解集合S不断扩展，直到构成一个满足问题的完整解。比如，在付款问题中，已付出的货币构成解集合。</div>
<div>
<div>（3）解决函数solution：检查解集合S是否构成问题的完整解。比如，在付款问题中，解决函数是已付出的货币金额恰好等于应付款。</div>
<div>（4）选择函数select：即贪心策略，这是贪心法的关键，它指出哪个候选对象最有希望构成问题的解，选择函数通常和目标函数有关。比如，在付款 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 问题中，贪心策略就是在候选集合中选择面值最大的货币。</div>
<div>（5）可行函数feasible：检查解集合中增加一个候选对象是否可行，即解集合扩展后是否满足约束条件。比如，在付款问题中，可行函数是每一步选 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;择的货币和已付出的货币相加不超过应付款。</div>
<div>
<h4>贪心法的一般流程</h4>
<div>Greedy(C)&nbsp; //C是问题的输入集合即候选集合</div>
<div>{</div>
<div>&nbsp;&nbsp;&nbsp; S={ };&nbsp; //初始解集合为空集</div>
<div>&nbsp;&nbsp;&nbsp; while (not solution(S))&nbsp; //集合S没有构成问题的一个解</div>
<div>&nbsp;&nbsp;&nbsp; {</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x=select(C);&nbsp;&nbsp;&nbsp; //在候选集合C中做贪心选择</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if feasible(S, x)&nbsp; //推断集合S中增加x后的解是否可行</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S=S+{x};</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C=C-{x};</div>
<div>&nbsp;&nbsp;&nbsp; }</div>
<div>&nbsp;&nbsp; return S;</div>
<div>
<h2><strong>贪心法的基本要素</strong></h2>
<div>
<div>&nbsp;&nbsp; &nbsp; &nbsp;对于一个详细的问题，怎么知道是否可用贪心算法解此问题，以及是否能得到问题的最优解呢?这个问题非常难给予肯定的回答。</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可是，从很多能够用贪心算法求解的问题中看到这类问题一般具有2个重要的性质：<strong>贪心选择性质</strong>和<strong>最优子结构性质</strong>。</div>
<div>子问题：如果为了解决某一优化问题，须要依次作出n个决策D1，D2，&hellip;，Dn，对于不论什么一个整数k，1 &lt; k &lt; n，以Dk作为问题的初始状态，来进行以后的决策，这种问题就成为是原问题的一个子问题。</div>
<div>
<h4><strong>1.贪心选择性质</strong></h4>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所谓<strong>贪心选择性质</strong>是指所求问题的<strong>总体最优解</strong>能够通过一系列<strong>局部最优</strong>的选择，换句话说，当考虑做何种选择的时候，我们仅仅考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。</div>
<div>贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于一个详细问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择终于导致问题的总体最优解。</div>
<div>
<h4><strong>2.最优子结构性质</strong></h4>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个问题的最优解包括其子问题的最优解时，称此问题具有<strong>最优子结构性质</strong>。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。</div>
<div>
<h2><strong>贪心法的应用</strong></h2>
<div>
<ul>
<li>哈夫曼编码</li>
<li>0-1背包问题</li>
<li>磁盘文件的存储</li>
<li>生产调度问题</li>
<li>信息查询</li>
</ul>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/mfrbuaa/p/3853682.html">https://www.cnblogs.com/mfrbuaa/p/3853682.html</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="show-content" data-note-content="">
<div class="show-content-free">&nbsp;</div>
</div>