# æ·±å…¥æµ…å‡ºCAS

[![96]()]()

[å å°ç‹¼]() ![11f8cfa8 ec9f 4f82 be92 d6a39f61b5c1]()  [å…³æ³¨]()

4.3  2016.07.12 13:42/* å­—æ•° 1637 é˜…è¯» 46285è¯„è®º 102å–œæ¬¢ 266èµèµ 2

[å å°ç‹¼](https://www.jianshu.com/users/90ab66c248e6/latest_articles) è½¬è½½è¯·æ³¨æ˜åŸåˆ›å‡ºå¤„ï¼Œè°¢è°¢ï¼

### å‰è¨€

CASï¼ˆCompare and Swapï¼‰ï¼Œå³æ¯”è¾ƒå¹¶æ›¿æ¢ï¼Œå®ç°å¹¶å‘ç®—æ³•æ—¶å¸¸ç”¨åˆ°çš„ä¸€ç§æŠ€æœ¯ï¼ŒDoug leaå¤§ç¥åœ¨javaåŒæ­¥å™¨ä¸­å¤§é‡ä½¿ç”¨äº†CASæŠ€æœ¯ï¼Œé¬¼æ–§ç¥å·¥çš„å®ç°äº†å¤šçº¿ç¨‹æ‰§è¡Œçš„å®‰å…¨æ€§ã€‚

CASçš„æ€æƒ³å¾ˆç®€å•ï¼šä¸‰ä¸ªå‚æ•°ï¼Œä¸€ä¸ªå½“å‰å†…å­˜å€¼Vã€æ—§çš„é¢„æœŸå€¼Aã€å³å°†æ›´æ–°çš„å€¼Bï¼Œå½“ä¸”ä»…å½“é¢„æœŸå€¼Aå’Œå†…å­˜å€¼Vç›¸åŒæ—¶ï¼Œå°†å†…å­˜å€¼ä¿®æ”¹ä¸ºBå¹¶è¿”å›trueï¼Œå¦åˆ™ä»€ä¹ˆéƒ½ä¸åšï¼Œå¹¶è¿”å›falseã€‚

### é—®é¢˜

ä¸€ä¸ª

n++
çš„é—®é¢˜ã€‚

```
public class Case { public volatile int n; public void add(){ n++; } }
```

é€šè¿‡

javap -verbose Case
çœ‹çœ‹addæ–¹æ³•çš„å­—èŠ‚ç æŒ‡ä»¤

```
public void add(); flags: ACC_PUBLIC Code: stack=3, locals=1, args_size=1 0: aload_0 1: dup 2: getfield /#2 // Field n:I 5: iconst_1 6: iadd 7: putfield /#2 // Field n:I 10: return
```

n++
è¢«æ‹†åˆ†æˆäº†å‡ ä¸ªæŒ‡ä»¤ï¼š

1. æ‰§è¡Œ

getfield
æ‹¿åˆ°åŸå§‹nï¼›
1. æ‰§è¡Œ

iadd
è¿›è¡ŒåŠ 1æ“ä½œï¼›
1. æ‰§è¡Œ

putfield
å†™æŠŠç´¯åŠ åçš„å€¼å†™å›nï¼›

é€šè¿‡volatileä¿®é¥°çš„å˜é‡å¯ä»¥ä¿è¯çº¿ç¨‹ä¹‹é—´çš„å¯è§æ€§ï¼Œä½†å¹¶ä¸èƒ½ä¿è¯è¿™3ä¸ªæŒ‡ä»¤çš„åŸå­æ‰§è¡Œï¼Œåœ¨å¤šçº¿ç¨‹å¹¶å‘æ‰§è¡Œä¸‹ï¼Œæ— æ³•åšåˆ°çº¿ç¨‹å®‰å…¨ï¼Œå¾—åˆ°æ­£ç¡®çš„ç»“æœï¼Œé‚£ä¹ˆåº”è¯¥å¦‚ä½•è§£å†³å‘¢ï¼Ÿ

### å¦‚ä½•è§£å†³

åœ¨

add
æ–¹æ³•åŠ ä¸Šsynchronizedä¿®é¥°è§£å†³ã€‚

```
public class Case{ public volatile int n; public synchronized void add(){ n++; } }
```

è¿™ä¸ªæ–¹æ¡ˆå½“ç„¶å¯è¡Œï¼Œä½†æ˜¯æ€§èƒ½ä¸Šå·®äº†ç‚¹ï¼Œè¿˜æœ‰å…¶å®ƒæ–¹æ¡ˆä¹ˆï¼Ÿ

å†æ¥çœ‹ä¸€æ®µä»£ç 

```
public int a = 1; public boolean compareAndSwapInt(int b){ if (a == 1) { a = b; return true; } return false; }
```

å¦‚æœè¿™æ®µä»£ç åœ¨å¹¶å‘ä¸‹æ‰§è¡Œï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

å‡è®¾çº¿ç¨‹1å’Œçº¿ç¨‹2éƒ½è¿‡äº†

a==1
çš„æ£€æµ‹ï¼Œéƒ½å‡†å¤‡æ‰§è¡Œå¯¹aè¿›è¡Œèµ‹å€¼ï¼Œç»“æœå°±æ˜¯ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹äº†å˜é‡aï¼Œæ˜¾ç„¶è¿™ç§ç»“æœæ˜¯æ— æ³•ç¬¦åˆé¢„æœŸçš„ï¼Œæ— æ³•ç¡®å®šaçš„æœ€ç»ˆå€¼ã€‚

è§£å†³æ–¹æ³•ä¹ŸåŒæ ·æš´åŠ›ï¼Œåœ¨compareAndSwapIntæ–¹æ³•åŠ é”åŒæ­¥ï¼Œå˜æˆä¸€ä¸ªåŸå­æ“ä½œï¼ŒåŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰èƒ½ä¿®æ”¹å˜é‡aã€‚

é™¤äº†ä½æ€§èƒ½çš„åŠ é”æ–¹æ¡ˆï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨JDKè‡ªå¸¦çš„CASæ–¹æ¡ˆï¼Œåœ¨CASä¸­ï¼Œæ¯”è¾ƒå’Œæ›¿æ¢æ˜¯ä¸€ç»„åŸå­æ“ä½œï¼Œä¸ä¼šè¢«å¤–éƒ¨æ‰“æ–­ï¼Œä¸”åœ¨æ€§èƒ½ä¸Šæ›´å æœ‰ä¼˜åŠ¿ã€‚

ä¸‹é¢ä»¥

AtomicInteger
çš„å®ç°ä¸ºä¾‹ï¼Œåˆ†æä¸€ä¸‹CASæ˜¯å¦‚ä½•å®ç°çš„ã€‚

```
public class AtomicInteger extends Number implements java.io.Serializable{ // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; public final int get(){return value;} }
```

1. Unsafeï¼Œæ˜¯CASçš„æ ¸å¿ƒç±»ï¼Œç”±äºJavaæ–¹æ³•æ— æ³•ç›´æ¥è®¿é—®åº•å±‚ç³»ç»Ÿï¼Œéœ€è¦é€šè¿‡æœ¬åœ°ï¼ˆnativeï¼‰æ–¹æ³•æ¥è®¿é—®ï¼ŒUnsafeç›¸å½“äºä¸€ä¸ªåé—¨ï¼ŒåŸºäºè¯¥ç±»å¯ä»¥ç›´æ¥æ“ä½œç‰¹å®šå†…å­˜çš„æ•°æ®ã€‚
1. å˜é‡valueOffsetï¼Œè¡¨ç¤ºè¯¥å˜é‡å€¼åœ¨å†…å­˜ä¸­çš„åç§»åœ°å€ï¼Œå› ä¸ºUnsafeå°±æ˜¯æ ¹æ®å†…å­˜åç§»åœ°å€è·å–æ•°æ®çš„ã€‚
1. å˜é‡valueç”¨volatileä¿®é¥°ï¼Œä¿è¯äº†å¤šçº¿ç¨‹ä¹‹é—´çš„å†…å­˜å¯è§æ€§ã€‚

çœ‹çœ‹

AtomicInteger
å¦‚ä½•å®ç°å¹¶å‘ä¸‹çš„ç´¯åŠ æ“ä½œï¼š

```
public final int getAndAdd(int delta){ return unsafe.getAndAddInt(this, valueOffset, delta); } //unsafe.getAndAddInt public final int getAndAddInt(Object var1, long var2, int var4){ int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; }
```

å‡è®¾çº¿ç¨‹Aå’Œçº¿ç¨‹BåŒæ—¶æ‰§è¡ŒgetAndAddæ“ä½œï¼ˆåˆ†åˆ«è·‘åœ¨ä¸åŒCPUä¸Šï¼‰ï¼š

1. AtomicIntegeré‡Œé¢çš„valueåŸå§‹å€¼ä¸º3ï¼Œå³ä¸»å†…å­˜ä¸­AtomicIntegerçš„valueä¸º3ï¼Œæ ¹æ®Javaå†…å­˜æ¨¡å‹ï¼Œçº¿ç¨‹Aå’Œçº¿ç¨‹Bå„è‡ªæŒæœ‰ä¸€ä»½valueçš„å‰¯æœ¬ï¼Œå€¼ä¸º3ã€‚
1. çº¿ç¨‹Aé€šè¿‡

getIntVolatile(var1, var2)
æ‹¿åˆ°valueå€¼3ï¼Œè¿™æ—¶çº¿ç¨‹Aè¢«æŒ‚èµ·ã€‚
1. çº¿ç¨‹Bä¹Ÿé€šè¿‡

getIntVolatile(var1, var2)
æ–¹æ³•è·å–åˆ°valueå€¼3ï¼Œè¿æ°”å¥½ï¼Œçº¿ç¨‹Bæ²¡æœ‰è¢«æŒ‚èµ·ï¼Œå¹¶æ‰§è¡Œ

compareAndSwapInt
æ–¹æ³•æ¯”è¾ƒå†…å­˜å€¼ä¹Ÿä¸º3ï¼ŒæˆåŠŸä¿®æ”¹å†…å­˜å€¼ä¸º2ã€‚
1. è¿™æ—¶çº¿ç¨‹Aæ¢å¤ï¼Œæ‰§è¡Œ

compareAndSwapInt
æ–¹æ³•æ¯”è¾ƒï¼Œå‘ç°è‡ªå·±æ‰‹é‡Œçš„å€¼(3)å’Œå†…å­˜çš„å€¼(2)ä¸ä¸€è‡´ï¼Œè¯´æ˜è¯¥å€¼å·²ç»è¢«å…¶å®ƒçº¿ç¨‹æå‰ä¿®æ”¹è¿‡äº†ï¼Œé‚£åªèƒ½é‡æ–°æ¥ä¸€éäº†ã€‚
1. é‡æ–°è·å–valueå€¼ï¼Œå› ä¸ºå˜é‡valueè¢«volatileä¿®é¥°ï¼Œæ‰€ä»¥å…¶å®ƒçº¿ç¨‹å¯¹å®ƒçš„ä¿®æ”¹ï¼Œçº¿ç¨‹Aæ€»æ˜¯èƒ½å¤Ÿçœ‹åˆ°ï¼Œçº¿ç¨‹Aç»§ç»­æ‰§è¡Œ

compareAndSwapInt
è¿›è¡Œæ¯”è¾ƒæ›¿æ¢ï¼Œç›´åˆ°æˆåŠŸã€‚

æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œåˆ©ç”¨CASä¿è¯äº†å¯¹äºvalueçš„ä¿®æ”¹çš„å¹¶å‘å®‰å…¨ï¼Œç»§ç»­æ·±å…¥çœ‹çœ‹Unsafeç±»ä¸­çš„compareAndSwapIntæ–¹æ³•å®ç°ã€‚

```
public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
```

Unsafeç±»ä¸­çš„compareAndSwapIntï¼Œæ˜¯ä¸€ä¸ªæœ¬åœ°æ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„å®ç°ä½äº

unsafe.cpp
ä¸­

```
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv /*env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper("Unsafe_CompareAndSwapInt"); oop p = JNIHandles::resolve(obj); jint/* addr = (jint /*) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e; UNSAFE_END
```

1. å…ˆæƒ³åŠæ³•æ‹¿åˆ°å˜é‡valueåœ¨å†…å­˜ä¸­çš„åœ°å€ã€‚
1. é€šè¿‡

Atomic::cmpxchg
å®ç°æ¯”è¾ƒæ›¿æ¢ï¼Œå…¶ä¸­å‚æ•°xæ˜¯å³å°†æ›´æ–°çš„å€¼ï¼Œå‚æ•°eæ˜¯åŸå†…å­˜çš„å€¼ã€‚

å¦‚æœæ˜¯Linuxçš„x86ï¼Œ

Atomic::cmpxchg
æ–¹æ³•çš„å®ç°å¦‚ä¸‹ï¼š

```
inline jint Atomic::cmpxchg (jint exchange_value, volatile jint/* dest, jint compare_value) { int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)" : "=a" (exchange_value) : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp) : "cc", "memory"); return exchange_value; }
```

çœ‹åˆ°è¿™æ±‡ç¼–ï¼Œå†…å¿ƒå´©æºƒ ğŸ˜–

__asm__
è¡¨ç¤ºæ±‡ç¼–çš„å¼€å§‹

volatile
è¡¨ç¤ºç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–

LOCK_IF_MP
æ˜¯ä¸ªå†…è”å‡½æ•°

```
/#define LOCK_IF_MP(mp) "cmp $0, " /#mp "; je 1f; lock; 1: "
```

Windowçš„x86å®ç°å¦‚ä¸‹ï¼š

```
inline jint Atomic::cmpxchg (jint exchange_value, volatile jint/* dest, jint compare_value) { int mp = os::isMP(); //åˆ¤æ–­æ˜¯å¦æ˜¯å¤šå¤„ç†å™¨ _asm { mov edx, dest mov ecx, exchange_value mov eax, compare_value LOCK_IF_MP(mp) cmpxchg dword ptr [edx], ecx } } // Adding a lock prefix to an instruction on MP machine // VC++ doesn't like the lock prefix to be on a single line // so we can't insert a label after the lock prefix. // By emitting a lock prefix, we can define a label after it. /#define LOCK_IF_MP(mp) __asm cmp mp, 0 \ __asm je L0 \ __asm _emit 0xF0 \ __asm L0:
```

LOCK_IF_MP
æ ¹æ®å½“å‰ç³»ç»Ÿæ˜¯å¦ä¸ºå¤šæ ¸å¤„ç†å™¨å†³å®šæ˜¯å¦ä¸ºcmpxchgæŒ‡ä»¤æ·»åŠ lockå‰ç¼€ã€‚

1. å¦‚æœæ˜¯å¤šå¤„ç†å™¨ï¼Œä¸ºcmpxchgæŒ‡ä»¤æ·»åŠ lockå‰ç¼€ã€‚
1. åä¹‹ï¼Œå°±çœç•¥lockå‰ç¼€ã€‚ï¼ˆå•å¤„ç†å™¨ä¼šä¸éœ€è¦lockå‰ç¼€æä¾›çš„å†…å­˜å±éšœæ•ˆæœï¼‰

intelæ‰‹å†Œå¯¹lockå‰ç¼€çš„è¯´æ˜å¦‚ä¸‹ï¼š

1. ç¡®ä¿åç»­æŒ‡ä»¤æ‰§è¡Œçš„åŸå­æ€§ã€‚
åœ¨PentiumåŠä¹‹å‰çš„å¤„ç†å™¨ä¸­ï¼Œå¸¦æœ‰lockå‰ç¼€çš„æŒ‡ä»¤åœ¨æ‰§è¡ŒæœŸé—´ä¼šé”ä½æ€»çº¿ï¼Œä½¿å¾—å…¶å®ƒå¤„ç†å™¨æš‚æ—¶æ— æ³•é€šè¿‡æ€»çº¿è®¿é—®å†…å­˜ï¼Œå¾ˆæ˜¾ç„¶ï¼Œè¿™ä¸ªå¼€é”€å¾ˆå¤§ã€‚åœ¨æ–°çš„å¤„ç†å™¨ä¸­ï¼ŒIntelä½¿ç”¨ç¼“å­˜é”å®šæ¥ä¿è¯æŒ‡ä»¤æ‰§è¡Œçš„åŸå­æ€§ï¼Œç¼“å­˜é”å®šå°†å¤§å¤§é™ä½lockå‰ç¼€æŒ‡ä»¤çš„æ‰§è¡Œå¼€é”€ã€‚
1. ç¦æ­¢è¯¥æŒ‡ä»¤ä¸å‰é¢å’Œåé¢çš„è¯»å†™æŒ‡ä»¤é‡æ’åºã€‚
1. æŠŠå†™ç¼“å†²åŒºçš„æ‰€æœ‰æ•°æ®åˆ·æ–°åˆ°å†…å­˜ä¸­ã€‚

ä¸Šé¢çš„ç¬¬2ç‚¹å’Œç¬¬3ç‚¹æ‰€å…·æœ‰çš„å†…å­˜å±éšœæ•ˆæœï¼Œä¿è¯äº†CASåŒæ—¶å…·æœ‰volatileè¯»å’Œvolatileå†™çš„å†…å­˜è¯­ä¹‰ã€‚

### CASç¼ºç‚¹

CASå­˜åœ¨ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„é—®é¢˜ï¼Œå³ABAé—®é¢˜ã€‚

é—®é¢˜ï¼šå¦‚æœå˜é‡Våˆæ¬¡è¯»å–çš„æ—¶å€™æ˜¯Aï¼Œå¹¶ä¸”åœ¨å‡†å¤‡èµ‹å€¼çš„æ—¶å€™æ£€æŸ¥åˆ°å®ƒä»ç„¶æ˜¯Aï¼Œé‚£èƒ½è¯´æ˜å®ƒçš„å€¼æ²¡æœ‰è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹è¿‡äº†å—ï¼Ÿ

å¦‚æœåœ¨è¿™æ®µæœŸé—´æ›¾ç»è¢«æ”¹æˆBï¼Œç„¶ååˆæ”¹å›Aï¼Œé‚£CASæ“ä½œå°±ä¼šè¯¯è®¤ä¸ºå®ƒä»æ¥æ²¡æœ‰è¢«ä¿®æ”¹è¿‡ã€‚é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œjavaå¹¶å‘åŒ…ä¸­æä¾›äº†ä¸€ä¸ªå¸¦æœ‰æ ‡è®°çš„åŸå­å¼•ç”¨ç±»

AtomicStampedReference
ï¼Œå®ƒå¯ä»¥é€šè¿‡æ§åˆ¶å˜é‡å€¼çš„ç‰ˆæœ¬æ¥ä¿è¯CASçš„æ­£ç¡®æ€§ã€‚
![]()