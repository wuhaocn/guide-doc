## 668.乘法表中第k小的数.md
    几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？
    给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

### 例 1：

    输入: m = 3, n = 3, k = 5
    输出: 3
    解释: 
    乘法表:
    1	2	3
    2	4	6
    3	6	9
    
    第5小的数字是 3 (1, 2, 2, 3, 3).
### 例 2：

    输入: m = 2, n = 3, k = 6
    输出: 6
    解释: 
    乘法表:
    1	2	3
    2	4	6
    
    第6小的数字是 6 (1, 2, 2, 3, 4, 6).

### 注意：

    1.m 和 n 的范围在 [1, 30000] 之间。
    2.k 的范围在 [1, m * n] 之间。



### 思路分析

思路分析： 这道题可能有人会想着先构造出这个乘法表，然后再去搜索，但这样是行不通的，
因为m、n的取值可能非常大，非常耗内存。首先我们知道在m、n的乘法表中取值范围为[1, m * n]，
那么我们可不可以使用使用二分搜索呢？

首先观察乘法表我们会发现，由于构造关系，决定了他每一行都是递增的。

如果我们需要在第i行中寻找大于num的个数，我们只要min(num / i, n)，
其中（i是这一行的行号，n是矩阵的列数）num / i代表的是如果num也在第i行，
它存在的列数，所以只要取最小值就是第i行不大于num的个数。
（比如例题1中，我们需要知道第2行，不大于4的个数，min(4 / 2, 3) == 2个（就是2， 4））

那么如果我们需要确定这个乘法表中不大于num的个数就非常简单了，我们只要将每一行
不大于num的个数累加即可。（比如例题1中，我们需要知道乘法表中不大于4的个数，
第一行3个、第二行2个，第三行1个）

现在我们就可以使用二分搜索了，初始化left = 1， right = n * m + 1，
mid = （left + right） / 2，在m，n的乘法表中寻找不超过mid的个数。


### 官方题解
二分搜索[通过]
由于 \text{k}k 和 \text{m*n}m*n 最多为 9 * 10^89∗10 
8
 ，线性解将不起作用。这将激发具有 \loglog 复杂性的解决方案，例如二分搜索。

算法：
让我们用二分搜索答案 \text{A}A。

当且仅当乘法表中存在小于或等于 \text{k}k，enough(x) 才为真。通俗地说，enough(x) 描述了 \text{x}x 是否足够大可以成为乘法表中的 k^{th}k 
th
  值。
然后（对于我们的答案 \text{A}A），每当 \text{x ≥ A}x ≥ A，enough(x) 为 True；每当 \text{x < A}x < A，enough(x) 为 False。
在二分搜索中，循环不变量 enough(hi) = True。在开始时，enough(m*n) = True，并且每当设置 hi时，都将其设置为“enough”（enough(mi) = True）的值。这意味着 hi 将是二分搜索结束时的最小值。
这样我们就可以计算出有多少值小于或等于 \text{x}x。对于 \text{m}m 行中的每一行，i^{th}i 
th
  行看起来像是 \text{[i, 2i, 3i, ..., ni]}[i, 2i, 3i, ..., ni]。可能出现的最大的 \text{ki ≤ x}ki ≤ x 是 \text{k = x // i}k = x // i。但是，如果 \text{x}x 真的很大，那么可能是\text{k > n}k > n，那么在该行中总共有 \text{min(k, n) = min(x // i, n)}min(k, n) = min(x // i, n) 值小于或等于 \text{x}x。
复杂度分析

时间复杂度：O(m * \log (mn))O(m∗log(mn))。我们的二分搜索在每一步将间隔 \text{[lo, hi]}[lo, hi] 分为两部分。在每个步骤中，我们都调用了 enough，这需要O(m)O(m) 时间。
空间复杂度：O(1)O(1) ,我们只在中间计算期间将整数保存在内存中。


```java
class Solution {
    public int findKthNumber(int m, int n, int k) {
        int start = 1;
        int end = m * n;
        int mid;
        while (start < end) {
            mid = start + (end - start) / 2;
            int count = counter(m, n, mid);
            if (count >= k) {
                end = mid; 
            } else{
                start = mid + 1;
            }
        }
        
        return start;
    }
    
    public int counter(int m, int n, int mid) {
        int x = m;
        int y = 1;
        int counter = 0;
        while (x >= 1 && y <= n) {
            if (x * y <= mid) {
                counter += x;
                y++;
            } else {
                x--;
            }
        }
        
        return counter;
    }
}

```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。