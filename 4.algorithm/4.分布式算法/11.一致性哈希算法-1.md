## [一致性哈希算法原理分析及实现](https://www.cnblogs.com/markcd/p/8476237.html)

一致性哈希算法常用于负载均衡中要求资源被均匀的分布到所有节点上，并且对资源的请求能快速路由到对应的节点上。具体的举两个场景的例子：

1、MemCache集群，要求存储各种数据均匀的存到集群中的各个节点上，访问这些数据时能快速的路由到集群中对应存放该数据的节点上；并且要求增删节点对整个集群的影响很小，不至于有大的动荡造成整体负载的不稳定；

2、RPC过程中服务提供者做N个节点的集群部署，为了能在服务上维护一些业务状态，希望同一种请求每次都落到同一台服务上。

比如有{N0, N1, N2}三个节点，陆续有多个资源要分配到这三个节点上，如何尽可能均匀的分配到这些节点上？

一致性哈希算法的思路为：先构造出一个长度为232整数环，根据N0-3的节点名称的hash值（分布为[0,232-1]）放到这个环上。现在要存放资源，根据资源的Key的Hash值（也是分布为[0,232-1]）值Haaa，在环上顺时针的找到离Haaa最近（第一个大于或等于Haaa）的一个节点，就建立了资源和节点的映射关系。

![](https://images2018.cnblogs.com/blog/1335235/201802/1335235-20180227210146353-634482541.png)

以上图片引自http://www.cnblogs.com/xrq730/p/4948707.html。

为什么要用环存储节点，并用hashKey顺时针寻找对应节点？

我们分配节点最简单的办法是取余算法，即有3个节点，资源key=5, 5%3=2，选取N2，key=3，3%3=0，选取N0。虽然简单，但有个缺点，如果节点数增加或减少，就会有大量的key不命中，造成请求压力转移，可能对系统整体有很大的影响，甚至发生宕机危险。

而一致性哈希算法增加或减少节点，只会引起少部分key不命中，如下图，增加一个Node4节点，只会将加粗部分的key值从Node1(10.0.0.0:91002)移到Node4(10.0.0.0:91003)，对集群影响很小。

![](https://images2018.cnblogs.com/blog/1335235/201802/1335235-20180227212707491-375499397.png)

以上图片引自http://www.cnblogs.com/xrq730/p/4948707.html

Java实现中用什么表示Hash环好呢？经对比，用TreeMap的时间复杂度是O(logN)，相对效率比较高，因为TreeMap使用了红黑树结构存储实体对象。

Hash算法的选择上，首先我们考虑简单的String.HashCode()方法，这个算法的缺点是，相似的字符串如N1(10.0.0.0:91001)，N2(10.0.0.0:91002)，N3(10.0.0.0:91003)，哈希值也很相近，造成的结果是节点在Hash环上分布很紧密，导致大部分Key值落到了N0上，节点资源分布不均。一般我们采用FNV1_32_HASH、KETAMA_HASH等算法，KETAMA_HASH是MemCache集群默认的实现方法，这些算法效果要好得多，会使N0，N1，N2的Hash值更均匀的分布在环上。

我们用KETAMA_HASH算法实现一致性哈希（无虚拟节点方式），如下代码所示：
[![复制代码]()]( "复制代码")
```
1 packagecom.example.demo.arithmetic;2 3 importjava.io.UnsupportedEncodingException;4 importjava.security.MessageDigest;5 importjava.security.NoSuchAlgorithmException;6 importjava.util.Arrays;7 importjava.util.Map;8 importjava.util.TreeMap;9 10 //*/* 11 /* Created by markcd on 2018/2/28.12 /*/ 13 public classConsistentHashLoadBalanceNoVirtualNode {14 15 private TreeMap<Long, String> realNodes = new TreeMap<>();16 privateString[] nodes;17 18 publicConsistentHashLoadBalanceNoVirtualNode(String[] nodes){19 this.nodes =Arrays.copyOf(nodes, nodes.length);20 initalization();21 }22 23 //*/* 24 /* 初始化哈希环25 /* 循环计算每个node名称的哈希值，将其放入treeMap26 /*/ 27 private voidinitalization(){28 for(String nodeName: nodes) {29 realNodes.put(hash(nodeName, 0), nodeName);30 }31 }32 33 //*/* 34 /* 根据资源key选择返回相应的节点名称35 /*@paramkey36 /*@return节点名称37 /*/ 38 publicString selectNode(String key){39 Long hashOfKey = hash(key, 0);40 if (!realNodes.containsKey(hashOfKey)) {
//ceilingEntry()的作用是得到比hashOfKey大的第一个Entry41 Map.Entry<Long, String> entry =realNodes.ceilingEntry(hashOfKey);42 if (entry != null)43 returnentry.getValue();44 else 45 return nodes[0];46 }else 47 returnrealNodes.get(hashOfKey);48 }49 50 private Long hash(String nodeName, intnumber) {51 byte[] digest =md5(nodeName);52 return (((long) (digest[3 + number /* 4] & 0xFF) << 24)53 | ((long) (digest[2 + number /* 4] & 0xFF) << 16)54 | ((long) (digest[1 + number /* 4] & 0xFF) << 8)55 | (digest[number /* 4] & 0xFF))56 & 0xFFFFFFFFL;57 }58 59 //*/* 60 /* md5加密61 /*62 /*@paramstr63 /*@return 64 /*/ 65 public byte[] md5(String str) {66 try{67 MessageDigest md = MessageDigest.getInstance("MD5");68 md.reset();69 md.update(str.getBytes("UTF-8"));70 returnmd.digest();71 } catch(NoSuchAlgorithmException e) {72 e.printStackTrace();73 return null;74 } catch(UnsupportedEncodingException e) {75 e.printStackTrace();76 return null;77 }78 }79 80 private voidprintTreeNode(){81 if (realNodes != null && !realNodes.isEmpty()){82 realNodes.forEach((hashKey, node) -> 83 System.out.println(84 newStringBuffer(node)85 .append(" ==> ")86 .append(hashKey)87 )88 );89 }else 90 System.out.println("Cycle is Empty");91 }92 93 public static voidmain(String[] args){94 String[] nodes = new String[]{"192.168.2.1:8080", "192.168.2.2:8080", "192.168.2.3:8080", "192.168.2.4:8080"};95 ConsistentHashLoadBalanceNoVirtualNode consistentHash = newConsistentHashLoadBalanceNoVirtualNode(nodes);96 consistentHash.printTreeNode();97 }98 }
```
[![复制代码]()]( "复制代码")

main()方法执行结果如下，可以看到，hash值分布的距离比较开阔。

192.168.2.3:8080 ==> 1182102228

192.168.2.4:8080 ==> 1563927337

192.168.2.1:8080 ==> 2686712470

192.168.2.2:8080 ==> 3540412423

KETAMA_HASH解决了hash值分布不均的问题，但还存在一个问题，如下图，在没有Node3节点时，资源相对均匀的分布在{Node0,Node1,Node2}上。增加了Node3节点后，Node1到Node3节点中间的所有资源从Node2迁移到了Node3上。这样，Node0,Node1存储的资源多，Node2,Node3存储的资源少，资源分布不均匀。

![](https://images2018.cnblogs.com/blog/1335235/201803/1335235-20180303200455882-625465220.png)

以上图片引自http://www.cnblogs.com/xrq730/p/4948707.html

如何解决这个问题呢？我们引入虚拟节点概念，如将一个真实节点Node0映射成100个虚拟节点分布在Hash环上，与这100个虚拟节点根据KETAMA_HASH哈希环匹配的资源都存到真实节点Node0上。{Node0,Node1,Node2}以相同的方式拆分虚拟节点映射到Hash环上。当集群增加节点Node3时，在Hash环上增加Node3拆分的100个虚拟节点，这新增的100个虚拟节点更均匀的分布在了哈希环上，可能承担了{Node0,Node1,Node2}每个节点的部分资源，资源分布仍然保持均匀。

每个真实节点应该拆分成多少个虚拟节点？数量要合适才能保证负载分布的均匀，有一个大致的规律，如下图所示，Y轴表示真实节点的数目，X轴表示需拆分的虚拟节点数目：

![](https://images2018.cnblogs.com/blog/1335235/201803/1335235-20180303214723675-958695068.png)

真实节点越少，所需阐发的虚拟节点越多，比如有10个真实节点，每个节点所需拆分的虚拟节点个数可能是100~200个，才能达到真正的负载均衡。

下面贴出使用了虚拟节点的算法实现：
[![复制代码]()]( "复制代码")
```
1 packagecom.example.demo.arithmetic;2 3 importjava.io.UnsupportedEncodingException;4 importjava.security.MessageDigest;5 importjava.security.NoSuchAlgorithmException;6 importjava.util.LinkedList;7 importjava.util.Map;8 importjava.util.TreeMap;9 10 //*/* 11 /* Created by markcd on 2018/2/28.12 /*/ 13 public classConsistentHashLoadBalance {14 15 private TreeMap<Long, String> virtualNodes = new TreeMap<>();16 private LinkedList<String>nodes;
//每个真实节点对应的虚拟节点数17 private final intreplicCnt;18 19 public ConsistentHashLoadBalance(LinkedList<String> nodes, intreplicCnt){20 this.nodes =nodes;21 this.replicCnt =replicCnt;22 initalization();23 }24 25 //*/* 26 /* 初始化哈希环27 /* 循环计算每个node名称的哈希值，将其放入treeMap28 /*/ 29 private voidinitalization(){30 for(String nodeName: nodes) {31 for (int i = 0; i < replicCnt/4; i++) {32 String virtualNodeName =getNodeNameByIndex(nodeName, i);33 for (int j = 0; j < 4; j++) {34 virtualNodes.put(hash(virtualNodeName, j), nodeName);35 }36 }37 }38 }39 40 private String getNodeNameByIndex(String nodeName, intindex){41 return newStringBuffer(nodeName)42 .append("&&")43 .append(index)44 .toString();45 }46 47 //*/* 48 /* 根据资源key选择返回相应的节点名称49 /*@paramkey50 /*@return节点名称51 /*/ 52 publicString selectNode(String key){53 Long hashOfKey = hash(key, 0);54 if (!virtualNodes.containsKey(hashOfKey)) {55 Map.Entry<Long, String> entry =virtualNodes.ceilingEntry(hashOfKey);56 if (entry != null)57 returnentry.getValue();58 else 59 returnnodes.getFirst();60 }else 61 returnvirtualNodes.get(hashOfKey);62 }63 64 private Long hash(String nodeName, intnumber) {65 byte[] digest =md5(nodeName);66 return (((long) (digest[3 + number /* 4] & 0xFF) << 24)67 | ((long) (digest[2 + number /* 4] & 0xFF) << 16)68 | ((long) (digest[1 + number /* 4] & 0xFF) << 8)69 | (digest[number /* 4] & 0xFF))70 & 0xFFFFFFFFL;71 }72 73 //*/* 74 /* md5加密75 /*76 /*@paramstr77 /*@return 78 /*/ 79 public byte[] md5(String str) {80 try{81 MessageDigest md = MessageDigest.getInstance("MD5");82 md.reset();83 md.update(str.getBytes("UTF-8"));84 returnmd.digest();85 } catch(NoSuchAlgorithmException e) {86 e.printStackTrace();87 return null;88 } catch(UnsupportedEncodingException e) {89 e.printStackTrace();90 return null;91 }92 }93 94 public voidaddNode(String node){95 nodes.add(node);96 String virtualNodeName = getNodeNameByIndex(node, 0);97 for (int i = 0; i < replicCnt/4; i++) {98 for (int j = 0; j < 4; j++) {99 virtualNodes.put(hash(virtualNodeName, j), node);100 }101 }102 }103 104 public voidremoveNode(String node){105 nodes.remove(node);106 String virtualNodeName = getNodeNameByIndex(node, 0);107 for (int i = 0; i < replicCnt/4; i++) {108 for (int j = 0; j < 4; j++) {109 virtualNodes.remove(hash(virtualNodeName, j), node);110 }111 }112 }113 114 private voidprintTreeNode(){115 if (virtualNodes != null && !virtualNodes.isEmpty()){116 virtualNodes.forEach((hashKey, node) -> 117 System.out.println(118 newStringBuffer(node)119 .append(" ==> ")120 .append(hashKey)121 )122 );123 }else 124 System.out.println("Cycle is Empty");125 }126 127 public static voidmain(String[] args){128 LinkedList<String> nodes = new LinkedList<>();129 nodes.add("192.168.2.1:8080");130 nodes.add("192.168.2.2:8080");131 nodes.add("192.168.2.3:8080");132 nodes.add("192.168.2.4:8080");133 ConsistentHashLoadBalance consistentHash = new ConsistentHashLoadBalance(nodes, 160);134 consistentHash.printTreeNode();135 }136 }
```
[![复制代码]()]( "复制代码")

以上main方法执行的结果如下：

192.168.2.4:8080 ==> 18075595
192.168.2.1:8080 ==> 18286704
192.168.2.1:8080 ==> 35659769
192.168.2.2:8080 ==> 43448858
192.168.2.1:8080 ==> 44075453
192.168.2.3:8080 ==> 47625378
........(由于内容过多，不做全部展示)

至此哈希一致性算法的原理和实现描述完毕，欢迎大家讨论，如有不当的地方欢迎大家提出异议。

分类: [算法](https://www.cnblogs.com/markcd/category/1165262.html)

标签: [算法](https://www.cnblogs.com/markcd/tag/%E7%AE%97%E6%B3%95/)
[好文要顶]() [关注我]() [收藏该文]() [![](https://common.cnblogs.com/images/icon_weibo_24.png)]( "分享至新浪微博") [![](https://common.cnblogs.com/images/wechat.png)]( "分享至微信")

[![](https://pic.cnblogs.com/face/1335235/20180218124351.png)](https://home.cnblogs.com/u/markcd/)

[滴水穿石，写自己的故事](https://home.cnblogs.com/u/markcd/)
[关注 - 1](https://home.cnblogs.com/u/markcd/followees/)
[粉丝 - 8](https://home.cnblogs.com/u/markcd/followers/)

[+加关注]()
1

0

[«](https://www.cnblogs.com/markcd/p/8456870.html) 上一篇： [负载均衡算法WeightedRoundRobin(加权轮询)简介及算法实现](https://www.cnblogs.com/markcd/p/8456870.html "发布于 2018-02-22 19:35")
[»](https://www.cnblogs.com/markcd/p/8504674.html) 下一篇： [Dubbo学习源码总结系列四--集群容错机制](https://www.cnblogs.com/markcd/p/8504674.html "发布于 2018-03-04 14:38")

posted on 2018-03-03 21:54 [滴水穿石，写自己的故事](https://www.cnblogs.com/markcd/) 阅读(7732) 评论(0) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=8476237) [收藏]()   []()

[]()

[刷新评论]()[刷新页面]()[返回顶部]()
注册用户登录后才能发表评论，请 [登录]() 或 [注册]()， [访问](https://www.cnblogs.com/) 网站首页。

[【推荐】超50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库](http://www.ucancode.com/index.htm)
[【活动】京东云限时优惠1.5折购云主机，最高返价值1000元礼品！](https://www.jdcloud.com/cn/activity/newUser?utm_source=DMT_cnblogs&utm_medium=CH&utm_campaign=09vm&utm_term=Virtual-Machines)
[【推荐】零基础轻松玩转华为云产品，获壕礼加返百元大礼](http://clickc.admaster.com.cn/c/a131574,b3595115,c1705,i0,m101,8a1,8b3,h)
[【推荐】919 天翼云钜惠，全网低价，云主机9元轻松购](https://www.ctyun.cn/activity/#/20190919?hmsr=%E5%8D%9A%E5%AE%A2%E5%9B%AD-0916-919%E6%B4%BB%E5%8A%A8&hmpl=&hmcu=&hmkw=&hmci=)
[【推荐】华为云文字识别资源包重磅上市，1元万次限时抢购](http://clickc.admaster.com.cn/c/a131575,b3595121,c1705,i0,m101,8a1,8b3,h)
[【推荐】腾讯云海外云服务器1核2G19.8元/月](https://cloud.tencent.com/act/pro/overseas?fromSource=gwzcw.2802159.2802159.2802159&utm_medium=cpc&utm_id=gwzcw.2802159.2802159.2802159)
[【福利】git pull && cherry-pick 博客园&华为云百万代金券](https://www.cnblogs.com/cmt/p/11505603.html)
**相关博文：**
· [一致性哈希原理及应用浅析](https://www.cnblogs.com/iwangzheng/p/8807824.html "一致性哈希原理及应用浅析")
· [一致性哈希算法学习及JAVA代码实现分析](https://www.cnblogs.com/hapjin/p/4737207.html "一致性哈希算法学习及JAVA代码实现分析")
· [一致性哈希算法----nginx负载均衡器配置之一](https://www.cnblogs.com/FengGeBlog/p/10615345.html "一致性哈希算法----nginx负载均衡器配置之一")
· [总结一致性哈希(Consistent Hashing)](https://www.cnblogs.com/lidj/p/8065349.html "总结一致性哈希(Consistent Hashing)")
· [一致性哈希算法与Java实现](https://www.cnblogs.com/javaee6/p/3717681.html "一致性哈希算法与Java实现")

**最新 IT 新闻**:
· [三星显示器拟投资110亿美元升级韩国LCD工厂]()
· [前密西西比大学校长Jeffrey加入百度研究院]()
· [一加7T系列官方存储配置曝光：RAM最高支持12GB]()
· [Facebook中国程序员之死：年仅38岁跳楼轻生，浙大EE毕业生]()
· [谷歌“量子霸权”被删论文曝光！Scott Aaronson：只有谷歌实现了量子霸权]()
» [更多新闻...](https://news.cnblogs.com/ "IT 新闻")