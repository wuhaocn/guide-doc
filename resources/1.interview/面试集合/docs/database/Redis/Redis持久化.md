非常感谢《redis 实战》真本书，本文大多内容也参考了书中的内容。非常推荐大家看一下《redis 实战》这本书，感觉书中的很多理论性东西还是很不错的。

为什么本文的名字要加上春夏秋冬又一春，哈哈 ，这是一部韩国的电影，我感觉电影不错，所以就用在文章名字上了，没有什么特别的含义，然后下面的有些配图也是电影相关镜头。

![春夏秋冬又一春](https://user-gold-cdn.xitu.io/2018/6/13/163f97071d71f6de?w=1280&h=720&f=jpeg&s=205252)

**很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。**

Redis 不同于 Memcached 的很重一点就是，**Redis 支持持久化**，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫**快照（snapshotting，RDB）**,另一种方式是**只追加文件（append-only file,AOF）**.这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。

## 快照（snapshotting）持久化

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

![春夏秋冬又一春](https://user-gold-cdn.xitu.io/2018/6/13/163f97568281782a?w=600&h=329&f=jpeg&s=88616)

**快照持久化是 Redis 默认采用的持久化方式**，在 redis.conf 配置文件中默认有此下配置：

```
save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

根据配置，快照将被写入 dbfilename 选项指定的文件里面，并存储在 dir 选项指定的路径上面。如果在新的快照文件创建完毕之前，Redis、系统或者硬件这三者中的任意一个崩溃了，那么 Redis 将丢失最近一次创建快照写入的所有数据。

举个例子：假设 Redis 的上一个快照是 2：35 开始创建的，并且已经创建成功。下午 3：06 时，Redis 又开始创建新的快照，并且在下午 3：08 快照创建完毕之前，有 35 个键进行了更新。如果在下午 3：06 到 3：08 期间，系统发生了崩溃，导致 Redis 无法完成新快照的创建工作，那么 Redis 将丢失下午 2：35 之后写入的所有数据。另一方面，如果系统恰好在新的快照文件创建完毕之后崩溃，那么 Redis 将丢失 35 个键的更新数据。

**创建快照的办法有如下几种：**

- **BGSAVE 命令：** 客户端向 Redis 发送 **BGSAVE 命令** 来创建一个快照。对于支持 BGSAVE 命令的平台来说（基本上所有平台支持，除了 Windows 平台），Redis 会调用 fork 来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。
- **SAVE 命令：** 客户端还可以向 Redis 发送 **SAVE 命令** 来创建一个快照，接到 SAVE 命令的 Redis 服务器在快照创建完毕之前不会再响应任何其他命令。SAVE 命令不常用，我们通常只会在没有足够内存去执行 BGSAVE 命令的情况下，又或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。
- **save 选项：** 如果用户设置了 save 选项（一般会默认设置），比如 **save 60 10000**，那么从 Redis 最近一次创建快照之后开始算起，当“60 秒之内有 10000 次写入”这个条件被满足时，Redis 就会自动触发 BGSAVE 命令。
- **SHUTDOWN 命令：** 当 Redis 通过 SHUTDOWN 命令接收到关闭服务器的请求时，或者接收到标准 TERM 信号时，会执行一个 SAVE 命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在 SAVE 命令执行完毕之后关闭服务器。
- **一个 Redis 服务器连接到另一个 Redis 服务器：** 当一个 Redis 服务器连接到另一个 Redis 服务器，并向对方发送 SYNC 命令来开始一次复制操作的时候，如果主服务器目前没有执行 BGSAVE 操作，或者主服务器并非刚刚执行完 BGSAVE 操作，那么主服务器就会执行 BGSAVE 命令

如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此，快照持久化只适用于即使丢失一部分数据也不会造成一些大问题的应用程序。不能接受这个缺点的话，可以考虑 AOF 持久化。

## **AOF（append-only file）持久化**

与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：

```
appendonly yes
```

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。

![春夏秋冬又一春](https://user-gold-cdn.xitu.io/2018/6/13/163f976818876166?w=400&h=219&f=jpeg&s=91022)

**在 Redis 的配置文件中存在三种同步方式，它们分别是：**

```
appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no      #让操作系统决定何时进行同步
```

**appendfsync always** 可以实现将数据丢失减到最少，不过这种方式需要对硬盘进行大量的写入而且每次只写入一个命令，十分影响 Redis 的速度。另外使用固态硬盘的用户谨慎使用 appendfsync always 选项，因为这会明显降低固态硬盘的使用寿命。

为了兼顾数据和写入性能，用户可以考虑 **appendfsync everysec 选项** ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

**appendfsync no** 选项一般不推荐，这种方案会使 Redis 丢失不定量的数据而且如果用户的硬盘处理写入操作的速度不够的话，那么当缓冲区被等待写入的数据填满时，Redis 的写入操作将被阻塞，这会导致 Redis 的请求速度变慢。

**虽然 AOF 持久化非常灵活地提供了多种不同的选项来满足不同应用程序对数据安全的不同要求，但 AOF 持久化也有缺陷——AOF 文件的体积太大。**

## 重写/压缩 AOF

AOF 虽然在某个角度可以将数据丢失降低到最小而且对性能影响也很小，但是极端的情况下，体积不断增大的 AOF 文件很可能会用完硬盘空间。另外，如果 AOF 体积过大，那么还原操作执行时间就可能会非常长。

为了解决 AOF 体积过大的问题，用户可以向 Redis 发送 **BGREWRITEAOF 命令** ，这个命令会通过移除 AOF 文件中的冗余命令来重写（rewrite）AOF 文件来减小 AOF 文件的体积。BGREWRITEAOF 命令和 BGSAVE 创建快照原理十分相似，所以 AOF 文件重写也需要用到子进程，这样会导致性能问题和内存占用问题，和快照持久化一样。更糟糕的是，如果不加以控制的话，AOF 文件的体积可能会比快照文件大好几倍。

**文件重写流程：**

![文件重写流程](https://user-gold-cdn.xitu.io/2018/6/13/163f97f9bd0eea50?w=380&h=345&f=jpeg&s=14501)
和快照持久化可以通过设置 save 选项来自动执行 BGSAVE 一样，AOF 持久化也可以通过设置

```
auto-aof-rewrite-percentage
```

选项和

```
auto-aof-rewrite-min-size
```

选项自动执行 BGREWRITEAOF 命令。举例：假设用户对 Redis 设置了如下配置选项并且启用了 AOF 持久化。那么当 AOF 文件体积大于 64mb，并且 AOF 的体积比上一次重写之后的体积大了至少一倍（100%）的时候，Redis 将执行 BGREWRITEAOF 命令。

```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

无论是 AOF 持久化还是快照持久化，将数据持久化到硬盘上都是非常有必要的，但除了进行持久化外，用户还必须对持久化得到的文件进行备份（最好是备份到不同的地方），这样才能尽量避免数据丢失事故发生。如果条件允许的话，最好能将快照文件和重新重写的 AOF 文件备份到不同的服务器上面。

随着负载量的上升，或者数据的完整性变得 越来越重要时，用户可能需要使用到复制特性。

## Redis 4.0 对于持久化机制的优化

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。

参考：

《Redis 实战》

[深入学习 Redis（2）：持久化](https://www.cnblogs.com/kismetv/p/9137897.html)
