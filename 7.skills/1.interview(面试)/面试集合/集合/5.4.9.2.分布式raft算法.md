<div class="preview-main">

<p><span style="font-size: 14px;color: rgb(255, 0, 0);">分布式系统</span><span style="font-size: 14px;">在极大提高可用性、容错性的同时，带来了一致性问题（</span><span style="font-size: 14px;color: rgb(255, 0, 0);">CAP理论</span><span style="font-size: 14px;">）。Raft算法能够解决分布式系统环境下的一致性问题。</span></p><p><span style="font-size: 14px;">我们熟悉的</span><span style="font-size: 14px;color: rgb(255, 0, 0);">ETCD</span><span style="font-size: 14px;">注册中心就采用了这个算法；你现在看的这篇</span><span style="font-size: 14px;color: rgb(255, 0, 0);">微信公众号文章</span><span style="font-size: 14px;">，也是保存在基于Raft算法的高可用存储服务器中。</span></p><p><span style="font-size: 14px;">没有耐心看文字，就直接</span><span style="font-size: 14px;color: rgb(255, 0, 0);"><strong>拉到第四章</strong></span><span style="font-size: 14px;">。</span></p><p><strong><span style="font-size: 14px;">一、Raft算法是什么？</span></strong></p><p><span style="font-size: 14px;">过去，Paxos一直是分布式协议的标准，但是Paxos难于理解，更难以实现，Google的分布式锁系统Chubby作为Paxos实现曾经遭遇到很多坑。后来斯坦福大学提出了Raft算法。</span></p><p><span style="font-size: 14px;color: rgb(255, 0, 0);">Raft是</span><span style="font-size: 14px;">用于管理复制日志的</span><span style="font-size: 14px;color: rgb(255, 0, 0);">一致性算法</span><span style="font-size: 14px;">。它的效果相当于(multi-)Paxos，跟Paxos一样高效，但结构与Paxos不同。这使得</span><span style="font-size: 14px;color: rgb(255, 0, 0);">Raft比Paxos更容易理解</span><span style="font-size: 14px;">，也为构建实用系统提供了更好的基础。</span></p><p><span style="font-size: 14px;">下图是斯坦福大学的Diego Ongaro和John Ousterhout在《In Search of an Understandable Consensus Algorithm》一文（提出Raft算法的论文）中，依据Raft学习难度的实验数据绘制的。实验对象是斯坦福大学和加州大学伯克利分校的高年级本科生和研究生。这些<span style="font-size: 14px;color: rgb(255, 38, 0);">天才也觉得Paxos很难</span>。所以对于大多数人看不懂Paxos算法是很正常的，看不懂Raft原理也不奇怪。&nbsp;</span></p><p><img src="http://img.blog.itpub.net/blog/2019/02/27/9d5affe578ed50d5.jpeg?x-oss-process=style/bb"></p><p><strong><span style="font-size: 14px;">二、什么是一致性（Consensus）</span></strong><br></p><p><span style="font-size: 14px;">一致性是分布式系统</span><span style="font-size: 14px;color: rgb(255, 0, 0);">容错</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;color: rgb(255, 0, 0);">基本问题</span><span style="font-size: 14px;">。一致性涉及多个服务器状态（Values）达成一致。 一旦他们就状态做出决定，该决定就是最终决定。 当大多数服务器可用时，典型的一致性算法会取得进展。例如，即使2台服务器发生故障，5台服务器的集群也可以继续运行。 如果更多服务器失败，它们将停止进展（但永远不会返回错误的结果）。</span></p><p><strong><span style="font-size: 14px;">三、Raft算法</span></strong></p><p><span style="font-size: 14px;">论文Raft算法介绍的章节包括6个部分，了解个大概就行，然后</span><span style="font-size: 14px;color: rgb(255, 0, 0);">拉到本文后边</span><span style="font-size: 14px;">，有个可操作的游戏</span><span style="font-size: 14px;color: rgb(255, 0, 0);">辅助理解</span><span style="font-size: 14px;">这个算法。</span></p><p><span style="font-size: 14px;">1、Raft基础知识</span></p><p><span style="font-size: 14px;">Raft集群包含多个服务器，5个服务器是比较典型的，允许系统容忍两个故障。在任何给定时间，每个服务器都处于以下三种状态之一，</span><span style="font-size: 14px;font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">领导者（Leader），追随者（Follower）或候选人（Candidate）。 这几个状态见可以相互转换。</span></p><p><span style="font-size: 14px;color: rgb(255, 0, 0);">Leader</span><span style="font-size: 14px;">：处理所有客户端交互，日志复制等，一般一次只有一个Leader</span></p><p><span style="font-size: 14px;color: rgb(255, 0, 0);">Follower</span><span style="font-size: 14px;">：类似选民，完全被动</span></p><p><span style="font-size: 14px;color: rgb(255, 0, 0);">Candidate</span><span style="font-size: 14px;">：类似Proposer律师，可以被选为一个新的领导人&nbsp;</span></p><p><img src="http://img.blog.itpub.net/blog/2019/02/27/74cce07d126d7342.jpeg?x-oss-process=style/bb"></p><p><span style="font-size: 14px;">2、选举Leader</span><br></p><p><span style="font-size: 14px;">Raft使用</span><span style="font-size: 14px;color: rgb(255, 0, 0);">心跳机制</span><span style="font-size: 14px;">来触发领导者选举。 当服务器启动时，它们以Follower的身份开始。 只要服务器从Leader或Candidate接收到有效的RPC请求，服务器就会保持Follower状态。 Leader向所有Follower发送定期心跳（不带日志条目的AppendEntries RPC）以保持其权限。 如果一个Follower在称为选举超时的一段时间内没有接到任何通信，该Follower认为没有可行的领导者并开始选举新的Leader。</span></p><p><span style="font-size: 14px;">3、日志复制</span></p><p><span style="font-size: 14px;">一旦Leader当选，它就开始为客户请求提供服务。每个客户端请求包含由复制状态机执行的命令。Leader将命令作为新条目附加到其日志，然后并行地向每个其他服务器发出AppendEntries RPC以复制条目。当条目被安全地复制时，Leader将条目应用于其状态机并将该执行的结果返回给客户端。如果Follower崩溃或运行缓慢，或者网络数据包丢失，Leader将无限期地重试AppendEntries RPC（即使它已经响应客户端），直到所有Follower最终存储所有日志条目。（后边游戏中有个<span style="font-size: 14px;color: rgb(255, 38, 0);">request命令</span>菜单，就是<span style="font-size: 14px;color: rgb(255, 38, 0);">模仿客户端请求</span>的）</span></p><p><span style="font-size: 14px;">除了以上3点，文章还重点描述了</span><span style="font-size: 14px;color: rgb(255, 0, 0);">安全</span><span style="font-size: 14px;">、</span><span style="font-size: 14px;color: rgb(255, 0, 0);">Follower和Candidate崩溃</span><span style="font-size: 14px;">、</span><span style="font-size: 14px;color: rgb(255, 0, 0);">时间和可用性</span><span style="font-size: 14px;">三个方面。</span></p><p><strong><span style="font-size: 14px;">四、可视化的Raft算法</span></strong></p><p><span style="font-size: 14px;">github上有一个</span><span style="font-size: 14px;color: rgb(255, 0, 0);"><strong>帮助大家理解算法的页面</strong></span><span style="font-size: 14px;">，地址是https://raft.github.io/raftscope/index.html&nbsp;</span></p><p><span style="font-size: 14px;">建议用电脑浏览器打开，如果在手机微信里打开，需要选择“<span style="font-size: 14px;color: rgb(255, 38, 0);">访问原网页</span>”</span></p><p><span style="font-size: 14px;">我截了一个运行状态的截图，左侧显示五台服务器，右侧显示日志。&nbsp;</span></p><p><img src="http://img.blog.itpub.net/blog/2019/02/27/6137a718a3d5f80b.jpeg?x-oss-process=style/bb"></p><p><span style="font-size: 14px;"><br></span></p><p><span style="font-size: 14px;">在服务器图标上点击</span><span style="font-size: 14px;color: rgb(255, 0, 0);">鼠标右键</span><span style="font-size: 14px;">会出现操作菜单。操作菜单对应服务节点的状态改变，其中request模拟客户端请求服务器集群执行任务，会在右边产生日志。</span></p><p><img src="http://img.blog.itpub.net/blog/2019/02/27/6178ef9b7ef0ebcb.jpeg?x-oss-process=style/bb"></p><p><span style="font-size: 14px;"></span><br></p><p><br></p><p><span style="font-size: 14px;">多操作一会，一定能够理解Raft算法是怎么运行的!</span></p><p><strong><span style="font-size: 14px;">五、总结</span></strong></p><p><span style="font-size: 14px;">Raft算法具备强一致、高可靠、高可用等优点，具体体现在：</span></p><p><span style="font-size: 14px;">强一致性：虽然所有节点的数据并非实时一致，但Raft算法保证Leader节点的数据最全，同时<span style="font-size: 14px;color: rgb(255, 38, 0);">所有请求都由Leader处理</span>，所以在客户端角度看是强一致性的。</span></p><p><span style="font-size: 14px;">高可靠性：Raft算法保证了Committed的日志不会被修改，State Matchine只应用Committed的日志，所以当客户端收到请求成功即代表数据不再改变。Committed日志在大多数节点上冗余存储，<span style="font-size: 14px;color: rgb(255, 38, 0);">少于一半的磁盘故障</span>数据不会丢失。</span></p><p><span style="font-size: 14px;">高可用性：从Raft算法原理可以看出，选举和日志同步都只需要大多数的节点正常互联即可，所以少量节点故障或网络异常不会影响系统的可用性。即使Leader故障，在选举超时到期后，集群自发选举新Leader，无需人工干预，不可用时间极小。但<span style="font-size: 14px;color: rgb(255, 38, 0);">Leader故障时</span>存在重复数据问题，需要<span style="font-size: 14px;color: rgb(255, 38, 0);">业务去重或幂等性</span>保证。</span></p><p><span style="font-size: 14px;">高性能：与必须将数据写到所有节点才能返回客户端成功的算法相比，Raft算法只需要大多数节点成功即可，少量节点处理缓慢不会延缓整体系统运行。&nbsp;</span></p>
<p style="clear:both;"></p>
<p class="translate">
来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/31556438/viewspace-2637112/，如需转载，请注明出处，否则将追究法律责任。
</p>

</div>