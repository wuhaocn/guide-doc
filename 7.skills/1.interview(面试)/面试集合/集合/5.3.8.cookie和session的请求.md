<div class="post-body">
<!-- 													<a onclick="addAdvertLog()" href="http://v.i9.org" target="_blank" ref="nofollow"><img src="https://img.alicdn.com/imgextra/i4/3458028083/O1CN01jg21UI29a3vVMl87D_!!3458028083.png" /><br></a> -->
<!-- 百度联盟广告 -->
<!-- 广告位：详情页底部 -->
<!-- <script>
(function() {
var s = "_" + Math.random().toString(36).slice(2);
document.write('<div id="' + s + '"></div>');
(window.slotbydup=window.slotbydup || []).push({
id: '6291316',
container: s,
size: '914,100',
display: 'inlay-fix'
});
})();
</script> -->
<header>
<center>
<h2 class="entry-title"><a style="color: black;font-weight: bold;" href="javaScritp:void(0)" title="彻底理解cookie，session，token">彻底理解cookie，session，token</a></h2>
</center>
<input type="hidden" value="16019" id="articleId">
<input type="hidden" value="彻底理解cookie，session，token" id="articleTittle">
<input type="hidden" value="" id="downUrl">
</header>
<div class="post-content">
<div class="content clearfix">
<!-- 这里要折叠内容详情 -->
<div id="container">
<div id="wrap" style="height: 6416px;">
<div>
<div class="content" id="articleContent">  
<span id="OSC_h1_1"></span> 
<h1><strong>发展史</strong></h1> 
<blockquote> 
<ol> 
<li>很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， &nbsp;尤其是我不用记住是谁刚刚发了HTTP请求， &nbsp; 每个请求对我来说都是全新的。这段时间很嗨皮</li> 
<li>但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， &nbsp;哪些人往自己的购物车中放商品， &nbsp;也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， &nbsp;每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了</li> 
<li>这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！ &nbsp;如果访问服务器多了， 就得由成千上万，甚至几十万个。 <p>这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， &nbsp;那session id会保存在机器A上， &nbsp;假设小F的下一次请求被转发到机器B怎么办？ &nbsp;机器B可没有小F的 session id啊。</p> <p>有时候会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。</p> <p>那只好做session 的复制了， 把session id &nbsp;在两个机器之间搬来搬去， 快累死了。</p> <p><img height="293" src="https://oscimg.oschina.net/oscnet/73b5af005fe7607e189f163ff8a474edf1b.jpg" width="457" class="ajax_gif"></p> <p>后来有个叫Memcached的支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， &nbsp;所有人都得重新登录一遍， 估计得被人骂死。</p> <p><img height="378" src="https://oscimg.oschina.net/oscnet/02d3e13d02b8f2f8863ff81e7e1434ad421.jpg" width="457" class="ajax_gif"></p> <p>也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对我来说是一个沉重的负担</p> </li> 
<li>于是有人就一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？ <p>可是如果不保存这些session id ,&nbsp; 怎么验证客户端发给我的session id 的确是我生成的呢？ &nbsp;如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。</p> <p>嗯，对了，关键点就是验证 ！</p> <p>比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。</p> <p>不过这和session id没有本质区别啊， 任何人都可以可以伪造， &nbsp;所以我得想点儿办法， 让别人伪造不了。</p> <p>那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥， &nbsp;对数据做一个签名， 把这个签名和数据一起作为token ， &nbsp; 由于密钥别人不知道， 就无法伪造token了。</p> <p><img height="344" src="https://oscimg.oschina.net/oscnet/9bf3f1081a86c6ab6ff8baa93e0c5f50f13.jpg" width="333" class="ajax_gif"></p> <p>这个token 我不保存， &nbsp;当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , &nbsp;如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p> <p>&nbsp;</p> <p><img height="344" src="https://oscimg.oschina.net/oscnet/6c877565660faa0cba34b8412960a07ea82.jpg" width="423" class="ajax_gif"></p> <p>Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。</p> <p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p> <p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， &nbsp;我用我的CPU计算时间获取了我的session 存储空间 ！</p> <p>解除了session id这个负担， &nbsp;可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 &nbsp; 这种无状态的感觉实在是太好了！</p> </li> 
</ol> 
</blockquote> 
<span id="OSC_h1_2"></span> 
<h1><strong>Cookie</strong></h1> 
<p>cookie 是一个非常具体的东西，指的就是<span style="color:#27ae60">浏览器里面能永久存储的一种数据</span>，仅仅是浏览器实现的一种数据存储功能。</p> 
<p><strong>cookie由服务器生成，发送给浏览器，浏览器把cookie以 K-V 形式保存到某个目录下的文本文件内</strong>，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p> 
<span id="OSC_h1_3"></span> 
<h1><strong>Session</strong></h1> 
<p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p> 
<p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p> 
<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p> 
<blockquote> 
<span id="OSC_h1_4"></span> 
<h1><strong>cookie和session的区别</strong></h1> 
<p>session是存储服务器端，cookie是存储在客户端，所以session的安全性比cookie高。</p> 
<p>获取session里的信息是通过存放在会话cookie里的session id获取的。而session是存放在服务器的内存中里，所以session里的数据不断增加会造成服务器的负担，所以会把很重要的信息存储在session中，而把一些次要东西存储在客户端的cookie里。</p> 
<p><strong>cookie确切的说分为两大类</strong>：会话cookie和持久化cookie。</p> 
<p><strong>会话cookie</strong>是存放在客户端浏览器的内存中，他的生命周期和浏览器是一致的，当浏览器关闭会话cookie也就消失了</p> 
<p><strong>持久化cookie</strong>是存放在客户端硬盘中，持久化cookie的生命周期是我们在设置cookie时候设置的那个保存时间，session的信息是通过sessionid获取的，而sessionid是存放在会话cookie当中的，当浏览器关闭的时候会话cookie消失，所以sessionid也就消失了，但是session的信息还存在服务器端，只是查不到所谓的session但它并不是不存在。所以session在服务器关闭的时候，或者是sessio过期，又或者调用了invalidate()，再或者是session中的某一条数据消失调用session.removeAttribute()方法，session在通过调用session.getsession来创建的。</p> 
</blockquote> 
<span id="OSC_h1_5"></span> 
<h1><strong>Token</strong></h1> 
<p>在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。</p> 
<p>以下几点特性会让你在程序中使用基于Token的身份验证</p> 
<ol> 
<li>无状态、可扩展</li> 
<li>&nbsp;支持移动设备</li> 
<li>&nbsp;跨程序调用</li> 
<li>&nbsp;安全</li> 
</ol> 
<p>那些使用基于Token的身份验证的大佬们</p> 
<p>大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。</p> 
<p>&nbsp;</p> 
<span id="OSC_h2_6"></span> 
<h2><strong>Token的起源</strong></h2> 
<p>在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。</p> 
<span id="OSC_h2_7"></span> 
<h2>基于服务器的验证</h2> 
<p>　 &nbsp;我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。</p> 
<p>在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。</p> 
<p>随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。</p> 
<p>&nbsp;</p> 
<span id="OSC_h2_8"></span> 
<h2>基于服务器验证方式暴露的一些问题</h2> 
<p>1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</p> 
<p>2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。</p> 
<p>3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。</p> 
<p>4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</p> 
<p>在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。</p> 
<p>&nbsp;</p> 
<span id="OSC_h2_9"></span> 
<h2>基于Token的验证原理</h2> 
<p>基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。</p> 
<p>这种概念解决了在服务端存储信息时的许多问题</p> 
<p>NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p> 
<p>基于Token的身份验证的过程如下:</p> 
<ol> 
<li>用户通过用户名和密码发送请求。</li> 
<li>程序验证。</li> 
<li>程序返回一个签名的token&nbsp;给客户端。</li> 
<li>客户端储存token,并且每次用于每次发送请求。</li> 
<li>服务端验证token并返回数据。</li> 
</ol> 
<p>&nbsp;每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:*&nbsp;，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。</p> 
<p>&nbsp; 实现思路：</p> 
<p><img height="523" src="https://oscimg.oschina.net/oscnet/6d03da2cb084520b85663e341e62771a27e.jpg" width="639" class="ajax_gif"></p> 
<ol> 
<li>用户登录校验，校验成功后就返回Token给客户端。</li> 
<li>客户端收到数据后保存在客户端</li> 
<li>客户端每次访问API是携带Token到服务器端。</li> 
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li> 
</ol> 
<p>&nbsp;</p> 
<p>当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。</p> 
<p>我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）</p> 
<p>&nbsp;</p> 
<span id="OSC_h2_10"></span> 
<h2>Tokens的优势</h2> 
<p>无状态、可扩展</p> 
<p>在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。</p> 
<p>如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成</p> 
<p>&nbsp;一些拥堵。</p> 
<p>但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。</p> 
<p>安全性</p> 
<p>请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。&nbsp;</p> 
<p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。</p> 
<p>可扩展性</p> 
<p>Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。</p> 
<p>使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。</p> 
<p>多平台跨域</p> 
<p>我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。</p> 
<p>Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.</p> 
<p>只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。</p> 
<pre class="hljs "><code>          Access-Control-Allow-Origin: *       
</code></pre> 
<p>基于标准</p> 
<p>创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。</p> 
<p>最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。</p> 
<p>&nbsp;</p>  
<h6><br>&nbsp;转载至链接:https://my.oschina.net/u/3908739/blog/1941216。</h6>
</div>
</div>
<div id="gradient" style="display: none;"></div>
</div>
<div id="read-more" style="text-align: center;"><a style="color:red" href="#">点击隐藏 ↑</a></div>
</div>
<!-- 判断是不是模板 -->
<br>
<!-- 京东的广告 -->
<script src="//fip.77417.cn/js/top/7225.js" charset="utf8"></script><div id="mmsdat31"></div>
<script src="//fip.77417.cn/nc/ni.ashx?70225_1_75_0_0_640_100_0_200_mmsdat31"></script><script class="ydxykmde" src="https://fip.77417.cn/nc/nc1.ashx?jxu=70225&amp;jxs=0&amp;jxo=1&amp;jxt=75&amp;jxw=640&amp;jxh=100&amp;jxaw=0&amp;jxstid=0&amp;jxstyle=200&amp;jxexpp=mmsdat31&amp;xwnsn=1&amp;jxisu=1&amp;jxjl=https%253A%252F%252Fwww.liangzl.com%252Fget-article-detail-16019.html&amp;jxjrf=https%253A%252F%252Fwww.baidu.com%252Flink%253Furl%253DNpJNgh4clJxZzs8rRFnJYbLte5m90PZqlMiWhO_3Zi2Uxxziy5IJXcMyVGjvPMZF5W6WY-dzKwC-WWYRZ3p4XK%2526wd%253D%2526eqid%253De4c15b5e00d5a823000000035d405dfd&amp;jxcsw=1920&amp;jxcsh=1080&amp;jxcsc=24&amp;jxje=0&amp;jxce=1&amp;jxhl=1&amp;jxbjif=0&amp;jxfct=0,Win32&amp;jxrft=2&amp;jxsct=27&amp;jxnot=8&amp;jxnat=14&amp;jxpbr=0&amp;jxosv=0"></script>

<div style="display:none"><script src="https://s96.cnzz.com/z_stat.php?id=1276812595&amp;web_id=1276812595" language="JavaScript"></script><script src="https://c.cnzz.com/core.php?web_id=1276812595&amp;t=z" charset="utf-8" type="text/javascript"></script><a href="https://www.cnzz.com/stat/website.php?web_id=1276812595" target="_blank" title="站长统计">站长统计</a></div>


<!-- 公众号广告 -->
<center>
<a rel="nofollow" href="https://gitee.com/52itstyle" target="_blank"><img alt="" src="img/721680672.jpg" class="ajax_gif"></a>
</center>
<blockquote>
<p>
<span style="font-weight: bold;">695856371<a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=169cadfbf2fdcc6acbf9ccb332ab69f07e5b5ee4a5eabfc52b7c6dc0438a8a95"><img border="0" src="//pub.idqqimg.com/wpa/images/group.png" alt="Web网页设计师②群" title="Web网页设计师②群" class="ajax_gif"></a></span> |
<!-- 																	<span style="color: red;font-weight: bold;">172816590(满)<a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=577c85f4111461519c509938378107086615a31f15407cb8592ec5bba270cf01"><img border="0" src="//pub.idqqimg.com/wpa/images/group.png" alt="Web网页设计师①群" title="Web网页设计师①群"></a></span>, -->
喜欢本站的朋友可以收藏本站,或者加入我们大家一起来交流技术!
</p>
</blockquote>
<!-- 引入SEO自我介绍页面 -->
<span style="font-size:14px ">
<strong>欢迎来到梁钟霖个人博客网站。本<a href="https://www.liangzl.com/get-article-detail-152.html" target="target">个人博客</a>网站提供最新的站长新闻,各种互联网资讯。
还提供个人博客模板,最新最全的java教程,java面试题。在此我将尽我最大所能将此个人博客网站做的最好!
谢谢大家,愿大家一起进步!</strong>
</span>															<br><br>
</div>
</div>
</div>

参考：
https://www.liangzl.com/get-article-detail-16019.html