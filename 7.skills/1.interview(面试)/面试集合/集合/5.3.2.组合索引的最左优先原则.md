/#/# 组合索引的最左优先原则

# [组合索引的最左优先原则](https://www.cnblogs.com/CKhomepage/p/10613618.html)

MySQL数据库，game_order表表结构如下，下面哪些sql能使用到索引？

![](https://img2018.cnblogs.com/blog/1634165/201903/1634165-20190328103958526-580710965.png)
这道题目考察的知识点是MySQL组合索引（复合索引）的最左优先原则。

**最左前缀匹配原则**

在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到，示例：
对列col1、列col2和列col3建一个联合索引：

KEY

test_col1_col2_col3

on

test(col1,col2,col3);

联合索引
test_col1_col2_col3
实际建立了
(col1)、(col1,col2)、(col,col2,col3)
三个索引。

上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。

**注意**

索引的字段可以是任意顺序的，如：
SELECT

/*

FROM

test

WHERE

col1=“1”

AND

clo2=“2”

SELECT

/*

FROM

test

WHERE

col2=“2”

AND

clo1=“1”

这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。

所以题目会创建三个索引（plat_order_id）、（plat_order_id与plat_game_id的组合索引）、（plat_order_id、plat_game_id与plat_id的组合索引）。根据最左匹配原则，where语句必须要有plat_order_id才能调用索引（如果没有plat_order_id字段那么一个索引也调用不到），如果同时出现plat_order_id与plat_game_id则会调用两者的组合索引，如果同时出现三者则调用三者的组合索引。

**思考**

对于联合索引(col1,col2,col3)，查询语句
SELECT /* FROM test WHERE col2=2;
是否能够触发索引？
EXPLAIN

SELECT

/*

FROM

test

WHERE

col2=2;

EXPLAIN

SELECT

/*

FROM

test

WHERE

col1=1;
借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划，观察explain中上述两个sql语句结果的type字段。查询中分别是：

* type: index
* type: ref

index：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个联合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。
ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。

**为什么要使用联合索引**

**减少开销。**建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！

**覆盖索引。**对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。

**效率高。**索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% /*10%=1w，效率提升可想而知！

分类: [MySQL之sql语句](https://www.cnblogs.com/CKhomepage/category/1430769.html)

[好文要顶]() [关注我]() [收藏该文]() [![]()]( "分享至新浪微博") [![]()]( "分享至微信")

[![]()](https://home.cnblogs.com/u/CKhomepage/)

[小六boss](https://home.cnblogs.com/u/CKhomepage/)
[关注 - 1](https://home.cnblogs.com/u/CKhomepage/followees)
[粉丝 - 0](https://home.cnblogs.com/u/CKhomepage/followers)

[+加关注]()
0

0
[«](https://www.cnblogs.com/CKhomepage/p/10613158.html) 上一篇：[Java基础之二维数组的创建与访问](https://www.cnblogs.com/CKhomepage/p/10613158.html "发布于2019-03-28 10:18")
[»](https://www.cnblogs.com/CKhomepage/p/10613742.html) 下一篇：[父类引用指向子类对象](https://www.cnblogs.com/CKhomepage/p/10613742.html "发布于2019-03-28 11:20")

posted @ 2019-03-28 11:05 [小六boss](https://www.cnblogs.com/CKhomepage/) 阅读(194) 评论(0) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=10613618) [收藏]()