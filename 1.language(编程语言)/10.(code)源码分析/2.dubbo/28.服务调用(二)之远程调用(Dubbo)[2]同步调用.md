# æœåŠ¡è°ƒç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆDubboï¼‰ã€2ã€‘åŒæ­¥è°ƒç”¨

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡åˆ†äº«

dubbo://
åè®®çš„è¿œç¨‹è°ƒç”¨çš„**ç¬¬äºŒéƒ¨åˆ†ï¼šåŒæ­¥è°ƒç”¨**ã€‚

åœ¨

dubbo://
åè®®çš„è°ƒç”¨ï¼Œä¸€å…±åˆ†æˆä¸‰ç§ï¼š

1. sync åŒæ­¥è°ƒç”¨
1. async å¼‚æ­¥è°ƒç”¨
1. oneway å•å‘è°ƒç”¨

å‰ä¸¤ç§æ¯”è¾ƒå¥½ç†è§£ï¼Œéƒ½æ˜¯åŸºäº Request Response æ¨¡å‹ï¼Œå·®å¼‚ç‚¹åœ¨å¼‚æ­¥è°ƒç”¨ï¼ŒæœåŠ¡æ¶ˆè´¹è€…**ä¸é˜»å¡**ç­‰å¾…ç»“æœï¼Œè€Œæ˜¯é€šè¿‡**å›è°ƒ**çš„æ–¹å¼ï¼Œå¤„ç†æœåŠ¡æä¾›è€…è¿”å›çš„ç»“æœã€‚
æœ€åä¸€ç§ï¼ŒåŸºäº Message æ¨¡å‹ï¼Œå‘èµ·è°ƒç”¨ï¼Œè€Œä¸å…³æ³¨ç­‰å¾…å’Œå…³æ³¨æ‰§è¡Œç»“æœã€‚
å› æ­¤ï¼Œä»æ€§èƒ½ä¸Šï¼šoneway > async > sync ã€‚
å‹æƒ…æç¤ºï¼šæœ¬æ–‡ä¼šåˆ†äº« sync å’Œ oneway ä¸¤ç§æ–¹å¼ã€‚

# 2. é¡ºåºå›¾

* æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡çš„é¡ºåºå›¾ï¼š![é¡ºåºå›¾](http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_01.jpeg)

* æ­¤å›¾æ˜¯åœ¨

injvm://
åè®®çš„é¡ºåºå›¾çš„åŸºç¡€ä¸Šä¿®æ”¹ï¼š

* å°† InjvmInvoker æ›¿æ¢æˆ DubboInvoker ã€‚
* åœ¨

/#doInvoker()
æ–¹æ³•ä¸­ï¼ŒDubboInvoker ä¼šè°ƒç”¨ Client ï¼Œå‘æœåŠ¡æä¾›è€…å‘èµ·è¯·æ±‚ã€‚
* å¯èƒ½ä¼šæœ‰èƒ–å‹é—®ï¼Œ**é›†ç¾¤å®¹é”™**å‘¢ï¼Ÿåœ¨ InvokerInvocationHandler ä¹‹åï¼ŒProtocolFilterWrapper$Invoker ä¹‹å‰ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![é›†ç¾¤å®¹é”™](http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_02.png)

* ğŸ™‚ æˆ‘ä»¬åé¢ä¸“é—¨å†™å‡ ç¯‡æ–‡ç« ï¼Œä¸“é—¨åˆ†äº«é›†ç¾¤å®¹é”™ï¼Œæ‰€ä»¥æœ¬æ–‡ç•¥è¿‡ã€‚
* æä¾›è€…æä¾›æœåŠ¡çš„é¡ºåºå›¾ï¼š![é¡ºåºå›¾](http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_03.jpeg)

* æ­¤å›¾æ˜¯åœ¨

injvm://
åè®®çš„é¡ºåºå›¾çš„åŸºç¡€ä¸Šä¿®æ”¹ï¼š

* InjvmInvoker æ›¿æ¢æˆ ExchangeServer ã€‚ä¾‹å¦‚åœ¨ Netty4 ä¸­ï¼ŒIO Worker è§£æè¯·æ±‚ï¼Œè½¬å‘ç»™ ExchangeHandler å¤„ç†ã€‚
* InjvmProtocol æ›¿æ¢æˆ DubboProtocol ã€‚åœ¨è¯¥ç±»ä¸­ï¼Œå®ç°äº†è‡ªå®šä¹‰çš„ ExchangeHandler å¤„ç†è¯·æ±‚ã€‚**æ³¨æ„**ï¼Œåœ¨ **Dubbo ThreadPool** ä¸­å¤„ç†è¯·æ±‚ï¼Œå‚è§ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” çº¿ç¨‹æ¨¡å‹ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html) æ–‡æ¡£ã€‚

# 3. æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡

è°ƒç”¨

DubboInvoker/#invoke(Invocation)
æ–¹æ³•ï¼Œè°ƒç”¨æœåŠ¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* ä½¿ç”¨çš„ {@link /#clients} çš„ä½ç½®
/*/
private final AtomicPositiveInteger index = new AtomicPositiveInteger();
1: @Override
2: protected Result doInvoke(final Invocation invocation){
3: RpcInvocation inv = (RpcInvocation) invocation;
4: // è·å¾—æ–¹æ³•å
5: final String methodName = RpcUtils.getMethodName(invocation);
6: // è·å¾— `path`( æœåŠ¡å )ï¼Œ`version`
7: inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());
8: inv.setAttachment(Constants.VERSION_KEY, version);
9:
10: // è·å¾— ExchangeClient å¯¹è±¡
11: ExchangeClient currentClient;
12: if (clients.length == 1) {
13: currentClient = clients[0];
14: } else {
15: currentClient = clients[index.getAndIncrement() % clients.length];
16: }
17: // è¿œç¨‹è°ƒç”¨
18: try {
19: // è·å¾—æ˜¯å¦å¼‚æ­¥è°ƒç”¨
20: boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);
21: // è·å¾—æ˜¯å¦å•å‘è°ƒç”¨
22: boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
23: // è·å¾—è¶…æ—¶æ—¶é—´
24: int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
25: // å•å‘è°ƒç”¨
26: if (isOneway) {
27: boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);
28: currentClient.send(inv, isSent);
29: RpcContext.getContext().setFuture(null);
30: return new RpcResult();
31: // å¼‚æ­¥è°ƒç”¨
32: } else if (isAsync) {
33: ResponseFuture future = currentClient.request(inv, timeout);
34: RpcContext.getContext().setFuture(new FutureAdapter<Object>(future));
35: return new RpcResult();
36: // åŒæ­¥è°ƒç”¨
37: } else {
38: RpcContext.getContext().setFuture(null);
39: return (Result) currentClient.request(inv, timeout).get();
40: }
41: } catch (TimeoutException e) {
42: throw new RpcException(RpcException.TIMEOUT_EXCEPTION, "Invoke remote method timeout. method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
43: } catch (RemotingException e) {
44: throw new RpcException(RpcException.NETWORK_EXCEPTION, "Failed to invoke remote method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
45: }
46: }
```

* ç¬¬ 5 è¡Œï¼šè°ƒç”¨

RpcUtils/#getMethodName()
æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•åã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public static String getMethodName(Invocation invocation){
// æ³›åŒ–è°ƒç”¨ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ–¹æ³•å
if (Constants.$INVOKE.equals(invocation.getMethodName())
&& invocation.getArguments() != null
&& invocation.getArguments().length > 0
&& invocation.getArguments()[0] instanceof String) {
return (String) invocation.getArguments()[0];
}
// æ™®é€šè°ƒç”¨ï¼Œç›´æ¥è·å¾—
return invocation.getMethodName();
}
```
* ç¬¬ 6 è‡³ 8 è¡Œï¼šè·å¾—

path
( æœåŠ¡å )ã€

version
ã€‚
* ç¬¬ 10 è‡³ 16 è¡Œï¼š**é¡ºåº**ï¼Œè·å¾— ExchangeClient å¯¹è±¡ã€‚
* ç¬¬ 20 è¡Œï¼šè°ƒç”¨

RpcUtils/#isAsync(url, invocation)
æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public static boolean isAsync(URL url, Invocation inv){
return Boolean.TRUE.toString().equals(inv.getAttachment(Constants.ASYNC_KEY)) // RpcContext/#asyncCall(Callable) æ–¹æ³•ï¼Œå¯ä»¥è®¾ç½®
|| url.getMethodParameter(getMethodName(inv), Constants.ASYNC_KEY, false);
}
```

* è·å¾—æ˜¯å¦å¼‚æ­¥ã€‚æœåŠ¡å¼•ç”¨æˆ–æ–¹æ³•ï¼Œä»»ä¸€é…ç½®

async = true
ï¼Œå³ä¸ºå¼‚æ­¥ã€‚
* ç¬¬ 22 è¡Œï¼šè°ƒç”¨

RpcUtils/#isOneway(url, invocation)
æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public static boolean isOneway(URL url, Invocation inv){
return Boolean.FALSE.toString().equals(inv.getAttachment(Constants.RETURN_KEY)) // RpcContext/#asyncCall(Runnable) æ–¹æ³•ï¼Œå¯ä»¥è®¾ç½®
|| !url.getMethodParameter(getMethodName(inv), Constants.RETURN_KEY, true);
}
```

* è·å¾—æ˜¯å¦å•å‘ã€‚æ–¹æ³•é…ç½®

return = true
ï¼Œå³ä¸ºå•å‘ã€‚
* ç¬¬ 24 è¡Œï¼šè°ƒç”¨

URL/#getMethodParameter(method, key, defaultValue)
æ–¹æ³•ï¼Œè·å¾—è¿œç¨‹è°ƒç”¨è¶…æ—¶æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚
* ç¬¬ 25 è‡³ 30 è¡Œï¼šoneway å•å‘è°ƒç”¨ã€‚

* ç¬¬ 28 è¡Œï¼š**æ³¨æ„**ï¼Œè°ƒç”¨çš„æ˜¯

ExchangeClient/#send(invocation, sent)
æ–¹æ³•ï¼Œå‘é€**æ¶ˆæ¯**ï¼Œè€Œä¸æ˜¯**è¯·æ±‚**ã€‚
* ç¬¬ 29 è¡Œï¼šè®¾ç½®

RpcContext.future = null
ï¼Œæ— éœ€ FutureFilter ï¼Œå¼‚æ­¥å›è°ƒã€‚
* ç¬¬ 30 è¡Œï¼šåˆ›å»º RpcResult å¯¹è±¡ï¼Œ**ç©ºè¿”å›**ã€‚
* ç¬¬ 31 è‡³ 35 è¡Œï¼šasync å¼‚æ­¥è°ƒç”¨ã€‚

* ç¬¬ 33 è¡Œï¼šè°ƒç”¨

ExchangeClient/#request(invocation, timeout)
æ–¹æ³•ï¼Œå‘é€**è¯·æ±‚**ã€‚
* ç¬¬ 34 è¡Œï¼šè°ƒç”¨

RpcContext/#setFuture(future)
æ–¹æ³•ï¼Œåœ¨ FutureFitler ä¸­ï¼Œå¼‚æ­¥å›è°ƒã€‚
* ç¬¬ 35 è¡Œï¼šåˆ›å»º RpcResult å¯¹è±¡ï¼Œ**ç©ºè¿”å›**ã€‚
* ç¬¬ 36 è‡³ 40 è¡Œï¼šsync åŒæ­¥è°ƒç”¨ã€‚

* ç¬¬ 38 è¡Œï¼šè®¾ç½®

RpcContext.future = null
ï¼Œæ— éœ€ FutureFilter ï¼Œå¼‚æ­¥å›è°ƒã€‚
* ç¬¬ 39 è¡Œï¼šè°ƒç”¨

ExchangeClient/#request(invocation, timeout)
æ–¹æ³•ï¼Œå‘é€**è¯·æ±‚**ã€‚
* ç¬¬ 39 è¡Œï¼šè°ƒç”¨

ResponseFuture/#get()
æ–¹æ³•ï¼Œ**é˜»å¡**ç­‰å¾…ï¼Œè¿”å›ç»“æœã€‚

# 4. æä¾›è€…æä¾›æœåŠ¡

åœ¨ DubboProtocol ç±»ä¸­ï¼Œå®ç°äº†è‡ªå·±çš„ ExchangeHandler å¯¹è±¡ï¼Œå¤„ç†è¯·æ±‚ã€æ¶ˆæ¯ã€è¿æ¥ã€æ–­å¼€è¿æ¥ç­‰äº‹ä»¶ã€‚å¯¹äºæœåŠ¡æ¶ˆè´¹è€…çš„è¿œç¨‹è°ƒç”¨ï¼Œé€šè¿‡

/#reply(ExchangeChannel channel, Object message)
å’Œ

/#reply(Channel channel, Object message)
æ–¹æ³•æ¥å¤„ç†ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š![ExchangeHandler](http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_04.png)

ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹æ¯ä¸ªæ–¹æ³•çš„å®ç°ä»£ç ã€‚

## 4.1 reply

```
1: @Override
2: public Object reply(ExchangeChannel channel, Object message) throws RemotingException{
3: if (message instanceof Invocation) {
4: Invocation inv = (Invocation) message;
5: // è·å¾—è¯·æ±‚å¯¹åº”çš„ Invoker å¯¹è±¡
6: Invoker<?> invoker = getInvoker(channel, inv);
7: // å¦‚æœæ˜¯callback éœ€è¦å¤„ç†é«˜ç‰ˆæœ¬è°ƒç”¨ä½ç‰ˆæœ¬çš„é—®é¢˜
8: // need to consider backward-compatibility if it's a callback
9: if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
10: String methodsStr = invoker.getUrl().getParameters().get("methods");
11: boolean hasMethod = false;
12: if (methodsStr == null || !methodsStr.contains(",")) {
13: hasMethod = inv.getMethodName().equals(methodsStr);
14: } else {
15: String[] methods = methodsStr.split(",");
16: for (String method : methods) {
17: if (inv.getMethodName().equals(method)) {
18: hasMethod = true;
19: break;
20: }
21: }
22: }
23: if (!hasMethod) {
24: logger.warn(new IllegalStateException("The methodName " + inv.getMethodName() + " not found in callback service interface ,invoke will be ignored. please update the api interface. url is:" + invoker.getUrl()) + " ,invocation is :" + inv);
25: return null;
26: }
27: }
28: // è®¾ç½®è°ƒç”¨æ–¹çš„åœ°å€
29: RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
30: // æ‰§è¡Œè°ƒç”¨
31: return invoker.invoke(inv);
32: }
33: throw new RemotingException(channel, message.getClass().getName() + ": " + message
34: + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress());
35: }
```

* ç”¨äºå¤„ç†æœåŠ¡æ¶ˆè´¹è€…çš„åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨çš„è¯·æ±‚ã€‚
* ç¬¬ 6 è¡Œï¼šè°ƒç”¨

/#getInvoker(channel, invocation)
æ–¹æ³•ï¼Œè·å¾—è¯·æ±‚å¯¹åº”çš„ Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* Exporter é›†åˆ
/*
/* key: æœåŠ¡é”® {@link /#serviceKey(URL)} æˆ– {@link URL/#getServiceKey()} ã€‚
/* ä¸åŒåè®®ä¼šä¸åŒ
/*/
protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>(); // FROM çˆ¶ç±» AbstractProtocol.java
1: Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException {
2: boolean isCallBackServiceInvoke;
3: boolean isStubServiceInvoke;
4: int port = channel.getLocalAddress().getPort();
5: String path = inv.getAttachments().get(Constants.PATH_KEY);
6: // TODO ã€8033 å‚æ•°å›è°ƒã€‘
7: // if it's callback service on client side
8: isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));
9: if (isStubServiceInvoke) {
10: port = channel.getRemoteAddress().getPort();
11: }
12: // å¦‚æœæ˜¯å‚æ•°å›è°ƒï¼Œè·å¾—çœŸæ­£çš„æœåŠ¡å `path` ã€‚
13: // callback
14: isCallBackServiceInvoke = isClientSide(channel) && !isStubServiceInvoke;
15: if (isCallBackServiceInvoke) {
16: path = inv.getAttachments().get(Constants.PATH_KEY) + "." + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);
17: inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());
18: }
19: // è·å¾—æœåŠ¡å»º
20: String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));
21: // è·å¾— Exporter å¯¹è±¡
22: DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);
23: // è·å¾— Invoker å¯¹è±¡
24: if (exporter == null) {
25: throw new RemotingException(channel, "Not found exported service: " + serviceKey + " in " + exporterMap.keySet() + ", may be version or group mismatch " + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress() + ", message:" + inv);
26: }
27: return exporter.getInvoker();
28: }
```

* ç¬¬ 6 è‡³ 11 è¡Œï¼šTODO ã€8033 å‚æ•°å›è°ƒã€‘
* ç¬¬ 12 è‡³ 18 è¡Œï¼šå¦‚æœæ˜¯å‚æ•°å›è°ƒï¼Œè·å¾—çœŸæ­£çš„æœåŠ¡å

path
ã€‚åœ¨**å‚æ•°å›è°ƒ**ä¸€æ–‡ä¸­ï¼Œæˆ‘ä»¬è¯¦ç»†è§£æã€‚
* ç¬¬ 20 è¡Œï¼šè°ƒç”¨

/#serviceKey(port, path, version)
æ–¹æ³•ï¼Œè·å¾—æœåŠ¡é”®ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup){
return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);
}
```
* ç¬¬ 22 è¡Œï¼šä»

exporterMap
é›†åˆä¸­ï¼Œè·å¾— Exporter å¯¹è±¡ã€‚
* ç¬¬ 23 è‡³ 27 è¡Œï¼šè·å¾— Invoker å¯¹è±¡ã€‚
* ç¬¬ 8 è‡³ 27 è¡Œï¼šå¦‚æœæ˜¯**å‚æ•°å›è°ƒ**ï¼Œæ ¡éªŒæœåŠ¡æ¶ˆè´¹è€…å®é™…å­˜åœ¨å¯¹åº”çš„å›è°ƒæ–¹æ³•ï¼Œé€šè¿‡æ–¹æ³•ååˆ¤æ–­ã€‚
* ç¬¬ 29 è¡Œï¼šè®¾ç½®è°ƒç”¨æ–¹çš„åœ°å€ã€‚
* ç¬¬ 31 è¡Œï¼šè°ƒç”¨

Invoker/#invoke(invocation)
æ–¹æ³•ï¼Œæ‰§è¡Œè°ƒç”¨ï¼Œå¹¶è¿”å›ç»“æœã€‚åç»­çš„é€»è¾‘ï¼Œå’Œ

injvm://
åè®®æ˜¯ä¸€è‡´çš„ã€‚

## 4.2 received

```
@Override
public void received(Channel channel, Object message) throws RemotingException{
if (message instanceof Invocation) {
this.reply((ExchangeChannel) channel, message);
} else {
super.received(channel, message);
}
}
```

* ç”¨äºå¤„ç†æœåŠ¡æ¶ˆè´¹è€…çš„**å•æ¬¡è°ƒç”¨**çš„æ¶ˆæ¯ï¼Œé€šè¿‡åˆ¤æ–­æ¶ˆæ¯ç±»å‹æ˜¯ä¸æ˜¯ Invocation ã€‚

## 4.3 connected && disconnected

æœ¬å°èŠ‚å’Œ Dubbo RPC æ— å…³ç³»ï¼Œåªæ˜¯ä¸ºäº†å®Œæ•´åˆ†äº« DubboProtocol ExchangeHandler çš„å®Œæ•´ä»£ç å®ç°ã€‚

åœ¨æœåŠ¡æä¾›è€…ä¸Šï¼Œæœ‰

"onconnect"
å’Œ

"ondisconnect"
é…ç½®é¡¹ï¼Œåœ¨æœåŠ¡æä¾›è€…è¿æ¥æˆ–æ–­å¼€è¿æ¥æ—¶ï¼Œè°ƒç”¨ Service å¯¹åº”çš„æ–¹æ³•ã€‚ç›®å‰è¿™ä¸ªé…ç½®é¡¹ï¼Œåœ¨ Dubbo æ–‡æ¡£é‡Œï¼Œæš‚æœªæåŠã€‚å½“ç„¶ï¼Œè¿™ä¸ªåœ¨å®é™…åœºæ™¯ä¸‹ï¼ŒåŸºæœ¬æ²¡ç”¨è¿‡ã€‚

```
@Override
public void connected(Channel channel){
this.invoke(channel, Constants.ON_CONNECT_KEY);
}
@Override
public void disconnected(Channel channel) throws RemotingException{
if (logger.isInfoEnabled()) {
logger.info("disconected from " + channel.getRemoteAddress() + ",url:" + channel.getUrl());
}
this.invoke(channel, Constants.ON_DISCONNECT_KEY);
}
```

* è°ƒç”¨

/#invoke(channel, methodKey)
æ–¹æ³•ï¼Œæ‰§è¡Œå¯¹åº”çš„æ–¹æ³•ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* è°ƒç”¨æ–¹æ³•
/*
/* @param channel é€šé“
/* @param methodKey æ–¹æ³•å
/*/
private void invoke(Channel channel, String methodKey){
// åˆ›å»º Invocation å¯¹è±¡
Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);
// è°ƒç”¨ received æ–¹æ³•ï¼Œæ‰§è¡Œå¯¹åº”çš„æ–¹æ³•
if (invocation != null) {
try {
this.received(channel, invocation);
} catch (Throwable t) {
logger.warn("Failed to invoke event method " + invocation.getMethodName() + "(), cause: " + t.getMessage(), t);
}
}
}
private Invocation createInvocation(Channel channel, URL url, String methodKey){
String method = url.getParameter(methodKey);
if (method == null || method.length() == 0) {
return null;
}
RpcInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);
invocation.setAttachment(Constants.PATH_KEY, url.getPath());
invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));
invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));
invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));
if (url.getParameter(Constants.STUB_EVENT_KEY, false)) {
invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());
}
return invocation;
}
```