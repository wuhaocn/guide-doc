# é›†ç¾¤å®¹é”™ï¼ˆä¸‰ï¼‰ä¹‹ Directory å®ç°

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆäºŒï¼‰ä¹‹ Cluster å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-2-impl-cluster/?self) ä¸€æ–‡ï¼Œåˆ†äº«

dubbo-cluster
æ¨¡å—ï¼Œ

directory
åŒ…ï¼Œ**å„ç§ Directory å®ç°ç±»**ã€‚

Directory ï¼Œä¸­æ–‡ç›´è¯‘ä¸º**ç›®å½•**ï¼Œä»£è¡¨äº†**å¤šä¸ª** Invoker ï¼Œå¯ä»¥æŠŠå®ƒçœ‹æˆ

List<Invoker>
ã€‚ä½†ä¸ List ä¸åŒçš„æ˜¯ï¼Œå®ƒçš„å€¼å¯èƒ½æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œæ¯”å¦‚æ³¨å†Œä¸­å¿ƒæ¨é€å˜æ›´ã€‚

Directory å­ç±»å¦‚ä¸‹å›¾ï¼š

![Directory å­ç±»](http://static2.iocoder.cn/images/Dubbo/2019_04_10/01.png)

æˆ‘ä»¬çœ‹åˆ°æœ‰ä¸¤ä¸ªå®ç°ç±»ï¼š

* StaticDirectory ï¼Œ**é™æ€** Directory å®ç°ç±»ï¼Œä»å‘½åä¸Šçœ‹å‡ºå®ƒæ˜¯**é™æ€**çš„

List<Invoker>
ã€‚
* RegistryDirectory ï¼ŒåŸºäº**æ³¨å†Œä¸­å¿ƒ**çš„**åŠ¨æ€** Directory å®ç°ç±»ï¼Œä»å‘½åä¸Šçœ‹å‡ºå®ƒæ˜¯**åŠ¨æ€**çš„ï¼Œä¼šæ ¹æ®æ³¨å†Œä¸­å¿ƒçš„æ¨é€å˜æ›´

List<Invoker>
ã€‚

# 2. Directory

com.alibaba.dubbo.rpc.cluster.Directory
ï¼Œç»§æ‰¿ Node æ¥å£ï¼ŒDirectory æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public interface Directory<T> extends Node{
//*/*
/* get service type.
/*
/* è·å¾—æœåŠ¡ç±»å‹ï¼Œä¾‹å¦‚ï¼šcom.alibaba.dubbo.demo.DemoService
/*
/* @return service type.
/*/
Class<T> getInterface();
//*/*
/* list invokers.
/*
/* è·å¾—æ‰€æœ‰æœåŠ¡ Invoker é›†åˆ
/*
/* @return invokers
/*/
List<Invoker<T>> list(Invocation invocation) throws RpcException;
}
```

* å®šä¹‰äº†**ä¸¤ä¸ª**æ¥å£æ–¹æ³•ï¼Œåˆ†åˆ«è¿”å›æœåŠ¡çš„**ç±»å‹**å’Œ **Invoker é›†åˆ**ã€‚
* ä¸€ä¸ª Directory **åªå¯¹åº”**ä¸€ä¸ªæœåŠ¡ç±»å‹ã€‚

# 3. AbstractDirectory

com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory
ï¼Œå®ç° Directory æ¥å£ï¼ŒDirectory æŠ½è±¡å®ç°ç±»ï¼Œå®ç°äº†å…¬ç”¨çš„**è·¯ç”±è§„åˆ™( Router )**çš„é€»è¾‘ã€‚

## 3.1 æ„é€ æ–¹æ³•

```
//*/*
/* æ˜¯å¦å·²ç»é”€æ¯
/*/
private volatile boolean destroyed = false;
//*/*
/* æ³¨å†Œä¸­å¿ƒ URL
/*/
private final URL url;
//*/*
/* æ¶ˆè´¹è€… URL
/*
/* è‹¥æœªæ˜¾ç¤ºè°ƒç”¨ {@link /#AbstractDirectory(URL, URL, List)} æ„é€ æ–¹æ³•ï¼ŒconsumerUrl ç­‰äº {@link /#url}
/*/
private volatile URL consumerUrl;
//*/*
/* Router æ•°ç»„
/*/
private volatile List<Router> routers;
public AbstractDirectory(URL url){
this(url, null);
}
public AbstractDirectory(URL url, List<Router> routers){
this(url, url, routers);
}
public AbstractDirectory(URL url, URL consumerUrl, List<Router> routers){
if (url == null) {
throw new IllegalArgumentException("url == null");
}
this.url = url;
this.consumerUrl = consumerUrl;
// è®¾ç½® Router æ•°ç»„
setRouters(routers);
}
```

* consumerUrl
å­—æ®µï¼Œè®¤çœŸçœ‹ä¸‹æ³¨é‡Šå’Œæ„é€ æ–¹æ³•ã€‚
* è°ƒç”¨

/#setRouters(routers)
æ–¹æ³•ï¼Œåˆå§‹åŒ–å¹¶è®¾ç½® Router æ•°ç»„ã€‚

## 3.2 setRouters

/#setRouters(routers)
æ–¹æ³•ï¼Œåˆå§‹åŒ–å¹¶è®¾ç½® Router æ•°ç»„ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router?self) ä¸­ã€‚

## 3.3 list

/#list(Invocation)
**å®ç°**æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰æœåŠ¡ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: @Override
2: public List<Invoker<T>> list(Invocation invocation) throws RpcException {
3: if (destroyed) {
4: throw new RpcException("Directory already destroyed .url: " + getUrl());
5: }
6: // è·å¾—æ‰€æœ‰ Invoker é›†åˆ
7: List<Invoker<T>> invokers = doList(invocation);
8: // æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰ Invoker é›†åˆ
9: List<Router> localRouters = this.routers; // local reference æœ¬åœ°å¼•ç”¨ï¼Œé¿å…å¹¶å‘é—®é¢˜
10: if (localRouters != null && !localRouters.isEmpty()) {
11: for (Router router : localRouters) {
12: try {
13: if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {
14: invokers = router.route(invokers, getConsumerUrl(), invocation);
15: }
16: } catch (Throwable t) {
17: logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
18: }
19: }
20: }
21: return invokers;
22: }
```

* ç¬¬ 7 è¡Œï¼šè°ƒç”¨

/#doList(invocation)
**æŠ½è±¡**æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;
```
* ç¬¬ 9 è‡³ 20 è¡Œï¼šæ ¹æ®**è·¯ç”±è§„åˆ™( Router )**ï¼Œè¿›ä¸€æ­¥ç­›é€‰åˆé€‚çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚

# 4. RegistryDirectory

com.alibaba.dubbo.registry.integration.RegistryDirectory
ï¼Œå®ç° NotifyListener æ¥å£ï¼Œå®ç° AbstractDirectory æŠ½è±¡ç±»ï¼ŒåŸºäº**æ³¨å†Œä¸­å¿ƒ**çš„ Directory å®ç°ç±»ã€‚

1. RegistryDirectory åœ¨

dubbo-registry
æ¨¡å—ï¼Œ

integration
åŒ…ä¸‹ï¼Œæ˜¯ Dubbo æ³¨å†Œä¸­å¿ƒæ¨¡å—é›†æˆ Directory çš„å®ç°ç±»ã€‚
1. RegistryDirectory ä½œä¸ºä¸€ä¸ª NotifyListener ï¼Œ**è®¢é˜…**æ³¨å†Œä¸­å¿ƒ( Registry ) çš„æ•°æ®ï¼Œå®ç°å¯¹å˜æ›´çš„**ç›‘å¬**ã€‚

## 4.1 æ„é€ æ–¹æ³•

RegistryDirectory çš„å­—æ®µæœ‰ **17** ä¸ªï¼Œæ¯”è¾ƒå¤šï¼Œæ‰€ä»¥èƒ–å‹è¯·è€å¿ƒã€‚
  ```
// ========== Dubbo SPI Adaptive å¯¹è±¡ BEGIN ==========
//*/*
/* Cluster$Adaptive å¯¹è±¡
/*/
private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();
//*/*
/* RouterFactory$Adaptive å¯¹è±¡
/*/
private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension();
//*/*
/* ConfiguratorFactory$Adaptive å¯¹è±¡
/*/
private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();
// ========== æœåŠ¡æ¶ˆè´¹è€…ç›¸å…³ BEGIN ==========
//*/*
/* æœåŠ¡ç±»å‹ï¼Œä¾‹å¦‚ï¼šcom.alibaba.dubbo.demo.DemoService
/*/
private final Class<T> serviceType; // Initialization at construction time, assertion not null
//*/*
/* Consumer URL çš„é…ç½®é¡¹ Map
/*/
private final Map<String, String> queryMap; // Initialization at construction time, assertion not null
//*/*
/* æœåŠ¡æ–¹æ³•æ•°ç»„
/*/
private final String[] serviceMethods;
//*/*
/* æ˜¯å¦å¼•ç”¨å¤šåˆ†ç»„
/*
/* æœåŠ¡åˆ†ç»„ï¼šhttp://dubbo.apache.org/zh-cn/docs/user/demos/service-group.html
/*/
private final boolean multiGroup;
// ========== æ³¨å†Œä¸­å¿ƒç›¸å…³ BEGIN ==========
//*/*
/* æ³¨å†Œä¸­å¿ƒçš„ Protocol å¯¹è±¡
/*/
private Protocol protocol; // Initialization at the time of injection, the assertion is not null
//*/*
/* æ³¨å†Œä¸­å¿ƒ
/*/
private Registry registry; // Initialization at the time of injection, the assertion is not null
//*/*
/* æ³¨å†Œä¸­å¿ƒçš„æœåŠ¡ç±»ï¼Œç›®å‰æ˜¯ com.alibaba.dubbo.registry.RegistryService
/*
/* é€šè¿‡ {@link /#url} çš„ {@link URL/#getServiceKey()} è·å¾—
/*/
private final String serviceKey; // Initialization at construction time, assertion not null
//*/*
/* æ˜¯å¦ç¦æ­¢è®¿é—®ã€‚
/*
/* æœ‰ä¸¤ç§æƒ…å†µä¼šå¯¼è‡´ï¼š
/*
/* 1. æ²¡æœ‰æœåŠ¡æä¾›è€…
/* 2. æœåŠ¡æä¾›è€…è¢«ç¦ç”¨
/*/
private volatile boolean forbidden = false;
// ========== é…ç½®è§„åˆ™ç›¸å…³ BEGIN ==========
//*/*
/* åŸå§‹çš„ç›®å½• URL
/*
/* ä¾‹å¦‚ï¼šzookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&callbacks=1000&check=false&client=netty4&cluster=failback&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,saves&payload=1000&pid=63400&qos.port=33333&register.ip=192.168.16.23&sayHello.async=true&side=consumer&timeout=10000&timestamp=1527056491064
/*/
private final URL directoryUrl; // Initialization at construction time, assertion not null, and always assign non null value
//*/*
/* è¦†å†™çš„ç›®å½• URL ï¼Œç»“åˆé…ç½®è§„åˆ™
/*/
private volatile URL overrideDirectoryUrl; // Initialization at construction time, assertion not null, and always assign non null value
//*/*
/* é…ç½®è§„åˆ™æ•°ç»„
/*
/* override rules
/* Priority: override>-D>consumer>provider
/* Rule one: for a certain provider <ip:port,timeout=100>
/* Rule two: for all providers </* ,timeout=5000>
/*/
private volatile List<Configurator> configurators; // The initial value is null and the midway may be assigned to null, please use the local variable reference
// ========== æœåŠ¡æä¾›è€…ç›¸å…³ BEGIN ==========
//*/*
/* [url]ä¸[æœåŠ¡æä¾›è€… Invoker é›†åˆ]çš„æ˜ å°„ç¼“å­˜
/*/
// Map<url, Invoker> cache service url to invoker mapping.
private volatile Map<String, Invoker<T>> urlInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference
//*/*
/* [æ–¹æ³•å]ä¸[æœåŠ¡æä¾›è€… Invoker é›†åˆ]çš„æ˜ å°„ç¼“å­˜
/*/
// Map<methodName, Invoker> cache service method to invokers mapping.
private volatile Map<String, List<Invoker<T>>> methodInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference
//*/*
/* [æœåŠ¡æä¾›è€… Invoker é›†åˆ]ç¼“å­˜
/*/
// Set<invokerUrls> cache invokeUrls to invokers mapping.
private volatile Set<URL> cachedInvokerUrls; // The initial value is null and the midway may be assigned to null, please use the local variable reference
public RegistryDirectory(Class<T> serviceType, URL url){
super(url);
if (serviceType == null) {
throw new IllegalArgumentException("service type is null.");
}
if (url.getServiceKey() == null || url.getServiceKey().length() == 0) {
throw new IllegalArgumentException("registry serviceKey is null.");
}
this.serviceType = serviceType;
this.serviceKey = url.getServiceKey();
// è·å¾— queryMap
this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));
// è·å¾— overrideDirectoryUrl å’Œ directoryUrl
this.overrideDirectoryUrl = this.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);
// åˆå§‹åŒ– multiGroup
String group = directoryUrl.getParameter(Constants.GROUP_KEY, "");
this.multiGroup = group != null && ("/*".equals(group) || group.contains(","));
// åˆå§‹åŒ– serviceMethods
String methods = queryMap.get(Constants.METHODS_KEY);
this.serviceMethods = methods == null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);
}
```

* åˆ†æˆ**äº”ç±»**å˜é‡ã€‚èƒ–å‹è‡ªå·±çœ‹æ³¨é‡Šã€‚
* å¦‚æœä¸ç†è§£ï¼Œå¯ä»¥ç»“åˆä¸‹é¢çš„å…·ä½“æ–¹æ³•çš„ä½¿ç”¨ã€‚ğŸ™‚ å½“ç„¶ä¹Ÿå¯ä»¥ç»™æˆ‘ç•™è¨€ï¼Œå› ä¸ºç¡®å®å˜é‡æœ‰ç‚¹å¤šå’Œå¤æ‚ã€‚

## 4.2 subscribe

/#subscribe(URL)
æ–¹æ³•ï¼Œå‘**æ³¨å†Œä¸­å¿ƒ**å‘èµ·è®¢é˜…ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public void subscribe(URL url){
// è®¾ç½®æ¶ˆè´¹è€… URL
setConsumerUrl(url);
// å‘æ³¨å†Œä¸­å¿ƒï¼Œå‘èµ·è®¢é˜…
registry.subscribe(url, this);
}
```

* è°ƒç”¨**çˆ¶**

/#setConsumerUrl(url)
æ–¹æ³•ï¼Œè®¾ç½®

consumerUrl
æ¶ˆè´¹è€… URL ã€‚
* è°ƒç”¨

Registry/#subscribe(url, NotifyListener)
æ–¹æ³•ï¼Œå‘æ³¨å†Œä¸­å¿ƒï¼Œå‘èµ·è®¢é˜…ã€‚

æœåŠ¡æ¶ˆè´¹è€…ï¼Œå†å¼•ç”¨æœåŠ¡æ—¶ï¼Œä¼šåˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œå¹¶å‘èµ·**1ï¼‰æœåŠ¡æä¾›è€… + 2ï¼‰è·¯ç”±è§„åˆ™ + 3ï¼‰é…ç½®è§„åˆ™**çš„æ•°æ®è®¢é˜…ã€‚å¦‚ä¸‹å›¾ï¼š

![doRefer](http://static2.iocoder.cn/images/Dubbo/2019_04_10/02.png)

* å¯¹åº”ä¸º

RegistryProtocol/#doRefer(Cluster, Registry, Class<T> type, URL url)
æ–¹æ³•ã€‚

## 4.3 notify

åœ¨æ³¨å†Œä¸­å¿ƒ( Registry )å‘ç°æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šé€šçŸ¥å¯¹åº”çš„ NotifyListener ä»¬ã€‚å¦‚ä¸‹å›¾ï¼š

![notify](http://static2.iocoder.cn/images/Dubbo/2019_04_10/03.png)

* å¯¹åº”ä¸º

AbstractRegistry/#notify(URL url, NotifyListener, List<URL> urls)
æ–¹æ³•ã€‚
* å› ä¸º RegistryDirectory ä½œä¸ºä¸€ä¸ª NotifyListener ï¼Œå‘æ³¨å†Œä¸­å¿ƒ( Registry )å‘èµ·äº†è®¢é˜…ï¼Œæ‰€ä»¥æ­¤æ—¶ä¼šè¢«é€šçŸ¥ã€‚**æ³¨æ„ï¼Œæ˜¯æŒ‰ç…§åˆ†ç±»å¾ªç¯é€šçŸ¥çš„**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ**ä¸€æ¬¡åªæœ‰ä¸€ç±» URL** ã€‚

/#notify(List<URL> urls)
**å®ç°**æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
1: @Override
2: public synchronized void notify(List<URL> urls){
3: // æ ¹æ® URL çš„åˆ†ç±»æˆ–åè®®ï¼Œåˆ†ç»„æˆä¸‰ä¸ªé›†åˆ ã€‚
4: List<URL> invokerUrls = new ArrayList<URL>(); // æœåŠ¡æä¾›è€… URL é›†åˆ
5: List<URL> routerUrls = new ArrayList<URL>();
6: List<URL> configuratorUrls = new ArrayList<URL>();
7: for (URL url : urls) {
8: String protocol = url.getProtocol();
9: String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
10: if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) {
11: routerUrls.add(url);
12: } else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {
13: configuratorUrls.add(url);
14: } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {
15: invokerUrls.add(url);
16: } else {
17: logger.warn("Unsupported category " + category + " in notified url: " + url + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost());
18: }
19: }
20: // å¤„ç†é…ç½®è§„åˆ™ URL é›†åˆ
21: // configurators
22: if (!configuratorUrls.isEmpty()) {
23: this.configurators = toConfigurators(configuratorUrls);
24: }
25: // å¤„ç†è·¯ç”±è§„åˆ™ URL é›†åˆ
26: // routers
27: if (!routerUrls.isEmpty()) {
28: List<Router> routers = toRouters(routerUrls);
29: if (routers != null) { // null - do nothing
30: setRouters(routers);
31: }
32: }
33: // åˆå¹¶é…ç½®è§„åˆ™ï¼Œåˆ° `directoryUrl` ä¸­ï¼Œå½¢æˆ `overrideDirectoryUrl` å˜é‡ã€‚
34: List<Configurator> localConfigurators = this.configurators; // local reference
35: // merge override parameters
36: this.overrideDirectoryUrl = directoryUrl;
37: if (localConfigurators != null && !localConfigurators.isEmpty()) {
38: for (Configurator configurator : localConfigurators) {
39: this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);
40: }
41: }
42: // å¤„ç†æœåŠ¡æä¾›è€… URL é›†åˆ
43: refreshInvoker(invokerUrls);
44: }
```

* **æ³¨æ„**ï¼Œè¿™æ˜¯ä¸€ä¸ª**åŒæ­¥**çš„æ–¹æ³•ã€‚
* ç¬¬ 3 è‡³ 19 è¡Œï¼šæ ¹æ® URL çš„**åˆ†ç±»**æˆ–åè®®ï¼Œåˆ†æˆç»„**ä¸‰ä¸ª**é›†åˆï¼š**1ï¼‰æœåŠ¡æä¾›è€… + 2ï¼‰è·¯ç”±è§„åˆ™ + 3ï¼‰é…ç½®è§„åˆ™**ã€‚
* ç¬¬ 20 è‡³ 24 è¡Œï¼šéç©ºï¼Œè°ƒç”¨

/#toConfigurators(configuratorUrls)
æ–¹æ³•ï¼Œå¤„ç†**é…ç½®è§„åˆ™** URL é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.1 toConfiguratorsã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 25 è‡³ 32 è¡Œï¼šéç©ºï¼Œè°ƒç”¨

/#toRouters(routerUrls)
æ–¹æ³•ï¼Œå¤„ç†**è·¯ç”±è§„åˆ™** URL é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.2 toRoutersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚

* è‹¥è½¬æ¢åˆ°

routers
éç©ºï¼Œè°ƒç”¨**çˆ¶**

/#setRouters(routers)
æ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™ã€‚
* ç¬¬ 33 è‡³ 41 è¡Œï¼šåˆå¹¶é…ç½®è§„åˆ™ï¼Œåˆ°

directoryUrl
ä¸­ï¼Œå½¢æˆ

overrideDirectoryUrl
å˜é‡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self) çš„ [ã€Œ4.1.2 mergeUrlã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 43 è¡Œï¼šè°ƒç”¨

/#refreshInvoker(invokerUrls)
æ–¹æ³•ï¼Œå¤„ç†**æœåŠ¡æä¾›è€…** URL é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3 refreshInvokerã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚

### 4.3.1 toConfigurators

è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self) çš„ [ã€Œ4.1.1 toConfiguratorsã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚

### 4.3.2 toRouters

è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚

## 4.7 å†…éƒ¨ç±»

### 4.7.1 InvokerDelegate

InvokerDelegate ï¼Œå®ç°

com.alibaba.dubbo.rpc.protocol.InvokerWrapper
ç±»ï¼ŒInvoker ä»£ç†ç±»ï¼Œä¸»è¦ç”¨äºå­˜å‚¨**æ³¨å†Œä¸­å¿ƒä¸‹å‘çš„ url åœ°å€**(

providerUrl
)ï¼Œç”¨äºé‡æ–°é‡æ–° refer æ—¶èƒ½å¤Ÿæ ¹æ®

providerURL
queryMap overrideMap é‡æ–°ç»„è£…ã€‚ ä»£ç å¦‚ä¸‹ï¼š
è€è‰¿è‰¿ï¼šç›®å‰è²Œä¼¼æ²¡çœ‹åˆ°è¿™å—é€»è¾‘å™¢ ğŸ˜¯ğŸ˜¯ğŸ˜¯
  ```
private static class InvokerDelegate<T> extends InvokerWrapper<T>{
//*/*
/* æœåŠ¡æä¾›è€… URL
/*
/* æœªç»è¿‡é…ç½®åˆå¹¶
/*/
private URL providerUrl;
public InvokerDelegate(Invoker<T> invoker, URL url, URL providerUrl){
super(invoker, url);
this.providerUrl = providerUrl;
}
public URL getProviderUrl(){
return providerUrl;
}
}
```

### 4.7.2 InvokerComparator

InvokerComparator ï¼Œå®ç° Comparator æ¥å£ï¼ŒInvoker æ’åºå™¨å®ç°ç±»ï¼Œ**æ ¹æ® URL å‡åº** ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private static class InvokerComparator implements Comparator<Invoker<?>>{
//*/*
/* å•ä¾‹
/*/
private static final InvokerComparator comparator = new InvokerComparator();
private InvokerComparator(){
}
public static InvokerComparator getComparator(){
return comparator;
}
@Override
public int compare(Invoker<?> o1, Invoker<?> o2){
return o1.getUrl().toString().compareTo(o2.getUrl().toString());
}
}
```

### 4.3.3 refreshInvoker

/#refreshInvoker(List<URL> invokerUrls)
æ–¹æ³•ï¼Œå®˜æ–¹æ³¨é‡Šå…¶å¦‚ä¸‹ï¼š
æ ¹æ® invokerURL åˆ—è¡¨è½¬æ¢ä¸º invoker åˆ—è¡¨ã€‚è½¬æ¢è§„åˆ™å¦‚ä¸‹ï¼š

1. å¦‚æœ url å·²ç»è¢«è½¬æ¢ä¸º invoker ï¼Œåˆ™ä¸åœ¨é‡æ–°å¼•ç”¨ï¼Œç›´æ¥ä»ç¼“å­˜ä¸­è·å–ï¼Œæ³¨æ„å¦‚æœ url ä¸­ä»»ä½•ä¸€ä¸ªå‚æ•°å˜æ›´ä¹Ÿä¼šé‡æ–°å¼•ç”¨
1. å¦‚æœä¼ å…¥çš„ invoker åˆ—è¡¨ä¸ä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºæœ€æ–°çš„ invoker åˆ—è¡¨
1. å¦‚æœä¼ å…¥çš„ invokerUrl åˆ—è¡¨æ˜¯ç©ºï¼Œåˆ™è¡¨ç¤ºåªæ˜¯ä¸‹å‘çš„ override è§„åˆ™æˆ– route è§„åˆ™ï¼Œéœ€è¦é‡æ–°äº¤å‰å¯¹æ¯”ï¼Œå†³å®šæ˜¯å¦éœ€è¦é‡æ–°å¼•ç”¨ã€‚

* æ˜¯ä¸æ˜¯çœ‹èµ·æ¥æœ‰ç‚¹ç‚¹æ‡µé€¼ï¼Ÿæ·¡å®šï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ä»£ç ã€‚
```
1: private void refreshInvoker(List<URL> invokerUrls){
2: if (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null
3: && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
4: // è®¾ç½®ç¦æ­¢è®¿é—®
5: this.forbidden = true; // Forbid to access
6: // methodInvokerMap ç½®ç©º
7: this.methodInvokerMap = null; // Set the method invoker map to null
8: // é”€æ¯æ‰€æœ‰ Invoker é›†åˆ
9: destroyAllInvokers(); // Close all invokers
10: } else {
11: // è®¾ç½®å…è®¸è®¿é—®
12: this.forbidden = false; // Allow to access
13: // å¼•ç”¨è€çš„ urlInvokerMap
14: Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference
15: // ä¼ å…¥çš„ invokerUrls ä¸ºç©ºï¼Œè¯´æ˜æ˜¯è·¯ç”±è§„åˆ™æˆ–é…ç½®è§„åˆ™å‘ç”Ÿæ”¹å˜ï¼Œæ­¤æ—¶ invokerUrls æ˜¯ç©ºçš„ï¼Œç›´æ¥ä½¿ç”¨ cachedInvokerUrls ã€‚
16: if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {
17: invokerUrls.addAll(this.cachedInvokerUrls);
18: // ä¼ å…¥çš„ invokerUrls éç©ºï¼Œæ›´æ–° cachedInvokerUrls ã€‚
19: } else {
20: this.cachedInvokerUrls = new HashSet<URL>();
21: this.cachedInvokerUrls.addAll(invokerUrls); //Cached invoker urls, convenient for comparison //ç¼“å­˜invokerUrlsåˆ—è¡¨ï¼Œä¾¿äºäº¤å‰å¯¹æ¯”
22: }
23: // å¿½ç•¥ï¼Œè‹¥æ—  invokerUrls
24: if (invokerUrls.isEmpty()) {
25: return;
26: }
27: // å°†ä¼ å…¥çš„ invokerUrls ï¼Œè½¬æˆæ–°çš„ urlInvokerMap
28: Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
29: // è½¬æ¢å‡ºæ–°çš„ methodInvokerMap
30: Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map
31: // state change
32: // If the calculation is wrong, it is not processed. å¦‚æœè®¡ç®—é”™è¯¯ï¼Œåˆ™ä¸è¿›è¡Œå¤„ç†.
33: if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
34: logger.error(new IllegalStateException("urls to invokers error .invokerUrls.size :" + invokerUrls.size() + ", invoker.size :0. urls :" + invokerUrls.toString()));
35: return;
36: }
37: // è‹¥æœåŠ¡å¼•ç”¨å¤š group ï¼Œåˆ™æŒ‰ç…§ method + group èšåˆ Invoker é›†åˆ
38: this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;
39: this.urlInvokerMap = newUrlInvokerMap;
40: // é”€æ¯ä¸å†ä½¿ç”¨çš„ Invoker é›†åˆ
41: try {
42: destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker
43: } catch (Exception e) {
44: logger.warn("destroyUnusedInvokers error. ", e);
45: }
46: }
47: }
```

* ========== ç¬¬ä¸€éƒ¨åˆ† ==========
* ç¬¬ 2 è‡³ 3 è¡Œï¼šå½“

invokerUrls
é›†åˆå¤§å°ä¸º **1** ï¼Œå¹¶ä¸”åè®®ä¸º

empty://
ï¼Œè¯´æ˜æ‰€æœ‰æœåŠ¡æä¾›è€…éƒ½å·²ç»**ä¸‹çº¿**ã€‚è‹¥æ³¨å†Œä¸­å¿ƒä¸º Zookeeper ï¼Œå¯å‚è§

ZookeeperRegistry/#toUrlsWithEmpty(URL consumer, String path, List<String> providers)
æ–¹æ³•ã€‚
* ç¬¬ 5 è¡Œï¼šè®¾ç½®**ç¦æ­¢**è®¿é—®ï¼Œå› ä¸ºæ²¡æœ‰æœåŠ¡æä¾›è€…äº†ã€‚
* ç¬¬ 7 è¡Œï¼š

methodInvokerMap
ç½®ç©ºã€‚
* ç¬¬ 9 è¡Œï¼šè°ƒç”¨

/#destroyAllInvokers()
æ–¹æ³•ï¼Œé”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.5 destroyAllInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ========== ç¬¬äºŒéƒ¨åˆ† ==========
* ç¬¬ 12 è¡Œï¼šè®¾ç½®**å…è®¸**è®¿é—®ï¼Œå› ä¸ºæœ‰æœåŠ¡æä¾›è€…äº†ã€‚
* ç¬¬ 15 è‡³ 17 è¡Œï¼šä¼ å…¥çš„

invokerUrls
ä¸ºç©ºï¼Œ**è¯´æ˜æ˜¯è·¯ç”±è§„åˆ™æˆ–é…ç½®è§„åˆ™å‘ç”Ÿæ”¹å˜**ï¼Œæ­¤æ—¶

invokerUrls
æ˜¯ç©ºçš„ï¼Œç›´æ¥ä½¿ç”¨

cachedInvokerUrls
ã€‚å¯¹åº”å®˜æ–¹æ³¨é‡Šã€ç¬¬ 3 ç‚¹ã€‘ï¼ˆéƒ¨åˆ†ï¼Œä¸åŒ…æ‹¬â€œéœ€è¦é‡æ–°äº¤å‰å¯¹æ¯”ï¼Œå†³å®šæ˜¯å¦éœ€è¦é‡æ–°å¼•ç”¨â€ï¼‰ã€‚
* ç¬¬ 18 è‡³ 22 è¡Œï¼šä¼ å…¥çš„

invokerUrls
éç©ºï¼Œæ›´æ–°

cachedInvokerUrls
ã€‚è€ƒè™‘åˆ°å¹¶å‘çš„é—®é¢˜ï¼Œæ›´æ–°çš„æ–¹å¼ä¸ºåˆ›å»º**æ–°çš„** HashSet ã€‚å¯¹åº”å®˜æ–¹æ³¨é‡Šã€ç¬¬ 2 ç‚¹ã€‘ã€‚

* ä¸ºä»€ä¹ˆã€ç¬¬ 15 è‡³ 17 è¡Œã€‘**ä¸éœ€è¦æ›´æ–°**å‘¢ï¼Ÿå› ä¸º

invokerUrls
ä¸ºç©ºï¼Œç›´æ¥ä½¿ç”¨

cachedInvokerUrls
ï¼Œç›¸å½“äºè¿›è¡Œäº†â€œæ›´æ–°â€ã€‚
* ç¬¬ 23 è‡³ 26 è¡Œï¼šå¿½ç•¥ï¼Œè‹¥æ— 

invokerUrls
ã€‚å‡ºç°æƒ…å†µä¸ºï¼Œåˆå§‹æ˜¯æŒ‰ç…§

configurators => routers => providers
ï¼Œæ‰€ä»¥å‰ä¸¤ä¸ªä¼šå‡ºç°è¿™ä¸ªæƒ…å†µã€‚å…³äºè¿™ä¸€ç‚¹ï¼Œèƒ–å‹å¯ä»¥è°ƒè¯•æ„Ÿå—ä¸‹ã€‚
* ç¬¬ 28 è¡Œï¼šè°ƒç”¨

/#toInvokers(List<URL> urls)
æ–¹æ³•ï¼Œå°†ä¼ å…¥çš„

invokerUrls
ï¼Œè½¬æ¢æˆ**æ–°çš„**

urlInvokerMap
ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.1 toInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 30 è¡Œï¼šè°ƒç”¨

/#toMethodInvokers(newUrlInvokerMap)
æ–¹æ³•ï¼Œå°†

urlInvokerMap
è½¬æˆä¸æ–¹æ³•çš„æ˜ å°„å…³ç³»ï¼Œå³**æ–°çš„**

methodInvokerMap
ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.2 toMethodInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 31 è‡³ 36 è¡Œï¼šå¦‚æœè®¡ç®—é”™è¯¯ï¼Œåˆ™ä¸è¿›è¡Œå¤„ç†ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ˜¯é˜²å¾¡æ€§ç¼–ç¨‹ã€‚
* ç¬¬ 38 è¡Œï¼šè‹¥æœåŠ¡å¼•ç”¨**å¤š** group ï¼Œåˆ™è°ƒç”¨

/#toMergeMethodInvokerMap(newMethodInvokerMap)
æ–¹æ³•ï¼ŒæŒ‰ç…§ **method + group** èšåˆ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.3 toMethodInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 39 è¡Œï¼šèµ‹å€¼

urlInvokerMap
å±æ€§ã€‚
* ç¬¬ 40 è‡³ 45 è¡Œï¼šè°ƒç”¨

/#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)
æ–¹æ³•ï¼Œ**é”€æ¯**ä¸å†ä½¿ç”¨çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.4 toMethodInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚

### 4.3.3.1 toInvokers

/#toInvokers(List<URL> urls)
æ–¹æ³•ï¼Œ
```
1: private Map<String, Invoker<T>> toInvokers(List<URL> urls) {
2: // æ–°çš„ `newUrlInvokerMap`
3: Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();
4: // è‹¥ä¸ºç©ºï¼Œç›´æ¥è¿”å›
5: if (urls == null || urls.isEmpty()) {
6: return newUrlInvokerMap;
7: }
8: // å·²åˆå§‹åŒ–çš„æœåŠ¡å™¨æä¾› URL é›†åˆ
9: Set<String> keys = new HashSet<String>();
10: // è·å¾—å¼•ç”¨æœåŠ¡çš„åè®®
11: String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);
12: // å¾ªç¯æœåŠ¡æä¾›è€… URL é›†åˆï¼Œè½¬æˆ Invoker é›†åˆ
13: for (URL providerUrl : urls) {
14: // If protocol is configured at the reference side, only the matching protocol is selected
15: // å¦‚æœ reference ç«¯é…ç½®äº† protocol ï¼Œåˆ™åªé€‰æ‹©åŒ¹é…çš„ protocol
16: if (queryProtocols != null && queryProtocols.length() > 0) {
17: boolean accept = false;
18: String[] acceptProtocols = queryProtocols.split(","); // å¯é…ç½®å¤šä¸ªåè®®
19: for (String acceptProtocol : acceptProtocols) {
20: if (providerUrl.getProtocol().equals(acceptProtocol)) {
21: accept = true;
22: break;
23: }
24: }
25: if (!accept) {
26: continue;
27: }
28: }
29: // å¿½ç•¥ï¼Œè‹¥ä¸º `empty://` åè®®
30: if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
31: continue;
32: }
33: // å¿½ç•¥ï¼Œè‹¥åº”ç”¨ç¨‹åºä¸æ”¯æŒè¯¥åè®®
34: if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
35: logger.error(new IllegalStateException("Unsupported protocol " + providerUrl.getProtocol() + " in notified url: " + providerUrl + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost()
36: + ", supported protocol: " + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));
37: continue;
38: }
39: // åˆå¹¶ URL å‚æ•°
40: URL url = mergeUrl(providerUrl);
41: // å¿½ç•¥ï¼Œè‹¥å·²ç»åˆå§‹åŒ–
42: String key = url.toFullString(); // The parameter urls are sorted
43: if (keys.contains(key)) { // Repeated url
44: continue;
45: }
46: // æ·»åŠ åˆ° `keys` ä¸­
47: keys.add(key);
48: // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
49: // å¦‚æœæœåŠ¡ç«¯ URL å‘ç”Ÿå˜åŒ–ï¼Œåˆ™é‡æ–° refer å¼•ç”¨
50: Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference
51: Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
52: if (invoker == null) { // Not in the cache, refer again æœªåœ¨ç¼“å­˜ä¸­ï¼Œé‡æ–°å¼•ç”¨
53: try {
54: // åˆ¤æ–­æ˜¯å¦å¼€å¯
55: boolean enabled;
56: if (url.hasParameter(Constants.DISABLED_KEY)) {
57: enabled = !url.getParameter(Constants.DISABLED_KEY, false);
58: } else {
59: enabled = url.getParameter(Constants.ENABLED_KEY, true);
60: }
61: // è‹¥å¼€å¯ï¼Œåˆ›å»º Invoker å¯¹è±¡
62: if (enabled) {
63: // æ³¨æ„ï¼Œå¼•ç”¨æœåŠ¡
64: invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);
65: }
66: } catch (Throwable t) {
67: logger.error("Failed to refer invoker for interface:" + serviceType + ",url:(" + url + ")" + t.getMessage(), t);
68: }
69: // æ·»åŠ åˆ° newUrlInvokerMap ä¸­
70: if (invoker != null) { // Put new invoker in cache
71: newUrlInvokerMap.put(key, invoker);
72: }
73: } else { // åœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ Invoker å¯¹è±¡ï¼Œæ·»åŠ åˆ° newUrlInvokerMap ä¸­
74: newUrlInvokerMap.put(key, invoker);
75: }
76: }
77: // æ¸…ç©º keys
78: keys.clear();
79: return newUrlInvokerMap;
80: }
```

* ç¬¬ 3 è¡Œï¼š

newUrlInvokerMap
å˜é‡ï¼Œæ–°çš„

urlInvokerMap
å­—æ®µï¼Œåé¢ä¼šèµ‹å€¼ç»™å®ƒã€‚
* ç¬¬ 4 è‡³ 7 è¡Œï¼šè‹¥

urls
ä¸ºç©ºï¼Œç›´æ¥è¿”å›ï¼Œé˜²å¾¡æ€§ç¼–ç¨‹ã€‚
* ç¬¬ 9 è¡Œï¼š

keys
å˜é‡ï¼Œ**å·²åˆå§‹åŒ–**çš„æœåŠ¡å™¨æä¾› URL é›†åˆï¼Œå³æœåŠ¡æä¾›è€… URL å·²ç»å¤„ç†ã€‚
* ç¬¬ 11 è¡Œï¼šè·å¾—å¼•ç”¨æœåŠ¡çš„åè®®ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šè®¾ç½®

<dubbo:reference protocol=""/>
é…ç½®é¡¹ã€‚
* ç¬¬ 13 è¡Œï¼š**å¾ªç¯**

urls
é›†åˆï¼Œè½¬æˆ Invoker é›†åˆã€‚
* åè®®å¤„ç†ç›¸å…³

* ç¬¬ 14 è‡³ 28 è¡Œï¼šå¦‚æœ reference ç«¯é…ç½®äº† protocol ï¼Œåˆ™**åªé€‰æ‹©åŒ¹é…**çš„ protocol ã€‚
* ç¬¬ 29 è‡³ 32 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥ä¸º

empty://
åè®®ã€‚
* ç¬¬ 33 è‡³ 38 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥åº”ç”¨ç¨‹åºä¸æ”¯æŒè¯¥åè®®ã€‚
* ç¬¬ 40 è¡Œï¼šè°ƒç”¨

/#mergeUrl(providerUrl)
æ–¹æ³•ï¼Œ**åˆå¹¶** URL å‚æ•°ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.1 mergeUrlã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 41 è‡³ 47 è¡Œï¼š**å¿½ç•¥**ï¼Œé€šè¿‡

keys
åˆ¤æ–­å·²ç»åˆå§‹åŒ–ã€‚

* è‹¥æœªåˆå§‹åŒ–ï¼Œæ·»åŠ åˆ°

keys
ä¸­ã€‚
* ç¬¬ 48 è‡³ 75 è¡Œï¼šâ€œåˆ›å»ºâ€æœåŠ¡ Invoker å¯¹è±¡ã€‚

* ç¬¬ 50 è‡³ 51 è¡Œï¼šè·å¾—

url
å¯¹åº”åœ¨

localUrlInvokerMap
ç¼“å­˜çš„ Invoker å¯¹è±¡ã€‚
* ç¬¬ 52 è‡³ 72 è¡Œï¼šä¸åœ¨ç¼“å­˜ä¸­ï¼Œéœ€è¦é‡æ–° refer å¼•ç”¨ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚

* ç¬¬ 54 è‡³ 60 è¡Œï¼šé€šè¿‡é…ç½®é¡¹

enable
å’Œ

disable
åˆ¤æ–­ï¼ŒæœåŠ¡æ˜¯å¦å¼€å¯ã€‚
* ç¬¬ 61 è‡³ 65 è¡Œï¼š è‹¥å¼€å¯ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚

* ã€é‡è¦ã€‘**ç¬¬ 64 è¡Œï¼šè°ƒç”¨

Protocol$Adaptive/#refer(serviceType, url)
æ–¹æ³•ï¼Œå¼•ç”¨æœåŠ¡ï¼Œåˆ›å»ºæœåŠ¡æä¾›è€… Invoker å¯¹è±¡**ã€‚è¯¦ç»†è§£æï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” æœåŠ¡å¼•ç”¨ã€‹](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) å·²ç»æœ‰äº†ã€‚
* ç¬¬ 64 è¡Œï¼šåˆ›å»º InvokerDelegate å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.7.1 InvokerDelegateã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 73 è‡³ 75 è¡Œï¼šåœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ Invoker å¯¹è±¡ï¼Œæ·»åŠ åˆ°

newUrlInvokerMap
ä¸­ã€‚
* ç¬¬ 78 è¡Œï¼šæ¸…ç©º

keys
ã€‚
* ç¬¬ 79 è¡Œï¼šè¿”å›ç»“æœ

newUrlInvokerMap
ã€‚

### 4.3.3.1.1 mergeUrl

/#mergeUrl(providerUrl)
æ–¹æ³•ï¼Œåˆå¹¶ URL å‚æ•°ï¼Œ**ä¼˜å…ˆçº§**ä¸ºé…ç½®è§„åˆ™ > æœåŠ¡æ¶ˆè´¹è€…é…ç½® > æœåŠ¡æä¾›è€…é…ç½®ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private URL mergeUrl(URL providerUrl){
2: // åˆå¹¶æ¶ˆè´¹ç«¯å‚æ•°
3: providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
4:
5: // åˆå¹¶é…ç½®è§„åˆ™
6: List<Configurator> localConfigurators = this.configurators; // local reference
7: if (localConfigurators != null && !localConfigurators.isEmpty()) {
8: for (Configurator configurator : localConfigurators) {
9: providerUrl = configurator.configure(providerUrl);
10: }
11: }
12:
13: // ä¸æ£€æŸ¥è¿æ¥æ˜¯å¦æˆåŠŸï¼Œæ€»æ˜¯åˆ›å»º Invoker ï¼
14: providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
15:
16: // The combination of directoryUrl and override is at the end of notify, which can't be handled here
17: // ä»…åˆå¹¶æä¾›è€…å‚æ•°ï¼Œå› ä¸º directoryUrl ä¸ override åˆå¹¶æ˜¯åœ¨ notify çš„æœ€åï¼Œè¿™é‡Œä¸èƒ½å¤Ÿå¤„ç†
18: this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters // åˆå¹¶æä¾›è€…å‚æ•°
19:
20: // ã€å¿½ç•¥ã€‘å› ä¸ºæ˜¯å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹
21: if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0)
22: && "dubbo".equals(providerUrl.getProtocol())) { // Compatible version 1.0
23: //fix by tony.chenl DUBBO-44
24: String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);
25: if (path != null) {
26: int i = path.indexOf('/');
27: if (i >= 0) {
28: path = path.substring(i + 1);
29: }
30: i = path.lastIndexOf(':');
31: if (i >= 0) {
32: path = path.substring(0, i);
33: }
34: providerUrl = providerUrl.setPath(path);
35: }
36: }
37:
38: // è¿”å›æœåŠ¡æä¾›è€… URL
39: return providerUrl;
40: }
```

* ã€**é‡è¦**ã€‘ç¬¬ 3 è¡Œï¼šè°ƒç”¨

ClusterUtils/#mergeUrl(providerUrl, queryMap)
æ–¹æ³•ï¼Œåˆå¹¶æœåŠ¡æ¶ˆè´¹è€…é…ç½®åˆ°

providerUrl
ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6. ClusterUtilsã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚
* ç¬¬ 5 è‡³ 11 è¡Œï¼šåˆå¹¶**é…ç½®è§„åˆ™**åˆ°

providerUrl
ä¸­ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self)
* ç¬¬ 14 è¡Œï¼šè®¾ç½®

providerUrl
ä¸æ£€æŸ¥è¿æ¥æ˜¯å¦æˆåŠŸï¼Œæ€»æ˜¯åˆ›å»º Invoker ï¼
* ç¬¬ 18 è¡Œï¼šä»…åˆå¹¶æä¾›è€…å‚æ•°ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self)
* ç¬¬ 20 è‡³ 36 è¡Œï¼šã€**å¿½ç•¥**ã€‘å› ä¸ºæ˜¯å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹ã€‚

### 4.3.3.2 toMethodInvokers

/#toMethodInvokers(Map<String, Invoker<T>> invokersMap)
æ–¹æ³•ï¼Œå°†

invokersMap
è½¬æˆ**ä¸æ–¹æ³•**çš„æ˜ å°„å…³ç³»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {
2: // åˆ›å»ºæ–°çš„ `methodInvokerMap`
3: Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();
4: // åˆ›å»º Invoker é›†åˆ
5: List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();
6: // According to the methods classification declared by the provider URL, the methods is compatible with the registry to execute the filtered methods
7: // æŒ‰æœåŠ¡æä¾›è€… URL æ‰€å£°æ˜çš„ methods åˆ†ç±»ï¼Œå…¼å®¹æ³¨å†Œä¸­å¿ƒæ‰§è¡Œè·¯ç”±è¿‡æ»¤æ‰çš„ methods
8: if (invokersMap != null && invokersMap.size() > 0) {
9: // å¾ªç¯æ¯ä¸ªæœåŠ¡æä¾›è€… Invoker
10: for (Invoker<T> invoker : invokersMap.values()) {
11: String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY); // methods
12: if (parameter != null && parameter.length() > 0) {
13: String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);
14: if (methods != null && methods.length > 0) {
15: // å¾ªç¯æ¯ä¸ªæ–¹æ³•ï¼ŒæŒ‰ç…§æ–¹æ³•åä¸ºç»´åº¦ï¼Œèšåˆåˆ° `methodInvokerMap` ä¸­
16: for (String method : methods) {
17: if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) { // å½“æœåŠ¡æä¾›è€…çš„æ–¹æ³•ä¸º "/*" ï¼Œä»£è¡¨æ³›åŒ–è°ƒç”¨
18: List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
19: if (methodInvokers == null) {
20: methodInvokers = new ArrayList<Invoker<T>>();
21: newMethodInvokerMap.put(method, methodInvokers);
22: }
23: methodInvokers.add(invoker);
24: }
25: }
26: }
27: }
28: // æ·»åŠ åˆ° `invokersList` ä¸­
29: invokersList.add(invoker);
30: }
31: }
32: // è·¯ç”±å…¨ `invokersList` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆã€‚
33: List<Invoker<T>> newInvokersList = route(invokersList, null);
34: // æ·»åŠ  `newInvokersList` åˆ° `newMethodInvokerMap` ä¸­ï¼Œè¡¨ç¤ºè¯¥æœåŠ¡æä¾›è€…çš„å…¨é‡ Invoker é›†åˆ
35: newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);
36: // å¾ªç¯ï¼ŒåŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ
37: if (serviceMethods != null && serviceMethods.length > 0) {
38: for (String method : serviceMethods) {
39: List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
40: if (methodInvokers == null || methodInvokers.isEmpty()) {
41: methodInvokers = newInvokersList;
42: }
43: newMethodInvokerMap.put(method, route(methodInvokers, method));
44: }
45: }
46: // å¾ªç¯æ’åºæ¯ä¸ªæ–¹æ³•çš„ Invoker é›†åˆï¼Œå¹¶è®¾ç½®ä¸ºä¸å¯å˜
47: // sort and unmodifiable
48: for (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {
49: List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
50: Collections.sort(methodInvokers, InvokerComparator.getComparator());
51: newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));
52: }
53: return Collections.unmodifiableMap(newMethodInvokerMap);
54: }
```

* ç¬¬ 3 è¡Œï¼š

newMethodInvokerMap
å˜é‡ï¼Œæ–°çš„

methodInvokerMap
å­—æ®µï¼Œåé¢ä¼šèµ‹å€¼ç»™å®ƒã€‚
* ç¬¬ 5 è¡Œï¼šåˆ›å»º Invoker é›†åˆã€‚åœ¨ã€ç¬¬ 29 è¡Œã€‘ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå®é™…å°±æ˜¯

invokersMap
çš„å€¼çš„é›†åˆã€‚
* ç¬¬ 8 è‡³ 31 è¡Œï¼šæŒ‰ç…§æ–¹æ³•åä¸º**ç»´åº¦**( KEY ) ï¼Œèšåˆ**å¯¹åº”çš„ Invoker é›†åˆ**åˆ°

newMethodInvokerMap
ä¸­ã€‚
* ç¬¬ 33 è¡Œï¼šè·¯ç”±å…¨

invokersList
ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚
* ç¬¬ 35 è¡Œï¼šæ·»åŠ 

newInvokersList
åˆ°

newMethodInvokerMap
ä¸­ï¼Œè¡¨ç¤ºè¯¥æœåŠ¡æä¾›è€…çš„**å…¨é‡** Invoker é›†åˆã€‚
* ç¬¬ 36 è‡³ 45 è¡Œï¼š**å¾ªç¯**ï¼ŒåŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚
* ç¬¬ 46 è‡³ 53 è¡Œï¼šå¾ªç¯**æ’åº**æ¯ä¸ªæ–¹æ³•çš„ Invoker é›†åˆï¼Œå¹¶è®¾ç½®ä¸º**ä¸å¯å˜**ã€‚

### 4.3.3.3 toMergeMethodInvokerMap

/#toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap)
ï¼ŒæŒ‰ç…§ **method + group**èšåˆ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {
2: Map<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();
3: // å¾ªç¯æ–¹æ³•ï¼ŒæŒ‰ç…§ method + group èšåˆ Invoker é›†åˆ
4: for (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {
5: String method = entry.getKey();
6: List<Invoker<T>> invokers = entry.getValue();
7: // æŒ‰ç…§ Group èšåˆ Invoker é›†åˆçš„ç»“æœã€‚å…¶ä¸­ï¼ŒKEYï¼šgroup VALUEï¼šInvoker é›†åˆã€‚
8: Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();
9: // å¾ªç¯ Invoker é›†åˆï¼ŒæŒ‰ç…§ group èšåˆ Invoker é›†åˆ
10: for (Invoker<T> invoker : invokers) {
11: String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, "");
12: List<Invoker<T>> groupInvokers = groupMap.get(group);
13: if (groupInvokers == null) {
14: groupInvokers = new ArrayList<Invoker<T>>();
15: groupMap.put(group, groupInvokers);
16: }
17: groupInvokers.add(invoker);
18: }
19: // å¤§å°ä¸º 1ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª
20: if (groupMap.size() == 1) {
21: result.put(method, groupMap.values().iterator().next());
22: // å¤§äº 1ï¼Œå°†æ¯ä¸ª Group çš„ Invoker é›†åˆï¼Œåˆ›å»ºæˆ Cluster Invoker å¯¹è±¡ã€‚
23: } else if (groupMap.size() > 1) {
24: List<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();
25: for (List<Invoker<T>> groupList : groupMap.values()) {
26: groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));
27: }
28: result.put(method, groupInvokers);
29: // å¤§å°ä¸º 0 ï¼Œä½¿ç”¨åŸæœ‰å€¼
30: } else {
31: result.put(method, invokers);
32: }
33: }
34: return result;
35: }
```

* ç¬¬ 2 è¡Œï¼š

result
å±æ€§ï¼Œ**æ–°çš„**

methodInvokerMap
å­—æ®µï¼Œåé¢ä¼šèµ‹å€¼ç»™å®ƒã€‚
* ç¬¬ 3 ç»ˆ 33 è¡Œï¼š**å¾ªç¯**ï¼ŒæŒ‰ç…§ **method + group** èšåˆ Invoker é›†åˆã€‚

* ç¬¬ 8 è¡Œï¼š æŒ‰ç…§ Group èšåˆ Invoker é›†åˆçš„ç»“æœã€‚å…¶ä¸­ï¼Œ**KEY**ï¼šgroup ï¼Œ**VALUE**ï¼šInvoker é›†åˆã€‚
* ç¬¬ 9 è‡³ 18 è¡Œï¼š**å¾ªç¯** Invoker é›†åˆï¼ŒæŒ‰ç…§ **group** èšåˆ Invoker é›†åˆã€‚
* ========== ç»“æœ

groupMap
å¤„ç† ==========
* ç¬¬ 19 è‡³ 21 è¡Œï¼šè‹¥æ•°é‡ä¸º 1 ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªã€‚
* ç¬¬ 29 è‡³ 32 è¡Œï¼šè‹¥æ•°é‡ä¸º 0 ï¼Œä½¿ç”¨åŸæœ‰å€¼

invokers
ã€‚å®é™…ä¸Šï¼Œå’Œã€ç¬¬ 19 è‡³ 21 è¡Œã€‘**ç­‰ä»·**ã€‚
* ç¬¬ 22 è‡³ 28 è¡Œï¼šè‹¥æ•°é‡**å¤§äº** 1 ï¼Œå¾ªç¯**æ¯ä¸ª** Group çš„ Invoker é›†åˆï¼Œè°ƒç”¨

Cluster$Adaptive/#join(Directory)
æ–¹æ³•ï¼Œåˆ›å»ºå¯¹åº”çš„ Cluster Invoker å¯¹è±¡ã€‚

* æˆ‘ä»¬å‘ç°ï¼Œæ­¤å¤„åˆ›å»º **StaticDirectory** å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5. StaticDirectoryã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) ã€‚

é‚£ä¹ˆï¼Œå¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿä¸ºä»€ä¹ˆè¦æŒ‰ç…§ **group** è¿›è¡Œèšåˆï¼Œç›´æ¥è°ƒç”¨ä¸å¯ä»¥ä¹ˆï¼Ÿè®©æˆ‘ä»¬æ¥æ‰“å¼€

ProtocolRegistry/#refer(Class<T> type, URL url)
æ–¹æ³•ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![refer](http://static2.iocoder.cn/images/Dubbo/2019_04_10/04.png)

* å½“å¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„æ—¶ï¼Œä¼š**è‡ªåŠ¨**ä½¿ç”¨åˆ°**åˆ†ç»„èšåˆ**çš„ç‰¹æ€§ã€‚é‚£ä¹ˆä¹‹å MergeableCluster ä¼šæ€ä¹ˆåšå‘¢ï¼Ÿè¯¦ç»†è§£æï¼Œè§åæ–‡ ğŸ˜ˆã€‚

### 4.3.3.4 destroyUnusedInvokers

/#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)
æ–¹æ³•ï¼Œ**é”€æ¯**ä¸å†ä½¿ç”¨çš„ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap, Map<String, Invoker<T>> newUrlInvokerMap){
// é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œç›®å‰ä¸å­˜åœ¨è¿™ä¸ªæƒ…å†µ
if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
// é”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker
destroyAllInvokers();
return;
}
// check deleted invoker
// å¯¹æ¯”æ–°è€é›†åˆï¼Œè®¡ç®—éœ€è¦é”€æ¯çš„ Invoker é›†åˆ
List<String> deleted = null;
if (oldUrlInvokerMap != null) {
Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();
for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {
// è‹¥ä¸å­˜åœ¨ï¼Œæ·»åŠ åˆ° `deleted` ä¸­
if (!newInvokers.contains(entry.getValue())) {
if (deleted == null) {
deleted = new ArrayList<String>();
}
deleted.add(entry.getKey());
}
}
}
// è‹¥æœ‰éœ€è¦é”€æ¯çš„ Invoker ï¼Œåˆ™è¿›è¡Œé”€æ¯
if (deleted != null) {
for (String url : deleted) {
if (url != null) {
// ç§»é™¤å‡º `urlInvokerMap`
Invoker<T> invoker = oldUrlInvokerMap.remove(url);
if (invoker != null) {
try {
// é”€æ¯ Invoker
invoker.destroy();
if (logger.isDebugEnabled()) {
logger.debug("destroy invoker[" + invoker.getUrl() + "] success. ");
}
} catch (Exception e) {
logger.warn("destroy invoker[" + invoker.getUrl() + "] failed. " + e.getMessage(), e);
}
}
}
}
}
}
```

### 4.3.3.5 destroyAllInvokers

/#destroyAllInvokers()
æ–¹æ³•ï¼Œé”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private void destroyAllInvokers(){
Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference æœ¬åœ°å¼•ç”¨ï¼Œé¿å…å¹¶å‘é—®é¢˜
if (localUrlInvokerMap != null) {
// å¾ªç¯ urlInvokerMap ï¼Œé”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker
for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {
try {
invoker.destroy();
} catch (Throwable t) {
logger.warn("Failed to destroy service " + serviceKey + " to provider " + invoker.getUrl(), t);
}
}
// urlInvokerMap æ¸…ç©º
localUrlInvokerMap.clear();
}
// methodInvokerMap ç½®ç©º
methodInvokerMap = null;
}
```

## 4.4 doList

/#doList(Invocation)
**å®ç°**æ–¹æ³•ï¼Œè·å¾—å¯¹åº”çš„ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: @Override
2: public List<Invoker<T>> doList(Invocation invocation) {
3: if (forbidden) {
4: // 1. No service provider 2. Service providers are disabled
5: throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,
6: "No provider available from registry " + getUrl().getAddress() + " for service " + getConsumerUrl().getServiceKey() + " on consumer " + NetUtils.getLocalHost()
7: + " use dubbo version " + Version.getVersion() + ", please check status of providers(disabled, not registered or in blacklist).");
8: }
9: List<Invoker<T>> invokers = null;
10: Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap; // local reference
11: // è·å¾— Invoker é›†åˆ
12: if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {
13: // è·å¾—æ–¹æ³•åã€æ–¹æ³•å‚æ•°
14: String methodName = RpcUtils.getMethodName(invocation);
15: Object[] args = RpcUtils.getArguments(invocation);
16: // ã€ç¬¬ä¸€ã€‘å¯æ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°æšä¸¾è·¯ç”±
17: if (args != null && args.length > 0 && args[0] != null
18: && (args[0] instanceof String || args[0].getClass().isEnum())) {
19: // invokers = localMethodInvokerMap.get(methodName + "." + args[0]); // The routing can be enumerated according to the first parameter
20: invokers = localMethodInvokerMap.get(methodName + args[0]); // The routing can be enumerated according to the first parameter
21: }
22: // ã€ç¬¬äºŒã€‘æ ¹æ®æ–¹æ³•åè·å¾— Invoker é›†åˆ
23: if (invokers == null) {
24: invokers = localMethodInvokerMap.get(methodName);
25: }
26: // ã€ç¬¬ä¸‰ã€‘ä½¿ç”¨å…¨é‡ Invoker é›†åˆã€‚ä¾‹å¦‚ï¼Œ`/#$echo(name)` ï¼Œå›å£°æ–¹æ³•
27: if (invokers == null) {
28: invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);
29: }
30: // ã€ç¬¬å››ã€‘ä½¿ç”¨ `methodInvokerMap` ç¬¬ä¸€ä¸ª Invoker é›†åˆã€‚é˜²å¾¡æ€§ç¼–ç¨‹ã€‚
31: if (invokers == null) {
32: Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();
33: if (iterator.hasNext()) {
34: invokers = iterator.next();
35: }
36: }
37: }
38: return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;
39: }
```

* é€šè¿‡å››ç§æ–¹å¼ï¼Œä»

methodInvokerMap
ä¸­ï¼Œè·å¾—å¯¹åº”çš„ Invoker é›†åˆã€‚
* ç¬¬ä¸€ç§ï¼Œå¯æ ¹æ®**ç¬¬ä¸€ä¸ªå‚æ•°**æšä¸¾è·¯ç”±ã€‚è¿™æ˜¯ä¸ªéå¸¸å°ä¼—çš„åœºæ™¯ï¼Œèƒ–å‹ä¸å¿…ç†è§£ã€‚ä¾‹å­å¦‚ä¸‹ï¼š
```
// DemoService æ¥å£å®šä¹‰
public interface DemoService{
void hello(String name);
void hello01(String name);
void hello02(String name);
}
// æ¶ˆè´¹è€…è°ƒç”¨
DemoService demoService = (DemoService) context.getBean("demoService");
demoService.hello("01");
```

* é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œè°ƒç”¨åˆ°çš„æœåŠ¡æä¾›è€…çš„

DemoServiceImpl/#hello01(name)
æ–¹æ³•ã€‚
* å¦‚æœä½¿ç”¨è¯¥**ç‰¹æ€§**ï¼Œæ³¨æ„é¿å…å‡ºç°**æ— å…³**çš„å‡ ä¸ªæ–¹æ³•ï¼Œä¾‹å¦‚

/#hello(name)
å’Œ

/#hello01(name)
æ˜¯æ¯«æ— å…³ç³»çš„ä¸¤ä¸ªæ–¹æ³•ï¼Œè€Œæˆ‘çœŸçš„æƒ³è°ƒç”¨

/#hello(name)
æ–¹æ³•ï¼Œç»“æœè°ƒç”¨åˆ°äº†

/#hello01(name)
æ–¹æ³•ã€‚
* å¦‚ä¸‹æ˜¯ Dubbo Commiter **è¯£æ** çš„è§£æƒ‘ï¼Œéå¸¸æ„Ÿè°¢ã€‚
åŠ¨æ€çš„æ–¹æ³•åæœ¬èº«å°±æ˜¯æ¥å£ä¸­å·²ç»å®šä¹‰çš„

ä¸¾ä¸ªä¾‹å­å§å€Ÿå£å®šä¹‰äº† method, method1,method2ï¼Œ å¦‚æœæˆ‘å‘èµ·rpcè°ƒç”¨method(1, 2, 3), è¿™ä¸ªæ—¶å€™ä¼šå»æŸ¥æ‰¾æ–¹æ³•method1çš„invokersï¼Œ å¦‚æœæˆ‘è¿™ä¸ªæ—¶å€™å‘èµ·rpc method(2, 1, 3), è¿™ä¸ªæ—¶å€™ä¼šå»æŸ¥æ‰¾æ–¹æ³•method2çš„invokersï¼Œ ç„¶åè°ƒç”¨invokersçš„methodæ–¹æ³•

* å¦å¤–ï¼Œç»è¿‡æ²Ÿé€šï¼Œã€ç¬¬ 19 è¡Œã€‘çš„

"."
æ˜¯ä¸ª BUG ï¼Œæ–¹æ³•é‡Œä¸èƒ½åŒ…å«è¯¥å­—ç¬¦ï¼Œå› æ­¤ï¼Œç¬”è€…æ”¹æˆäº†ã€ç¬¬ 20 è¡Œã€‘ï¼Œå»æ‰äº†

"."
è¿›è¡Œæµ‹è¯•ã€‚
* ç¬¬äºŒç§ï¼Œæ ¹æ®**æ–¹æ³•å**è·å¾— Invoker é›†åˆã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œéƒ½èƒ½åŒ¹é…åˆ°ã€‚
* ç¬¬ä¸‰ç§ï¼Œä½¿ç”¨å…¨é‡ Invoker é›†åˆã€‚ä¾‹å¦‚ï¼Œ

/#$echo(name)
å›å£°æ–¹æ³•ã€‚
* ç¬¬å››ç§ï¼Œä½¿ç”¨

methodInvokerMap
ç¬¬ä¸€ä¸ª Invoker é›†åˆã€‚é˜²å¾¡æ€§ç¼–ç¨‹ã€‚

## 4.5 isAvailable

```
@Override
public boolean isAvailable(){
// è‹¥å·²é”€æ¯ï¼Œè¿”å›ä¸å¯ç”¨
if (isDestroyed()) {
return false;
}
// ä»»æ„ä¸€ä¸ª Invoker å¯ç”¨ï¼Œåˆ™è¿”å›å¯ç”¨
Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;
if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {
for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {
if (invoker.isAvailable()) {
return true;
}
}
}
return false;
}
```

## 4.6 destroy

```
@Override
public void destroy(){
if (isDestroyed()) {
return;
}
// å–æ¶ˆè®¢é˜…
// unsubscribe.
try {
if (getConsumerUrl() != null && registry != null && registry.isAvailable()) {
registry.unsubscribe(getConsumerUrl(), this);
}
} catch (Throwable t) {
logger.warn("unexpeced error when unsubscribe service " + serviceKey + "from registry" + registry.getUrl(), t);
}
// æ ‡è®°å·²ç»é”€æ¯
super.destroy(); // must be executed after unsubscribing
// é”€æ¯æ‰€æœ‰ Invoker
try {
destroyAllInvokers();
} catch (Throwable t) {
logger.warn("Failed to destroy service " + serviceKey, t);
}
}
```

# 5. StaticDirectory

com.alibaba.dubbo.rpc.cluster.directory.StaticDirectory
ï¼Œå®ç° AbstractDirectory æŠ½è±¡ç±»ï¼Œ**é™æ€** Directory å®ç°ç±»ã€‚é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå°†ä¼ å…¥çš„

invokers
é›†åˆï¼Œå°è£…æˆé™æ€çš„ Directory å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class StaticDirectory<T> extends AbstractDirectory<T>{
//*/*
/* Invoker é›†åˆ
/*/
private final List<Invoker<T>> invokers;
public StaticDirectory(List<Invoker<T>> invokers){
this(null, invokers, null);
}
public StaticDirectory(List<Invoker<T>> invokers, List<Router> routers){
this(null, invokers, routers);
}
public StaticDirectory(URL url, List<Invoker<T>> invokers){
this(url, invokers, null);
}
public StaticDirectory(URL url, List<Invoker<T>> invokers, List<Router> routers){
// é»˜è®¤ä½¿ç”¨ `url` å‚æ•°ã€‚å½“å®ƒä¸ºç©ºæ—¶ï¼Œä½¿ç”¨ `invokers[0].url` ã€‚
super(url == null && invokers != null && !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers);
if (invokers == null || invokers.isEmpty()) {
throw new IllegalArgumentException("invokers == null");
}
this.invokers = invokers;
}
@Override
public Class<T> getInterface(){
return invokers.get(0).getInterface();
}
@Override
public boolean isAvailable(){
// è‹¥å·²ç»é”€æ¯ï¼Œåˆ™ä¸å¯ç”¨
if (isDestroyed()) {
return false;
}
// ä»»ä¸€ä¸€ä¸ª Invoker å¯ç”¨ï¼Œåˆ™ä¸ºå¯ç”¨
for (Invoker<T> invoker : invokers) {
if (invoker.isAvailable()) {
return true;
}
}
return false;
}
@Override
public void destroy(){
// è‹¥å·²ç»é”€æ¯ï¼Œ è·³è¿‡
if (isDestroyed()) {
return;
}
// é”€æ¯
super.destroy();
// é”€æ¯æ¯ä¸ª Invoker
for (Invoker<T> invoker : invokers) {
invoker.destroy();
}
// æ¸…ç©º Invoker é›†åˆ
invokers.clear();
}
@Override
protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {
return invokers;
}
}
```

* ä»£ç æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹è‡ªå·±çœ‹ä¸‹ã€‚

é™¤äº†åœ¨ [ã€Œ4.3.3.3 toMergeMethodInvokerMapã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/) æ–¹æ³•ä¸­ï¼Œä½¿ç”¨åˆ°äº† StaticDirectory å¯¹è±¡ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹

ReferenceConfig/#createProxy(Map<String, String> map)
çš„ä½¿ç”¨ï¼Œä»£ç å¦‚ä¸‹å›¾ï¼š

![createProxy](http://static2.iocoder.cn/images/Dubbo/2019_04_10/05.png)

* ç¬¬ 522 è‡³ 527 è¡Œï¼šå½“

registryURL
éç©ºæ—¶ï¼Œæ„å‘³ç€**æœ‰æ³¨å†Œä¸­å¿ƒ**ï¼Œä½¿ç”¨

cluster=available
é›†ç¾¤æ–¹å¼ï¼Œå¹¶è°ƒç”¨

Cluster$Adaptive/#join(StaticDirectory)
æ–¹æ³•ï¼Œåˆ›å»ºå¯¹åº”çš„ Cluster Invoker å¯¹è±¡ã€‚è¿™æ„å‘³ç€ï¼ŒæœåŠ¡è°ƒç”¨æ—¶ï¼Œå› ä¸ºä½¿ç”¨çš„æ˜¯

cluster=available
ï¼Œ**ä»…è°ƒç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„ Invoker å¯¹è±¡**ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥åšä¸€ä¸ª YY ï¼š

* ç›®å‰æˆ‘ä»¬æœ‰ A , B ä¸¤ä¸ªæœºæˆ¿ï¼Œåˆ†åˆ«å¯¹åº” zk01 é›†ç¾¤ï¼Œzk02 é›†ç¾¤ã€‚è¿™ä¸¤ä¸ª zk é›†ç¾¤**ä¸äº’é€š** ã€‚
* A , B æœºæˆ¿ï¼Œåˆ†åˆ«éƒ¨ç½²äº† **User æœåŠ¡æä¾›è€…**ï¼Œä»…æ³¨å†Œåˆ°è‡ªå·±æœºæˆ¿çš„ zk é›†ç¾¤ã€‚
* A , B æœºæˆ¿ï¼Œéƒ¨ç½²äº†å¯¹åº”çš„ **User æœåŠ¡æ¶ˆè´¹**ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬å¸Œæœ›ä¼˜å…ˆè°ƒç”¨æœ¬æœºæˆ¿ã€‚å½“æœ¬æœºæˆ¿ **User æœåŠ¡æä¾›è€…**å…¨æŒ‚çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨å¦å¤–ä¸€ä¸ªæœºæˆ¿ï¼Œè¯¥å¦‚ä½•é…ç½®å‘¢ï¼Ÿ
```
// A æœºæˆ¿
<dubbo:reference interface="com.alibaba.dubbo.demo.UserService" registry="zk01,zk02" />
// B æœºæˆ¿
<dubbo:reference interface="com.alibaba.dubbo.demo.UserService" registry="zk02,zk01" />
```

* å³åœ¨

"registry"
é…ç½®é¡¹ä¸­ï¼Œå°†è‡ªå·±çš„ zk é›†ç¾¤æ”¾åœ¨å‰é¢ã€‚
* å½“ç„¶ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå¾ˆå°‘ä¼šå‡ºç°ä¸€ä¸ªæœºæˆ¿æœåŠ¡æä¾›è€…å…¨æŒ‚ï¼Œzk é›†ç¾¤è¿˜å­˜æ´»ç€ã€‚

# 6. ClusterUtils

com.alibaba.dubbo.rpc.cluster.support.ClusterUtils
ï¼ŒCluster å·¥å…·ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: public class ClusterUtils{
2:
3: private ClusterUtils(){
4: }
5:
6: public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap){
7: // åˆå¹¶é…ç½® Map ç»“æœ
8: Map<String, String> map = new HashMap<String, String>();
9: // è¿œç¨‹é…ç½® Map ç»“æœ
10: Map<String, String> remoteMap = remoteUrl.getParameters();
11:
12: // æ·»åŠ  `remoteMap` åˆ° `map` ä¸­ï¼Œå¹¶ç§»é™¤ä¸å¿…è¦çš„é…ç½®
13: if (remoteMap != null && remoteMap.size() > 0) {
14: map.putAll(remoteMap);
15:
16: // Remove configurations from provider, some items should be affected by provider. çº¿ç¨‹æ± é…ç½®ä¸ä½¿ç”¨æä¾›è€…çš„
17: map.remove(Constants.THREAD_NAME_KEY);
18: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREAD_NAME_KEY);
19:
20: map.remove(Constants.THREADPOOL_KEY);
21: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADPOOL_KEY);
22:
23: map.remove(Constants.CORE_THREADS_KEY);
24: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.CORE_THREADS_KEY);
25:
26: map.remove(Constants.THREADS_KEY);
27: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADS_KEY);
28:
29: map.remove(Constants.QUEUES_KEY);
30: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.QUEUES_KEY);
31:
32: map.remove(Constants.ALIVE_KEY);
33: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.ALIVE_KEY);
34:
35: map.remove(Constants.TRANSPORTER_KEY);
36: map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.TRANSPORTER_KEY);
37: }
38: // æ·»åŠ  `localMap` åˆ° `map` ä¸­
39: if (localMap != null && localMap.size() > 0) {
40: map.putAll(localMap);
41: }
42:
43: // æ·»åŠ æŒ‡å®šçš„ `remoteMap` çš„é…ç½®é¡¹åˆ° `map` ä¸­ï¼Œå› ä¸ºä¸Šé¢è¢« `localMap` è¦†ç›–äº†ã€‚
44: if (remoteMap != null && remoteMap.size() > 0) {
45: // Use version passed from provider side
46: String dubbo = remoteMap.get(Constants.DUBBO_VERSION_KEY);
47: if (dubbo != null && dubbo.length() > 0) {
48: map.put(Constants.DUBBO_VERSION_KEY, dubbo);
49: }
50: String version = remoteMap.get(Constants.VERSION_KEY);
51: if (version != null && version.length() > 0) {
52: map.put(Constants.VERSION_KEY, version);
53: }
54: String group = remoteMap.get(Constants.GROUP_KEY);
55: if (group != null && group.length() > 0) {
56: map.put(Constants.GROUP_KEY, group);
57: }
58: String methods = remoteMap.get(Constants.METHODS_KEY);
59: if (methods != null && methods.length() > 0) {
60: map.put(Constants.METHODS_KEY, methods);
61: }
62: // Reserve timestamp of provider url. ä¿ç•™ provider çš„å¯åŠ¨ timestamp
63: String remoteTimestamp = remoteMap.get(Constants.TIMESTAMP_KEY);
64: if (remoteTimestamp != null && remoteTimestamp.length() > 0) {
65: map.put(Constants.REMOTE_TIMESTAMP_KEY, remoteMap.get(Constants.TIMESTAMP_KEY));
66: }
67: // Combine filters and listeners on Provider and Consumer åˆå¹¶ filter å’Œ listener
68: String remoteFilter = remoteMap.get(Constants.REFERENCE_FILTER_KEY);
69: String localFilter = localMap.get(Constants.REFERENCE_FILTER_KEY);
70: if (remoteFilter != null && remoteFilter.length() > 0
71: && localFilter != null && localFilter.length() > 0) {
72: localMap.put(Constants.REFERENCE_FILTER_KEY, remoteFilter + "," + localFilter);
73: }
74: String remoteListener = remoteMap.get(Constants.INVOKER_LISTENER_KEY);
75: String localListener = localMap.get(Constants.INVOKER_LISTENER_KEY);
76: if (remoteListener != null && remoteListener.length() > 0
77: && localListener != null && localListener.length() > 0) {
78: localMap.put(Constants.INVOKER_LISTENER_KEY, remoteListener + "," + localListener);
79: }
80: }
81:
82: // æ¸…ç©ºåŸæœ‰é…ç½®ï¼Œä½¿ç”¨åˆå¹¶çš„é…ç½®è¦†ç›–
83: return remoteUrl.clearParameters().addParameters(map);
84: }
85:
86: }
```

* å°†

localMap
å’Œ

remoteUrl.parameters
**åˆå¹¶**æˆ

map
ï¼Œå¤§å¤šæ•°ä»¥**å‰è€…**ä¸ºä¸»ã€ç¬¬ 12 è‡³ 41 è¡Œã€‘ï¼Œéƒ¨åˆ†**æŒ‡å®š**ä»¥åè€…ä¸ºä¸»ã€ç¬¬ 43 è‡³ 80 è¡Œã€‘ã€‚
* å°†åˆå¹¶çš„

map
çš„ç»“æœï¼Œ**è¦†ç›–**è®¾ç½®åˆ°

remoteUrl
ä¸­ã€‚