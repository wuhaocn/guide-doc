# é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self) ä¸€æ–‡ï¼Œåˆ†äº«

dubbo-cluster
æ¨¡å—ï¼Œ

router
åŒ…ï¼Œå®ç° Dubbo çš„**è·¯ç”±è§„åˆ™**åŠŸèƒ½ã€‚

Router ç›¸å…³ç±»ï¼Œå¦‚ä¸‹å›¾ï¼š

![Router ç›¸å…³ç±»](http://static2.iocoder.cn/images/Dubbo/2019_04_30/02.png)
è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” è·¯ç”±è§„åˆ™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html) æ–‡æ¡£ã€‚å¦‚æœä¹‹å‰æ²¡äº†è§£è¿‡è¯¥åŠŸèƒ½çš„èƒ–å‹ï¼Œè¯·å…ˆé˜…è¯»äº†è§£ä¸‹å“ˆã€‚

# 2. RouterFactory

com.alibaba.dubbo.rpc.cluster.RouterFactory
ï¼ŒRouter å·¥å‚**æ¥å£**ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
@SPI
public interface RouterFactory{
//*/*
/* Create router.
/*
/* åˆ›å»º Router å¯¹è±¡
/*
/* @param url
/* @return router
/*/
@Adaptive("protocol")
Router getRouter(URL url);
}
```

* @SPI
æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œæ— é»˜è®¤å€¼ã€‚
* @Adaptive("protocol")
æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Router å®ç°ï¼Œä½¿ç”¨

URL.protocol
å±æ€§ã€‚
* /#getRouter(URL url)
æ¥å£æ–¹æ³•ï¼Œè·å¾— Router å¯¹è±¡ã€‚

## 2.1 ConditionRouterFactory

com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouterFactory
ï¼Œå®ç° RouterFactory æ¥å£ï¼Œ**ConditionRouter** å·¥å‚å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class ConditionRouterFactory implements RouterFactory{
public static final String NAME = "condition";
@Override
public Router getRouter(URL url){
return new ConditionRouter(url);
}
}
```

* å¯¹åº” Router å®ç°ç±»ä¸º ConditionRouter ã€‚

## 2.2 ScriptRouterFactory

com.alibaba.dubbo.rpc.cluster.router.script.ScriptRouterFactory
ï¼Œå®ç° RouterFactory æ¥å£ï¼Œ**ScriptRouter** å·¥å‚å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public class ScriptRouterFactory implements RouterFactory{
public static final String NAME = "script";
@Override
public Router getRouter(URL url){
return new ScriptRouter(url);
}
}
```

* å¯¹åº” Router å®ç°ç±»ä¸º ScriptRouter ã€‚

## 2.3 FileRouterFactory

com.alibaba.dubbo.rpc.cluster.router.file.FileRouterFactory
ï¼Œå®ç° RouterFactory æ¥å£ï¼ŒåŸºäº**æ–‡ä»¶**è¯»å–è·¯ç”±è§„åˆ™ï¼Œåˆ›å»º**å¯¹åº”çš„ Router å®ç°ç±»çš„å¯¹è±¡**ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: public class FileRouterFactory implements RouterFactory{
2:
3: public static final String NAME = "file";
4:
5: //*/*
6: /* RouterFactory$Adaptive å¯¹è±¡
7: /*/
8: private RouterFactory routerFactory;
9:
10: public void setRouterFactory(RouterFactory routerFactory){
11: this.routerFactory = routerFactory;
12: }
13:
14: @Override
15: public Router getRouter(URL url){
16: try {
17: // Transform File URL into Script Route URL, and Load
18: // file:///d:/path/to/route.js?router=script ==> script:///d:/path/to/route.js?type=js&rule=<file-content>
19: // è·å¾— router é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º script
20: String protocol = url.getParameter(Constants.ROUTER_KEY, ScriptRouterFactory.NAME); // Replace original protocol (maybe 'file') with 'script'
21: // ä½¿ç”¨æ–‡ä»¶åç¼€åšä¸ºç±»å‹
22: String type = null; // Use file suffix to config script type, e.g., js, groovy ...
23: String path = url.getPath();
24: if (path != null) {
25: int i = path.lastIndexOf('.');
26: if (i > 0) {
27: type = path.substring(i + 1);
28: }
29: }
30: // è¯»å–è§„åˆ™å†…å®¹
31: String rule = IOUtils.read(new FileReader(new File(url.getAbsolutePath())));
32:
33: // åˆ›å»ºè·¯ç”±è§„åˆ™ URL
34: boolean runtime = url.getParameter(Constants.RUNTIME_KEY, false);
35: URL script = url.setProtocol(protocol).addParameter(Constants.TYPE_KEY, type)
36: .addParameter(Constants.RUNTIME_KEY, runtime)
37: .addParameterAndEncoded(Constants.RULE_KEY, rule);
38:
39: // é€šè¿‡ Dubbo SPI Adaptive æœºåˆ¶ï¼Œè·å¾— Router å¯¹è±¡
40: return routerFactory.getRouter(script);
41: } catch (IOException e) {
42: throw new IllegalStateException(e.getMessage(), e);
43: }
44: }
45:
46: }
```

* ç¬¬ 20 è¡Œï¼šè·å¾—

"router"
é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º

"script"
ã€‚
* ç¬¬ 21 è‡³ 29 è¡Œï¼šè·å¾—**ç±»å‹**ï¼ŒåŸºäºæ–‡ä»¶åç¼€ã€‚
* ç¬¬ 31 è¡Œï¼šä»**æ–‡ä»¶**ä¸­ï¼Œè¯»å–**è§„åˆ™å†…å®¹**ã€‚
* ç¬¬ 33 è‡³ 37 è¡Œï¼šåˆ›å»ºè·¯ç”±è§„åˆ™ URL å¯¹è±¡ã€‚
* ç¬¬ 40 è¡Œï¼šé€šè¿‡ Dubbo SPI **Adaptive** æœºåˆ¶ï¼Œè·å¾—**å¯¹åº”çš„ Router å¯¹è±¡**ã€‚

# 3. Router

com.alibaba.dubbo.rpc.cluster.Router
ï¼Œå®ç° Comparable æ¥å£ï¼Œ**è·¯ç”±è§„åˆ™**æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public interface Router extends Comparable<Router>{
//*/*
/* get the router url.
/* <p>
/* è·¯ç”±è§„åˆ™ URL
/*
/* @return url
/*/
URL getUrl();
//*/*
/* route.
/*
/* è·¯ç”±ï¼Œç­›é€‰åŒ¹é…çš„ Invoker é›†åˆ
/*
/* @param invokers Invoker é›†åˆ
/* @param url refer url
/* @param invocation
/* @return routed invokers è·¯ç”±åçš„ Invoker é›†åˆ
/* @throws RpcException
/*/
<T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;
}
```

* **ä¸€ä¸ª Router å¯¹è±¡ï¼Œå¯¹åº”ä¸€æ¡è·¯ç”±è§„åˆ™**ã€‚
* Configurator æœ‰**ä¼˜å…ˆçº§**çš„è¦æ±‚ï¼Œæ‰€ä»¥å®ç° Comparable æ¥å£ã€‚
* /#getUrl()
æ¥å£æ–¹æ³•ï¼Œè·å¾—è·¯ç”± URL ï¼Œé‡Œé¢å¸¦æœ‰è·¯ç”±è§„åˆ™ã€‚
* /#route(List<Invoker<T>> invokers, URL url, Invocation invocation)
æ¥å£æ–¹æ³•ï¼Œè·¯ç”±ï¼Œç­›é€‰**åŒ¹é…çš„**Invoker é›†åˆã€‚

## 3.1 ConditionRouter

com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouter
ï¼Œå®ç° Router æ¥å£ï¼Œ**åŸºäºæ¡ä»¶è¡¨è¾¾å¼**çš„ Router å®ç°ç±»ã€‚
åŸºäºæ¡ä»¶è¡¨è¾¾å¼çš„è·¯ç”±è§„åˆ™ï¼Œå¦‚ï¼š

host = 10.20.153.10 => host = 10.20.153.11

**æ³¨æ„**ï¼Œèƒ–å‹ä¸€å®šè¦çœ‹äº† [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” è·¯ç”±è§„åˆ™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html#%E6%9D%A1%E4%BB%B6%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99) çš„ [æ¡ä»¶è·¯ç”±è§„åˆ™](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/) éƒ¨åˆ†ï¼Œä¸ç„¶ä¸‹é¢å½±å“ç†è§£ã€‚

### 3.1.1 æ„é€ æ–¹æ³•

```
//*/*
/* åˆ†ç»„æ­£åˆ™åŒ¹é…ï¼Œè¯¦ç»†è§ {@link /#parseRule(String)} æ–¹æ³•
/*
/* å‰ [] ä¸ºåŒ¹é…ï¼Œåˆ†éš”ç¬¦
/* å [] ä¸ºåŒ¹é…ï¼Œå†…å®¹
/*/
private static Pattern ROUTE_PATTERN = Pattern.compile("([&!=,]/*)\\s/*([^&!=,\\s]+)");
//*/*
/* è·¯ç”±è§„åˆ™ URL
/*/
private final URL url;
//*/*
/* è·¯ç”±è§„åˆ™çš„ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰æ‰§è¡Œï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º 0 ã€‚
/*/
private final int priority;
//*/*
/* å½“è·¯ç”±ç»“æœä¸ºç©ºæ—¶ï¼Œæ˜¯å¦å¼ºåˆ¶æ‰§è¡Œï¼Œå¦‚æœä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè·¯ç”±ç»“æœä¸ºç©ºçš„è·¯ç”±è§„åˆ™å°†è‡ªåŠ¨å¤±æ•ˆï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º false ã€‚
/*/
private final boolean force;
//*/*
/* æ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶é›†åˆï¼Œé€šè¿‡è§£æã€æ¡ä»¶è¡¨è¾¾å¼ rule çš„ `=>` ä¹‹å‰åŠéƒ¨åˆ†ã€‘
/*/
private final Map<String, MatchPair> whenCondition;
//*/*
/* æä¾›è€…åœ°å€åˆ—è¡¨çš„è¿‡æ»¤æ¡ä»¶ï¼Œé€šè¿‡è§£æã€æ¡ä»¶è¡¨è¾¾å¼ rule çš„ `=>` ä¹‹ååŠéƒ¨åˆ†ã€‘
/*/
private final Map<String, MatchPair> thenCondition;
public ConditionRouter(URL url){
this.url = url;
this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
this.force = url.getParameter(Constants.FORCE_KEY, false);
try {
// æ‹†åˆ†æ¡ä»¶å˜å¤§æ—¶ä¸º when å’Œ then ä¸¤éƒ¨åˆ†
String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
if (rule == null || rule.trim().length() == 0) {
throw new IllegalArgumentException("Illegal route rule!");
}
rule = rule.replace("consumer.", "").replace("provider.", "");
int i = rule.indexOf("=>");
String whenRule = i < 0 ? null : rule.substring(0, i).trim();
String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
// è§£æ `whenCondition`
Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || "true".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);
// è§£æ `thenCondition`
Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || "false".equals(thenRule) ? null : parseRule(thenRule);
// NOTE: It should be determined on the business level whether the `When condition` can be empty or not.
this.whenCondition = when;
this.thenCondition = then;
} catch (ParseException e) {
throw new IllegalStateException(e.getMessage(), e);
}
}
```

* æ¯ä¸ªå­—æ®µçš„è§£é‡Šï¼Œèƒ–å‹è‡ªå·±çœ‹ä¸‹æ³¨é‡Šã€‚
* MatchPair ï¼Œè§ [ã€Œ3.1.2 MatchPairã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/) ä¸­ã€‚
* /#parseRule()
æ–¹æ³•ï¼Œè§ [ã€Œ3.1.3 parseRuleã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/) ä¸­ã€‚

### 3.1.2 MatchPair

MatchPair ä¸º ConditionRouter çš„**å†…éƒ¨é™æ€ç±»**ï¼Œç”¨äºåŒ¹é…çš„å€¼**ç»„**ã€‚**æ¯ä¸ª**å±æ€§æ¡ä»¶ï¼Œä¾‹å¦‚

method

host
ç­‰ï¼Œå¯¹åº”**ä¸€ä¸ª** MatchPair å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private static final class MatchPair{
//*/*
/* åŒ¹é…çš„å€¼é›†åˆ
/*/
final Set<String> matches = new HashSet<String>();
//*/*
/* ä¸åŒ¹é…çš„å€¼é›†åˆ
/*/
final Set<String> mismatches = new HashSet<String>();
//*/*
/* åˆ¤æ–­ value æ˜¯å¦åŒ¹é… matches + mismatches
/*
/* @param value å€¼
/* @param param URL
/* @return æ˜¯å¦åŒ¹é…
/*/
private boolean isMatch(String value, URL param){
// åªåŒ¹é… matches
if (!matches.isEmpty() && mismatches.isEmpty()) {
for (String match : matches) {
if (UrlUtils.isMatchGlobPattern(match, value, param)) {
return true;
}
}
return false; // å¦‚æœæ²¡åŒ¹é…ä¸Šï¼Œè®¤ä¸ºä¸º false ï¼Œå³ä¸åŒ¹é…
}
// åªåŒ¹é… mismatches
if (!mismatches.isEmpty() && matches.isEmpty()) {
for (String mismatch : mismatches) {
if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
return false;
}
}
return true; // æ³¨æ„ï¼Œè¿™é‡Œå’Œä¸Šé¢ä¸åŒã€‚åŸå› ï¼Œä½ æ‡‚çš„ã€‚
}
// åŒ¹é… mismatches + matches
if (!matches.isEmpty()) {
//when both mismatches and matches contain the same value, then using mismatches first
for (String mismatch : mismatches) {
if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
return false;
}
}
for (String match : matches) {
if (UrlUtils.isMatchGlobPattern(match, value, param)) {
return true;
}
}
return false; // å¦‚æœæ²¡åŒ¹é…ä¸Šï¼Œè®¤ä¸ºä¸º false ï¼Œå³ä¸åŒ¹é…
}
return false;
}
}
```

* /#isMatch(String value, URL param)
æ–¹æ³•ï¼Œåˆ¤æ–­

value
æ˜¯å¦**åŒ¹é…**

matches
å’Œ

mismatches
ã€‚

* é‚£ä¹ˆä¸ºä»€ä¹ˆä¼šæœ‰

param
å‚æ•°å‘¢ï¼Ÿå› ä¸ºè¦æ”¯æŒ

$
ä» URL ä¸­ï¼Œè¯»å–å‚æ•°ã€‚
* /#UrlUtils/#isMatchGlobPattern(match, value, URL)
æ–¹æ³•ï¼Œæ”¯æŒ

/*
é€šé…ï¼Œåˆ¤æ–­

match
å’Œ

value
æ˜¯å¦åŒ¹é…ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
public static boolean isMatchGlobPattern(String pattern, String value, URL param){
// ä»¥ç¾å…ƒç¬¦ `$` å¼€å¤´ï¼Œè¡¨ç¤ºå¼•ç”¨å‚æ•°
if (param != null && pattern.startsWith("$")) {
pattern = param.getRawParameter(pattern.substring(1));
}
// åŒ¹é…
return isMatchGlobPattern(pattern, value);
}
public static boolean isMatchGlobPattern(String pattern, String value){
// å…¨åŒ¹é…
if ("/*".equals(pattern)) {
return true;
}
// å…¨éƒ¨ä¸ºç©ºï¼ŒåŒ¹é…
if ((pattern == null || pattern.length() == 0) && (value == null || value.length() == 0)) {
return true;
}
// æœ‰ä¸€ä¸ªä¸ºç©ºï¼Œä¸åŒ¹é…
if ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) {
return false;
}
// æ”¯æŒ /* çš„é€šé…
int i = pattern.lastIndexOf('/*');
// doesn't find "/*"
if (i == -1) {
return value.equals(pattern);
}
// "/*" is at the end
else if (i == pattern.length() - 1) {
return value.startsWith(pattern.substring(0, i));
}
// "/*" is at the beginning
else if (i == 0) {
return value.endsWith(pattern.substring(i + 1));
}
// "/*" is in the middle
else {
String prefix = pattern.substring(0, i);
String suffix = pattern.substring(i + 1);
return value.startsWith(prefix) && value.endsWith(suffix);
}
}
```

* x

ğŸ˜ˆ ä»£ç æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥èƒ–å‹è‡ªå·±è¯»ä¸‹ã€‚

### 3.1.3 parseRule

/#parseRule(rule)
æ–¹æ³•ï¼Œè§£æè·¯ç”±é…ç½®å†…å®¹

"rule"
ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: private static Map<String, MatchPair> parseRule(String rule) throws ParseException{
2: // System.out.println("rule: " + rule); // add by èŠ‹è‰¿ï¼Œæ–¹ä¾¿å¤§å®¶çœ‹
3: Map<String, MatchPair> condition = new HashMap<String, MatchPair>();
4: if (StringUtils.isBlank(rule)) {
5: return condition;
6: }
7: // Key-Value pair, stores both match and mismatch conditions
8: MatchPair pair = null;
9: // Multiple values
10: Set<String> values = null;
11: final Matcher matcher = ROUTE_PATTERN.matcher(rule);
12: while (matcher.find()) { // Try to match one by one
13: String separator = matcher.group(1);
14: String content = matcher.group(2);
15: // System.out.println(separator + "\t" + content); // add by èŠ‹è‰¿ï¼Œæ–¹ä¾¿å¤§å®¶çœ‹
16: // Start part of the condition expression.
17: if (separator == null || separator.length() == 0) {
18: pair = new MatchPair();
19: condition.put(content, pair);
20: }
21: // The KV part of the condition expression
22: else if ("&".equals(separator)) {
23: if (condition.get(content) == null) {
24: pair = new MatchPair();
25: condition.put(content, pair);
26: } else {
27: pair = condition.get(content);
28: }
29: }
30: // The Value in the KV part.
31: else if ("=".equals(separator)) {
32: if (pair == null) {
33: throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
34: }
35: values = pair.matches;
36: values.add(content);
37: }
38: // The Value in the KV part.
39: else if ("!=".equals(separator)) {
40: if (pair == null) {
41: throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
42: }
43: values = pair.mismatches;
44: values.add(content);
45: }
46: // The Value in the KV part, if Value have more than one items.
47: else if (",".equals(separator)) { // Should be seperateed by ','
48: if (values == null || values.isEmpty()) {
49: throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
50: }
51: values.add(content);
52: } else {
53: throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
54: }
55: }
56: return condition;
57: }
```

* ç¬¬ 11 è‡³ 14 è¡Œï¼šé€šè¿‡

ROUTE_PATTERN
æ­£åˆ™åŒ¹é…

rule
ï¼Œ**å¾ªç¯**å¤šæ¬¡ï¼Œç›´åˆ°ç»“æŸã€‚å¦‚ä¸‹æ˜¯ä¸¤ä¸ªä¾‹å­ï¼š
```
rule: host = 192.168.3.17 & method = say01
host
= 192.168.3.17
& method
= say01
---------- åˆ†å‰²çº¿ ----------
rule: host = 192.168.3.17
host
= 192.168.3.17
```
* ç¬¬ 16 è‡³ 29 è¡Œï¼šå¤„ç†æ¡ä»¶**å±æ€§**çš„æƒ…å†µï¼Œä¾‹å¦‚ï¼š

host
å’Œ

& method
ç­‰ç­‰ï¼Œæ­¤æ—¶ä¼šè·å¾—å¯¹åº”çš„ MatchPair å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»º MatchPair å¯¹è±¡ã€‚
* ç¬¬ 30 è‡³ 45 è¡Œï¼šå¤„ç†æ¡ä»¶**æ¡ä»¶å€¼**çš„æƒ…å†µï¼Œä¾‹å¦‚ï¼š

= 192.168.3.17
å’Œ

!= say01
ç­‰ç­‰ï¼Œæ­¤æ—¶ä¼šæ·»åŠ åˆ° MatchPair çš„

matches
æˆ–

mismatches
ä¸­ã€‚

* ç¬¬ 46 è‡³ 51 è¡Œï¼šå¤„ç†æ¡ä»¶**æ¡ä»¶å€¼**ä»¥é€—å·(

,
)åˆ†éš”å¤šä¸ªå€¼çš„æƒ…å†µï¼Œæ­¤æ—¶**ä¹Ÿä¼š**æ·»åŠ åˆ° MatchPair çš„

matches
æˆ–

mismatches
ä¸­ã€‚
* ç¬¬ 52 è‡³ 54 è¡Œï¼šéæ³•ï¼ŒæŠ›å‡º ParseException å¼‚å¸¸ã€‚

### 3.1.4 route

```
1: @Override
2: public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
3: // ä¸ºç©ºï¼Œç›´æ¥è¿”å›ç©º Invoker é›†åˆ
4: if (invokers == null || invokers.isEmpty()) {
5: return invokers;
6: }
7: try {
8: // ä¸åŒ¹é… `whenCondition` ï¼Œç›´æ¥è¿”å› `invokers` é›†åˆï¼Œå› ä¸ºä¸éœ€è¦èµ° `whenThen` çš„åŒ¹é…
9: if (!matchWhen(url, invocation)) {
10: return invokers;
11: }
12: List<Invoker<T>> result = new ArrayList<Invoker<T>>();
13: // `whenThen` ä¸ºç©ºï¼Œåˆ™è¿”å›ç©º Invoker é›†åˆ
14: if (thenCondition == null) {
15: logger.warn("The current consumer in the service blacklist. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey());
16: return result;
17: }
18: // ä½¿ç”¨ `whenThen` ï¼ŒåŒ¹é… `invokers` é›†åˆã€‚è‹¥ç¬¦åˆï¼Œæ·»åŠ åˆ° `result` ä¸­
19: for (Invoker<T> invoker : invokers) {
20: if (matchThen(invoker.getUrl(), url)) {
21: result.add(invoker);
22: }
23: }
24: // è‹¥ `result` éç©ºï¼Œè¿”å›å®ƒ
25: if (!result.isEmpty()) {
26: return result;
27: // å¦‚æœ `force=true` ï¼Œä»£è¡¨å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å›ç©º Invoker é›†åˆ
28: } else if (force) {
29: logger.warn("The route result is empty and force execute. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey() + ", router: " + url.getParameterAndDecoded(Constants.RULE_KEY));
30: return result;
31: }
32: } catch (Throwable t) {
33: logger.error("Failed to execute condition router rule: " + getUrl() + ", invokers: " + invokers + ", cause: " + t.getMessage(), t);
34: }
35: // å¦‚æœ `force=false` ï¼Œä»£è¡¨ä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å› `invokers` é›†åˆï¼Œå³å¿½ç•¥è·¯ç”±è§„åˆ™
36: return invokers;
37: }
```

* ç¬¬ 3 è‡³ 6 è¡Œï¼šè‹¥

invokers
ä¸ºç©ºï¼Œç›´æ¥è¿”å›**ç©º** Invoker é›†åˆã€‚
* ç¬¬ 8 è‡³ 11 è¡Œï¼šè°ƒç”¨

/#matchWhen(url, invocation)
æ–¹æ³•ï¼Œä½¿ç”¨æœåŠ¡**æ¶ˆè´¹è€…**

url
åŒ¹é…

whenCondition
ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
boolean matchWhen(URL url, Invocation invocation){
return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation);
}
```

* å¦‚æœåŒ¹é…æ¡ä»¶ä¸ºç©ºï¼Œè¡¨ç¤ºå¯¹æ‰€æœ‰æ¶ˆè´¹æ–¹åº”ç”¨ï¼Œå¦‚ï¼š

=> host != 10.20.153.11
ã€‚
* è‹¥**ä¸åŒ¹é…**ï¼Œåˆ™ç›´æ¥è¿”å›**å…¨**

invokers
é›†åˆï¼Œå› ä¸ºä¸éœ€è¦èµ°

whenThen
çš„åŒ¹é…ã€‚
* /#matchCondition(...)
æ–¹æ³•çš„è¯¦ç»†è§£æï¼Œè§ [ã€Œ3.1.5 matchConditionã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/) ã€‚
* ç¬¬ 13 è‡³ 17 è¡Œï¼šè‹¥

whenThen
ä¸ºç©ºï¼Œåˆ™è¿”å›**ç©º** Invoker é›†åˆã€‚
* ç¬¬ 18 è‡³ 23 è¡Œï¼š**å¾ªç¯**è°ƒç”¨

/#matchThen(url, invocation)
æ–¹æ³•ï¼Œä½¿ç”¨æœåŠ¡**æä¾›è€…è€…**

invokers
çš„ URL ï¼ŒåŒ¹é…

whenThen
é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private boolean matchThen(URL url, URL param){
return !(thenCondition == null || thenCondition.isEmpty()) && matchCondition(thenCondition, url, param, null);
}
```

* å¦‚æœè¿‡æ»¤æ¡ä»¶ä¸ºç©ºï¼Œè¡¨ç¤ºç¦æ­¢è®¿é—®ï¼Œå¦‚ï¼š

host = 10.20.153.10 =>
ã€‚
* è‹¥**åŒ¹é…**ï¼Œæ·»åŠ åˆ°

result
ä¸­ã€‚
* ========== å¤„ç†

result
+

force
çš„**ä¸‰ç§**æƒ…å†µ ==========
* ç¬¬ 24 è‡³ 26 è¡Œï¼šè‹¥

result
**éç©º**ï¼Œè¿”å›**å®ƒ**ã€‚
* ç¬¬ 27 è‡³ 31 è¡Œï¼šè‹¥

result
**ä¸ºç©º**ï¼Œå¦‚æœ

force=true
ï¼Œä»£è¡¨å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å›**ç©º** Invoker é›†åˆã€‚
* ç¬¬ 36 è¡Œï¼šè‹¥

result
**ä¸ºç©º**ï¼Œå¦‚æœ

force=false
ï¼Œä»£è¡¨**ä¸**å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å›**å…¨**

invokers
é›†åˆï¼Œå³**å¿½ç•¥**è·¯ç”±è§„åˆ™ã€‚

ğŸ˜ˆ æƒ…å†µæ¯”è¾ƒå¤šï¼Œèƒ–å‹å¯ä»¥å›è¿‡å¤´åœ¨ç†ä¸€ç†ã€‚

### 3.1.5 matchCondition

```
private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation){
Map<String, String> sample = url.toMap();
boolean result = false; // æ˜¯å¦åŒ¹é…
for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {
// è·å¾—æ¡ä»¶å±æ€§
String key = matchPair.getKey();
String sampleValue;
// get real invoked method name from invocation
if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {
sampleValue = invocation.getMethodName();
} else {
sampleValue = sample.get(key);
if (sampleValue == null) {
sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);
}
}
// åŒ¹é…æ¡ä»¶å€¼
if (sampleValue != null) {
if (!matchPair.getValue().isMatch(sampleValue, param)) { // è¿”å›ä¸åŒ¹é…
return false;
} else {
result = true;
}
} else {
// not pass the condition
if (!matchPair.getValue().matches.isEmpty()) { // æ— æ¡ä»¶å€¼ï¼Œä½†æ˜¯æœ‰åŒ¹é…æ¡ä»¶ `matches` ï¼Œåˆ™è¿”å›ä¸åŒ¹é…ã€‚
return false;
} else {
result = true;
}
}
}
return result;
}
```

### 3.1.5 compareTo

```
@Override
public int compareTo(Router o){
if (o == null || o.getClass() != ConditionRouter.class) {
return 1;
}
ConditionRouter c = (ConditionRouter) o;
return this.priority == c.priority ? url.toFullString().compareTo(c.url.toFullString()) : (this.priority > c.priority ? 1 : -1);
}
```

* ä¼˜å…ˆï¼ŒæŒ‰ç…§

"priority"
**é™åº**ã€‚
* å…¶æ¬¡ï¼ŒæŒ‰ç…§

"url"
**å‡åº**ã€‚

## 3.2 ScriptRouter

com.alibaba.dubbo.rpc.cluster.router.script.ScriptRouter
ï¼Œå®ç° Router æ¥å£ï¼ŒåŸºäº**è„šæœ¬**çš„ Router å®ç°ç±»ã€‚
è„šæœ¬è·¯ç”±è§„åˆ™ [4](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html#fn_4) æ”¯æŒ JDK è„šæœ¬å¼•æ“çš„æ‰€æœ‰è„šæœ¬ï¼Œæ¯”å¦‚ï¼šjavascript, jruby, groovy ç­‰ï¼Œé€šè¿‡

type=javascript
å‚æ•°è®¾ç½®è„šæœ¬ç±»å‹ï¼Œç¼ºçœä¸º javascriptã€‚
 ```
> "script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("function route(invokers) { ... } (invokers)")
>
``` 
åŸºäºè„šæœ¬å¼•æ“çš„è·¯ç”±è§„åˆ™ï¼Œå¦‚ï¼š
```
> function route(invokers) {
> var result = new java.util.ArrayList(invokers.size());
> for (i = 0; i < invokers.size(); i ++) {
> if ("10.20.153.10".equals(invokers.get(i).getUrl().getHost())) {
> result.add(invokers.get(i));
> }
> }
> return result;
> } (invokers); // è¡¨ç¤ºç«‹å³æ‰§è¡Œæ–¹æ³•
>
```

### 3.2.1 æ„é€ æ–¹æ³•

```
//*/*
/* è„šæœ¬ç±»å‹ ä¸ ScriptEngine çš„æ˜ å°„ç¼“å­˜
/*/
private static final Map<String, ScriptEngine> engines = new ConcurrentHashMap<String, ScriptEngine>();
//*/*
/* è·¯ç”±è§„åˆ™ URL
/*/
private final ScriptEngine engine;
//*/*
/* è·¯ç”±è§„åˆ™çš„ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰æ‰§è¡Œï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º 0 ã€‚
/*/
private final int priority;
//*/*
/* è·¯ç”±è§„åˆ™å†…å®¹
/*/
private final String rule;
//*/*
/* è·¯ç”±è§„åˆ™ URL
/*/
private final URL url;
public ScriptRouter(URL url){
this.url = url;
String type = url.getParameter(Constants.TYPE_KEY);
this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
// åˆå§‹åŒ– `engine`
if (type == null || type.length() == 0) {
type = Constants.DEFAULT_SCRIPT_TYPE_KEY;
}
if (rule == null || rule.length() == 0) {
throw new IllegalStateException(new IllegalStateException("route rule can not be empty. rule:" + rule));
}
ScriptEngine engine = engines.get(type);
if (engine == null) { // åœ¨ç¼“å­˜ä¸­ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»º ScriptEngine å¯¹è±¡
engine = new ScriptEngineManager().getEngineByName(type);
if (engine == null) {
throw new IllegalStateException(new IllegalStateException("Unsupported route rule type: " + type + ", rule: " + rule));
}
engines.put(type, engine);
}
this.engine = engine;
this.rule = rule;
}
```

### 3.2.2 route

```
@Override
public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
try {
// æ‰§è¡Œè„šæœ¬
List<Invoker<T>> invokersCopy = new ArrayList<Invoker<T>>(invokers);
Compilable compilable = (Compilable) engine;
Bindings bindings = engine.createBindings();
bindings.put("invokers", invokersCopy);
bindings.put("invocation", invocation);
bindings.put("context", RpcContext.getContext());
CompiledScript function = compilable.compile(rule); // ç¼–è¯‘
Object obj = function.eval(bindings); // æ‰§è¡Œ
// æ ¹æ®ç»“æœç±»å‹ï¼Œè½¬æ¢æˆ (List<Invoker<T>> ç±»å‹è¿”å›
if (obj instanceof Invoker[]) {
invokersCopy = Arrays.asList((Invoker<T>[]) obj);
} else if (obj instanceof Object[]) {
invokersCopy = new ArrayList<Invoker<T>>();
for (Object inv : (Object[]) obj) {
invokersCopy.add((Invoker<T>) inv);
}
} else {
invokersCopy = (List<Invoker<T>>) obj;
}
return invokersCopy;
} catch (ScriptException e) {
// å‘ç”Ÿå¼‚å¸¸ï¼Œå¿½ç•¥è·¯ç”±è§„åˆ™ï¼Œè¿”å›å…¨ `invokers` é›†åˆ
logger.error("route error , rule has been ignored. rule: " + rule + ", method:" + invocation.getMethodName() + ", url: " + RpcContext.getContext().getUrl(), e);
return invokers;
}
}
```

* ğŸ™‚ æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹è‡ªå·±çœ‹ä»£ç æ³¨é‡Šã€‚

### 3.2.3 compareTo

```
@Override
public int compareTo(Router o){
if (o == null || o.getClass() != ScriptRouter.class) {
return 1;
}
ScriptRouter c = (ScriptRouter) o;
return this.priority == c.priority ? rule.compareTo(c.rule) : (this.priority > c.priority ? 1 : -1);
}
```

* ä¼˜å…ˆï¼ŒæŒ‰ç…§

"priority"
**é™åº**ã€‚
* å…¶æ¬¡ï¼ŒæŒ‰ç…§

"rule"
**å‡åº**ã€‚

## 3.3 MockInvokersSelector

è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…«ï¼‰ä¹‹ Mock å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/?self) ã€‚

# 4. é›†æˆ Router æ¨¡å—

å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ‰**äºŒä¸ªç±»**ï¼Œè°ƒç”¨

Router/#route(List<Invoker<T>>, URL, Invocation)
æ–¹æ³•ï¼Œé›†æˆ Router æ¨¡å—ã€‚

![é›†æˆ](http://static2.iocoder.cn/images/Dubbo/2019_04_30/01.png)

## 4.1 AbstractDirectory

### 4.1.1 setRouters

/#setRouters(List<Router> routers)
æ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™ä»¬ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
1: protected void setRouters(List<Router> routers){
2: // copy list // å¤åˆ¶ routers ï¼Œå› ä¸ºä¸‹é¢è¦ä¿®æ”¹
3: routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);
4: // append url router
5: // æ‹¼æ¥ `url` ä¸­ï¼Œé…ç½®çš„è·¯ç”±è§„åˆ™
6: String routerkey = url.getParameter(Constants.ROUTER_KEY);
7: if (routerkey != null && routerkey.length() > 0) {
8: RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);
9: routers.add(routerFactory.getRouter(url));
10: }
11: // append mock invoker selector
12: routers.add(new MockInvokersSelector());
13: // æ’åº
14: Collections.sort(routers);
15: // èµ‹å€¼ç»™å±æ€§
16: this.routers = routers;
17: }
```

* ç¬¬ 3 è¡Œï¼šå¤åˆ¶é‡æ–°åˆ›å»º

routers
æ•°ç»„ï¼Œå› ä¸ºä¸‹é¢ä¼šè¿›è¡Œä¿®æ”¹ã€‚
* ç¬¬ 5 è‡³ 10 è¡Œï¼šæ·»åŠ 

url
ä¸­**é…ç½®çš„è·¯ç”±è§„åˆ™**åˆ°

routers
ä¸­ã€‚ä¾‹å¦‚ï¼š
```
<dubbo:registry id="zk01" address="zookeeper://127.0.0.1:2181">
<dubbo:parameter key="router" value="file" />
<dubbo:parameter key="rule" value="/Users/yunai/xxx.js" />
</dubbo:registry>
```

* å—é™äº XML å¯¹å­—ç¬¦çš„é™åˆ¶ï¼Œ

"condition"
æˆ–

"script"
ç±»å‹çš„è·¯ç”±é…ç½®ä¼šæ¯”è¾ƒéš¾è®¾ç½®ã€‚æ‰€ä»¥ç¬”è€…è®¤ä¸ºï¼Œå¦‚æœæ˜¯ä½¿ç”¨ XML é…ç½®è·¯ç”±è§„åˆ™ï¼Œ

"file"
ç±»å‹æ˜¯æ¯”è¾ƒåˆé€‚çš„æ–¹å¼ã€‚å½“ç„¶ï¼Œå¦‚æœä½¿ç”¨ Java API åˆæˆ–è€…æ³¨è§£çš„æ–¹å¼ï¼Œåº”è¯¥ä¸å­˜åœ¨è¿™æ ·çš„é—®é¢˜ã€‚
* ç¬¬ 12 è¡Œï¼šæ·»åŠ  **MockInvokersSelector** åˆ°

routers
ä¸­ã€‚
* ç¬¬ 14 è¡Œï¼šæ’åº

routers
ã€‚
* ç¬¬ 16 è¡Œï¼š**èµ‹å€¼å±æ€§**ç»™ AbstractDirectory ã€‚

### 4.1.2 list

```
1: @Override
2: public List<Invoker<T>> list(Invocation invocation) throws RpcException {
3: if (destroyed) {
4: throw new RpcException("Directory already destroyed .url: " + getUrl());
5: }
6: // è·å¾—æ‰€æœ‰ Invoker é›†åˆ
7: List<Invoker<T>> invokers = doList(invocation);
8: // æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰ Invoker é›†åˆ
9: List<Router> localRouters = this.routers; // local reference æœ¬åœ°å¼•ç”¨ï¼Œé¿å…å¹¶å‘é—®é¢˜
10: if (localRouters != null && !localRouters.isEmpty()) {
11: for (Router router : localRouters) {
12: try {
13: if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {
14: invokers = router.route(invokers, getConsumerUrl(), invocation);
15: }
16: } catch (Throwable t) {
17: logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
18: }
19: }
20: }
21: return invokers;
22: }
```

* ç¬¬ 8 è‡³ 20 è¡Œï¼š**å¾ªç¯**ï¼Œè°ƒç”¨

Router/#route(invokers, url, invocation)
æ–¹æ³•ï¼Œä¸æ–­è·¯ç”±ï¼Œç­›é€‰**åŒ¹é…çš„**Invoker é›†åˆã€‚

* ç¬¬ 13 è¡Œï¼šåˆ¤æ–­

"runtime"
ä¸º **true** æ‰æ‰§è¡Œï¼šæ˜¯å¦åœ¨æ¯æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œè·¯ç”±è§„åˆ™ï¼Œ**å¦åˆ™åªåœ¨æä¾›è€…åœ°å€åˆ—è¡¨å˜æ›´æ—¶é¢„å…ˆæ‰§è¡Œå¹¶ç¼“å­˜ç»“æœ**ï¼Œè°ƒç”¨æ—¶ç›´æ¥ä»ç¼“å­˜ä¸­è·å–è·¯ç”±ç»“æœã€‚å¦‚æœç”¨äº†å‚æ•°è·¯ç”±ï¼Œå¿…é¡»è®¾ä¸º

true
ï¼Œéœ€è¦æ³¨æ„è®¾ç½®ä¼šå½±å“è°ƒç”¨çš„æ€§èƒ½ï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º

flase
ã€‚

## 4.2 RegistryDirectory

### 4.2.1 notify

```
1: @Override
2: public synchronized void notify(List<URL> urls){
3: // ã€çœç•¥æ— å…³ä»£ç ã€‘æ ¹æ® URL çš„åˆ†ç±»æˆ–åè®®ï¼Œåˆ†ç»„æˆä¸‰ä¸ªé›†åˆ ã€‚
4: List<URL> invokerUrls = new ArrayList<URL>(); // æœåŠ¡æä¾›è€… URL é›†åˆ
5: List<URL> routerUrls = new ArrayList<URL>();
6: List<URL> configuratorUrls = new ArrayList<URL>();
7:
8: // ã€çœç•¥æ— å…³ä»£ç ã€‘å¤„ç†é…ç½®è§„åˆ™ URL é›†åˆ
9: // configurators
10:
11: // å¤„ç†è·¯ç”±è§„åˆ™ URL é›†åˆ
12: if (!routerUrls.isEmpty()) {
13: List<Router> routers = toRouters(routerUrls);
14: if (routers != null) { // null - do nothing
15: setRouters(routers);
16: }
17: }
18:
19: // ã€çœç•¥æ— å…³ä»£ç ã€‘åˆå¹¶é…ç½®è§„åˆ™ï¼Œåˆ° `directoryUrl` ä¸­ï¼Œå½¢æˆ `overrideDirectoryUrl` å˜é‡ã€‚
20: // ã€çœç•¥æ— å…³ä»£ç ã€‘å¤„ç†æœåŠ¡æä¾›è€… URL é›†åˆ
21: }
```

* ç¬¬ 12 è¡Œï¼šè‹¥æ³¨å†Œä¸­å¿ƒé€šçŸ¥çš„

routerUrls
éç©ºï¼Œè¿›è¡Œå¤„ç†

routerUrls
é›†åˆã€‚
* ç¬¬ 13 è¡Œï¼šè°ƒç”¨

/#toRouters(routerUrls)
æ–¹æ³•ï¼Œå°†è·¯ç”±è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Router é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private List<Router> toRouters(List<URL> urls){
List<Router> routers = new ArrayList<Router>();
if (urls == null || urls.isEmpty()) {
return routers;
}
for (URL url : urls) {
// å¿½ç•¥ï¼Œè‹¥æ˜¯ "empty://" ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæ‰€æœ‰è·¯ç”±è§„åˆ™è¢«åˆ é™¤æ—¶ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€æ¡åè®®ä¸º "empty://" çš„è·¯ç”±è§„åˆ™ URL
if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {
continue;
}
// è·å¾— "router"
String routerType = url.getParameter(Constants.ROUTER_KEY);
if (routerType != null && routerType.length() > 0) {
url = url.setProtocol(routerType);
}
try {
// åˆ›å»º Router å¯¹è±¡
Router router = routerFactory.getRouter(url);
// æ·»åŠ åˆ°è¿”å›ç»“æœ
if (!routers.contains(router)) {
routers.add(router);
}
} catch (Throwable t) {
logger.error("convert router url to router error, url: " + url, t);
}
}
return routers;
}
```

* ä»£ç æ˜“æ‡‚ï¼Œèƒ–å‹çœ‹ä¸‹æ³¨é‡Šç†è§£ã€‚
* ç¬¬ 14 è‡³ 16 è¡Œï¼š

routers
é›†åˆé **null**( å…è®¸é›†åˆå¤§å°ä¸º **0** )ï¼Œè°ƒç”¨

/#setRouters(routers)
æ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™é›†åˆï¼Œå³ [ã€Œ4.1.1 setRoutersã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/) ã€‚

### 4.2.2 toMethodInvokers

```
1: private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {
2: // åˆ›å»ºæ–°çš„ `methodInvokerMap`
3: Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();
4: // åˆ›å»º Invoker é›†åˆ
5: List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();
6: // ã€çœç•¥æ— å…³ä»£ç ã€‘æŒ‰æœåŠ¡æä¾›è€… URL æ‰€å£°æ˜çš„ methods åˆ†ç±»ï¼Œå…¼å®¹æ³¨å†Œä¸­å¿ƒæ‰§è¡Œè·¯ç”±è¿‡æ»¤æ‰çš„ methods
7: // è·¯ç”±å…¨ `invokersList` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ
8: List<Invoker<T>> newInvokersList = route(invokersList, null);
9: // æ·»åŠ  `newInvokersList` åˆ° `newMethodInvokerMap` ä¸­ï¼Œè¡¨ç¤ºè¯¥æœåŠ¡æä¾›è€…çš„å…¨é‡ Invoker é›†åˆ
10: newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);
11: // å¾ªç¯ï¼ŒåŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ
12: if (serviceMethods != null && serviceMethods.length > 0) {
13: for (String method : serviceMethods) {
14: List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
15: if (methodInvokers == null || methodInvokers.isEmpty()) {
16: methodInvokers = newInvokersList;
17: }
18: newMethodInvokerMap.put(method, route(methodInvokers, method));
19: }
20: }
21: // ã€çœç•¥æ— å…³ä»£ç ã€‘å¾ªç¯æ’åºæ¯ä¸ªæ–¹æ³•çš„ Invoker é›†åˆï¼Œå¹¶è®¾ç½®ä¸ºä¸å¯å˜
22: }
```

* ç¬¬ 8 è¡Œï¼šè°ƒç”¨

/#route(invokers, method)
æ–¹æ³•ï¼Œè·¯ç”±**å…¨**

invokersList
ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ**è¿›è¡Œç¼“å­˜**ï¼Œè¿™å°±æ˜¯ä¸Šæ–‡æåˆ°çš„â€œ*åªåœ¨æä¾›è€…åœ°å€åˆ—è¡¨å˜æ›´æ—¶é¢„å…ˆæ‰§è¡Œå¹¶ç¼“å­˜ç»“æœ*â€ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
private List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {
// åˆ›å»º Invocation å¯¹è±¡
Invocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);
// è·å¾— Router æ•°ç»„
List<Router> routers = getRouters();
// æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰ Invoker é›†åˆ
if (routers != null) {
for (Router router : routers) {
if (router.getUrl() != null) {
invokers = router.route(invokers, getConsumerUrl(), invocation);
}
}
}
return invokers;
}
```

* ä¸»è¦æ˜¯è°ƒç”¨

Router/#route(...)
æ–¹æ³•ï¼Œè·¯ç”±ã€‚
* ç¬¬ 11 è‡³ 20 è¡Œï¼š**å¾ªç¯**ï¼Œè°ƒç”¨

/#route(invokers, method)
æ–¹æ³•ï¼Œè·¯ç”±**æ¯ä¸ªæ–¹æ³•**çš„

methodInvokers
ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ**è¿›è¡Œç¼“å­˜**ã€‚