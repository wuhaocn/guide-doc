# æœåŠ¡è°ƒç”¨ï¼ˆä¸‰ï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆHTTPï¼‰

æœ¬æ–‡åŸºäº Dubbo 2.6.1 ç‰ˆæœ¬ï¼Œæœ›çŸ¥æ‚‰ã€‚

# 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº«

http://
åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸‰ä¸ªéƒ¨åˆ†**ï¼š

* æœåŠ¡æš´éœ²
* æœåŠ¡å¼•ç”¨
* æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º

dubbo-rpc-http
ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” http://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/http.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š
åŸºäº HTTP è¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®ï¼Œé‡‡ç”¨ Spring çš„ **HttpInvoker** å®ç°

**æ³¨æ„**ï¼Œä»å®šä¹‰ä¸Šæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œä¸æ˜¯æˆ‘ä»¬å¸¸è§„ç†è§£çš„ HTTP è°ƒç”¨ï¼Œè€Œæ˜¯ **Spring çš„ HttpInvoker** ã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾ï¼ˆçº¢åœˆéƒ¨åˆ†ï¼‰å¦‚ä¸‹ï¼š

![ç±»å›¾](http://static2.iocoder.cn/images/Dubbo/2018_10_10/01.png)

# 2. AbstractProxyProtocol

[
com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractProxyProtocol.java) ï¼Œå®ç° AbstractProtocol æŠ½è±¡ç±»ï¼Œ**Proxy**åè®®æŠ½è±¡ç±»ã€‚ä¸º HttpProtocol ã€RestProtocol ç­‰å­ç±»ï¼Œæä¾›å…¬ç”¨çš„æœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨çš„**å…¬ç”¨æ–¹æ³•**ï¼ŒåŒæ—¶å®šä¹‰äº†å¦‚ä¸‹**æŠ½è±¡æ–¹æ³•**ï¼Œç”¨äºä¸åŒå­ç±»åè®®å®ç°ç±»çš„**è‡ªå®šä¹‰**çš„é€»è¾‘ï¼š
```
//*/*
/* æ‰§è¡Œæš´éœ²ï¼Œå¹¶è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
/*
/* @param impl æœåŠ¡ Proxy å¯¹è±¡
/* @param type æœåŠ¡æ¥å£
/* @param url URL
/* @param <T> æœåŠ¡æ¥å£
/* @return æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
/* @throws RpcException å½“å‘ç”Ÿå¼‚å¸¸
/*/
protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;
//*/*
/* æ‰§è¡Œå¼•ç”¨ï¼Œå¹¶è¿”å›è°ƒç”¨è¿œç¨‹æœåŠ¡çš„ Service å¯¹è±¡
/*
/* @param type æœåŠ¡æ¥å£
/* @param url URL
/* @param <T> æœåŠ¡æ¥å£
/* @return è°ƒç”¨è¿œç¨‹æœåŠ¡çš„ Service å¯¹è±¡
/* @throws RpcException å½“å‘ç”Ÿå¼‚å¸¸
/*/
protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
```

## 2.1 æ„é€ æ–¹æ³•

```
//*/*
/* éœ€è¦æŠ›å‡ºçš„å¼‚å¸¸ç±»é›†åˆï¼Œè¯¦è§ {@link /#reder(Class, URL)} æ–¹æ³•ã€‚
/*/
private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();
//*/*
/* ProxyFactory å¯¹è±¡
/*/
private ProxyFactory proxyFactory;
public AbstractProxyProtocol(){
}
public AbstractProxyProtocol(Class<?>... exceptions){
for (Class<?> exception : exceptions) {
addRpcException(exception);
}
}
public void addRpcException(Class<?> exception){
this.rpcExceptions.add(exception);
}
```

* rpcExceptions
å±æ€§ï¼Œä¸åŒåè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¼šæŠ›å‡ºçš„å¼‚å¸¸æ˜¯ä¸åŒçš„ã€‚åœ¨

/#refer(Class, URL)
æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å¯¹è¿™ä¸ªå±æ€§çš„ä½¿ç”¨ï¼Œç†è§£ä¼šæ›´æ¸…æ™°ä¸€äº›ã€‚

## 2.2 export

```
//*/*
/* Exporter é›†åˆ
/*
/* key: æœåŠ¡é”® {@link /#serviceKey(URL)} æˆ– {@link URL/#getServiceKey()} ã€‚
/* ä¸åŒåè®®ä¼šä¸åŒ
/*/
protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>(); // FROM AbstractProtocol.java
1: @Override
2: @SuppressWarnings("unchecked")
3: public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException{
4: // è·å¾—æœåŠ¡é”®
5: final String uri = serviceKey(invoker.getUrl());
6: // è·å¾— Exporter å¯¹è±¡ã€‚è‹¥å·²ç»æš´éœ²ï¼Œç›´æ¥è¿”å›ã€‚
7: Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
8: if (exporter != null) {
9: return exporter;
10: }
11: // æ‰§è¡Œæš´éœ²æœåŠ¡
12: final Runnable runnable = doExport(proxyFactory.getProxy(invoker), invoker.getInterface(), invoker.getUrl());
13: // åˆ›å»º Exporter å¯¹è±¡
14: exporter = new AbstractExporter<T>(invoker) {
15:
16: @Override
17: public void unexport(){
18: // å–æ¶ˆæš´éœ²
19: super.unexport();
20: exporterMap.remove(uri);
21: // æ‰§è¡Œå–æ¶ˆæš´éœ²çš„å›è°ƒ
22: if (runnable != null) {
23: try {
24: runnable.run();
25: } catch (Throwable t) {
26: logger.warn(t.getMessage(), t);
27: }
28: }
29: }
30:
31: };
32: // æ·»åŠ åˆ° Exporter é›†åˆ
33: exporterMap.put(uri, exporter);
34: return exporter;
35: }
```

* ç¬¬ 5 è¡Œï¼šè°ƒç”¨

/#serviceKey(url)
æ–¹æ³•ï¼Œè·å¾—æœåŠ¡é”®ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
protected static String serviceKey(URL url){
return ProtocolUtils.serviceKey(url);
}
```
* ç¬¬ 6 è‡³ 10 è¡Œï¼šä»

exporterMap
ä¸­ï¼Œè·å¾— Exporter å¯¹è±¡ã€‚è‹¥å·²ç»æš´éœ²ï¼Œç›´æ¥è¿”å›ã€‚
* ç¬¬ 12 è¡Œï¼šè°ƒç”¨

ProxyFactory/#getProxy(invoker)
æ–¹æ³•ï¼Œè·å¾— Service Proxy å¯¹è±¡ã€‚
* ç¬¬ 12 è¡Œï¼šè°ƒç”¨

/#doExport(impl, type, url)
**æŠ½è±¡**æ–¹æ³•ï¼Œæ‰§è¡Œ**å­ç±»å®ç°**çš„æš´éœ²æœåŠ¡ã€‚
* ç¬¬ 14 è‡³ 31 è¡Œï¼šåˆ›å»º Exporter å¯¹è±¡ã€‚åŸºäº AbstractExporter æŠ½è±¡ç±»å®ç°ï¼Œè¦†å†™

/#unexport()
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

* ç¬¬ 18 è‡³ 20 è¡Œï¼šå–æ¶ˆæš´éœ²ã€‚
* ç¬¬ 22 è‡³ 28 è¡Œï¼šè°ƒç”¨

Runnable/#run()
æ–¹æ³•ï¼Œæ‰§è¡Œå–æ¶ˆæš´éœ²çš„å›è°ƒæ–¹æ³•ã€‚
* ç¬¬ 33 è¡Œï¼šæ·»åŠ åˆ° Exporter é›†åˆã€‚

## 2.3 refer

```
//*/*
/* Invoker é›†åˆ
/*/
//TODO SOFEREFENCE
protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>(); // FROM AbstractProtocol.java
1: @Override
2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException{
3: // æ‰§è¡Œå¼•ç”¨æœåŠ¡
4: final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);
5: // åˆ›å»º Invoker å¯¹è±¡
6: Invoker<T> invoker = new AbstractInvoker<T>(type, url) {
7:
8: @Override
9: protected Result doInvoke(Invocation invocation) throws Throwable{
10: try {
11: // è°ƒç”¨
12: Result result = target.invoke(invocation);
13: // è‹¥è¿”å›ç»“æœå¸¦æœ‰å¼‚å¸¸ï¼Œå¹¶ä¸”éœ€è¦æŠ›å‡ºï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚
14: Throwable e = result.getException();
15: if (e != null) {
16: for (Class<?> rpcException : rpcExceptions) {
17: if (rpcException.isAssignableFrom(e.getClass())) {
18: throw getRpcException(type, url, invocation, e);
19: }
20: }
21: }
22: return result;
23: } catch (RpcException e) {
24: // è‹¥æ˜¯æœªçŸ¥å¼‚å¸¸ï¼Œè·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç 
25: if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {
26: e.setCode(getErrorCode(e.getCause()));
27: }
28: throw e;
29: } catch (Throwable e) {
30: // æŠ›å‡º RpcException å¼‚å¸¸
31: throw getRpcException(type, url, invocation, e);
32: }
33: }
34:
35: };
36: // æ·»åŠ åˆ° Invoker é›†åˆã€‚
37: invokers.add(invoker);
38: return invoker;
39: }
```

* ç¬¬ 4 è¡Œï¼šè°ƒç”¨

/#doRefer(type, url)
**æŠ½è±¡**æ–¹æ³•ï¼Œæ‰§è¡Œ**å­ç±»å®ç°**çš„å¼•ç”¨æœåŠ¡ã€‚
* ç¬¬ 4 è¡Œï¼šè°ƒç”¨

ProxyFactory/#getInvoker(proxy, type, url)
æ–¹æ³•ï¼Œè·å¾— Invoker å¯¹è±¡ã€‚
* ç¬¬ 6 è‡³ 35 è¡Œï¼šåˆ›å»º Invoker å¯¹è±¡ã€‚åŸºäº AbstractExporter æŠ½è±¡ç±»å®ç°ï¼Œè¦†å†™

/#doInvoke(invocation)
æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

* ç¬¬ 12 è¡Œï¼šè°ƒç”¨

Invoker/#invoke(invocation)
æ–¹æ³•ï¼Œæ‰§è¡Œ RPC è°ƒç”¨ã€‚
* ç¬¬ 13 è‡³ 21 è¡Œï¼šè‹¥è¿”å›ç»“æœå¸¦æœ‰å¼‚å¸¸ï¼Œå¹¶ä¸”éœ€è¦æŠ›å‡º( å¼‚å¸¸åœ¨

rpcExceptions
ä¸­)ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚
* ç¬¬ 22 è¡Œï¼šè¿”å›è°ƒç”¨ç»“æœã€‚
* ç¬¬ 23 è‡³ 28 è¡Œï¼šè‹¥æ•æ‰åˆ° RpcException å¼‚å¸¸ï¼Œè°ƒç”¨

/#getErrorCode(Throwable)
æ–¹æ³•ï¼Œè·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
//*/*
/* è·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç 
/*
/* @param e å¼‚å¸¸
/* @return é”™è¯¯ç 
/*/
protected int getErrorCode(Throwable e){
return RpcException.UNKNOWN_EXCEPTION;
}
```

* å­ç±»åè®®å®ç°ç±»ï¼Œä¸€èˆ¬ä¼šè¦†å†™è¿™ä¸ªæ–¹æ³•ï¼Œå®ç°è‡ªå·±å¼‚å¸¸çš„ç¿»è¯‘ã€‚
* ç¬¬ 29 è‡³ 32 è¡Œï¼šè‹¥æ•æ‰åˆ° Throwable å¼‚å¸¸ï¼Œè°ƒç”¨

/#getRpcException(type, url, invocation, e)
æ–¹æ³•ï¼ŒåŒ…è£…æˆ RpcException å¼‚å¸¸ï¼Œä»£ç å¦‚ä¸‹ï¼š
```
protected RpcException getRpcException(Class<?> type, URL url, Invocation invocation, Throwable e){
RpcException re = new RpcException("Failed to invoke remote service: " + type + ", method: "
+ invocation.getMethodName() + ", cause: " + e.getMessage(), e);
re.setCode(getErrorCode(e));
return re;
}
```
* ç¬¬ 37 è¡Œï¼šæ·»åŠ åˆ° Invoker é›†åˆã€‚

# 3. HttpProtocol

[
com.alibaba.dubbo.rpc.protocol.http.HttpProtocol
](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-http/src/main/java/com/alibaba/dubbo/rpc/protocol/http/HttpProtocol.java) ï¼Œå®ç° AbstractProxyProtocol æŠ½è±¡ç±»ï¼Œ

dubbo://
åè®®å®ç°ç±»ã€‚

## 3.1 æ„é€ æ–¹æ³•

```
//*/*
/* é»˜è®¤æœåŠ¡å™¨ç«¯å£
/*/
public static final int DEFAULT_PORT = 80;
//*/*
/* Http æœåŠ¡å™¨é›†åˆ
/*
/* keyï¼šip:port
/*/
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
//*/*
/* Spring HttpInvokerServiceExporter é›†åˆ
/*
/* keyï¼špath æœåŠ¡å
/*/
private final Map<String, HttpInvokerServiceExporter> skeletonMap = new ConcurrentHashMap<String, HttpInvokerServiceExporter>();
//*/*
/* HttpBinder$Adaptive å¯¹è±¡
/*/
private HttpBinder httpBinder;
public HttpProtocol(){
super(RemoteAccessException.class);
}
public void setHttpBinder(HttpBinder httpBinder){
this.httpBinder = httpBinder;
}
```

* serverMap
å±æ€§ï¼ŒHttpServer é›†åˆã€‚é”®ä¸º

ip:port
ï¼Œé€šè¿‡

/#getAddr(url)
æ–¹æ³•ï¼Œè®¡ç®—ã€‚ä»£ç å¦‚ä¸‹ï¼š
```
// AbstractProxyProtocol.java
protected String getAddr(URL url){
String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
if (url.getParameter(Constants.ANYHOST_KEY, false)) {
bindIp = Constants.ANYHOST_VALUE;
}
return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
}
```
* skeletonMap
å±æ€§ï¼ŒSpring HttpInvokerServiceExporter é›†åˆã€‚è¯·æ±‚å¤„ç†è¿‡ç¨‹ä¸º

HttpServer => DispatcherServlet => InternalHandler => HttpInvokerServiceExporter
ã€‚
* httpBinder
å±æ€§ï¼ŒHttpBinder$Adaptive å¯¹è±¡ï¼Œé€šè¿‡

/#setHttpBinder(httpBinder)
æ–¹æ³•ï¼ŒDubbo SPI è°ƒç”¨è®¾ç½®ã€‚
* rpcExceptions = RemoteAccessException.class
ã€‚

## 3.2 doExport

```
1: @Override
2: protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException{
3: // è·å¾—æœåŠ¡å™¨åœ°å€
4: String addr = getAddr(url);
5: // è·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»ºã€‚
6: HttpServer server = serverMap.get(addr);
7: if (server == null) {
8: server = httpBinder.bind(url, new InternalHandler()); // InternalHandler
9: serverMap.put(addr, server);
10: }
11: // åˆ›å»º HttpInvokerServiceExporter å¯¹è±¡
12: final HttpInvokerServiceExporter httpServiceExporter = new HttpInvokerServiceExporter();
13: httpServiceExporter.setServiceInterface(type);
14: httpServiceExporter.setService(impl);
15: try {
16: httpServiceExporter.afterPropertiesSet();
17: } catch (Exception e) {
18: throw new RpcException(e.getMessage(), e);
19: }
20: // æ·»åŠ åˆ° skeletonMap ä¸­
21: final String path = url.getAbsolutePath();
22: skeletonMap.put(path, httpServiceExporter);
23: // è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
24: return new Runnable() {
25: public void run(){
26: skeletonMap.remove(path);
27: }
28: };
29: }
```

* åŸºäº

dubbo-remoting-http
é¡¹ç›®ï¼Œä½œä¸º**é€šä¿¡æœåŠ¡å™¨**ã€‚
* ç¬¬ 4 è¡Œï¼šè°ƒç”¨

/#getAddr(url)
æ–¹æ³•ï¼Œè·å¾—æœåŠ¡å™¨åœ°å€ã€‚
* ç¬¬ 5 è‡³ 10 è¡Œï¼šä»

serverMap
ä¸­ï¼Œè·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè°ƒç”¨

HttpBinder/#bind(url, handler)
æ–¹æ³•ï¼Œåˆ›å»º HttpServer å¯¹è±¡ã€‚æ­¤å¤„ä½¿ç”¨çš„ InternalHandler ï¼Œä¸‹æ–‡è¯¦ç»†è§£æã€‚
* ç¬¬ 11 è‡³ 19 è¡Œï¼šåˆ›å»º HttpInvokerServiceExporter å¯¹è±¡ã€‚
* ç¬¬ 20 è‡³ 22 è¡Œï¼šæ·»åŠ åˆ°

skeletonMap
é›†åˆä¸­ã€‚
* ç¬¬ 23 è‡³ 28 è¡Œï¼šè¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable å¯¹è±¡ã€‚

### 3.2.1 InternalHandler

```
private class InternalHandler implements HttpHandler{
@Override
public void handle(HttpServletRequest request, HttpServletResponse response) throws ServletException{
String uri = request.getRequestURI();
// è·å¾— HttpInvokerServiceExporter å¯¹è±¡
HttpInvokerServiceExporter skeleton = skeletonMap.get(uri);
// å¿…é¡»æ˜¯ POST è¯·æ±‚
if (!request.getMethod().equalsIgnoreCase("POST")) {
response.setStatus(500);
// æ‰§è¡Œè°ƒç”¨
} else {
RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
try {
skeleton.handleRequest(request, response);
} catch (Throwable e) {
throw new ServletException(e);
}
}
}
}
```

## 3.3 doRefer

```
1: @Override
2: @SuppressWarnings("unchecked")
3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException{
4: // åˆ›å»º HttpInvokerProxyFactoryBean å¯¹è±¡
5: final HttpInvokerProxyFactoryBean httpProxyFactoryBean = new HttpInvokerProxyFactoryBean();
6: httpProxyFactoryBean.setServiceUrl(url.toIdentityString());
7: httpProxyFactoryBean.setServiceInterface(serviceType);
8: // åˆ›å»ºæ‰§è¡Œå™¨ SimpleHttpInvokerRequestExecutor å¯¹è±¡
9: String client = url.getParameter(Constants.CLIENT_KEY);
10: if (client == null || client.length() == 0 || "simple".equals(client)) {
11: SimpleHttpInvokerRequestExecutor httpInvokerRequestExecutor = new SimpleHttpInvokerRequestExecutor() {
12: protected void prepareConnection(HttpURLConnection con,
13: int contentLength) throws IOException{
14: super.prepareConnection(con, contentLength);
15: con.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
16: con.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
17: }
18: };
19: httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);
20: // åˆ›å»ºæ‰§è¡Œå™¨ HttpComponentsHttpInvokerRequestExecutor å¯¹è±¡
21: } else if ("commons".equals(client)) {
22: HttpComponentsHttpInvokerRequestExecutor httpInvokerRequestExecutor = new HttpComponentsHttpInvokerRequestExecutor();
23: httpInvokerRequestExecutor.setReadTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
24: httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);
25: } else {
26: throw new IllegalStateException("Unsupported http protocol client " + client + ", only supported: simple, commons");
27: }
28: httpProxyFactoryBean.afterPropertiesSet();
29: // è¿”å› HttpInvokerProxyFactoryBean å¯¹è±¡
30: return (T) httpProxyFactoryBean.getObject();
31: }
```

* åŸºäº HttpClient ï¼Œä½œä¸º**é€šä¿¡å®¢æˆ·ç«¯**ã€‚
* ç¬¬ 4 è‡³ 7 è¡Œï¼šåˆ›å»º HttpInvokerProxyFactoryBean å¯¹è±¡ã€‚
* ç¬¬ 9 è‡³ 27 è¡Œï¼šè·å¾—

client
é…ç½®é¡¹ï¼Œæ ¹æ®è¯¥é…ç½®é¡¹ï¼Œåˆ›å»ºå¯¹åº”çš„æ‰§è¡Œå™¨ã€‚

* "simple"
ï¼šç¬¬ 10 è‡³ 19 è¡Œï¼šåˆ›å»ºæ‰§è¡Œå™¨ SimpleHttpInvokerRequestExecutor å¯¹è±¡ã€‚
* "commons"
ï¼šç¬¬ 20 è‡³ 24 è¡Œï¼šåˆ›å»ºæ‰§è¡Œå™¨ HttpComponentsHttpInvokerRequestExecutor å¯¹è±¡ã€‚
* ä¸¤è€…çš„å·®å¼‚ç‚¹åœ¨äºä½¿ç”¨çš„ HttpClient ä¸åŒï¼Œå‰è€…ä½¿ç”¨ JDK HttpClient ï¼Œåè€…ä½¿ç”¨ Apache HttpClient ã€‚
* ç¬¬ 30 è¡Œï¼šè¿”å› HttpInvokerProxyFactoryBean å¯¹è±¡ã€‚
* ğŸ™‚ å…·ä½“ RPC è°ƒç”¨çš„å®ç°ï¼Œåœ¨çˆ¶ç±»

/#refer()
æ–¹æ³•é‡Œã€‚

### 3.3.1 getErrorCode

```
@Override
@SuppressWarnings("Duplicates")
protected int getErrorCode(Throwable e){
if (e instanceof RemoteAccessException) {
e = e.getCause();
}
if (e != null) {
Class<?> cls = e.getClass();
if (SocketTimeoutException.class.equals(cls)) {
return RpcException.TIMEOUT_EXCEPTION;
} else if (IOException.class.isAssignableFrom(cls)) {
return RpcException.NETWORK_EXCEPTION;
} else if (ClassNotFoundException.class.isAssignableFrom(cls)) {
return RpcException.SERIALIZATION_EXCEPTION;
}
}
return super.getErrorCode(e);
}
```

* å°†å¼‚å¸¸ï¼Œç¿»è¯‘æˆ Dubbo å¼‚å¸¸ç ã€‚